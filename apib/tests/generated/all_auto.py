from collections.abc import Generator
from datetime import datetime
from json import loads
from typing import Optional, Union

from dateutil.parser import isoparse
from pydantic import Field, TypeAdapter

from wxc_sdk.api_child import ApiChild
from wxc_sdk.base import ApiModel, dt_iso_str, enum_str
from wxc_sdk.base import SafeEnum as Enum


__auto__ = ['AcdObject', 'Action', 'ActivationCode', 'ActivationStates', 'ActivityList', 'ActivityListDatasetMetadata',
            'AdaptiveCard', 'AdaptiveCardActions', 'AdaptiveCardBody', 'AddDECTHandset', 'Address',
            'AddressAgentHuntGroupObject', 'AdminBatchStartJobObject',
            'AdminBatchStartJobObjectLocationCustomizations', 'AdmitParticipant', 'AdmitParticipantsObject',
            'AdmitParticipantsObject1', 'Agent', 'AgentActivity', 'AgentAgentDn', 'AgentAvaliableCallQueueIdList',
            'AgentAvaliableCallQueueIdList1', 'AgentCallQueueId', 'AgentCallQueueId1', 'AgentCallerId',
            'AgentCallerIdType', 'AgentChannelType', 'AgentCurrentState', 'AgentSession', 'AgentStats',
            'AgentStatsChannel', 'AgentStatsChannelChannelType', 'AgentStatsResponse', 'AggregatedMetric', 'Alarm',
            'AlarmCollection', 'AlarmSeverity', 'AlternateNumbersObject', 'AlternateNumbersObjectRingPattern',
            'AlternateNumbersWithPattern', 'AnalyzeEntitiesDocument', 'AnnouncementAudioFileGet',
            'AnnouncementAudioFileGetLevel', 'AnnouncementResponse', 'AnnouncementUsageResponse',
            'AnnouncementsListResponse', 'AnnouncementsListResponseLevel', 'AnswerForCustomizedQuestion',
            'AnswerObject', 'AnswerSummaryItem', 'Application', 'ApplicationOrgSubmissionStatus',
            'ApplicationSubmissionStatus', 'ApplicationType', 'ApplicationUsage',
            'ApplicationUsageCollectionResponse', 'ApplicationUsagePolicyAction', 'ApplicationsCollectionResponse',
            'ApplicationsSetting', 'ApplicationsSettingPut', 'ApplyLineKeyTemplateJobDetails',
            'ApplyLineKeyTemplateJobErrors', 'ApplyLineKeyTemplateJobList', 'ArrayOfExtensionsObject', 'Artifact',
            'ArtifactAttributes', 'AtaDtmfMethodObject', 'AtaDtmfModeObject', 'AtaObject', 'Attachment',
            'Attachment1', 'AttachmentAction', 'AttachmentActivity', 'AttachmentActivityType',
            'AudioAnnouncementFileFeatureGetObject', 'AudioAnnouncementFileGetObject',
            'AudioAnnouncementFileGetObject1', 'AudioAnnouncementFileGetObjectLevel',
            'AudioAnnouncementFileGetObjectMediaFileType1', 'AudioCodecPriorityObject', 'AudioFileObject',
            'AudioFileObjectMediaType', 'AudioIn', 'AudioInType', 'AuditEvent', 'AuditEvent1',
            'AuditEventCategoryCollectionResponse', 'AuditEventCollectionResponse', 'AuditEventCollectionResponse1',
            'AuditEventData', 'AuditEventData1', 'AuthenticationMethodObject', 'Authorization', 'AuthorizationCode',
            'AuthorizationType', 'AuthorizationsCollectionResponse', 'AutoAttendantCallForwardSettingsDetailsObject',
            'AutoAttendantCallForwardSettingsModifyDetailsObject', 'AvailableCallerIdList', 'AvailableCallerIdObject',
            'AvailableMember', 'AvailableMembersResponse', 'AvailableSharedLineMemberItem',
            'AvailableSharedLineMemberItem1', 'AvailableSharedLineMemberList', 'AvailableSharedLineMemberList1',
            'BackgroundImage', 'BackgroundImageColor', 'BacklightTimer68XX', 'BacklightTimerObject', 'BandwidthTest',
            'BargeInInfo', 'BaseStationPostResult', 'BaseStationResponse', 'BaseStationsPostResponse',
            'BatchJobError', 'BatchRefreshPMRIDObject', 'BatchRefreshPMRIDResponseObject',
            'BatchRegisterMeetingRegistrantsResponse', 'BatchResponse',
            'BatchUpdateMeetingRegistrantsStatusStatusOpType', 'BillingReportsListResponse', 'BlrClusterDetails',
            'BlrNode1', 'BlrNodeLocation', 'BluetoothObject', 'BluetoothObjectMode', 'BreakoutSessionObject',
            'BulkCreate', 'BulkCreateContacts', 'BulkDelete', 'BulkPurgeRecordingObject',
            'BulkRestoreRecordingObject', 'BulkSoftDeleteRecordingObject', 'BulkUpdateEventThresholdResponse',
            'BulkUser', 'BulkUserOperations', 'BulkUserOperationsMethod', 'CDR', 'CDRResponse', 'CLIDPolicySelection',
            'Call', 'Call2', 'CallBackEffectiveLevel', 'CallBackQuality', 'CallBackSelected', 'CallBridgeInfo',
            'CallForwardExpandedSoftKey', 'CallForwardRulesGet', 'CallForwardRulesModifyObject',
            'CallForwardRulesObject', 'CallForwardSelectiveCallsFromCustomNumbersObject',
            'CallForwardSelectiveCallsFromObject', 'CallForwardSelectiveCallsFromObjectSelection',
            'CallForwardSelectiveCallsToNumbersObject', 'CallForwardSelectiveCallsToNumbersObjectType',
            'CallForwardSelectiveCallsToObject', 'CallForwardSelectiveForwardToObject',
            'CallForwardSelectiveForwardToObjectSelection', 'CallForwardSettingsGet',
            'CallForwardSettingsGetCallForwarding', 'CallForwardSettingsGetCallForwardingAlways',
            'CallForwardingInfo', 'CallForwardingInfoCallForwarding', 'CallForwardingInfoCallForwardingNoAnswer',
            'CallForwardingPut', 'CallForwardingPutCallForwarding', 'CallForwardingPutCallForwardingNoAnswer',
            'CallHistoryMethod', 'CallHistoryRecord', 'CallHistoryRecordTypeEnum', 'CallInterceptInfo',
            'CallInterceptInfoIncoming', 'CallInterceptInfoIncomingAnnouncements', 'CallInterceptPut',
            'CallInterceptPutIncoming', 'CallInterceptPutIncomingAnnouncements', 'CallMembership',
            'CallMembershipAudio', 'CallMembershipCollectionResponse', 'CallMembershipStatus',
            'CallParkSettingsObject', 'CallPersonalityEnum', 'CallQueueAudioFilesObject',
            'CallQueueHolidaySchedulesObject', 'CallQueueObject', 'CallQueueObject1',
            'CallQueueQueueSettingsGetObject', 'CallQueueQueueSettingsGetObjectComfortMessage',
            'CallQueueQueueSettingsGetObjectComfortMessageBypass', 'CallQueueQueueSettingsGetObjectMohMessage',
            'CallQueueQueueSettingsGetObjectMohMessageNormalSource', 'CallQueueQueueSettingsGetObjectOverflow',
            'CallQueueQueueSettingsGetObjectWelcomeMessage', 'CallQueueQueueSettingsObject',
            'CallQueueQueueSettingsObject1', 'CallQueueQueueSettingsObjectComfortMessage',
            'CallQueueQueueSettingsObjectComfortMessageBypass', 'CallQueueQueueSettingsObjectMohMessage',
            'CallQueueQueueSettingsObjectMohMessageNormalSource', 'CallQueueQueueSettingsObjectOverflow',
            'CallQueueQueueSettingsObjectOverflowAction', 'CallQueueQueueSettingsObjectWaitMessage',
            'CallQueueQueueSettingsObjectWaitMessageWaitMode', 'CallQueueQueueSettingsObjectWelcomeMessage',
            'CallRecordingInfo', 'CallRecordingInfo1', 'CallRecordingInfoNotification',
            'CallRecordingInfoNotificationType', 'CallRecordingInfoRecord', 'CallRecordingInfoRepeat',
            'CallRecordingInfoStartStopAnnouncement', 'CallRecordingPut', 'CallRecordingPut1', 'CallSourceInfo',
            'CallSourceType', 'CallStateEnum', 'CallTypeEnum', 'CallerIdInfo', 'CallerIdPut', 'CallerIdSelectedType',
            'CallingPermissionObject', 'CallingPermissionObjectAction', 'CallingPermissionObjectCallType',
            'CallsCollectionResponse', 'CallsQualitiesResponse', 'CapabilityMap', 'CapabilityResponse',
            'CatalogListResponse', 'CatalogResponse', 'CatalogResponseAvailability', 'ChatObject', 'ChatObjectSender',
            'ClientTypeDistributionTrend1', 'ClienttypedistributionCollectionforOrg', 'ClienttypedistributionforOrg',
            'ClosedCaptionObject', 'CloudOverflowTrend1', 'Cluster', 'ClusterAvailability',
            'ClusterAvailabilityCollection', 'ClusterAvailableTimeline', 'ClusterClientTypeDistributionBlr1',
            'ClusterClientTypeDistributionDetailsBlr1a', 'ClusterCollection', 'ClusterDetails',
            'ClusterDetailsCollection', 'ClusterRedirectBlr1', 'ClusterRedirectDetailsBlr1a',
            'ClusterUpgradeScheduleBlr', 'ClusterUtilizationCollection', 'ClusterUtilizationT1SJ',
            'ClusterUtilizationTrend1', 'ClustersAvailability', 'ClustersUtilization', 'CommSecurityType',
            'ConferenceDetails', 'ConferenceParticipant', 'ConferenceStateEnum', 'ConferenceTypeEnum',
            'ConnectivityTestResultsClustersObject1', 'ConnectivityTestResultsForNode',
            'ConnectivityTestResultsObject', 'Connector', 'ConnectorCollection', 'ConnectorStatus', 'ConnectorType',
            'Contact', 'ContactDetails', 'ContactEmails', 'ContactEmailsType', 'ContactIms', 'ContactImsType',
            'ContactPayload', 'ContactPayloadForModify', 'ContactPhoneNumbers', 'ContactPhoneNumbersType',
            'ContactPrimaryContactMethod', 'ContactResponse', 'ContactSipAddresses', 'ContactSipAddressesType',
            'ContactSource', 'Control', 'CountObject', 'CountObject2', 'Counts', 'CreateADectNetworkResponse',
            'CreateAPersonPhoneNumbers', 'CreateAPersonPhoneNumbersType', 'CreateCallQueueObject',
            'CreateDECTNetwork', 'CreateDECTNetworkModel', 'CreateHuntGroupObject', 'CreateHuntGroupObject1',
            'CreateHuntGroupObject2', 'CreateInvitationSourcesResponse', 'CreateInviteeObject',
            'CreateInviteesItemObject', 'CreateInviteesItemResponseObject', 'CreateInviteesObject',
            'CreateInviteesResponse', 'CreateMeetingObject', 'CreateMeetingObject1',
            'CreateMeetingObjectRegistration', 'CreateMeetingObjectSimultaneousInterpretation',
            'CreateOrUpdateTrackingCodeObject', 'Customer1', 'Customer2', 'CustomerActivity', 'CustomerCallDirection',
            'CustomerCurrentState', 'CustomerListResponse', 'CustomerSession', 'CustomerSessionTerminatingEnd',
            'CustomerSessionTerminationType', 'CustomerStatus', 'CustomerTagsResponse',
            'CustomizationDeviceLevelObject', 'CustomizationDeviceLevelObjectDevice', 'CustomizationObject',
            'CustomizedQuestionForCreateMeeting', 'CustomizedQuestionForCreateMeetingOptions',
            'CustomizedQuestionForCreateMeetingRules', 'CustomizedQuestionForCreateMeetingRulesCondition',
            'CustomizedQuestionForCreateMeetingRulesResult', 'CustomizedQuestionForCreateMeetingType',
            'CustomizedQuestionForGetMeeting', 'CustomizedQuestionForGetMeetingRules', 'CustomizedRegistrant',
            'DectDeviceList', 'DectObject', 'DectVlanObject', 'DefaultLoggingLevelObject', 'DefaultSiteObject',
            'DeleteTranscriptObject', 'DepartmentCollectionRequest', 'DepartmentCollectionResponse',
            'DepartmentResponse', 'DepartmentResponseDepartment', 'DepartmentResponseWithId', 'DestinationType',
            'DetailedTemplateObject', 'DetailedTemplateObject1', 'DeveloperRegistrationGetResponse',
            'DeveloperRegistrationUpdateRequest', 'Device', 'Device1', 'DeviceAudioType', 'DeviceCallType',
            'DeviceCapabilities', 'DeviceCollectionResponse', 'DeviceConnectionStatus', 'DeviceList', 'DeviceObject',
            'DeviceOwner', 'DevicePermissions', 'DeviceSettingsObject', 'DeviceSettingsObjectForDeviceLevel',
            'DeviceStatus', 'DeviceType', 'DeviceType1', 'Devices', 'DialPattern', 'DialPatternPut',
            'DialPatternStatus', 'DialPatternValidate', 'DialPatternValidateResult', 'DialPlan', 'DialPlanGet',
            'DialPlanPost', 'DialPlanPut', 'DialResponse', 'DirectMessage', 'DirectMessage1',
            'DirectMessageCollectionResponse', 'DirectMessageCollectionResponse1', 'DirectoryMethod',
            'DisplayCallqueueAgentSoftkeysObject', 'DisplayNameSelection', 'DistributorDetailsResponse',
            'DistributorDetailsResponseCapabilities', 'DistributorListResponse', 'DistributorResponse',
            'DoNotDisturbInfo', 'DownloadMeetingClosedCaptionSnippetsFormat', 'DurationMetric', 'ECMFolder',
            'ECMFolderCollectionResponse', 'ECMFolderRoomType', 'EmailObject', 'Emergency', 'EndpointIdType',
            'EndpointInformation', 'Endpoints', 'Enterprise', 'Enterprise1', 'Enterprise3',
            'EnterpriseBroadworksDirectorySync', 'EnterpriseBroadworksDirectorySync1',
            'EnterpriseBroadworksDirectorySyncDirectorySyncStatus',
            'EnterpriseBroadworksDirectorySyncDirectorySyncStatus1',
            'EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors', 'EnterpriseListResponse',
            'EnterpriseListResponse1', 'EnterpriseListResponse3', 'Entity', 'EntityRecognition', 'Error1', 'Error3',
            'ErrorMessage', 'ErrorOrImpactItem', 'ErrorResponseObject', 'Event', 'Event1', 'EventCollectionResponse',
            'EventCollectionResponse1', 'EventData', 'EventData1', 'EventLongDetails', 'EventLongDetailsRecurrence',
            'EventLongDetailsRecurrenceRecurDaily', 'EventLongDetailsRecurrenceRecurWeekly', 'EventResourceEnum',
            'EventResourceEnum1', 'EventThresholdBody', 'EventThresholdBodyEventName', 'EventTypeEnum',
            'EventTypeEnum1', 'ExecuteCommandArguments', 'ExecuteCommandBody', 'ExecuteCommandBodyBooking',
            'ExecuteCommandBodyBookingOrganizer', 'ExecuteCommandBodyBookingTime', 'ExecuteCommandResponse',
            'ExtensionStatusObject', 'ExtensionStatusObjectState', 'ExtentionStatusObject',
            'ExternalCallerIdNumberListGet', 'FailureDetails3', 'FeatureAccessCode', 'FeatureReferenceObject',
            'FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelLocationId',
            'FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelResponse', 'FieldValidationError', 'File',
            'File1', 'FileExternalContent', 'FileType', 'Floor', 'FloorCollectionResponse', 'FloorCreationRequest',
            'GeneratePasswordPostResponse', 'GetAgentsStatisticsInterval', 'GetAnnouncementFileInfo',
            'GetAutoAttendantCallForwardSelectiveRuleObject', 'GetAutoAttendantCallForwardSettingsObject',
            'GetAutoAttendantObject', 'GetAutoAttendantObject1', 'GetAutoAttendantObject2',
            'GetAutoAttendantObjectExtensionDialing', 'GetAutoTransferNumberObject',
            'GetAvailableAgentsFromCallParksResponse', 'GetAvailableAgentsFromCallParksResponse1',
            'GetAvailableAgentsFromCallPickupsResponse', 'GetAvailableAgentsFromCallPickupsResponse1',
            'GetAvailableRecallHuntGroupsFromCallParksResponse', 'GetBreakoutSessionObject',
            'GetBreakoutSessionsObject', 'GetCallForwardAlwaysSettingObject', 'GetCallParkExtensionObject',
            'GetCallParkExtensionObject1', 'GetCallParkObject', 'GetCallParkObject1', 'GetCallParkSettingsObject',
            'GetCallPickupObject', 'GetCallPickupObject1', 'GetCallPickupObject2',
            'GetCallPickupObjectNotificationType', 'GetCallQueueCallPolicyObject', 'GetCallQueueCallPolicyObject1',
            'GetCallQueueCallPolicyObjectCallBounce', 'GetCallQueueCallPolicyObjectDistinctiveRing',
            'GetCallQueueForcedForwardObject', 'GetCallQueueHolidayObject', 'GetCallQueueHolidayObjectAction',
            'GetCallQueueNightServiceObject', 'GetCallQueueNightServiceObjectAnnouncementMode', 'GetCallQueueObject',
            'GetCallQueueObject1', 'GetCallQueueObject2', 'GetCallQueueObjectAlternateNumberSettings',
            'GetCallQueueStrandedCallsObject', 'GetCallQueueStrandedCallsObjectAction', 'GetCallRecordingObject',
            'GetCallRecordingTermsOfServiceObject', 'GetCallingBehaviorObject',
            'GetCallingBehaviorObjectBehaviorType', 'GetCallingBehaviorObjectEffectiveBehaviorType',
            'GetComplianceAnnouncementObject', 'GetComplianceAnnouncementObject1',
            'GetDetailsForAReceptionistContactDirectoryResponse', 'GetEntityThresholdConfig1', 'GetEvent',
            'GetEventThresholdResponse', 'GetGroupResponse', 'GetGroupResponseMembers',
            'GetGroupResponseUrnscimschemasextensionciscowebexidentity20Group',
            'GetGroupResponseUrnscimschemasextensionciscowebexidentity20GroupMeta', 'GetHuntGroupCallPolicyObject',
            'GetHuntGroupCallPolicyObjectBusinessContinuity', 'GetHuntGroupCallPolicyObjectNoAnswer',
            'GetHuntGroupObject', 'GetHuntGroupObject1', 'GetHuntGroupObject2', 'GetHuntGroupObject3',
            'GetHuntGroupObject4', 'GetLicenseDetailsIncludeAssignedTo', 'GetLineKeyTemplateResponse',
            'GetLocalGatewayDialPlanUsageForATrunkResponse', 'GetLocationAccessCodeObject',
            'GetLocationCallBackNumberObject', 'GetLocationCallBackNumberObjectLocationInfo',
            'GetLocationCallBackNumberObjectLocationMemberInfo', 'GetLocationInterceptObject',
            'GetLocationInterceptObjectIncoming', 'GetLocationInterceptObjectIncomingAnnouncements',
            'GetLocationInterceptObjectIncomingType', 'GetLocationInterceptObjectOutgoing',
            'GetLocationInterceptObjectOutgoingType', 'GetLocationOutgoingPermissionResponse',
            'GetLocationVoicemailGroupObject', 'GetLocationVoicemailGroupObject1',
            'GetLocationVoicemailGroupObjectEmailCopyOfMessage', 'GetLocationVoicemailGroupObjectFaxMessage',
            'GetLocationVoicemailGroupObjectMessageStorage',
            'GetLocationVoicemailGroupObjectMessageStorageStorageType',
            'GetLocationVoicemailGroupObjectNotifications', 'GetLocationVoicemailObject',
            'GetLocationsUsingTheLocalGatewayAsPstnConnectionRoutingResponse',
            'GetMeetingConfigurationCommonSettingObject',
            'GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptions',
            'GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptionsEntryAndExitTone',
            'GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptionsTelephonySupport',
            'GetMeetingConfigurationCommonSettingObjectScheduleMeetingOptions',
            'GetMeetingConfigurationCommonSettingObjectSecurityOptions',
            'GetMeetingConfigurationCommonSettingObjectSecurityOptionsPasswordCriteria',
            'GetMeetingConfigurationCommonSettingObjectSiteOptions',
            'GetMeetingConfigurationCommonSettingObjectTelephonyConfig', 'GetMeetingSurveyLinksResponse',
            'GetMemberResponse', 'GetMemberResponse1', 'GetMessageSummaryResponse', 'GetMonitoredElementsObject',
            'GetMonitoredElementsObject1', 'GetMonitoredElementsObjectCallparkextension',
            'GetMonitoredElementsObjectCallparkextension1', 'GetMonitoredElementsObjectMember',
            'GetMonitoredElementsObjectMember1', 'GetMusicOnHoldObject', 'GetMusicOnHoldObject1',
            'GetMusicOnHoldObjectGreeting', 'GetNumbers', 'GetNumbers1', 'GetNumbersPhoneNumbers',
            'GetNumbersPhoneNumbers1', 'GetOrgComplianceAnnouncementObject', 'GetPagingGroupAgentObject',
            'GetPagingGroupAgentObject1', 'GetPagingGroupAgentObject2', 'GetPagingGroupObject',
            'GetPagingGroupObject1', 'GetPagingGroupObject2', 'GetPersonOrWorkspaceDetailsObject',
            'GetPersonPlaceObject', 'GetPersonPlaceVirtualLineCallParksObject',
            'GetPersonPlaceVirtualLineCallParksObject1', 'GetPersonPlaceVirtualLineCallPickupObject',
            'GetPersonPlaceVirtualLineCallPickupObject1', 'GetPersonPlaceVirtualLineCallQueueObject',
            'GetPersonPlaceVirtualLineCallQueueObject1', 'GetPersonPlaceVirtualLineHuntGroupObject1',
            'GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType', 'GetPrivateNetworkConnectObject',
            'GetPrivateNetworkConnectObjectNetworkConnectionType', 'GetRecallHuntGroupObject',
            'GetRecallHuntGroupObjectOption', 'GetRecordingAuditReportDetailsResponse',
            'GetRouteGroupsUsingTheLocalGatewayResponse', 'GetScheduleEventObject', 'GetScheduleObject',
            'GetScheduleObjectType', 'GetSharedLineMemberItem', 'GetSharedLineMemberItem1', 'GetSharedLineMemberList',
            'GetSharedLineMemberList1', 'GetTelephonyLocationObject', 'GetTelephonyLocationObjectCallingLineId',
            'GetTelephonyLocationObjectConnection', 'GetThirdPartyDeviceObject', 'GetTrackingCodeForUserObject',
            'GetTrackingCodeItemForUserObject', 'GetTrackingCodeObject', 'GetTrackingCodeObjectHostProfileCode',
            'GetTrackingCodeObjectInputMode', 'GetTrackingCodesObject', 'GetUserNumberItemObject',
            'GetUserNumberItemObject2', 'GetUserResponse',
            'GetUserResponseUrnietfparamsscimschemasextensionenterprise20User', 'GetVoicePortalObject',
            'GetVoicePortalPasscodeRuleObject', 'GetVoicePortalPasscodeRuleObjectFailedAttempts',
            'GetVoicemailGroupObject', 'GetVoicemailGroupObject1', 'GetVoicemailRulesObject',
            'GetVoicemailRulesObjectBlockPreviousPasscodes', 'GetVoicemailRulesObjectDefaultVoicemailPinRules',
            'GetVoicemailRulesObjectDefaultVoicemailPinRulesBlockContiguousSequences',
            'GetVoicemailRulesObjectDefaultVoicemailPinRulesBlockRepeatedDigits',
            'GetVoicemailRulesObjectDefaultVoicemailPinRulesLength', 'GetVoicemailRulesObjectExpirePasscode',
            'GetVoicemailSettingsObject', 'GroupMemberObject', 'GroupMemberResponse', 'GroupMemberResponseMembers',
            'GroupResponse', 'Groups', 'GroupsCollectionResponse', 'HistoricalDataRelatedToMeetingsResponse',
            'HistoricalDataRelatedToMeetingsResponseMetrics',
            'HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByJoinMethods',
            'HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByLocation',
            'HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByRoles',
            'HistoricalDataRelatedToMessagingResponse', 'HistoricalDataRelatedToMessagingResponseMetrics',
            'HistoricalDataRelatedToMessagingResponseMetricsSharing', 'HistoricalDataRelatedToRoomDevicesResponse',
            'HistoricalDataRelatedToRoomDevicesResponseMetrics',
            'HistoricalDataRelatedToRoomDevicesResponseMetricsSharing', 'HostedAgent', 'HostedFeature', 'Hoteling',
            'HoursMenuGetObject', 'HoursMenuObject', 'HoursMenuObject1', 'HoursMenuObjectGreeting', 'HttpProxyObject',
            'HttpProxyObjectMode', 'HuntPolicySelection', 'HuntRoutingTypeSelection', 'HydraClassification',
            'IdentityManagedOrg', 'InProgressDevice', 'InProgressParticipant', 'InProgressParticipantState',
            'IncomingPermissionSetting', 'IncomingPermissionSettingExternalTransfer', 'InternalDialingGet',
            'InternalDialingPut', 'InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting',
            'InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting', 'InvitationSourceCreateObject',
            'InvitationSourceObject', 'InviteeObjectForCreateMeeting', 'Issue', 'IssueStatus', 'IssueType',
            'IssuesCollectionResponse', 'ItemObject', 'JobDetailsResponse', 'JobDetailsResponseById',
            'JobExecutionStatus', 'JobExecutionStatusObject', 'JobExecutionStatusObject1',
            'JobExecutionStatusObject3', 'JobIdResponseObject', 'JobListResponse', 'JobListResponse2',
            'JoinMeetingLinkObject', 'JoinMeetingObject', 'JoinMeetingObject1', 'JoinMeetingObject2',
            'KemModuleTypeObject', 'KeyConfigurationsGetObject', 'KeyConfigurationsGetObjectAction',
            'KeyConfigurationsObject', 'KeyConfigurationsObjectAction', 'KeyConfigurationsObjectKey', 'LdapObject',
            'License', 'LicenseCollectionResponse', 'LicenseProperties', 'LicenseRequest', 'LicenseRequestOperation',
            'LicenseSiteType', 'LicensewithUsers', 'LineKeyLEDPattern', 'LineKeyLabelSelection',
            'LineKeyTemplatesResponse', 'LineKeyType', 'LineType', 'Link', 'Link1', 'ListAnswersOfAQuestionResponse',
            'ListApplicationUsageOrderBy', 'ListApplicationsType', 'ListAutoAttendantObject',
            'ListAutoAttendantObject1', 'ListAutoAttendantObject2', 'ListCPCallParkExtensionObject',
            'ListCPCallParkExtensionObject1', 'ListCallHistoryResponse', 'ListCallMembershipsCallStatus',
            'ListCallMembershipsIsHost', 'ListCallParkExtensionObject', 'ListCallParkExtensionObject1',
            'ListCallQueueObject', 'ListCallQueueObject1', 'ListCallQueueObject2', 'ListCallsResponse',
            'ListCapturesQuery', 'ListCapturesResponse', 'ListDectDeviceType', 'ListDeviceSettingsObject',
            'ListDevicesProduct', 'ListDevicesType', 'ListEventThresholdConfigurationEventName',
            'ListEventThresholdConfigurationEventScope', 'ListLocationObject',
            'ListLocationsWebexCallingDetailsResponse', 'ListMediaHealthMonitoringToolTestResultsV2TriggerType',
            'ListMeetingArchiveSummariesResponse', 'ListMeetingAttendeeReportsResponse', 'ListMeetingChatsResponse',
            'ListMeetingClosedCaptionSnippetsResponse', 'ListMeetingClosedCaptionsResponse',
            'ListMeetingInterpretersResponse', 'ListMeetingParticipantsResponse', 'ListMeetingParticipantsResponse1',
            'ListMeetingQAndAResponse', 'ListMeetingRegistrantsResponse', 'ListMeetingRegistrantsResponse1',
            'ListMeetingSessionTypesResponse', 'ListMeetingSurveyResultsResponse', 'ListMeetingTemplatesResponse',
            'ListMeetingTranscriptsResponse', 'ListMeetingUsageReportsResponse',
            'ListMeetingsOfAMeetingSeriesMeetingType', 'ListMeetingsOfAMeetingSeriesResponse',
            'ListMeetingsOfAMeetingSeriesResponse1', 'ListMeetingsOfAMeetingSeriesState', 'ListMeetingsResponse',
            'ListMeetingsResponse1', 'ListMessage', 'ListMessageCollectionResponse', 'ListMessagesResponse',
            'ListNumbersAssociatedWithASpecificWorkspaceResponse',
            'ListNumbersAssociatedWithASpecificWorkspaceResponse1', 'ListOfRecordingAuditReportSummariesResponse',
            'ListPagingGroupObject', 'ListPagingGroupObject1', 'ListPoliciesType',
            'ListRecordingsForAnAdminOrComplianceOfficerResponse', 'ListRecordingsFormat', 'ListRecordingsResponse',
            'ListRecordingsStatus', 'ListReport', 'ListReport1', 'ListReportType', 'ListRoomsSortBy',
            'ListScheduleObject', 'ListSiteSessionTypesResponse', 'ListSnippetsOfAMeetingTranscriptResponse',
            'ListUserSessionTypeResponse', 'ListVirtualLineObject', 'ListVirtualLineObject1',
            'ListVirtualLineObjectExternalCallerIdNamePolicy', 'ListVoicemailGroupResponse',
            'ListVoicemailGroupResponse1', 'ListWholesaleBillingReportsSortBy', 'LocalGatewayUsageCount',
            'LocalGateways', 'Location', 'Location10', 'Location7', 'LocationsCollectionResponse',
            'MACAddressResponse', 'MacStatusObject', 'MacStatusObjectState', 'ManagedBy', 'ManagedByObject',
            'ManagedByObject1', 'ManagedGroupObject', 'ManagedOrgsResponse', 'ManagedSitesObject',
            'ManagerResponseObject', 'ManufacturerObject', 'MediaHealthMonitoringResultsCollectionfororganization',
            'MediaHealthMonitoringResultsforOrganization', 'MediaHealthMonitoringTestResultsFailure',
            'MediaHealthMonitoringTestResultsSuccess', 'MediaHealthMonitoringclusters',
            'MediaHealthMonitoringforfirstcluster', 'MediaHealthMonitoringsecondnode', 'MediaSessionQuality',
            'MediaSessionQuality1', 'MediaSessionQualityNetworkType', 'MediaSignallingtestResultFailure',
            'MediaSignallingtestResultSuccess', 'MediaType', 'MeetingAttendeeReportObject', 'MeetingPreferenceObject',
            'MeetingPreferenceObjectAudio', 'MeetingPreferenceObjectAudioDefaultAudioType',
            'MeetingPreferenceObjectAudioOfficeNumber', 'MeetingPreferenceObjectPersonalMeetingRoom',
            'MeetingPreferenceObjectPersonalMeetingRoomCoHosts',
            'MeetingPreferenceObjectPersonalMeetingRoomTelephony',
            'MeetingPreferenceObjectPersonalMeetingRoomTelephonyCallInNumbers',
            'MeetingPreferenceObjectPersonalMeetingRoomTelephonyCallInNumbersTollType',
            'MeetingPreferenceObjectSites', 'MeetingPreferenceObjectVideo',
            'MeetingPreferenceObjectVideoVideoDevices', 'MeetingQualitiesResponse', 'MeetingRecordingArchiveChat',
            'MeetingRecordingArchiveParticipant', 'MeetingRecordingArchivePoll',
            'MeetingRecordingArchivePollAnswerSummary', 'MeetingRecordingArchivePollContent',
            'MeetingRecordingArchivePollQuestion', 'MeetingRecordingArchivePollQuestionQuestion',
            'MeetingRecordingArchivePollRespondent', 'MeetingRecordingArchiveQA', 'MeetingRecordingArchiveQAAnswer',
            'MeetingRecordingArchiveSystemInfo', 'MeetingRecordingArchiveUser', 'MeetingSeriesObject',
            'MeetingSeriesObject1', 'MeetingSeriesObjectAttendeePrivileges',
            'MeetingSeriesObjectAudioConnectionOptions',
            'MeetingSeriesObjectAudioConnectionOptionsAudioConnectionType',
            'MeetingSeriesObjectAudioConnectionOptionsEntryAndExitTone', 'MeetingSeriesObjectForListMeeting',
            'MeetingSeriesObjectForListMeeting1', 'MeetingSeriesObjectMeetingOptions',
            'MeetingSeriesObjectMeetingOptionsNoteType', 'MeetingSeriesObjectMeetingType',
            'MeetingSeriesObjectRegistration', 'MeetingSeriesObjectScheduledType',
            'MeetingSeriesObjectSimultaneousInterpretation', 'MeetingSeriesObjectState',
            'MeetingSeriesObjectTelephony', 'MeetingSeriesObjectUnlockedMeetingJoinSecurity',
            'MeetingSeriesObjectWithAdhoc', 'MeetingSeriesObjectWithAdhoc1',
            'MeetingSeriesObjectWithAdhocRegistration', 'MeetingSessionTypeObject', 'MeetingSessionTypeObjectType',
            'MeetingTrackingCodesObject', 'MeetingUsageReportObject', 'MeetingUsageReportObjectScheduledType',
            'MeetingUsageReportObjectServiceType', 'MeetingUsageReportTrackingCodeObject', 'Member', 'MemberObject',
            'MemberObject1', 'MemberType', 'MemberType1', 'Membership', 'MembershipCollectionResponse', 'Message',
            'Message1', 'MessageCollectionResponse', 'MessageCollectionResponse1', 'Meta', 'Meta1', 'MetaObject',
            'MetaObjectResourceType', 'ModifyAutoAttendantCallForwardSelectiveRuleObject',
            'ModifyAutoAttendantCallForwardSettingsObject', 'ModifyAutoAttendantObject', 'ModifyAutoAttendantObject1',
            'ModifyCallExtensionParkObject', 'ModifyCallForwardingObject', 'ModifyCallForwardingObjectCallForwarding',
            'ModifyCallParkObject', 'ModifyCallParkSettingsObject', 'ModifyCallPickupObject',
            'ModifyCallPickupObject1', 'ModifyCallQueueHolidayObject', 'ModifyCallQueueObject',
            'ModifyCallQueueObject1', 'ModifyCallRecordingSettingsObject', 'ModifyCallRecordingTermsOfServiceObject',
            'ModifyDeviceTagsOp', 'ModifyHuntGroupObject', 'ModifyHuntGroupObject1', 'ModifyHuntGroupObject2',
            'ModifyHuntGroupObject3', 'ModifyNumbersForRouteListResponse',
            'ModifyPersonPlaceVirtualLineCallQueueObject', 'ModifyPlaceCallerIdGet', 'ModifyScheduleEventListObject',
            'ModifyScheduleEventObject', 'ModifyScheduleObject', 'MonitoredElementItem', 'MonitoredElementItem1',
            'MonitoredElementUser', 'MonitoredElementUser1', 'MonitoringSettings', 'MonitoringSettings1',
            'MonitoringSettingsPut', 'MoveNumberValidationError', 'MoveUsersErrorResponse', 'MoveUsersStartJobObject',
            'MoveUsersStartJobResponse', 'MoveUsersValidationResponse', 'MppAudioCodecPriorityObject', 'MppObject',
            'MppObjectDevice', 'MppVlanObject', 'NameObject', 'NetworkConnectivityType', 'NodeAvailability',
            'NodeAvailabilityCollection', 'NodeAvailableTimeline', 'NodeStatusList1', 'NodeStatusList1Status',
            'NodesAvailability', 'NoiseCancellationObject', 'Number', 'NumberCount', 'NumberItem',
            'NumberListGetObject', 'NumberListGetObject1', 'NumberListGetObject2', 'NumberObject', 'NumberObject1',
            'NumberObject2', 'NumberObject3', 'NumberObjectOwner', 'NumberObjectOwner2', 'NumberOwnerType',
            'NumberState', 'NumberStateOptions', 'NumberStatus', 'NumberTypeOptions', 'NumbersPost', 'NumbersPost1',
            'NumbersRequest', 'OnboardingMethodObject', 'Option', 'OptionsForTrackingCodeObject', 'OrderListResponse',
            'OrderRequest', 'OrderRequestLineItem', 'OrderResponse', 'OrderResponseLineItem', 'OrderShippingDetails',
            'Organization3', 'Organization4', 'Organization5', 'OrganizationCollectionResponse',
            'OrganizationCollectionResponse1', 'OrganizationCollectionResponse2', 'OrganizationSupportedContentType',
            'OrganizationsSpaceClassificationCollectionResponse', 'OriginatorType',
            'OutgoingCallingPermissionsSetting', 'OverflowDetails1', 'OverflowtoCloud', 'OverflowtoCloudCollection',
            'PMRIDObject', 'PMRIDResponseObject', 'Package', 'PackageName', 'PackageStatus', 'ParkResponse',
            'Participant', 'Participant1', 'ParticipantID', 'ParticipantState', 'PartnerAdminUser',
            'PartneradminsfororgResponse', 'PartyInformation', 'PasswordGenerate', 'PatchCallQueueNightServiceObject',
            'PatchCallingBehaviorObject', 'PatchGroup', 'PatchGroup1', 'PatchGroupOperations',
            'PatchMemberWithOperation', 'PatchUserLicenses', 'PbxUser', 'PerClusterConnectivityResult1',
            'PerNodeConnectivityResult1', 'Person', 'Person1', 'PersonAddresses', 'PersonCollectionResponse',
            'PersonId', 'PersonInvitePending', 'PersonPhoneNumbers', 'PersonPhoneNumbersType', 'PersonStatus',
            'PersonType', 'PhoneLanguage', 'PhoneNumber', 'PhotoObject', 'PhotoObjectType', 'PlaceCallerIdGet',
            'PoeMode', 'Policy', 'PolicyCollectionResponse', 'PolicyType', 'Poll', 'PollCollectionResponse',
            'PollResult', 'PollResultCollectionResponse', 'PostApplyLineKeyTemplateRequest',
            'PostApplyLineKeyTemplateRequestAction', 'PostCommonLocationObject', 'PostGroup', 'PostGroup1',
            'PostGroupUrnscimschemasextensionciscowebexidentity20Group', 'PostHuntGroupCallPolicyObject',
            'PostHuntGroupCallPolicyObjectNoAnswer', 'PostLineKeyTemplateRequest',
            'PostLocationAnnouncementLanguageObject', 'PostLocationCallingRequest',
            'PostLocationCallingRequestAddress', 'PostLocationVoicemailGroupObject', 'PostPagingGroupObject',
            'PostPersonPlaceObject', 'PostPersonPlaceVirtualLineCallQueueObject', 'PostScheduleObject', 'PostUser',
            'PostUserUrnietfparamsscimschemasextensionenterprise20User',
            'PostUserUrnscimschemasextensionciscowebexidentity20User', 'PostValidateExtensionResponse',
            'PostValidateExtensionResponseStatus', 'PrecheckABroadworksSubscriberProvisioningCustomerInfo',
            'PrecheckAWholesaleCustomerProvisioningCustomerInfo', 'PreviewApplyLineKeyTemplateResponse', 'PrivacyGet',
            'PrivacyGet1', 'ProgrammableLineKeys', 'ProvisionAWholesaleCustomerCustomerInfo',
            'ProvisionAWholesaleCustomerProvisioningParameters',
            'ProvisionAWholesaleCustomerProvisioningParametersCalling',
            'ProvisionAWholesaleCustomerProvisioningParametersCallingLocation',
            'ProvisionAWholesaleCustomerProvisioningParametersMeetings',
            'ProvisionAWholesaleSubscriberProvisioningParameters', 'PskObject', 'PstnNumber', 'PushToTalkAccessType',
            'PushToTalkConnectionType', 'PushToTalkInfo', 'PushToTalkInfo1', 'PushToTalkPut',
            'PutAccessCodeLocationObject', 'PutAgentCallQueueId', 'PutCommonLocationObject',
            'PutDeviceSettingsRequest', 'PutEvent', 'PutLineKeyTemplateRequest', 'PutLocationCallBackNumberObject',
            'PutLocationVoicemailGroupObject', 'PutMemberObject', 'PutMembersRequest', 'PutMusicOnHoldObject1',
            'PutPersonOrWorkspaceDetailsObject', 'PutRecallHuntGroupObject', 'PutSharedLineMemberItem',
            'PutSharedLineMemberList', 'PutTelephonyLocationObject', 'PutTelephonyLocationObject1',
            'PutThirdPartyDevice', 'PutUser', 'PutUserPhoneNumbers', 'PutVoicePortalObject',
            'PutVoicePortalObjectPasscode', 'PutVoicemailRulesObject', 'QAObject', 'QAObjectAnswers',
            'QueryRegistrants', 'QueryRegistrantsOrderBy', 'QueryRegistrantsOrderType', 'QueryStatusResponse',
            'QueryStatusResponseResult', 'QueryStatusResponseResultAudio', 'Question', 'QuestionObject',
            'QuestionObjectType', 'QuestionOptionObject', 'QuestionResult', 'QuestionType',
            'QuestionWithAnswersObject', 'QueueStats', 'QueueStatsResponse', 'RawMetric', 'ReachabilityTestResults',
            'ReachabilityTestResultsforcluster', 'ReachabilityTestResultsforfirstcluster',
            'ReachabilityTestresultsStunresults1', 'ReachabilityTestresultsSuccess',
            'ReachabilityTestresultsdestinationcluster', 'ReachabilityTestresultsfirstnode',
            'ReachabilityTestresultsfororganization', 'ReadListOfReceptionistContactDirectoriesResponse',
            'ReadTheListOfAnnouncementLanguagesResponse', 'ReadTheListOfAutoAttendantsResponse',
            'ReadTheListOfAutoAttendantsResponse1', 'ReadTheListOfAutoAttendantsResponse2',
            'ReadTheListOfCallParkExtensionsResponse', 'ReadTheListOfCallParkExtensionsResponse1',
            'ReadTheListOfCallParksResponse', 'ReadTheListOfCallPickupsResponse',
            'ReadTheListOfCallQueueAnnouncementFilesResponse', 'ReadTheListOfCallQueuesResponse',
            'ReadTheListOfCallQueuesResponse1', 'ReadTheListOfCallQueuesResponse2',
            'ReadTheListOfDialPatternsResponse', 'ReadTheListOfDialPlansResponse', 'ReadTheListOfHuntGroupsResponse',
            'ReadTheListOfHuntGroupsResponse1', 'ReadTheListOfHuntGroupsResponse2',
            'ReadTheListOfLineKeyTemplatesResponse', 'ReadTheListOfPagingGroupsResponse',
            'ReadTheListOfPagingGroupsResponse1', 'ReadTheListOfPagingGroupsResponse2',
            'ReadTheListOfRouteListsResponse', 'ReadTheListOfRoutingChoicesResponse',
            'ReadTheListOfRoutingGroupsResponse', 'ReadTheListOfSchedulesResponse', 'ReadTheListOfTrunksResponse',
            'ReadTheListOfUcManagerProfilesResponse', 'ReadTheListOfVirtualLinesResponse',
            'ReadTheListOfVirtualLinesResponse1', 'ReadTheRouteListsOfARoutingGroupResponse',
            'ReadTheUsageOfARoutingGroupResponse', 'ReassignMeetingErrorDescriptionObject',
            'ReassignMeetingRequestObject', 'ReassignMeetingResponseObject', 'ReassignMeetingsToANewHostResponse',
            'RecallInformation', 'RecallTypeEnum', 'ReceptionInfo', 'ReceptionInfo1', 'ReceptionPut', 'Recording',
            'RecordingAchriveSummaryObject', 'RecordingArchiveReportObject', 'RecordingObject',
            'RecordingObjectForAdminAndCO', 'RecordingObjectFormat', 'RecordingObjectWithDirectDownloadLinks',
            'RecordingObjectWithDirectDownloadLinksStatus',
            'RecordingObjectWithDirectDownloadLinksTemporaryDirectDownloadLinks', 'RecordingReportObject',
            'RecordingReportSummaryObject', 'RecordingStateEnum', 'RecordingStatus', 'RecurWeeklyObject',
            'RecurYearlyByDateObject', 'RecurYearlyByDateObjectMonth', 'RecurYearlyByDayObject',
            'RecurYearlyByDayObjectDay', 'RecurYearlyByDayObjectWeek', 'RecurrenceObject', 'RedirectCollectionForOrg',
            'RedirectTrend1', 'RedirectforOrg', 'RedirectionInformation', 'RedirectionReasonEnum', 'Registrant',
            'Registrant1', 'RegistrantCreateResponse', 'RegistrantFormObject', 'RegistrantStatus', 'Registration',
            'Registration2', 'RegistrationForUpdate', 'RegistrationForUpdate2', 'RejectActionEnum', 'Report',
            'Report1', 'Report2', 'ReportCollectionResponse', 'ReportError', 'ReportId1', 'ReportStatus',
            'ResourceDetails', 'ResourceGroup', 'ResourceGroupCollectionResponse', 'ResourceGroupMembership',
            'ResourceGroupMembershipCollectionResponse', 'ResourceGroupMembershipStatus', 'ResourceURL', 'Resources',
            'Respondent', 'RespondentCollectionResponse', 'RespondentsReferenceLinks', 'ResponseStatus',
            'ResponseStatusType', 'RetrieveExecutiveAssistantSettingsForAPersonResponse',
            'RetrieveExecutiveAssistantSettingsForAPersonResponseType', 'RingPatternObject', 'RoleCollectionResponse',
            'RoleObject', 'RoleObjectType', 'Room', 'RoomCollectionResponse', 'RoomMeetingDetails', 'RoomTab',
            'RoomTabsCollectionResponse', 'RouteGroup', 'RouteGroupGet', 'RouteGroupPatch',
            'RouteGroupUsageRouteListGet', 'RouteGroupUsageRouteListItem', 'RouteIdentity', 'RouteList',
            'RouteListGet', 'RouteListNumberListGet', 'RouteListNumberPatch', 'RouteListNumberPatchResponse',
            'RouteListPatch', 'RouteListPost', 'RouteType', 'ScheduleCollectionRequest', 'ScheduleCollectionResponse',
            'ScheduleLongDetails', 'ScheduleShortDetails', 'ScheduleStartCodeObject',
            'ScheduleStartCodeObjectService', 'ScheduleStartCodeObjectType', 'ScheduleUpdateRequest',
            'ScheduledMeetingObject', 'ScheduledMeetingObject1', 'SchedulingOptionsObject', 'SearchGroupResponse',
            'SearchMemberObject', 'SearchMemberResponse', 'SearchResponse', 'SearchUserResponse',
            'SecurityAuditEvent', 'SecurityAuditEventCollectionResponse', 'SecurityAuditEventData', 'SelectionType',
            'ServiceType', 'ServiceTypeResult2', 'ServiceTypeResult4', 'SessionType', 'SingleNodeAvailability',
            'SingleNodeAvailability1', 'SingleNodeAvailabilityCollection', 'SingleNodeAvailableTimeline',
            'SipAddressObject', 'SipAddressObjectType', 'SiteResponse', 'SiteResponseAccountType', 'SiteSessionType',
            'SiteSessionTypeType', 'SiteUrlsRequest', 'SiteUrlsRequestAccountType', 'SitesObject',
            'SkillCreateRequest', 'SkillCreateRequestLanguages', 'SkillCreateResponse', 'SnippetObject',
            'SnippetObject1', 'SnmpObject', 'SoftKeyLayoutObject', 'SoftKeyMenuObject',
            'StandardRegistrationApproveRule', 'StandardRegistrationApproveRuleQuestion',
            'StartJobExecutionStatusObject', 'StartJobResponse', 'StartJobResponseObject', 'State',
            'StatusOfExtensionsObject', 'StepExecutionStatuses', 'SubPartner', 'SubPartnerProvisioningState',
            'SubPartnersListResponse', 'SubmitCardAction', 'SubmitCardActionInputs', 'SubmitCardActionResponse',
            'Subscriber', 'Subscriber1', 'Subscriber2', 'SubscriberListResponse', 'SubscriberListResponse1',
            'SubscriberListResponse2', 'SubscriberPackage', 'SubscriberPackage2',
            'SubscriberProvisioningPrecheckResponse', 'SubscriberProvisioningPrecheckResponseInfo',
            'SubscriberStatus', 'SubscriberStatus2', 'SubscriptionTagsResponse', 'SupportAndConfiguredInfo',
            'SupportedDevicesObject', 'SurveyLinkObject', 'SurveyLinkRequestObject', 'SurveyObject',
            'SurveyResultObject', 'SystemInfoCatalog', 'TagsObj', 'TagsRequest', 'Task', 'TaskAttributes',
            'TaskAttributesStatus', 'TaskWithCaptures', 'TasksResponse', 'TasksValidationError', 'Team',
            'TeamCollectionResponse', 'TeamMembership', 'TeamMembershipCollectionResponse', 'TelephonyType',
            'Template', 'Template2', 'TemplateCollectionResponse', 'TemplateObject', 'TemplateTemplateType',
            'TestCallRoutingPostResponse', 'TranscriptObject', 'TranscriptObjectStatus',
            'TriggerDirectorySyncResponse', 'TriggerDirectorySyncResponseDirectorySyncStatus', 'TriggerOnDemandBody',
            'TriggerOnDemandBodyCluster', 'TriggerOnDemandBodyType', 'TriggerUserDirectorySyncResponse',
            'TriggerUserDirectorySyncResponseStatus', 'TriggerUserDirectorySyncResponseUserResponse',
            'TriggeredTestResult', 'TriggeredTestStatus1', 'Trunk', 'TrunkFQDNValidatePost', 'TrunkGet', 'TrunkPost',
            'TrunkPut', 'TrunkType', 'TrunkTypeGetList', 'TrunkTypeWithDeviceType', 'TypeObject',
            'UpdateAWholesaleSubscriberProvisioningParameters', 'UpdateEventThresholdConfig1',
            'UpdateEventThresholdConfigurationEventThresholds',
            'UpdateEventThresholdConfigurationEventThresholdsThresholdConfig', 'UpdateInterpreterObject',
            'UpdateInviteeObject', 'UpdateMeetingBreakoutSessionsObject',
            'UpdateMeetingConfigurationCommonSettingObject', 'UpdateMeetingObject', 'UpdateMeetingObject1',
            'UpdatePMRObject', 'UpdatePagingGroupObject', 'UpdatePagingGroupObject1', 'UpdateSnippetObject',
            'UpdateTrackingCodeForUserObject', 'UpdateUserSessionType', 'UsbPortsObject', 'UserHotelingRequestPatch',
            'UserItem', 'UserLicensesResponse', 'UserListItem', 'UserMonitoringGet', 'UserMonitoringGet1',
            'UserNumberItem', 'UserNumberItem1', 'UserNumbersPatch', 'UserPlaceAuthorizationCodeListGet',
            'UserSessionTypes', 'UserTypeObject', 'Users', 'UsersListItem', 'UtilizationMetricsT1SJ',
            'ValidateMACRequest', 'ValidateNumbersResponse', 'ValidationRules', 'ValidationRulesCollection',
            'VideoIn', 'VideoIn1', 'VideoInTransportType', 'VirtualExtension', 'VirtualExtensionRange',
            'VoiceMailPartyInformation', 'VoiceMessageDetails', 'VoicemailInfo', 'VoicemailInfoFaxMessage',
            'VoicemailInfoMessageStorage', 'VoicemailInfoSendBusyCalls', 'VoicemailInfoSendUnansweredCalls',
            'VoicemailInfoTransferToNumber', 'VoicemailPut', 'VoicemailPutSendBusyCalls',
            'VoicemailPutSendUnansweredCalls', 'VolumeSettingsObject', 'WebAccessObject', 'WebSocketConnectivityTest',
            'Webhook', 'WebhookCollectionResponse', 'WebhookEvent', 'WebhookResource', 'WebhookStatus',
            'WholesaleBillingReportsListResponse', 'WifiNetworkObject', 'WifiObject', 'WifiObjectDevice',
            'Workspace4', 'WorkspaceCalendar', 'WorkspaceCalendarType', 'WorkspaceCalling',
            'WorkspaceCallingHybridCalling', 'WorkspaceCallingType', 'WorkspaceCollectionResponse',
            'WorkspaceCreationRequest', 'WorkspaceCreationRequestCalendar', 'WorkspaceCreationRequestCalling',
            'WorkspaceCreationRequestCallingWebexCalling', 'WorkspaceDeviceHostedMeetings',
            'WorkspaceDurationMetricsResponse', 'WorkspaceDurationMetricsResponseAggregation',
            'WorkspaceDurationMetricsResponseMeasurement', 'WorkspaceHotdeskingStatus',
            'WorkspaceLocationsCollectionResponse', 'WorkspaceLocationsCreationRequest', 'WorkspaceMetricsResponse',
            'WorkspaceMetricsResponseAggregation', 'WorkspaceMetricsResponseMetricName',
            'WorkspaceMetricsResponseSortBy', 'WorkspaceMetricsResponseUnit', 'WorkspacePersonalizationRequest',
            'WorkspacePersonalizationTaskResponse', 'WorkspaceResponse', 'WorkspaceSupportedDevices', 'WorkspaceType',
            'WorkspaceType1', 'WorkspaceUpdateRequest', 'WorkspaceUpdateRequestType']


class AuditEventData(ApiModel):
    #: The display name of the organization.
    #: example: Acme Inc.
    actor_org_name: Optional[str] = None
    #: The name of the resource being acted upon.
    #: example: Acme Inc.
    target_name: Optional[str] = None
    #: A description for the event.
    #: example: An Admin logged in
    event_description: Optional[str] = None
    #: The name of the person who performed the action.
    #: example: Joe Smith
    actor_name: Optional[str] = None
    #: The email of the person who performed the action.
    #: example: joe@example.com
    actor_email: Optional[str] = None
    #: Admin roles for the person.
    #: example: ['User', 'Full_Admin', 'id_full_admin']
    admin_roles: Optional[list[str]] = None
    #: A tracking identifier for the event.
    #: example: ATLAS_6f23a878-bcd4-c204-a4db-e701b42b0e5c_0
    tracking_id: Optional[str] = None
    #: The type of resource changed by the event.
    #: example: TargetResourceType.ORG
    target_type: Optional[str] = None
    #: The identifier for the resource changed by the event.
    #: example: NWIzZTBiZDgtZjg4Ni00MjViLWIzMTgtYWNlYjliN2EwZGFj
    target_id: Optional[str] = None
    #: The category of resource changed by the event.
    #: example: EventCategory.LOGINS
    event_category: Optional[str] = None
    #: The browser user agent of the person who performed the action.
    #: example: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
    actor_user_agent: Optional[str] = None
    #: The IP address of the person who performed the action.
    #: example: 128.107.241.191
    actor_ip: Optional[str] = None
    #: The `orgId` of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    target_org_id: Optional[str] = None
    #: A more detailed description of the change made by the person.
    #: example: Joe Smith logged into organization Acme Inc.
    action_text: Optional[str] = None
    #: The name of the organization being acted upon.
    #: example: Acme Inc.
    target_org_name: Optional[str] = None
    #: User operation failure message.
    #: example: WXC-25058 Extension cannot be less than 2 or greater than 6 characters
    error_message: Optional[str] = None
    #: User operation failure code.
    #: example: WXC-25058
    error_code: Optional[str] = None


class AuditEvent(ApiModel):
    data: Optional[AuditEventData] = None
    #: The date and time the event took place.
    #: example: 2019-01-02T16:58:36.845Z
    created: Optional[datetime] = None
    #: The `orgId` of the person who made the change.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    actor_org_id: Optional[str] = None
    #: A unique identifier for the event.
    #: example: MjQ0ODhiZTYtY2FiMS00ZGRkLTk0NWQtZDFlYjkzOGQ4NGUy
    id: Optional[str] = None
    #: The `personId` of the person who made the change.
    #: example: MjQ4Njg2OTYtYWMwZC00ODY4LWJkMjEtZGUxZDc4MzhjOTdm
    actor_id: Optional[str] = None


class AuditEventCollectionResponse(ApiModel):
    #: An array of audit event objects. See `this article
    #: <https://help.webex.com/n3b0w6x/>`_ for details about each event type.
    items: Optional[list[AuditEvent]] = None


class AuditEventCategoryCollectionResponse(ApiModel):
    #: An array of audit event categories.
    event_categories: Optional[list[str]] = None


class AuditEventData1(ApiModel):
    #: The display name of the organization.
    #: example: Acme Inc.
    actor_org_name: Optional[str] = None
    #: The name of the resource being acted upon.
    #: example: Acme Inc.
    target_name: Optional[str] = None
    #: A description for the event.
    #: example: An Admin logged in
    event_description: Optional[str] = None
    #: The name of the person who performed the action.
    #: example: Joe Smith
    actor_name: Optional[str] = None
    #: The email of the person who performed the action.
    #: example: joe@example.com
    actor_email: Optional[str] = None
    #: Admin roles for the person.
    #: example: ['User', 'Full_Admin', 'id_full_admin']
    admin_roles: Optional[list[str]] = None
    #: A tracking identifier for the event.
    #: example: ATLAS_6f23a878-bcd4-c204-a4db-e701b42b0e5c_0
    tracking_id: Optional[str] = None
    #: The type of resource changed by the event.
    #: example: TargetResourceType.ORG
    target_type: Optional[str] = None
    #: The identifier for the resource changed by the event.
    #: example: NWIzZTBiZDgtZjg4Ni00MjViLWIzMTgtYWNlYjliN2EwZGFj
    target_id: Optional[str] = None
    #: The category of resource changed by the event.
    #: example: EventCategory.LOGINS
    event_category: Optional[str] = None
    #: The browser user agent of the person who performed the action.
    #: example: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
    actor_user_agent: Optional[str] = None
    #: The IP address of the person who performed the action.
    #: example: 128.107.241.191
    actor_ip: Optional[str] = None
    #: The `orgId` of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    target_org_id: Optional[str] = None
    #: A more detailed description of the change made by the person.
    #: example: Joe Smith logged into organization Acme Inc.
    action_text: Optional[str] = None
    #: The name of the organization being acted upon.
    #: example: Acme Inc.
    target_org_name: Optional[str] = None


class AuditEvent1(ApiModel):
    data: Optional[AuditEventData1] = None
    #: The date and time the event took place.
    #: example: 2019-01-02T16:58:36.845Z
    created: Optional[datetime] = None
    #: The `orgId` of the person who made the change.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    actor_org_id: Optional[str] = None
    #: A unique identifier for the event.
    #: example: MjQ0ODhiZTYtY2FiMS00ZGRkLTk0NWQtZDFlYjkzOGQ4NGUy
    id: Optional[str] = None
    #: The `personId` of the person who made the change.
    #: example: MjQ4Njg2OTYtYWMwZC00ODY4LWJkMjEtZGUxZDc4MzhjOTdm
    actor_id: Optional[str] = None


class AuditEventCollectionResponse1(ApiModel):
    #: An array of audit event objects. See `this article
    #: <https://help.webex.com/n3b0w6x/>`_ for details about each event type.
    items: Optional[list[AuditEvent1]] = None


class ApplicationUsagePolicyAction(str, Enum):
    allow = 'allow'
    deny = 'deny'


class ApplicationUsage(ApiModel):
    #: A unique identifier for the application.
    #: example: Y2lzY29zcGFyazovL3VzL0FQUExJQ0FUSU9OLzEyMzQ1Njc4LTkwYWItY2RlZi0xMjM0LTU2Nzg5MGFiY2RlZg
    id: Optional[str] = None
    #: The ID of the organization to which this application belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The ID of the policy which permits usage of this application.
    #: example: ``
    policy_id: Optional[str] = None
    #: A unique identifier for the application.
    #: example: Y2lzY29zcGFyazovL3VzL0FQUExJQ0FUSU9OLzEyMzQ1Njc4LTkwYWItY2RlZi0xMjM0LTU2Nzg5MGFiY2RlZg
    app_id: Optional[str] = None
    #: A descriptive name for the application.
    #: example: My Great App
    app_name: Optional[str] = None
    #: The application's Oauth client ID.
    #: example: C1234567890ABCDEF
    app_client_id: Optional[str] = None
    #: URL for the application's privacy policy.
    #: example: https://www.example.com/privacy-policy
    app_privacy_url: Optional[str] = None
    #: URL for the application's support information.
    #: example: https://help.example.com/
    app_support_url: Optional[str] = None
    #: URL for the application's maintainer.
    #: example: https://www.example.com
    app_company_url: Optional[str] = None
    #: Contact name for the application.
    #: example: John Andersen
    app_contact_name: Optional[str] = None
    #: Contact email for the application.
    #: example: info@example.com
    app_contact_email: Optional[str] = None
    #: How many users use the application.
    #: example: 5.0
    app_user_adoption: Optional[int] = None
    #: Whether or not the application is allowed by policy.
    #: example: allow
    policy_action: Optional[ApplicationUsagePolicyAction] = None
    #: The date and time the application was created.
    #: example: 2017-10-01T07:00:00.000Z
    app_created: Optional[datetime] = None
    #: The date and time this application's usage was last updated.
    #: example: 2018-10-01T07:00:00.000Z
    last_updated: Optional[datetime] = None


class ApplicationUsageCollectionResponse(ApiModel):
    items: Optional[list[ApplicationUsage]] = None


class ListApplicationUsageOrderBy(str, Enum):
    is_featured = 'isFeatured'
    last_submission_date = 'lastSubmissionDate'
    policy = 'policy'
    app_name = 'appName'
    name = 'name'


class ApplicationType(str, Enum):
    integration = 'integration'


class ApplicationSubmissionStatus(str, Enum):
    none_ = 'none'
    submitted = 'submitted'
    in_review = 'in_review'
    pending_approval = 'pending_approval'
    approved = 'approved'


class ApplicationOrgSubmissionStatus(str, Enum):
    none_ = 'none'
    submitted = 'submitted'
    in_review = 'in_review'
    pending_approval = 'pending_approval'
    approved = 'approved'
    none_ = 'none'


class Application(ApiModel):
    #: A unique identifier for the application.
    #: example: Y2lzY29zcGFyazovL3VzL0FQUExJQ0FUSU9OLzEyMzQ1Njc4LTkwYWItY2RlZi0xMjM0LTU2Nzg5MGFiY2RlZg
    id: Optional[str] = None
    #: A descriptive name for the application.
    #: example: My Great App
    name: Optional[str] = None
    #: A unique URL-friendly identifier for the application.
    #: example: my-great-app-my-company
    friendly_id: Optional[str] = None
    #: The type of application.
    #: example: integration
    type: Optional[ApplicationType] = None
    #: URL for the application's logo.
    #: example: https://cdn.example.com/my-great-app-logo.png
    logo: Optional[str] = None
    #: Brief description of the application.
    #: example: My Great App helps you get things done.
    tagline: Optional[str] = None
    #: Description of the application.
    #: example: My Great App helps you achieve your business goals by getting out of the way and letting you focus on what's important. Use My Great App to unlock the potential of your business.
    description: Optional[str] = None
    #: URL for the application's first screenshot.
    #: example: https://cdn.example.com/my-great-app-screenshot-1.png
    screenshot1: Optional[str] = None
    #: URL for the application's second screenshot.
    #: example: https://cdn.example.com/my-great-app-screenshot-2.png
    screenshot2: Optional[str] = None
    #: URL for the application's third screenshot.
    #: example: https://cdn.example.com/my-great-app-screenshot-3.png
    screenshot3: Optional[str] = None
    #: An array of languages supported by the application.
    #: example: ['en-US', 'es-MX']
    supported_languages: Optional[list[str]] = None
    #: An array of categories the application belongs to.
    #: example: ['productivity', 'other']
    categories: Optional[list[str]] = None
    tags: Optional[list[str]] = None
    #: URL for the application's informational video.
    #: example: https://youtu.be/abc123
    video_url: Optional[str] = None
    #: The ID of the organization to which this application belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: Contact email for the application.
    #: example: info@example.com
    contact_email: Optional[str] = None
    #: Contact name for the application.
    #: example: John Andersen
    contact_name: Optional[str] = None
    #: Company name for the application.
    #: example: Example, Inc.
    company_name: Optional[str] = None
    #: URL for the application's maintainer.
    #: example: https://www.example.com
    company_url: Optional[str] = None
    #: URL for the application's product information page.
    #: example: https://www.example.com/products/my-great-app
    product_url: Optional[str] = None
    #: URL for the application's support information.
    #: example: https://help.example.com/
    support_url: Optional[str] = None
    #: URL for the application's privacy policy.
    #: example: https://www.example.com/privacy-policy
    privacy_url: Optional[str] = None
    #: Oauth redirect URLs for the application (only present if the application is an integration).
    #: example: ['https://my-app.example.com/authenticate', 'https://my-app-staging.example.com/authenticate']
    redirect_urls: Optional[list[str]] = None
    #: Scopes requested by the application (only present if the application is an integration).
    #: example: ['spark:people_read', 'spark:messages_write']
    scopes: Optional[list[str]] = None
    #: An array of keywords associated with the application.
    #: example: ['productivity', 'efficiency']
    keywords: Optional[list[str]] = None
    #: The application's Oauth client ID.
    #: example: C1234567890ABCDEF
    client_id: Optional[str] = None
    #: If the application is a bot, this is the bot's email address. (only present if the application is a bot).
    #: example: my-great-app@webex.bot
    bot_email: Optional[str] = None
    #: If the application is a bot, this is the bot's personId (only present if the application is a bot).
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xMjM0NTY3OC05MGFiLWNkZWYtMTIzNC01Njc4OTBhYmNkZWY
    bot_person_id: Optional[str] = None
    #: Whether or not the application is featured on the Webex App Hub.
    is_featured: Optional[bool] = None
    #: Internal use only.
    is_native: Optional[bool] = None
    #: The date and time the application was submitted to Webex App Hub.
    #: example: 2017-12-01T07:00:00.000Z
    submission_date: Optional[datetime] = None
    #: The Webex App Hub submission status of the application.
    #: example: in_review
    submission_status: Optional[ApplicationSubmissionStatus] = None
    org_submission_status: Optional[ApplicationOrgSubmissionStatus] = None
    #: The ID of the person who created the application.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    created_by: Optional[str] = Field(alias='created_by', default=None)
    #: The date and time the application was created.
    #: example: 2017-10-01T07:00:00.000Z
    created: Optional[datetime] = None


class ApplicationsCollectionResponse(ApiModel):
    items: Optional[list[Application]] = None


class ListApplicationsType(str, Enum):
    integration = 'integration'
    bot = 'bot'


class AttachmentAction(ApiModel):
    ...


class SubmitCardActionInputs(ApiModel):
    #: example: John Andersen
    name: Optional[str] = Field(alias='Name', default=None)
    #: example: https://example.com
    url: Optional[str] = Field(alias='Url', default=None)
    #: example: john.andersen@example.com
    email: Optional[str] = Field(alias='Email', default=None)
    #: example: +1 408 555 7209
    tel: Optional[str] = Field(alias='Tel', default=None)


class AttachmentActivityType(str, Enum):
    submit = 'submit'


class SubmitCardAction(AttachmentAction):
    #: Type of action
    #: example: submit
    type: Optional[AttachmentActivityType] = None
    #: The parent message on which the attachment action was performed.
    #: example: GFyazovL3VzL1BFT1BMRS80MDNlZmUwNy02Yzc3LTQyY2UtOWI4NC
    message_id: Optional[str] = None
    inputs: Optional[SubmitCardActionInputs] = None


class SubmitCardActionResponse(SubmitCardAction):
    #: The unique identifier of the action.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExTLzU0MUFFMzBFLUUyQzUtNERENi04NTM4LTgzOTRDODYzM0I3MQo
    id: Optional[str] = None
    #: The person who performed the action.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83MTZlOWQxYy1jYTQ0LTRmZ
    person_id: Optional[str] = None
    #: The room in which the action was performed.
    #: example: L3VzL1BFT1BMRS80MDNlZmUwNy02Yzc3LTQyY2UtOWI
    room_id: Optional[str] = None
    #: The timestamp of the action.
    #: example: 2016-05-10T19:41:00.100Z
    created: Optional[datetime] = None


class AttachmentActivity(ApiModel):
    #: A unique identifier for the action.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExTLzU0MUFFMzBFLUUyQzUtNERENi04NTM4LTgzOTRDODYzM0I3MQo
    id: Optional[str] = None
    #: The ID of the person who performed the action.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83MTZlOWQxYy1jYTQ0LTRmZ
    person_id: Optional[str] = None
    #: The ID of the room in which the action was performed.
    #: example: L3VzL1BFT1BMRS80MDNlZmUwNy02Yzc3LTQyY2UtOWI
    room_id: Optional[str] = None
    #: The type of action performed.
    #: example: submit
    type: Optional[AttachmentActivityType] = None
    #: The parent message on which the attachment action was performed.
    #: example: GFyazovL3VzL1BFT1BMRS80MDNlZmUwNy02Yzc3LTQyY2UtOWI4NC
    message_id: Optional[str] = None
    #: The action's inputs.
    inputs: Optional[SubmitCardActionInputs] = None
    #: The date and time the action was created.
    #: example: 2016-05-10T19:41:00.100Z
    created: Optional[datetime] = None


class AuthorizationType(str, Enum):
    #: refresh authorization used to create `access` tokens
    refresh = 'refresh'
    #: `access` token authorization
    access = 'access'


class Authorization(ApiModel):
    #: The unique authorization identifier.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVEhPUklaQVRJT04vZjI3MDM0ZTMtMDA5ZS00ODA4LTk5MDQtNTNkMDQ0OGJlNDVk
    id: Optional[str] = None
    #: The unique identifier for the application.
    #: example: Y2lzY29zcGFyazovL3VzL0FQUExJQ0FUSU9OL0NmMzkyNWU5NDFmMzhhYTc0M2Y0MmFiNzcwZmZhZjFhNTIyMjcxZDI5OTQ4NDhjNjk2YWMwYTEwN2Q2YTg5MjI3
    application_id: Optional[str] = None
    #: The name of the Integration.
    #: example: Developer Portal
    application_name: Optional[str] = None
    #: The unique oAuth client id.
    #: example: C80fb9c7096bd8474627317ee1d7a817eff372ca9c9cee3ce43c3ea3e8d1511ec
    client_id: Optional[str] = None
    #: The date and time the authorization was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None
    #: The type of token associated with the authorization.
    #: example: refresh
    type: Optional[AuthorizationType] = None


class AuthorizationsCollectionResponse(ApiModel):
    items: Optional[list[Authorization]] = None


class EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors(ApiModel):
    #: An error code that identifies the reason for the error
    #: example: 6003.0
    error_code: Optional[int] = None
    #: A textual representation of the error code.
    #: example: Broadworks External Directory User Sync failed while trying to connect to Broadworks cluster.
    description: Optional[str] = None


class EnterpriseBroadworksDirectorySyncDirectorySyncStatus(ApiModel):
    #: The start date and time of the last sync.
    #: example: 2021-04-01T14:49:50.309640Z
    last_sync_start_time: Optional[datetime] = None
    #: The end date and time of the last sync.
    #: example: 2021-04-01T14:49:52.667189Z
    last_sync_end_time: Optional[datetime] = None
    #: The sync status of the enterprise.
    #: example: COMPLETE
    sync_status: Optional[str] = None
    #: The number of users added to CI (Common Identity) in this sync.
    #: example: 44.0
    users_added: Optional[int] = None
    #: The number of users updated in CI (Common Identity)  in this sync.
    #: example: 21.0
    users_updated: Optional[int] = None
    #: The number of users deleted from CI (Common Identity)  in this sync.
    #: example: 34.0
    users_deleted: Optional[int] = None
    #: The number of machines added to CI (Common Identity)  in this sync.
    #: example: 24.0
    machines_added: Optional[int] = None
    #: The number of machines updated in CI (Common Identity)  in this sync.
    #: example: 4.0
    machines_updated: Optional[int] = None
    #: The number of machines deleted from CI (Common Identity)  in this sync.
    #: example: 9.0
    machines_deleted: Optional[int] = None
    #: The number of total external users that have been added to CI across all syncs.
    #: example: 1077.0
    total_external_users_in_ci: Optional[int] = Field(alias='totalExternalUsersInCI', default=None)
    #: The number of total external machines that have been added to CI (Common Identity)  across all syncs.
    #: example: 326.0
    total_external_machines_in_ci: Optional[int] = Field(alias='totalExternalMachinesInCI', default=None)
    #: The date and time of the last successful sync.
    #: example: 2021-04-01T14:48:30.502539Z
    last_successful_sync_time: Optional[datetime] = None
    #: Unique tracking identifier.
    #: example: NA_dde3a13a-bad7-4990-b155-9b4574e545b9
    last_sync_tracking_id: Optional[str] = None
    #: List of errors that occurred during that last attempt to sync this BroadWorks enterprise. This list captures
    #: errors that occurred during *directory sync* of the BroadWorks enterprise, *after* the API has been accepted
    #: and 200 OK response returned. Any errors that occur during initial API request validation will be captured
    #: directly in error response with appropriate HTTP status code.
    errors: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None
    #: The number of user contacts added to Contact service in this sync.
    #: example: 5.0
    user_contacts_added: Optional[int] = None
    #: The number of user contacts updated in Contact service in this sync.
    #: example: 2.0
    user_contacts_updated: Optional[int] = None
    #: The number of user contacts deleted from Contact service in this sync.
    #: example: 1.0
    user_contacts_deleted: Optional[int] = None
    #: The number of org contacts added to Contact service in this sync.
    #: example: 5.0
    org_contacts_added: Optional[int] = None
    #: The number of org contacts updated in Contact service in this sync.
    #: example: 2.0
    org_contacts_updated: Optional[int] = None
    #: The number of org contacts deleted from Contact service in this sync.
    #: example: 1.0
    org_contacts_deleted: Optional[int] = None
    #: The total number of user contacts in Contact service.
    #: example: 10.0
    total_user_contacts_in_contact_service: Optional[int] = None
    #: The total number of org contacts in Contact service.
    #: example: 2.0
    total_org_contacts_in_contact_service: Optional[int] = None


class EnterpriseBroadworksDirectorySync(ApiModel):
    #: The toggle to enable/disable directory sync.
    #: example: True
    enable_dir_sync: Optional[bool] = None
    #: Directory sync status
    directory_sync_status: Optional[EnterpriseBroadworksDirectorySyncDirectorySyncStatus] = None


class Enterprise(ApiModel):
    #: A unique Cisco identifier for the enterprise.
    #: example: Y2lzY29zcGFyazovL3VzL0VOVEVSUFJJU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: The Organization ID of the enterprise on Cisco Webex.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The Provisioning ID associated with the enterprise.
    #: example: ZjViMzYxODctYzhkZC00NzI3LThiMmYtZjljNDQ3ZjI5MDQ2OjQyODVmNTk0LTViNTEtNDdiZS05Mzk2LTZjMzZlMmFkODNhNQ
    provisioning_id: Optional[str] = None
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    #: example: Reseller1+acme
    sp_enterprise_id: Optional[str] = None
    #: BroadWorks Directory sync
    broadworks_directory_sync: Optional[EnterpriseBroadworksDirectorySync] = None


class EnterpriseListResponse(ApiModel):
    items: Optional[list[Enterprise]] = None


class TriggerDirectorySyncResponseDirectorySyncStatus(ApiModel):
    #: The sync status of the enterprise.
    #: example: IN_PROGRESS
    sync_status: Optional[str] = None


class TriggerDirectorySyncResponse(ApiModel):
    #: The toggle that enabled the directory sync.
    #: example: True
    enable_dir_sync: Optional[bool] = None
    #: Directory sync status
    directory_sync_status: Optional[TriggerDirectorySyncResponseDirectorySyncStatus] = None


class TriggerUserDirectorySyncResponseUserResponse(ApiModel):
    #: The UserID of the user on Broadworks (A non-webex user).
    #: example: john.anderson@acme.com
    user_id: Optional[str] = None
    #: First Name of the user on Broadworks.
    #: example: John
    first_name: Optional[str] = None
    #: Last Name of the user on Broadworks.
    #: example: Anderson
    last_name: Optional[str] = None
    #: Extension of the user on Broadworks.
    #: example: 4653
    extension: Optional[datetime] = None
    #: Phone number of the user on Broadworks.
    #: example: +35391884653
    number: Optional[str] = None
    #: Mobile number of the user on Broadworks.
    #: example: +188-(2323)-(343)
    mobile: Optional[str] = None


class TriggerUserDirectorySyncResponseStatus(str, Enum):
    #: The external user is added in this sync
    add = 'ADD'
    #: The external user is updated in this sync
    update = 'UPDATE'
    #: The external user is deleted in this sync
    delete = 'DELETE'
    #: No changes made on the external user in this sync
    no_operation = 'NO_OPERATION'


class TriggerUserDirectorySyncResponse(ApiModel):
    #: User Directory sync response
    user_response: Optional[TriggerUserDirectorySyncResponseUserResponse] = None
    #: The Status of the operation being performed.
    #: example: ADD
    status: Optional[TriggerUserDirectorySyncResponseStatus] = None


class EnterpriseBroadworksDirectorySyncDirectorySyncStatus1(ApiModel):
    #: The start date and time of the last sync.
    #: example: 2021-04-01T14:49:50.309640Z
    last_sync_start_time: Optional[datetime] = None
    #: The end date and time of the last sync.
    #: example: 2021-04-01T14:49:52.667189Z
    last_sync_end_time: Optional[datetime] = None
    #: The sync status of the enterprise.
    #: example: COMPLETE
    sync_status: Optional[str] = None
    #: The number of users added to CI (Common Identity) in this sync.
    #: example: 44.0
    users_added: Optional[int] = None
    #: The number of users updated in CI (Common Identity) in this sync.
    #: example: 21.0
    users_updated: Optional[int] = None
    #: The number of users deleted from CI (Common Identity) in this sync.
    #: example: 34.0
    users_deleted: Optional[int] = None
    #: The number of machines added to CI (Common Identity) in this sync.
    #: example: 24.0
    machines_added: Optional[int] = None
    #: The number of machines updated in CI (Common Identity) in this sync.
    #: example: 4.0
    machines_updated: Optional[int] = None
    #: The number of machines deleted from CI (Common Identity) in this sync.
    #: example: 9.0
    machines_deleted: Optional[int] = None
    #: The number of total external users that have been added to CI across all syncs.
    #: example: 1077.0
    total_external_users_in_ci: Optional[int] = Field(alias='totalExternalUsersInCI', default=None)
    #: The number of total external machines that have been added to CI (Common Identity) across all syncs.
    #: example: 326.0
    total_external_machines_in_ci: Optional[int] = Field(alias='totalExternalMachinesInCI', default=None)
    #: The date and time of the last successful sync.
    #: example: 2021-04-01T14:48:30.502539Z
    last_successful_sync_time: Optional[datetime] = None
    #: Unique tracking identifier.
    #: example: NA_dde3a13a-bad7-4990-b155-9b4574e545b9
    last_sync_tracking_id: Optional[str] = None
    #: List of errors that occurred during that last attempt to sync this BroadWorks enterprise. This list captures
    #: errors that occurred during *directory sync* of the BroadWorks enterprise, *after* the API has been accepted
    #: and 200 OK response returned. Any errors that occur during initial API request validation will be captured
    #: directly in error response with appropriate HTTP status code.
    errors: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None
    #: The number of user contacts added to Contact service in this sync.
    #: example: 5.0
    user_contacts_added: Optional[int] = None
    #: The number of user contacts updated in Contact service in this sync.
    #: example: 2.0
    user_contacts_updated: Optional[int] = None
    #: The number of user contacts deleted from Contact service in this sync.
    #: example: 1.0
    user_contacts_deleted: Optional[int] = None
    #: The number of group contacts added to Contact service in this sync.
    #: example: 5.0
    group_contacts_added: Optional[int] = None
    #: The number of group contacts updated in Contact service in this sync.
    #: example: 2.0
    group_contacts_updated: Optional[int] = None
    #: The number of group contacts deleted from Contact service in this sync.
    #: example: 1.0
    group_contacts_deleted: Optional[int] = None
    #: The number of org contacts added to Contact service in this sync.
    #: example: 5.0
    org_contacts_added: Optional[int] = None
    #: The number of org contacts updated in Contact service in this sync.
    #: example: 2.0
    org_contacts_updated: Optional[int] = None
    #: The number of org contacts deleted from Contact service in this sync.
    #: example: 1.0
    org_contacts_deleted: Optional[int] = None
    #: The total number of user contacts in Contact service.
    #: example: 10.0
    total_user_contacts_in_contact_service: Optional[int] = None
    #: The total number of group contacts in Contact service.
    #: example: 10.0
    total_group_contacts_in_contact_service: Optional[int] = None
    #: The total number of org contacts in Contact service.
    #: example: 2.0
    total_org_contacts_in_contact_service: Optional[int] = None


class EnterpriseBroadworksDirectorySync1(ApiModel):
    #: The toggle to enable/disable directory sync.
    #: example: True
    enable_dir_sync: Optional[bool] = None
    #: Directory sync status.
    directory_sync_status: Optional[EnterpriseBroadworksDirectorySyncDirectorySyncStatus1] = None


class Enterprise1(ApiModel):
    #: A unique Cisco identifier for the enterprise.
    #: example: Y2lzY29zcGFyazovL3VzL0VOVEVSUFJJU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: The Organization ID of the enterprise on Cisco Webex.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The Provisioning ID associated with the enterprise.
    #: example: ZjViMzYxODctYzhkZC00NzI3LThiMmYtZjljNDQ3ZjI5MDQ2OjQyODVmNTk0LTViNTEtNDdiZS05Mzk2LTZjMzZlMmFkODNhNQ
    provisioning_id: Optional[str] = None
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    #: example: Reseller1+acme
    sp_enterprise_id: Optional[str] = None
    #: BroadWorks Directory sync.
    broadworks_directory_sync: Optional[EnterpriseBroadworksDirectorySync1] = None


class EnterpriseListResponse1(ApiModel):
    items: Optional[list[Enterprise1]] = None


class Enterprise3(ApiModel):
    #: A unique Cisco identifier for the enterprise.
    #: example: Y2lzY29zcGFyazovL3VzL0VOVEVSUFJJU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: The Organization ID for the Webex enterprise.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The Provisioning ID associated with the enterprise.
    #: example: ZjViMzYxODctYzhkZC00NzI3LThiMmYtZjljNDQ3ZjI5MDQ2OjQyODVmNTk0LTViNTEtNDdiZS05Mzk2LTZjMzZlMmFkODNhNQ
    provisioning_id: Optional[str] = None
    #: The date and time of org creation.
    #: example: 2022-03-25T11:33:48.455Z
    org_creation_time_stamp: Optional[datetime] = None
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    #: example: Reseller1+example
    sp_enterprise_id: Optional[str] = None
    #: BroadWorks Directory sync.
    broadworks_directory_sync: Optional[EnterpriseBroadworksDirectorySync] = None


class EnterpriseListResponse3(ApiModel):
    items: Optional[list[Enterprise3]] = None


class SubscriberPackage(str, Enum):
    #: Softphone package
    softphone = 'softphone'
    #: Basic package
    basic = 'basic'
    #: Standard package
    standard = 'standard'
    #: Premium package
    premium = 'premium'


class SubscriberStatus(str, Enum):
    #: Subscriber provisioning is paused, pending input of an email address.
    pending_email_input = 'pending_email_input'
    #: Subscriber provisioning is paused. The subscriber has entered an email address but has yet to complete
    #: validation.
    pending_email_validation = 'pending_email_validation'
    #: Subscriber provisioning is paused. An automated email has been sent to the subscriber; waiting for the
    #: subscriber's consent.
    pending_user_migration = 'pending_user_migration'
    #: Subscriber provisioning is in progress.
    provisioning = 'provisioning'
    #: The subscriber is fully provisioned on Webex.
    provisioned = 'provisioned'
    #: An update is in progress for a provisioned subscriber.
    updating = 'updating'
    #: An error occurred provisioning the subscriber on Webex.
    error = 'error'


class Subscriber(ApiModel):
    #: A unique Cisco identifier for the subscriber.
    #: example: 'Y2lzY29zcGFyazovL3VzL1NVQlNDUklCRVIvNjk3MGU2YmItNzQzOS00ZmZiLWFkMzQtZDNmZjAxNjdkZGFk'
    id: Optional[str] = None
    #: The Person Id of the subscriber on Webex. To be used when referencing this subscriber on other Webex APIs. Only
    #: presented when status is `provisioned`.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The user ID of the subscriber on BroadWorks.
    #: example: 95547321@sp.com
    user_id: Optional[str] = None
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    #: example: Enterprise1
    sp_enterprise_id: Optional[str] = None
    #: The group name under the enterprise in Broadworks. Only applicable to Enterprise mode.
    #: example: BroadworksEnterpriseGroup
    sp_enterprise_group_id: Optional[str] = None
    #: The first name of the subscriber.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the subscriber.
    #: example: Andersen
    last_name: Optional[str] = None
    #: The email address of the subscriber.
    #: example: john.anderson@acme.com
    email: Optional[str] = None
    #: The primary phone number configured against the subscriber on BroadWorks.
    #: example: +1-240-555-1212
    primary_phone_number: Optional[str] = None
    #: The mobile phone number configured against the subscriber on BroadWorks.
    #: example: +1-818-279-1234
    mobile_phone_number: Optional[str] = None
    #: The ISO 639-1 language code associated with the subscriber. Reserved for future use. Any value returned should
    #: be ignored. Currently set to "en" in all responses.
    #: example: en
    language: Optional[str] = None
    #: The Webex for BroadWorks Package assigned to the subscriber.
    #: example: standard
    package: Optional[SubscriberPackage] = None
    #: The provisioning status of the user.
    #: example: provisioned
    status: Optional[SubscriberStatus] = None
    #: List of errors that occurred during that last attempt to provision/update this subscriber.
    #: 
    #: *Note:*
    #: 
    #: + This list captures errors that occurred during *asynchronous or background* provisioning of the subscriber,
    #: *after* the API has been accepted and 200 OK response returned.
    #: 
    #: + Any errors that occur during initial API request validation will be captured directly in error response with
    #: appropriate HTTP status code.
    errors: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None
    #: The date and time the subscriber was provisioned.
    #: example: 2019-10-18T14:26:16.000Z
    created: Optional[datetime] = None
    #: The date and time the provisioning status of the subscriber last changed.
    #: example: 2020-03-18T16:05:34.000Z
    last_status_change: Optional[datetime] = None
    #: This Provisioning ID associated with this subscriber.
    #: example: ZjViMzYxODctYzhkZC00NzI3LThiMmYtZjljNDQ3ZjI5MDQ2OjQyODVmNTk0LTViNTEtNDdiZS05Mzk2LTZjMzZlMmFkODNhNQ
    provisioning_id: Optional[str] = None
    #: Indicates if the subscriber was self activated, rather than provisioned via these APIs.
    self_activated: Optional[bool] = None


class SubscriberListResponse(ApiModel):
    #: An array of Subscriber objects.
    items: Optional[list[Subscriber]] = None


class CallPersonalityEnum(str, Enum):
    #: An outgoing call originated by the user.
    originator = 'originator'
    #: An incoming call received by the user.
    terminator = 'terminator'
    #: A call that is alerting the user's devices for a Click to Dial action. When the user answers on one of these
    #: alerting devices, the call's personality is updated to originator.
    click_to_dial = 'clickToDial'


class CallStateEnum(str, Enum):
    #: The remote party is being alerted.
    connecting = 'connecting'
    #: The user's devices are alerting for the incoming or Click to Dial call.
    alerting = 'alerting'
    #: The call is connected.
    connected = 'connected'
    #: The user has placed the call on hold.
    held = 'held'
    #: The remote party within the same organization has placed the call on hold.
    remote_held = 'remoteHeld'
    #: The call has been disconnected.
    disconnected = 'disconnected'


class CallTypeEnum(str, Enum):
    #: The party is within the same location.
    location = 'location'
    #: The party is within the same organization but not within the same location.
    organization = 'organization'
    #: The party is outside the organization.
    external = 'external'
    #: The party is an emergency call destination.
    emergency = 'emergency'
    #: The party is a repair call destination.
    repair = 'repair'
    #: The party does not belong to one of the defined call types. For example, a call to a Call Forwarding Always
    #: feature activation code.
    other = 'other'


class PartyInformation(ApiModel):
    #: The party's name. Only present when the name is available and privacy is not enabled.
    #: example: John Smith
    name: Optional[str] = None
    #: The party's number. Only present when the number is available and privacy is not enabled. The number can be
    #: digits or a URI. Some examples for number include: `1234`, `2223334444`, `+12223334444`, `*73`,
    #: `user@company.domain`
    #: example: +12223334444
    number: Optional[str] = None
    #: The party's person ID. Only present when the person ID is available and privacy is not enabled.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9hMTlkODJhMi00ZTY5LTU5YWEtOWYyZi1iY2E2MzEwMTNhNjg=
    person_id: Optional[str] = None
    #: The party's place ID. Only present when the place ID is available and privacy is not enabled.
    #: example: Y2lzY29zcGFyazovL3VzL1BMQUNFL2ExOWQ4MmEyLTRlNjktNTlhYS05ZjJmLWJjYTYzMTAxM2E2OA==
    place_id: Optional[str] = None
    #: Indicates whether privacy is enabled for the name, number and personId/placeId.
    privacy_enabled: Optional[bool] = None
    #: The call type for the party.
    call_type: Optional[CallTypeEnum] = None


class RedirectionReasonEnum(str, Enum):
    #: The call was redirected on a busy condition. For example, the call was forwarded by Call Forwarding Busy.
    busy = 'busy'
    #: The call was redirected on a no answer condition. For example, the call was forwarded by Call Forwarding No
    #: Answer.
    no_answer = 'noAnswer'
    #: The call was redirected on an unavailable condition. For example, the call was forwarded by Business Continuity.
    unavailable = 'unavailable'
    #: The call was redirected unconditionally. For example, the call was forwarded by Call Forwarding Always.
    unconditional = 'unconditional'
    #: The call was redirected by a service schedule. For example, the call was forwarded by Selective Call Forwarding.
    time_of_day = 'timeOfDay'
    #: The call was redirected by divert action.
    divert = 'divert'
    #: The call was redirected by a follow me service. For example, the call was redirected by Simultaneous Ring.
    follow_me = 'followMe'
    #: The call was redirected by Hunt Group routing.
    hunt_group = 'huntGroup'
    #: The call was redirected by Call Queue routing.
    call_queue = 'callQueue'
    #: The call was redirected on an unknown condition.
    unknown = 'unknown'


class RedirectionInformation(ApiModel):
    #: The reason the incoming call was redirected.
    reason: Optional[RedirectionReasonEnum] = None
    #: The details of a party who redirected the incoming call.
    redirecting_party: Optional[PartyInformation] = None


class RecallTypeEnum(str, Enum):
    #: The user is being recalled for a call park they initiated.
    park = 'park'


class RecallInformation(ApiModel):
    #: The type of recall the incoming call is for. Park is the only type of recall currently supported but additional
    #: values may be added in the future.
    type: Optional[RecallTypeEnum] = None
    #: If the type is park, contains the details of where the call was parked. For example, if user A parks a call
    #: against user B and A is recalled for the park, then this field contains B's information in A's incoming call
    #: details. Only present when the type is park.
    party: Optional[PartyInformation] = None


class RecordingStateEnum(str, Enum):
    #: Recording has been requested for the call but has not yet started.
    pending = 'pending'
    #: Recording is active for the call.
    started = 'started'
    #: Recording has been paused for the call.
    paused = 'paused'
    #: Recording has been stopped for the call.
    stopped = 'stopped'
    #: Recording failed for the call.
    failed = 'failed'


class Call(ApiModel):
    #: The call identifier of the call.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTEwvQkNMRC9jYWxsaGFsZi00ODg6MA
    id: Optional[str] = None
    #: The call session identifier of the call session the call belongs to. This can be used to correlate multiple
    #: calls that are part of the same call session.
    #: example: MmFmNThiZjktYWE3Ny00NWE5LThiMDEtYzI4NDMxZWYwNzRm
    call_session_id: Optional[str] = None
    #: The personality of the call.
    personality: Optional[CallPersonalityEnum] = None
    #: The current state of the call.
    state: Optional[CallStateEnum] = None
    #: The remote party's details. For example, if user A calls user B then B is the remote party in A's outgoing call
    #: details and A is the remote party in B's incoming call details.
    remote_party: Optional[PartyInformation] = None
    #: The appearance value for the call. The appearance value can be used to display the user's calls in an order
    #: consistent with the user's devices. Only present when the call has an appearance value assigned.
    #: example: 1.0
    appearance: Optional[int] = None
    #: The date and time the call was created.
    #: example: 2016-04-21T17:00:00.000Z
    created: Optional[datetime] = None
    #: The date and time the call was answered. Only present when the call has been answered.
    #: example: 2016-04-21T17:00:00.000Z
    answered: Optional[datetime] = None
    #: The list of details for previous redirections of the incoming call ordered from most recent to least recent. For
    #: example, if user B forwards an incoming call to user C, then a redirection entry is present for B's forwarding
    #: in C's incoming call details. Only present when there were previous redirections and the incoming call's state
    #: is alerting.
    redirections: Optional[list[RedirectionInformation]] = None
    #: The recall details for the incoming call. Only present when the incoming call is for a recall.
    recall: Optional[RecallInformation] = None
    #: The call's current recording state. Only present when the user's call recording has been invoked during the life
    #: of the call.
    recording_state: Optional[RecordingStateEnum] = None


class CallHistoryRecordTypeEnum(str, Enum):
    #: A call history record for an outgoing call placed by the user.
    placed = 'placed'
    #: A call history record for an incoming call to the user that was not answered.
    missed = 'missed'
    #: A call history record for an incoming call to the user that was answered.
    received = 'received'


class CallHistoryRecord(ApiModel):
    #: The type of call history record.
    type: Optional[CallHistoryRecordTypeEnum] = None
    #: The name of the called/calling party. Only present when the name is available and privacy is not enabled.
    #: example: John Smith
    name: Optional[str] = None
    #: The number of the called/calling party. Only present when the number is available and privacy is not enabled.
    #: The number can be digits or a URI. Some examples for number include: `1234`, `2223334444`, `+12223334444`,
    #: `*73`, `user@company.domain`
    #: example: +12225554444
    number: Optional[str] = None
    #: Indicates whether privacy is enabled for the name and number.
    privacy_enabled: Optional[bool] = None
    #: The date and time the call history record was created. For a placed call history record, this is when the call
    #: was placed. For a missed call history record, this is when the call was disconnected. For a received call
    #: history record, this is when the call was answered.
    #: example: 2016-04-21T17:00:00.000Z
    time: Optional[datetime] = None


class RejectActionEnum(str, Enum):
    #: Send the call to busy.
    busy = 'busy'
    #: Send the call to temporarily unavailable.
    temporarily_unavailable = 'temporarilyUnavailable'
    #: Ignore the call by continuing ringback to the caller while no longer alerting the called user's devices.
    ignore = 'ignore'


class DialResponse(ApiModel):
    #: A unique identifier for the call which is used in all subsequent commands for the same call.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTEwvQkNMRC9jYWxsaGFsZi00ODg6MA
    call_id: Optional[str] = None
    #: A unique identifier for the call session the call belongs to. This can be used to correlate multiple calls that
    #: are part of the same call session.
    #: example: MmFmNThiZjktYWE3Ny00NWE5LThiMDEtYzI4NDMxZWYwNzRm
    call_session_id: Optional[str] = None


class ParkResponse(ApiModel):
    #: The details of where the call has been parked.
    parked_against: Optional[PartyInformation] = None


class ListCallsResponse(ApiModel):
    items: Optional[list[Call]] = None


class ListCallHistoryResponse(ApiModel):
    items: Optional[list[CallHistoryRecord]] = None


class StepExecutionStatuses(ApiModel):
    #: Unique identifier that identifies each step in a job.
    id: Optional[int] = None
    #: Step execution start time in UTC format.
    start_time: Optional[str] = None
    #: Step execution end time in UTC format.
    end_time: Optional[str] = None
    #: Last updated time for a step in UTC format.
    last_updated: Optional[str] = None
    #: Displays status for a step.
    status_message: Optional[str] = None
    #: Exit Code for a step.
    exit_code: Optional[str] = None
    #: Step name.
    name: Optional[str] = None
    #: Time lapsed since the step execution started.
    time_elapsed: Optional[str] = None


class JobExecutionStatus(ApiModel):
    #: Unique identifier that identifies each instance of the job.
    id: Optional[int] = None
    #: Job execution start time in UTC format.
    start_time: Optional[str] = None
    #: Job execution end time in UTC format.
    end_time: Optional[str] = None
    #: Last updated time (in UTC format) post one of the step execution completion.
    last_updated: Optional[str] = None
    #: Displays status for overall steps that are part of the job.
    status_message: Optional[str] = None
    #: Exit Code for a job.
    exit_code: Optional[str] = None
    #: Job creation time in UTC format.
    created_time: Optional[str] = None
    #: Status of each step within a job.
    step_execution_statuses: Optional[list[StepExecutionStatuses]] = None


class Counts(ApiModel):
    #: Indicates the total number of records whose routing prefix update is successful.
    routing_prefix_updated: Optional[int] = None
    #: Indicates the total number of records whose routing prefix update failed.
    routing_prefix_failed: Optional[int] = None


class BatchResponse(ApiModel):
    #: Job name.
    name: Optional[str] = None
    #: Unique identifier of the job.
    id: Optional[str] = None
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str] = None
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str] = None
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str] = None
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str] = None
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int] = None
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatus]] = None
    #: Indicates the most recent status (`STARTING`, `STARTED`, `COMPLETED`, `FAILED`) of the job at the time of
    #: invocation.
    latest_execution_status: Optional[str] = None
    #: Job statistics.
    counts: Optional[Counts] = None


class ErrorMessage(ApiModel):
    #: Error message.
    description: Optional[str] = None
    #: Internal error code.
    code: Optional[str] = None
    #: Error messages describing the location id in which the error occurs. For a move operation this is the target
    #: location ID.
    location_id: Optional[str] = None


class Error1(ApiModel):
    #: HTTP error code.
    key: Optional[str] = None
    #: Message string with further error information.
    message: Optional[list[ErrorMessage]] = None


class BatchJobError(ApiModel):
    #: Unique identifier to track the HTTP requests.
    tracking_id: Optional[str] = None
    #: row number of failed record.
    item_number: Optional[int] = None
    error: Optional[Error1] = None


class CreateDECTNetworkModel(str, Enum):
    #: Supports 1 base station and 30 line ports.
    dms_cisco_dbs110 = 'DMS Cisco DBS110'
    #: Supports 250 base stations and 1000 line ports.
    dms_cisco_dbs210 = 'DMS Cisco DBS210'


class CreateDECTNetwork(ApiModel):
    #: Name of the DECT network. Min and max length supported for the DECT network name are 1 and 40 respectively.
    #: example: test-dect
    name: Optional[str] = None
    #: Add a default name (11 characters max) to display for all handsets. If left blank, the default name will be an
    #: indexed number followed by the DECT network name.
    #: example: test-dect
    display_name: Optional[str] = None
    #: Select a device model type depending on the number of base stations and handset lines needed in the DECT
    #: network.
    model: Optional[CreateDECTNetworkModel] = None
    #: If set to true, need to provide a default access code that will be shared for all users in this network to pair
    #: their lines to the next available handset. Otherwise, each user will get a unique 4-digit access code that will
    #: be auto-generated.
    #: example: True
    default_access_code_enabled: Optional[bool] = None
    #: If `defaultAccessCodeEnabled` is set to true, then provide a default access code that needs to be a 4-numeric
    #: digit. The access code should be unique to the DECT network for the location.
    #: example: 1551
    default_access_code: Optional[datetime] = None


class BaseStationPostResult(ApiModel):
    #: HTTP status code indicating the creation of base station. 201 status code indicates the successful creation of
    #: base stations
    #: example: 201.0
    status: Optional[int] = None
    #: Unique identifier of the base station.
    #: example: Y2lzY29zcGFyazovL3VzL0RFQ1RfREVWX1NUQVRJT04vYzRhMTQxN2ItZGNiYi00MGMzLWE3YWQtNTY1MGZkZGRkNTNj
    id: Optional[str] = None


class BaseStationResponse(ApiModel):
    #: MAC Address added to the base station.
    #: example: 6DDE9EBDE1C9
    mac: Optional[str] = None
    #: Object with base station POST Result.
    result: Optional[BaseStationPostResult] = None


class BaseStationsPostResponse(ApiModel):
    #: List of base station MAC addresses that have to be added to the DECT network.
    base_station_macs: Optional[list[BaseStationResponse]] = None


class AddDECTHandset(ApiModel):
    #: ID of the member on line1 of the handset. Members can be PEOPLE or PLACE.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    line1_member_id: Optional[str] = None
    #: ID of the member on line2 of the handset. Members can be PEOPLE, PLACE, or VIRTUAL_LINE.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    line2_member_id: Optional[str] = None
    #: Custom display name on the handset. Min and max length supported for the custom display name is 1 and 16
    #: respectively
    #: example: handsetDisplayName
    custom_display_name: Optional[str] = None


class LineType(str, Enum):
    #: Primary line for the member.
    primary = 'PRIMARY'
    #: Shared line for the member.
    shared_call_appearance = 'SHARED_CALL_APPEARANCE'


class MemberType(str, Enum):
    #: Indicates the associated member is a person.
    people = 'PEOPLE'
    #: Indicates the associated member is a workspace.
    place = 'PLACE'
    #: Indicates the associated member is a virtual profile.
    virtual_line = 'VIRTUAL_LINE'


class Location(ApiModel):
    #: Location identifier associated with the member.
    #: example: Y2lzY29zcGFyazovL3VzL0RFQ1RfREVWX05FVC81NmRiMjRkMy03YTdhLTQwYTItOWFjOS1iMjMzMjc3OTIxTrd
    id: Optional[str] = None
    #: Location name associated with the member.
    #: example: MainOffice
    name: Optional[str] = None


class AvailableMember(ApiModel):
    #: Unique identifier for the member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    id: Optional[str] = None
    #: First name of the member.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of the member.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone Number of the member.
    #: example: +12055552221
    phone_number: Optional[str] = None
    #: Extension of the member.
    #: example: 1234
    extension: Optional[datetime] = None
    #: Line type indicates if the associated line is a primary line or a shared line.
    line_type: Optional[LineType] = None
    #: Indicates the type of the member.
    member_type: Optional[MemberType] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class AvailableMembersResponse(ApiModel):
    members: Optional[list[AvailableMember]] = None


class CreateADectNetworkResponse(ApiModel):
    #: A unique identifier for the DECT network.
    #: example: Y2lzY29zcGFyazovL3VzL0RFQ1RfREVWX05FVC81NmRiMjRkMy03YTdhLTQwYTItOWFjOS1iMjMzMjc3OTIxNzf
    dect_network_id: Optional[str] = None


class DepartmentCollectionRequest(ApiModel):
    #: Name of the department.
    #: example: HR
    name: Optional[str] = None


class DepartmentResponseDepartment(ApiModel):
    #: Unique identifier of the department.
    #: example: Y2lzY29zcGFyazovL3VzL1NDSU1fR1JPVVAvZjA2ZWRiOGMtMjMxNC00ZTcxLWIzNzgtZTdiMmQwNjk3OTliOjk2YWJjMmFhLTNkY2MtMTFlNS1hMTUyLWZlMzQ4MTljZGM5YQ
    id: Optional[str] = None
    #: Name of the department.
    #: example: HR
    name: Optional[str] = None
    #: Number of members in this department.
    #: example: 2.0
    member_count: Optional[int] = None


class DepartmentResponse(ApiModel):
    #: Specifies the department information.
    department: Optional[DepartmentResponseDepartment] = None


class DepartmentCollectionResponse(ApiModel):
    #: List of departments.
    departments: Optional[list[DepartmentResponse]] = None


class DepartmentResponseWithId(ApiModel):
    #: Unique identifier of the department.
    #: example: Y2lzY29zcGFyazovL3VzL1NDSU1fR1JPVVAvZjA2ZWRiOGMtMjMxNC00ZTcxLWIzNzgtZTdiMmQwNjk3OTliOjk2YWJjMmFhLTNkY2MtMTFlNS1hMTUyLWZlMzQ4MTljZGM5YQ
    id: Optional[str] = None


class MemberType1(str, Enum):
    #: Indicates the associated member is a person.
    people = 'PEOPLE'
    #: Indicates the associated member is a workspace.
    place = 'PLACE'


class MemberObject(ApiModel):
    #: Unique identifier for the member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    id: Optional[str] = None
    #: First name of a person or workspace.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of a person or workspace.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone Number of a person or workspace. In some regions phone numbers are not returned in E.164 format. This will
    #: be supported in a future update.
    #: example: 2055552221
    phone_number: Optional[str] = None
    #: Extension of a person or workspace.
    #: example: 000
    extension: Optional[str] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 1234000
    esn: Optional[str] = None
    #: This field indicates whether the person or the workspace is the owner of the device, and points to a primary
    #: Line/Port of the device.
    #: example: True
    primary_owner: Optional[bool] = None
    #: Port number assigned to person or workspace.
    #: example: 1.0
    port: Optional[int] = None
    #: T.38 Fax Compression setting and is available only for ATA Devices. Choose T.38 fax compression if the device
    #: requires this option. This will override user level compression options.
    t38_fax_compression_enabled: Optional[bool] = None
    #: Line type is used to differentiate Primary and SCA, at which endpoint it is assigned.
    line_type: Optional[LineType] = None
    #: Number of lines that have been configured for the person on the device.
    #: example: 1.0
    line_weight: Optional[int] = None
    #: Registration Host IP address for the line port.
    #: example: 10.0.0.45
    host_ip: Optional[str] = Field(alias='hostIP', default=None)
    #: Registration Remote IP address for the line port.
    #: example: 192.102.12.84
    remote_ip: Optional[str] = Field(alias='remoteIP', default=None)
    #: Enable Hotline. Configure this line to automatically call a predefined number whenever taken off-hook. Once
    #: enabled, the line can only make calls to the predefined number set in hotlineDestination.
    #: example: True
    hotline_enabled: Optional[bool] = None
    #: The preconfigured number for Hotline. Required only if `hotlineEnabled` is set to true.
    #: example: +12055552222
    hotline_destination: Optional[str] = None
    #: Set how a person's device behaves when a call is declined. When set to true, a call decline request is extended
    #: to all the endpoints on the device. When set to false, a call decline request only declines the current
    #: endpoint.
    #: example: True
    allow_call_decline_enabled: Optional[bool] = None
    #: Device line label.
    #: example: share line label
    line_label: Optional[str] = None
    #: Indicates if the member is of type `PEOPLE` or `PLACE`.
    member_type: Optional[MemberType1] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class GetMemberResponse(ApiModel):
    #: Model type of the device.
    #: example: DMS Cisco 192
    model: Optional[str] = None
    #: List of members that appear on the device.
    members: Optional[list[MemberObject]] = None
    #: Maximum number of lines available for the device.
    #: example: 10.0
    max_line_count: Optional[int] = None


class SearchMemberObject(ApiModel):
    #: Unique identifier for the member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    id: Optional[str] = None
    #: First name of a person or workspace.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of a person or workspace.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone Number of a person or workspace.
    #: example: +12055552221
    phone_number: Optional[str] = None
    #: T.38 Fax Compression setting and available only for ATA Devices. Choose T.38 fax compression if the device
    #: requires this option. this will override user level compression options.
    t38_fax_compression_enabled: Optional[bool] = None
    #: Line type is used to differentiate Primary and SCA, at which endpoint it is assigned.
    line_type: Optional[LineType] = None
    #: Set how a person's device behaves when a call is declined. When set to true, a call decline request is extended
    #: to all the endpoints on the device. When set to false, a call decline request only declines the current
    #: endpoint.
    #: example: True
    allow_call_decline_enabled: Optional[bool] = None
    #: Indicates if member is of type `PEOPLE` or `PLACE`.
    member_type: Optional[MemberType1] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class SearchMemberResponse(ApiModel):
    #: List of members available for the device.
    members: Optional[list[SearchMemberObject]] = None


class FeatureReferenceObject(ApiModel):
    #: Unique identifier of the call feature referenced. The call Feature can be Auto Attendant, Call Queue or Music On
    #: hold.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Name of the call feature referenced.
    #: example: Main Line AA - Test
    name: Optional[str] = None
    #: Resource Type of the call feature.
    #: example: Auto Attendant
    type: Optional[str] = None
    #: Unique identifier of the location.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi81ZTk3MzFlNy1iOWQ0LTRmMWQtYjYyMi05NDgwMDhhMjkzMzM
    location_id: Optional[str] = None
    #: Location name of the announcement file.
    #: example: RCDN
    location_name: Optional[str] = None


class AnnouncementResponse(ApiModel):
    #: Unique identifier of the announcement.
    #: example: Y2lzY29zcGFyazovL3VzL0FOTk9VTkNFTUVOVC8zMjAxNjRmNC1lNWEzLTQxZmYtYTMyNi02N2MwOThlNDFkMWQ
    id: Optional[str] = None
    #: Name of the announcement.
    #: example: Public_Announcement
    name: Optional[str] = None
    #: File name of the uploaded binary announcement greeting.
    #: example: Sample_Greetings_file.wav
    file_name: Optional[str] = None
    #: Size of the file in kilobytes.
    #: example: 356
    file_size: Optional[datetime] = None
    #: Media file type of the announcement file.
    #: example: WAV
    media_file_type: Optional[str] = None
    #: Last updated timestamp (in UTC format) of the announcement.
    #: example: 2023-06-13T18:39:53.651Z
    last_updated: Optional[datetime] = None
    #: Reference count of the call features this announcement is assigned to.
    #: example: 1.0
    feature_reference_count: Optional[int] = None
    #: Call features referenced by this announcement.
    feature_references: Optional[list[FeatureReferenceObject]] = None


class AnnouncementUsageResponse(ApiModel):
    #: Total file size used by announcements in this repository in kilobytes.
    #: example: 1068.0
    total_file_size_used_kb: Optional[int] = Field(alias='totalFileSizeUsedKB', default=None)
    #: Maximum audio file size allowed to upload in kilobytes.
    #: example: 9600.0
    max_audio_file_size_allowed_kb: Optional[int] = Field(alias='maxAudioFileSizeAllowedKB', default=None)
    #: Maximum video file size allowed to upload in kilobytes.
    #: example: 120000.0
    max_video_file_size_allowed_kb: Optional[int] = Field(alias='maxVideoFileSizeAllowedKB', default=None)
    #: Total file size limit for the repository in megabytes.
    #: example: 1000.0
    total_file_size_limit_mb: Optional[int] = Field(alias='totalFileSizeLimitMB', default=None)


class AnnouncementsListResponseLevel(str, Enum):
    location = 'LOCATION'


class AnnouncementsListResponse(ApiModel):
    #: Unique identifier of the announcement.
    #: example: Y2lzY29zcGFyazovL3VzL0FOTk9VTkNFTUVOVC8zMjAxNjRmNC1lNWEzLTQxZmYtYTMyNi02N2MwOThlNDFkMWQ
    id: Optional[str] = None
    #: Name of the announcement.
    #: example: Public_Announcement
    name: Optional[str] = None
    #: File name of the uploaded binary announcement greeting.
    #: example: Sample_Greetings_file.wav
    file_name: Optional[str] = None
    #: Size of the file in kilobytes.
    #: example: 356
    file_size: Optional[datetime] = None
    #: Media file type of the announcement file.
    #: example: WAV
    media_file_type: Optional[str] = None
    #: LastUpdated timestamp (in UTC format) of the announcement.
    #: example: 2023-06-13T18:39:53.651Z
    last_updated: Optional[datetime] = None
    #: The level at which this announcement exists.
    #: example: LOCATION
    level: Optional[AnnouncementsListResponseLevel] = None
    #: The details of location at which this announcement exists.
    location: Optional[Location] = None


class FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelLocationId(str, Enum):
    all = 'all'
    locations = 'locations'
    y2lz_y29zc_gfyazov_l3_vz_l0x_pq0_fusu9_olz_mx_mtyx = 'Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx'


class FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelResponse(ApiModel):
    #: Array of announcements.
    announcements: Optional[list[AnnouncementsListResponse]] = None


class AlternateNumbersObjectRingPattern(str, Enum):
    _0 = '0'
    normal = 'NORMAL'
    long_long = 'LONG_LONG'
    short_short_long = 'SHORT_SHORT_LONG'
    short_long_short = 'SHORT_LONG_SHORT'


class AlternateNumbersObject(ApiModel):
    #: Phone number defined as alternate number.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool] = None
    #: Ring pattern that will be used for the alternate number.
    #: example: 0
    ring_pattern: Optional[AlternateNumbersObjectRingPattern] = None


class GetAutoAttendantObjectExtensionDialing(str, Enum):
    enterprise = 'ENTERPRISE'
    group = 'GROUP'


class HoursMenuObjectGreeting(str, Enum):
    default = 'DEFAULT'
    custom = 'CUSTOM'


class KeyConfigurationsObjectKey(str, Enum):
    _0 = '0'
    _1 = '1'
    _2 = '2'
    _3 = '3'
    _4 = '4'
    _5 = '5'
    _6 = '6'
    _7 = '7'
    _8 = '8'
    _9 = '9'
    none_ = 'none'
    _ = '#'


class KeyConfigurationsObjectAction(str, Enum):
    transfer_without_prompt = 'TRANSFER_WITHOUT_PROMPT'
    transfer_with_prompt = 'TRANSFER_WITH_PROMPT'
    transfer_to_operator = 'TRANSFER_TO_OPERATOR'
    name_dialing = 'NAME_DIALING'
    extension_dialing = 'EXTENSION_DIALING'
    repeat_menu = 'REPEAT_MENU'
    exit = 'EXIT'
    transfer_to_mailbox = 'TRANSFER_TO_MAILBOX'
    return_to_previous_menu = 'RETURN_TO_PREVIOUS_MENU'


class KeyConfigurationsObject(ApiModel):
    #: Key assigned to specific menu configuration.
    #: example: 0
    key: Optional[KeyConfigurationsObjectKey] = None
    #: Action assigned to specific menu key configuration.
    #: example: EXIT
    action: Optional[KeyConfigurationsObjectAction] = None
    #: The description of each menu key.
    #: example: Exit the menu
    description: Optional[str] = None
    #: Value based on actions.
    #: example: +19705550006
    value: Optional[str] = None


class HoursMenuObject(ApiModel):
    #: Greeting type defined for the auto attendant.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Flag to indicate if auto attendant extension is enabled or not.
    #: example: True
    extension_enabled: Optional[bool] = None
    #: Key configurations defined for the auto attendant.
    key_configurations: Optional[KeyConfigurationsObject] = None


class GetAutoAttendantObject(ApiModel):
    #: A unique identifier for the auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5ULzUxZmIyMDhiLWQ2ZTAtNDNjNS1hZDYyLTkxNmJkMDhmZDY4Zg
    id: Optional[str] = None
    #: Unique name for the auto attendant.
    #: example: Main Line AA - Test
    name: Optional[str] = None
    #: Flag to indicate if auto attendant number is enabled or not.
    #: example: True
    enabled: Optional[bool] = None
    #: Auto attendant phone number. Either phone number or extension should be present as mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension. Either phone number or extension should be present as mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool] = None
    #: First name defined for an auto attendant.
    #: example: Main Line AA
    first_name: Optional[str] = None
    #: Last name defined for an auto attendant.
    #: example: Test
    last_name: Optional[str] = None
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]] = None
    #: Language for the auto attendant.
    #: example: English
    language: Optional[str] = None
    #: Language code for the auto attendant.
    #: example: en_us
    language_code: Optional[str] = None
    #: Business hours for the auto attendant.
    #: example: Peak Season Hours
    business_schedule: Optional[str] = None
    #: Holiday schedule for the auto attendant.
    #: example: Corporate Holidays
    holiday_schedule: Optional[str] = None
    #: Extension dialing setting. If the values are not set default will be set as ENTERPRISE.
    #: example: ENTERPRISE
    extension_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
    #: example: ENTERPRISE
    name_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Time zone defined for the auto attendant.
    #: example: America/Los_Angeles
    time_zone: Optional[str] = None
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[HoursMenuObject] = None
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[HoursMenuObject] = None
    #: Specifies the department information.
    department: Optional[DepartmentResponseWithId] = None


class ListAutoAttendantObject(ApiModel):
    #: A unique identifier for the auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5ULzUxZmIyMDhiLWQ2ZTAtNDNjNS1hZDYyLTkxNmJkMDhmZDY4Zg
    id: Optional[str] = None
    #: Unique name for the auto attendant.
    #: example: Main Line AA - Test
    name: Optional[str] = None
    #: Name of location for auto attendant.
    #: example: Houston
    location_name: Optional[str] = None
    #: ID of location for auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzI2NDE1MA
    location_id: Optional[str] = None
    #: Auto attendant phone number. Either phone number or extension should be present as mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension. Either phone number or extension should be present as mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool] = None
    #: Specifies the department information.
    department: Optional[Location] = None


class ModifyAutoAttendantObject(ApiModel):
    #: Unique name for the auto attendant.
    #: example: Main Line IA - Test
    name: Optional[str] = None
    #: Auto attendant phone number. Either phone number or extension should be present as mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension. Either phone number or extension should be present as mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: First name defined for an auto attendant.
    #: example: Main Line AA
    first_name: Optional[str] = None
    #: Last name defined for an auto attendant.
    #: example: Test
    last_name: Optional[str] = None
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]] = None
    #: Language code for the auto attendant.
    #: example: en_us
    language_code: Optional[str] = None
    #: Business hours for the auto attendant.
    #: example: Peak Season Hours
    business_schedule: Optional[str] = None
    #: Holiday schedule for the auto attendant.
    #: example: Corporate Holidays
    holiday_schedule: Optional[str] = None
    #: Extension dialing setting. If the values are not set default will be set as ENTERPRISE.
    #: example: ENTERPRISE
    extension_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
    #: example: ENTERPRISE
    name_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Time zone defined for the auto attendant.
    #: example: America/Los_Angeles
    time_zone: Optional[str] = None
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[HoursMenuObject] = None
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[HoursMenuObject] = None
    #: Specifies the department information.
    department: Optional[DepartmentResponseWithId] = None


class ReadTheListOfAutoAttendantsResponse(ApiModel):
    #: Array of auto attendants.
    auto_attendants: Optional[list[ListAutoAttendantObject]] = None


class AudioFileObjectMediaType(str, Enum):
    #: WMA File Extension.
    wma = 'WMA'
    #: WAV File Extension.
    wav = 'WAV'
    #: 3GP File Extension.
    _3_gp = '3GP'


class AudioFileObject(ApiModel):
    #: Announcement audio file name.
    #: example: AUDIO_FILE.wav
    name: Optional[str] = None
    #: Announcement audio file media type.
    #: example: WAV
    media_type: Optional[AudioFileObjectMediaType] = None


class HoursMenuObject1(ApiModel):
    #: Greeting type defined for the auto attendant.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Flag to indicate if auto attendant extension is enabled or not.
    #: example: True
    extension_enabled: Optional[bool] = None
    #: Announcement Audio File details.
    audio_file: Optional[AudioFileObject] = None
    #: Key configurations defined for the auto attendant.
    key_configurations: Optional[KeyConfigurationsObject] = None


class GetAutoAttendantObject1(ApiModel):
    #: A unique identifier for the auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Unique name for the auto attendant.
    #: example: Main Line AA - Test
    name: Optional[str] = None
    #: Flag to indicate if auto attendant number is enabled or not.
    #: example: True
    enabled: Optional[bool] = None
    #: Auto attendant phone number.  Either `phoneNumber` or `extension` is mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341001
    esn: Optional[datetime] = None
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool] = None
    #: First name defined for an auto attendant.
    #: example: Main Line AA
    first_name: Optional[str] = None
    #: Last name defined for an auto attendant.
    #: example: Test
    last_name: Optional[str] = None
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]] = None
    #: Language for the auto attendant.
    #: example: English
    language: Optional[str] = None
    #: Language code for the auto attendant.
    #: example: en_us
    language_code: Optional[str] = None
    #: Business hours defined for the auto attendant.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    business_schedule: Optional[str] = None
    #: Holiday defined for the auto attendant.
    #: example: AUTOATTENDANT-HOLIDAY
    holiday_schedule: Optional[str] = None
    #: Extension dialing setting. If the values are not set default will be set as `ENTERPRISE`.
    #: example: ENTERPRISE
    extension_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Name dialing setting. If the values are not set default will be set as `ENTERPRISE`.
    #: example: ENTERPRISE
    name_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Time zone defined for the auto attendant.
    #: example: America/Los_Angeles
    time_zone: Optional[str] = None
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[HoursMenuObject1] = None
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[HoursMenuObject1] = None


class ListAutoAttendantObject1(ApiModel):
    #: A unique identifier for the auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Unique name for the auto attendant.
    #: example: Main Line AA - Test
    name: Optional[str] = None
    #: Name of location for auto attendant.
    #: example: Houston
    location_name: Optional[str] = None
    #: ID of location for auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzI2NDE1MA
    location_id: Optional[str] = None
    #: Auto attendant phone number.  Either `phoneNumber` or `extension` is mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341001
    esn: Optional[datetime] = None
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool] = None


class ReadTheListOfAutoAttendantsResponse1(ApiModel):
    #: Array of auto attendants.
    auto_attendants: Optional[list[ListAutoAttendantObject1]] = None


class GetCallParkExtensionObject(ApiModel):
    #: The extension for the call park extension.
    #: example: 1415
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341415
    esn: Optional[str] = None
    #: Unique name for the call park extension.
    #: example: 14159265
    name: Optional[str] = None


class GetRecallHuntGroupObjectOption(str, Enum):
    #: Alert parking user only.
    alert_parking_user_only = 'ALERT_PARKING_USER_ONLY'
    #: Alert parking user first, then hunt group.
    alert_parking_user_first_then_hunt_group = 'ALERT_PARKING_USER_FIRST_THEN_HUNT_GROUP'
    #: Alert hunt group only.
    alert_hunt_group_only = 'ALERT_HUNT_GROUP_ONLY'


class GetRecallHuntGroupObject(ApiModel):
    #: Alternate user which is a hunt group ID for call park recall alternate destination.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvZEdWamFHNXBZMkZzTFhOMWNIQnZjblF0TlRVMU9EWTNOVE13T1VCbmJXRnBiQzVqYjIwPQ
    hunt_group_id: Optional[str] = None
    #: Unique name for the hunt group.
    #: example: Technical Support Group - 5558675309
    hunt_group_name: Optional[str] = None
    #: Call park recall options.
    #: example: ALERT_PARKING_USER_ONLY
    option: Optional[GetRecallHuntGroupObjectOption] = None


class GetUserNumberItemObject(ApiModel):
    #: Phone number of a person or workspace.
    #: example: +19075552859
    external: Optional[str] = None
    #: Extension of a person or workspace.
    #: example: 8080
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12348080
    esn: Optional[str] = None
    #: Flag to indicate a primary phone.
    #: example: True
    primary: Optional[bool] = None


class GetPersonPlaceVirtualLineCallParksObject(ApiModel):
    #: ID of a person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE2NmE
    id: Optional[str] = None
    #: First name of a person, workspace or virtual line.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of a person, workspace or virtual line.
    #: example: Brown
    last_name: Optional[str] = None
    #: Display name of a person, workspace or virtual line.
    #: example: johnBrown
    display_name: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: Email of a person or workspace.
    #: example: john.brown@example.com
    email: Optional[str] = None
    #: List of phone numbers of a person, workspace or virtual line.
    numbers: Optional[list[GetUserNumberItemObject]] = None


class ListCPCallParkExtensionObject(ApiModel):
    #: Unique identifier for the call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSS19FWFRFTlNJT04vMGYzZTkwNGItYzliNC00ODNmLWI4MWItZmI0ZjkyMWcxNDUzCg
    id: Optional[str] = None
    #: The extension for the call park.
    #: example: 1415
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341415
    esn: Optional[str] = None
    #: A unique name for the call park extension.
    #: example: 14159265
    name: Optional[str] = None


class GetCallParkObject(ApiModel):
    #: A unique identifier for the call park.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSSy9kR1ZqYUc1cFkyRnNJSE4xY0hCdmNuUWdMU0JwYm5OMWNtRnVZMlVnTFNCamRYTjBiMjFsY2lBeA==
    id: Optional[str] = None
    #: Unique name for the call park. The maximum length is 80.
    #: example: technical support - insurance - customer 1
    name: Optional[str] = None
    #: Recall options that are added to call park.
    recall: Optional[GetRecallHuntGroupObject] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject]] = None
    #: Whether or not the calls will be parked on agents as a destination.
    park_on_agents_enabled: Optional[bool] = None
    #: Array of call park extensions assigned to a call park.
    call_park_extensions: Optional[list[ListCPCallParkExtensionObject]] = None


class ListCallParkExtensionObject(ApiModel):
    #: Unique identifier for the call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSS19FWFRFTlNJT04vMGYzZTkwNGItYzliNC00ODNmLWI4MWItZmI0ZjkyMWcxNDUzCg
    id: Optional[str] = None
    #: The extension for the call park extension.
    #: example: 1415
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341415
    esn: Optional[str] = None
    #: A unique name for the call park extension.
    #: example: 14159265
    name: Optional[str] = None
    #: ID of location for call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx
    location_id: Optional[str] = None
    #: Name of location for call park extension.
    #: example: WXCSIVDKCPAPIC4S1
    location_name: Optional[str] = None


class GetAvailableAgentsFromCallParksResponse(ApiModel):
    #: Array of agents.
    agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject]] = None


class ReadTheListOfCallParkExtensionsResponse(ApiModel):
    #: Array of call park extensions.
    call_park_extensions: Optional[list[ListCallParkExtensionObject]] = None


class GetPersonPlaceVirtualLineCallPickupObject(ApiModel):
    #: ID of a person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: First name of a person, workspace or virtual line.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of a person, workspace or virtual line.
    #: example: Brown
    last_name: Optional[str] = None
    #: Display name of a person, workspace or virtual line.
    #: example: johnBrown
    display_name: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: Email of a person, workspace or virtual line.
    #: example: john.brown@example.com
    email: Optional[str] = None
    #: List of phone numbers of a person, workspace or virtual line.
    phone_number: Optional[list[GetUserNumberItemObject]] = None


class GetCallPickupObject(ApiModel):
    #: A unique identifier for the call pickup.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUElDS1VQL1kyRnNiRkJwWTJ0MWNERT0
    id: Optional[str] = None
    #: Unique name for the call pickup. The maximum length is 80.
    #: example: North Alaska-Group
    name: Optional[str] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallPickupObject]] = None


class GetAvailableAgentsFromCallPickupsResponse(ApiModel):
    #: Array of agents.
    agents: Optional[list[GetPersonPlaceVirtualLineCallPickupObject]] = None


class RingPatternObject(str, Enum):
    #: Normal incoming ring pattern.
    normal = 'NORMAL'
    #: Incoming ring pattern of two long rings.
    long_long = 'LONG_LONG'
    #: Incoming ring pattern of two short rings, followed by a short ring.
    short_short_long = 'SHORT_SHORT_LONG'
    #: Incoming ring pattern of a short ring, followed by a long ring, followed by a short ring.
    short_long_short = 'SHORT_LONG_SHORT'


class AlternateNumbersWithPattern(ApiModel):
    #: Alternate phone number for the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Ring pattern for when this alternate number is called. Only available when `distinctiveRing` is enabled for the
    #: hunt group.
    #: example: NORMAL
    ring_pattern: Optional[RingPatternObject] = None


class CallQueueQueueSettingsObjectOverflowAction(str, Enum):
    #: The caller hears a fast-busy tone.
    perform_busy_treatment = 'PERFORM_BUSY_TREATMENT'
    #: The caller hears ringing until they disconnect.
    play_ringing_until_caller_hangs_up = 'PLAY_RINGING_UNTIL_CALLER_HANGS_UP'
    #: Number where you want to transfer overflow calls.
    transfer_to_phone_number = 'TRANSFER_TO_PHONE_NUMBER'


class CallQueueQueueSettingsObjectOverflow(ApiModel):
    #: Indicates how to handle new calls when the queue is full.
    #: example: PERFORM_BUSY_TREATMENT
    action: Optional[CallQueueQueueSettingsObjectOverflowAction] = None
    #: When `true`, forwards all calls to a voicemail service of an internal number. This option is ignored when an
    #: external `transferNumber` is entered.
    send_to_voicemail: Optional[bool] = None
    #: Destination number for overflow calls when `action` is set to `TRANSFER_TO_PHONE_NUMBER`.
    #: example: +15553331212
    transfer_number: Optional[str] = None
    #: After calls wait for the configured number of seconds and no agent is available, the overflow treatment is
    #: triggered.
    #: example: True
    overflow_after_wait_enabled: Optional[bool] = None
    #: Number of seconds to wait before the overflow treatment is triggered when no agent is available.
    #: example: 20.0
    overflow_after_wait_time: Optional[int] = None
    #: Indicate overflow audio to be played, otherwise callers will hear the hold music until the call is answered by a
    #: user.
    #: example: True
    play_overflow_greeting_enabled: Optional[bool] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement file name strings to be played as overflow greetings. These files are from the list of
    #: announcements files associated with this call queue.
    audio_files: Optional[list[str]] = None


class CallQueueQueueSettingsObject(ApiModel):
    #: The maximum number of calls for this call queue. Once this number is reached, the overflow settings are
    #: triggered.
    #: example: 50.0
    queue_size: Optional[int] = None
    #: Play ringing tone to callers when their call is set to an available agent.
    #: example: True
    call_offer_tone_enabled: Optional[bool] = None
    #: Reset caller statistics upon queue entry.
    reset_call_statistics_enabled: Optional[bool] = None
    #: Settings for incoming calls exceed queueSize.
    overflow: Optional[CallQueueQueueSettingsObjectOverflow] = None


class GetCallQueueCallPolicyObjectCallBounce(ApiModel):
    #: If enabled, bounce calls after the set number of rings.
    #: example: True
    call_bounce_enabled: Optional[bool] = None
    #: Number of rings after which to bounce call, if call bounce is enabled.
    #: example: 5.0
    call_bounce_max_rings: Optional[int] = None
    #: Bounce if agent becomes unavailable.
    #: example: True
    agent_unavailable_enabled: Optional[bool] = None
    #: Alert agent if call on hold more than alertAgentMaxSeconds.
    #: example: True
    alert_agent_enabled: Optional[bool] = None
    #: Number of second after which to alert agent if alertAgentEnabled.
    #: example: 20.0
    alert_agent_max_seconds: Optional[int] = None
    #: Bounce if call on hold more than callBounceMaxSeconds.
    #: example: True
    call_bounce_on_hold_enabled: Optional[bool] = None
    #: Number of second after which to bounce if callBounceEnabled.
    #: example: 20.0
    call_bounce_on_hold_max_seconds: Optional[int] = None


class GetCallQueueCallPolicyObjectDistinctiveRing(ApiModel):
    #: Whether or not the distinctive ring is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Ring pattern for when this callqueue is called. Only available when `distinctiveRing` is enabled for the call
    #: queue.
    #: example: NORMAL
    ring_pattern: Optional[RingPatternObject] = None


class HuntPolicySelection(str, Enum):
    #: This option cycles through all agents after the last agent that took a call. It sends calls to the next
    #: available agent.
    circular = 'CIRCULAR'
    #: Send the call through the queue of agents in order, starting from the top each time.
    regular = 'REGULAR'
    #: Sends calls to all agents at once
    simultaneous = 'SIMULTANEOUS'
    #: Sends calls to the agent that has been idle the longest. If they don't answer, proceed to the next agent who has
    #: been idle the second longest, and so on until the call is answered.
    uniform = 'UNIFORM'
    #: Sends call to idle agents based on percentages you assign to each agent (up to 100%).
    weighted = 'WEIGHTED'


class GetCallQueueCallPolicyObject(ApiModel):
    #: Call routing policy to use to dispatch calls to agents.
    #: example: UNIFORM
    policy: Optional[HuntPolicySelection] = None
    #: Settings for when the call into the call queue is not answered.
    call_bounce: Optional[GetCallQueueCallPolicyObjectCallBounce] = None
    #: Whether or not the call queue has the distinctive ring option enabled.
    distinctive_ring: Optional[GetCallQueueCallPolicyObjectDistinctiveRing] = None


class GetCallQueueObjectAlternateNumberSettings(ApiModel):
    #: Distinctive Ringing selected for the alternate numbers in the call queue overrides the normal ringing patterns
    #: set for Alternate Number.
    #: example: True
    distinctive_ring_enabled: Optional[bool] = None
    #: Specifies up to 10 numbers which can each have an overriden distinctive ring setting.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None


class GetPersonPlaceObject(ApiModel):
    #: ID of person or workspace.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: First name of person or workspace.
    #: example: Hakim
    first_name: Optional[str] = None
    #: First name of person or workspace.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone number of person or workspace.
    #: example: +15555551234
    phone_number: Optional[str] = None
    #: Extension of person or workspace.
    #: example: 1234
    extension: Optional[datetime] = None
    #: Weight of person or workspace. Only applied when call policy is `WEIGHTED`.
    #: example: 50
    weight: Optional[datetime] = None


class GetCallQueueObject(ApiModel):
    #: A unique identifier for the call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUVVFVUUvNTU1MzY4Y2QtZDg5Mi00YzFlLTk0YjYtNzdjNjRiYWQ3NWMx
    id: Optional[str] = None
    #: Unique name for the call queue.
    #: example: CallQueue-1
    name: Optional[str] = None
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to ".".
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Extension of the call queue.
    #: example: 7781
    extension: Optional[datetime] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a call queue. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the call queue.
    alternate_number_settings: Optional[GetCallQueueObjectAlternateNumberSettings] = None
    #: Language for call queue.
    #: example: English
    language: Optional[str] = None
    #: Language code for call queue.
    #: example: en-US
    language_code: Optional[str] = None
    #: Time zone for the call queue.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetCallQueueCallPolicyObject] = None
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsObject] = None
    #: Flag to indicate whether call waiting is enabled for agents.
    allow_call_waiting_for_agents_enabled: Optional[bool] = None
    #: People, including workspaces, that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceObject]] = None
    #: Specifies the department information.
    department: Optional[Location] = None


class ListCallQueueObject(ApiModel):
    #: A unique identifier for the call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUVVFVUUvNTU1MzY4Y2QtZDg5Mi00YzFlLTk0YjYtNzdjNjRiYWQ3NWMx
    id: Optional[str] = None
    #: Unique name for the call queue.
    #: example: 5714328359
    name: Optional[str] = None
    #: Name of location for call queue.
    #: example: WXCSIVDKCPAPIC4S1
    location_name: Optional[str] = None
    #: ID of location for call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx
    location_id: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the call queue.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Specifies the department information.
    department: Optional[Location] = None


class PostPersonPlaceObject(ApiModel):
    #: ID of person or workspace.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: Weight of person or workspace. Only applied when call policy is `WEIGHTED`.
    #: example: 50
    weight: Optional[datetime] = None


class ModifyCallQueueObject(ApiModel):
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Unique name for the call queue.
    #: example: CallQueue-1
    name: Optional[str] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to ".".
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Extension of the call queue.
    #: example: 7781
    extension: Optional[datetime] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a call queue. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the call queue.
    alternate_number_settings: Optional[GetCallQueueObjectAlternateNumberSettings] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetCallQueueCallPolicyObject] = None
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsObject] = None
    #: Flag to indicate whether call waiting is enabled for agents.
    allow_call_waiting_for_agents_enabled: Optional[bool] = None
    #: People, including workspaces, that are eligible to receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: Specifies the department information.
    department: Optional[DepartmentResponseWithId] = None


class ReadTheListOfCallQueuesResponse(ApiModel):
    #: Array of call queues.
    queues: Optional[list[ListCallQueueObject]] = None


class CallQueueQueueSettingsObjectWelcomeMessage(ApiModel):
    #: If enabled play entrance message. The default value is `true`.
    #: example: True
    enabled: Optional[bool] = None
    #: Mandatory entrance message. The default value is `false`.
    always_enabled: Optional[bool] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement `fileName` strings to be played as `welcomeMessage` greetings. These files are from the
    #: list of announcement files associated with this call queue. For `CUSTOM` announcement, a minimum of 1
    #: `fileName` is mandatory, and the maximum is 4.
    #: example: ['[\"Greeting-1.wav\"]']
    audio_files: Optional[list[str]] = None


class CallQueueQueueSettingsObjectWaitMessageWaitMode(str, Enum):
    #: Announce the waiting time.
    time = 'TIME'
    #: Announce queue position.
    position = 'POSITION'


class CallQueueQueueSettingsObjectWaitMessage(ApiModel):
    #: If enabled play Wait Message.
    #: example: True
    enabled: Optional[bool] = None
    #: Estimated wait message operating mode. Supported values `TIME` and `POSITION`.
    #: example: POSITION
    wait_mode: Optional[CallQueueQueueSettingsObjectWaitMessageWaitMode] = None
    #: The number of minutes for which the estimated wait is played. The minimum time is 10 minutes. The maximum time
    #: is 100 minutes.
    #: example: 100.0
    handling_time: Optional[int] = None
    #: The default number of call handling minutes. The minimum time is 1 minutes, The maximum time is 100 minutes.
    #: example: 100.0
    default_handling_time: Optional[int] = None
    #: The number of the position for which the estimated wait is played. The minimum positions are 10, The maximum
    #: positions are 100.
    #: example: 100.0
    queue_position: Optional[int] = None
    #: Play time / Play position High Volume.
    high_volume_message_enabled: Optional[bool] = None
    #: The number of estimated waiting times in seconds. The minimum time is 10 seconds. The maximum time is 600
    #: seconds.
    #: example: 600.0
    estimated_waiting_time: Optional[int] = None
    #: Callback options enabled/disabled. Default value is false.
    callback_option_enabled: Optional[bool] = None
    #: The minimum estimated callback times in minutes. The default value is 30.
    #: example: 10.0
    minimum_estimated_callback_time: Optional[int] = None
    #: The international numbers for callback is enabled/disabled. The default value is `false`.
    international_callback_enabled: Optional[bool] = None
    #: Play updated estimated wait message.
    #: example: true
    play_updated_estimated_wait_message: Optional[str] = None


class CallQueueQueueSettingsObjectComfortMessage(ApiModel):
    #: If enabled play periodic comfort message.
    #: example: True
    enabled: Optional[bool] = None
    #: The interval in seconds between each repetition of the comfort message played to queued users. The minimum time
    #: is 10 seconds.The maximum time is 600 seconds.
    #: example: 10.0
    time_between_messages: Optional[int] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement `fileName` strings to be played as `comfortMessage` greetings. These files are from the
    #: list of announcement files associated with this call queue. These files are from the list of announcements
    #: files associated with this call queue. For `CUSTOM` announcement, a minimum of 1 `fileName` is mandatory, and
    #: the maximum is 4.
    #: example: ['[\"Greeting-1.wav\"]']
    audio_files: Optional[list[str]] = None


class CallQueueQueueSettingsObjectComfortMessageBypass(ApiModel):
    #: If enabled play comfort bypass message.
    #: example: True
    enabled: Optional[bool] = None
    #: The interval in seconds between each repetition of the comfort bypass message played to queued users. The
    #: minimum time is 1 seconds. The maximum time is 120 seconds.
    #: example: 10.0
    call_waiting_age_threshold: Optional[int] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement `fileName` strings to be played as `comfortMessageBypass` greetings. These files are from
    #: the list of announcements files associated with this call queue. For `CUSTOM` announcement, a minimum of 1
    #: `fileName` is mandatory, and the maximum is 4.
    #: example: ['[\"Greeting-1.wav\"]']
    audio_files: Optional[list[str]] = None


class CallQueueQueueSettingsObjectMohMessageNormalSource(ApiModel):
    #: Enable media on hold for queued calls.
    #: example: True
    enabled: Optional[bool] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement `fileName` strings to be played as `mohMessage` greetings. These files are from the list
    #: of announcement files associated with this call queue. For `CUSTOM` announcement, a minimum of 1 `fileName` is
    #: mandatory, and the maximum is 4.
    #: example: ['[\"Greeting-1.wav\"]']
    audio_files: Optional[list[str]] = None


class CallQueueQueueSettingsObjectMohMessage(ApiModel):
    normal_source: Optional[CallQueueQueueSettingsObjectMohMessageNormalSource] = None
    alternate_source: Optional[CallQueueQueueSettingsObjectMohMessageNormalSource] = None


class CallQueueQueueSettingsObject1(ApiModel):
    #: The maximum number of calls for this call queue. Once this number is reached, the `overflow` settings are
    #: triggered.
    #: example: 50.0
    queue_size: Optional[int] = None
    #: Play ringing tone to callers when their call is set to an available agent.
    #: example: True
    call_offer_tone_enabled: Optional[bool] = None
    #: Reset caller statistics upon queue entry.
    reset_call_statistics_enabled: Optional[bool] = None
    #: Settings for incoming calls exceed queueSize.
    overflow: Optional[CallQueueQueueSettingsObjectOverflow] = None
    #: Play a message when callers first reach the queue. For example, Thank you for calling. An agent will be with
    #: you shortly. It can be set as mandatory. If the mandatory option is not selected and a caller reaches the call
    #: queue while there is an available agent, the caller will not hear this announcement and is transferred to an
    #: agent. The welcome message feature is enabled by default.
    welcome_message: Optional[CallQueueQueueSettingsObjectWelcomeMessage] = None
    #: Notify the caller with either their estimated wait time or position in the queue. If this option is enabled, it
    #: plays after the welcome message and before the comfort message. By default, it is not enabled.
    wait_message: Optional[CallQueueQueueSettingsObjectWaitMessage] = None
    #: Play a message after the welcome message and before hold music. This is typically a `CUSTOM` announcement that
    #: plays information, such as current promotions or information about products and services.
    comfort_message: Optional[CallQueueQueueSettingsObjectComfortMessage] = None
    #: Play a shorter comfort message instead of the usual Comfort or Music On Hold announcement to all the calls that
    #: should be answered quickly. This feature prevents a caller from hearing a short portion of the standard comfort
    #: message that abruptly ends when they are connected to an agent.
    comfort_message_bypass: Optional[CallQueueQueueSettingsObjectComfortMessageBypass] = None
    #: Play music after the comforting message in a repetitive loop.
    moh_message: Optional[CallQueueQueueSettingsObjectMohMessage] = None
    #: Play a message to the agent immediately before the incoming call is connected. The message typically announces
    #: the identity of the call queue from which the call is coming.
    whisper_message: Optional[CallQueueQueueSettingsObjectMohMessageNormalSource] = None


class HuntRoutingTypeSelection(str, Enum):
    #: Default routing type which directly uses the routing policy to dispatch calls to the agents.
    priority_based = 'PRIORITY_BASED'
    #: This option uses skill level as the criteria to route calls to agents. When there is more than one agent with
    #: the same skill level, the selected `policy` helps dispatch the calls to the agents.
    skill_based = 'SKILL_BASED'


class GetCallQueueCallPolicyObject1(ApiModel):
    #: Call routing type to use to dispatch calls to agents.
    #: example: PRIORITY_BASED
    routing_type: Optional[HuntRoutingTypeSelection] = None
    #: Call routing policy to use to dispatch calls to agents.
    #: example: UNIFORM
    policy: Optional[HuntPolicySelection] = None
    #: Settings for when the call into the call queue is not answered.
    call_bounce: Optional[GetCallQueueCallPolicyObjectCallBounce] = None
    #: Whether or not the call queue has the distinctive ring option enabled.
    distinctive_ring: Optional[GetCallQueueCallPolicyObjectDistinctiveRing] = None


class GetPersonPlaceVirtualLineCallQueueObject(ApiModel):
    #: ID of person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: First name of person, workspace or virtual line.
    #: example: Hakim
    first_name: Optional[str] = None
    #: First name of person, workspace or virtual line.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone number of person, workspace or virtual line.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Extension of person, workspace or virtual line.
    #: example: 5309
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12345309
    esn: Optional[str] = None
    #: Weight of person, workspace or virtual line. Only applied when call policy is `WEIGHTED`.
    #: example: 50
    weight: Optional[datetime] = None
    #: Skill level of person, workspace or virtual line. Only applied when the call `routingType` is `SKILL_BASED`.
    #: example: 1.0
    skill_level: Optional[int] = None
    #: Indicates the join status of the agent for this queue. The default value while creating call queue is `true`.
    #: example: True
    join_enabled: Optional[bool] = None


class GetCallQueueObject1(ApiModel):
    #: A unique identifier for the call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the call queue.
    #: example: CallQueue-1
    name: Optional[str] = None
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Language for the call queue.
    #: example: English
    language: Optional[str] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to the `phoneNumber` if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the call queue.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Extension of the call queue.
    #: example: 5309
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12345309
    esn: Optional[str] = None
    #: When true, indicates that the agent's configuration allows them to use the queue's Caller ID for outgoing calls.
    #: example: True
    phone_number_for_outgoing_calls_enabled: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a call queue. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the call queue.
    alternate_number_settings: Optional[GetCallQueueObjectAlternateNumberSettings] = None
    #: Policy controlling how calls are routed to `agents`.
    call_policies: Optional[GetCallQueueCallPolicyObject1] = None
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsObject1] = None
    #: Flag to indicate whether call waiting is enabled for `agents`.
    allow_call_waiting_for_agents_enabled: Optional[bool] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallQueueObject]] = None
    #: Whether or not to allow agents to join or unjoin a queue.
    allow_agent_join_enabled: Optional[bool] = None


class ListCallQueueObject1(ApiModel):
    #: A unique identifier for the call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUVVFVUUvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the call queue.
    #: example: 5714328359
    name: Optional[str] = None
    #: Name of location for call queue.
    #: example: WXCSIVDKCPAPIC4S1
    location_name: Optional[str] = None
    #: ID of location for call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx
    location_id: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Primary phone extension of the call queue.
    #: example: 5309
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12345309
    esn: Optional[str] = None
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None


class ReadTheListOfCallQueuesResponse1(ApiModel):
    #: Array of call queues.
    queues: Optional[list[ListCallQueueObject1]] = None


class GetComplianceAnnouncementObject(ApiModel):
    #: Flag to indicate whether the Call Recording START/STOP announcement is played to an inbound caller.
    #: example: True
    inbound_pstncalls_enabled: Optional[bool] = Field(alias='inboundPSTNCallsEnabled', default=None)
    #: Flag to indicate whether to use the customer level compliance announcement default settings.
    #: example: True
    use_org_settings_enabled: Optional[bool] = None
    #: Flag to indicate whether the Call Recording START/STOP announcement is played to an outbound caller.
    outbound_pstncalls_enabled: Optional[bool] = Field(alias='outboundPSTNCallsEnabled', default=None)
    #: Flag to indicate whether compliance announcement is played after a specified delay in seconds.
    outbound_pstncalls_delay_enabled: Optional[bool] = Field(alias='outboundPSTNCallsDelayEnabled', default=None)
    #: Number of seconds to wait before playing the compliance announcement.
    #: example: 10.0
    delay_in_seconds: Optional[int] = None


class GetOrgComplianceAnnouncementObject(ApiModel):
    #: Flag to indicate whether the Call Recording START/STOP announcement is played to an inbound caller.
    #: example: True
    inbound_pstncalls_enabled: Optional[bool] = Field(alias='inboundPSTNCallsEnabled', default=None)
    #: Flag to indicate whether the Call Recording START/STOP announcement is played to an outbound caller.
    outbound_pstncalls_enabled: Optional[bool] = Field(alias='outboundPSTNCallsEnabled', default=None)
    #: Flag to indicate whether compliance announcement is played after a specified delay in seconds.
    outbound_pstncalls_delay_enabled: Optional[bool] = Field(alias='outboundPSTNCallsDelayEnabled', default=None)
    #: Number of seconds to wait before playing the compliance announcement.
    #: example: 10.0
    delay_in_seconds: Optional[int] = None


class GetComplianceAnnouncementObject1(ApiModel):
    #: Flag to indicate whether the Call Recording START/STOP announcement is played to an internal caller.
    #: example: True
    inbound_pstncalls_enabled: Optional[bool] = Field(alias='inboundPSTNCallsEnabled', default=None)


class AddressAgentHuntGroupObject(ApiModel):
    #: numeric address for the Hunt Group agent.
    #: example: 1234567890
    address: Optional[str] = None


class PostHuntGroupCallPolicyObjectNoAnswer(ApiModel):
    #: If enabled, advance to next agent after the `nextAgentRings` has occurred.
    #: example: True
    next_agent_enabled: Optional[bool] = None
    #: Number of rings before call will be forwarded if unanswered and `nextAgentEnabled` is true.
    #: example: 3.0
    next_agent_rings: Optional[int] = None
    #: If true, forwards unanswered calls to the destination after the number of rings occurs.
    forward_enabled: Optional[bool] = None
    #: Number of rings before forwarding calls if `forwardEnabled` is true.
    #: example: 15.0
    number_of_rings: Optional[int] = None
    #: Destination if `forwardEnabled` is True.
    #: example: 2225551212
    destination: Optional[str] = None
    #: If `forwardEnabled` is true, enables and disables sending incoming to destination number's voicemail if the
    #: destination is an internal phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool] = None


class GetHuntGroupCallPolicyObjectBusinessContinuity(ApiModel):
    #: Divert calls when unreachable, unanswered calls divert to a defined phone number. This could apply to phone
    #: calls that aren't answered due to a network outage, or all agents of the hunt group are busy and the Advance
    #: when the busy option is also enabled. For persons only using a mobile device, calls won't be diverted, if there
    #: is a network outage.
    #: example: True
    enabled: Optional[bool] = None
    #: Destination for Business Continuity.
    #: example: 2225551212
    destination: Optional[str] = None
    #: Indicates enabled or disabled state of sending diverted incoming calls to the destination number's voicemail if
    #: the destination is an internal phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool] = None


class PostHuntGroupCallPolicyObject(ApiModel):
    #: Call routing policy to use to dispatch calls to agents.
    #: example: UNIFORM
    policy: Optional[HuntPolicySelection] = None
    #: If false, then the option is treated as "Advance when busy": the hunt group won't ring agents when they're on a
    #: call and will advance to the next agent. If a hunt group agent has call waiting enabled and the call is
    #: advanced to them, then the call will wait until that hunt group agent isn't busy.
    #: example: True
    waiting_enabled: Optional[bool] = None
    #: Settings for when the call into the hunt group is not answered.
    no_answer: Optional[PostHuntGroupCallPolicyObjectNoAnswer] = None
    #: Settings for sending calls to a destination of your choice if your phone is not connected to the network for any
    #: reason, such as power outage, failed Internet connection, or wiring problem.
    business_continuity: Optional[GetHuntGroupCallPolicyObjectBusinessContinuity] = None


class CreateHuntGroupObject(ApiModel):
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group. Either phone number or extension are required.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the hunt group. Either phone number or extension are required.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject] = None
    #: Determines whether hosted or numeric Hunt Group agents are used for this Hunt Group
    #: example: True
    use_hosted_agent_enabled: Optional[bool] = None
    #: Determines wether to use the Policy Server for this Hunt Group
    use_policy_server_enabled: Optional[bool] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls, on-prem.
    address_agents: Optional[list[AddressAgentHuntGroupObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None


class GetHuntGroupCallPolicyObjectNoAnswer(ApiModel):
    #: If enabled, advance to next agent after the `nextAgentRings` has occurred.
    #: example: True
    next_agent_enabled: Optional[bool] = None
    #: Number of rings before call will be forwarded if unanswered and `nextAgentEnabled` is true.
    #: example: 3.0
    next_agent_rings: Optional[int] = None
    #: If true, forwards unanswered calls to the destination after the number of rings occurs.
    forward_enabled: Optional[bool] = None
    #: Destination if `forwardEnabled` is True.
    #: example: 2225551212
    destination: Optional[str] = None
    #: Number of rings before forwarding calls if `forwardEnabled` is true.
    #: example: 15.0
    number_of_rings: Optional[int] = None
    #: System-wide maximum number of rings allowed for `numberOfRings` setting.
    #: example: 15.0
    system_max_number_of_rings: Optional[int] = None
    #: If destinationVoicemailEnabled is true, enables and disables sending incoming to destination number's voicemail
    #: if the destination is an internal phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool] = None


class GetHuntGroupCallPolicyObject(ApiModel):
    #: Call routing policy to use to dispatch calls to agents.
    #: example: UNIFORM
    policy: Optional[HuntPolicySelection] = None
    #: If false, then the option is treated as "Advance when busy": the hunt group won't ring `agents` when they're on
    #: a call and will advance to the next agent. If a hunt group agent has call waiting enabled and the call is
    #: advanced to them, then the call will wait until that hunt group agent isn't busy.
    #: example: True
    waiting_enabled: Optional[bool] = None
    #: Settings for when the call into the hunt group is not answered.
    no_answer: Optional[GetHuntGroupCallPolicyObjectNoAnswer] = None
    #: Settings for sending calls to a destination of your choice if your phone is not connected to the network for any
    #: reason, such as power outage, failed Internet connection, or wiring problem.
    business_continuity: Optional[GetHuntGroupCallPolicyObjectBusinessContinuity] = None


class GetHuntGroupObject(ApiModel):
    #: A unique identifier for the hunt group.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language for hunt group.
    #: example: English
    language: Optional[str] = None
    #: Language code for hunt group.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetHuntGroupCallPolicyObject] = None
    #: Determines wether to use the Policy Server for this Hunt Group
    use_policy_server_enabled: Optional[bool] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[GetPersonPlaceObject]] = None
    #: Numeric addresses of people, workspaces and virtual lines that are eligible to  receive calls.
    address_agents: Optional[list[AddressAgentHuntGroupObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None


class ModifyHuntGroupObject(ApiModel):
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject] = None
    #: Determines wether to use the Policy Server for this Hunt Group
    use_policy_server_enabled: Optional[bool] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls, on-prem.
    address_agents: Optional[list[AddressAgentHuntGroupObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None


class GetHuntGroupObject1(ApiModel):
    #: A unique identifier for the hunt group.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language for hunt group.
    #: example: English
    language: Optional[str] = None
    #: Language code for hunt group.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to ".".
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetHuntGroupCallPolicyObject] = None
    #: People, including workspaces, that are eligible to  receive calls.
    agents: Optional[list[GetPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Specifies the department information.
    department: Optional[Location] = None


class ModifyHuntGroupObject1(ApiModel):
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to ".".
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject] = None
    #: People, including workspaces, that are eligible to  receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Department the huntgroup is assigned to.
    department: Optional[DepartmentResponseWithId] = None


class ReadTheListOfHuntGroupsResponse(ApiModel):
    #: Array of hunt groups.
    hunt_groups: Optional[list[ListCallQueueObject]] = None


class GetPersonPlaceVirtualLineHuntGroupObject1(ApiModel):
    #: ID of person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: First name of person, workspace or virtual line.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name of person, workspace or virtual line.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone number of person, workspace or virtual line.
    #: example: +15555551234
    phone_number: Optional[str] = None
    #: Extension of person, workspace or virtual line.
    #: example: 1234
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341234
    esn: Optional[str] = None
    #: Weight of person, workspace or virtual line. Only applied when call policy is `WEIGHTED`.
    #: example: 50
    weight: Optional[datetime] = None


class GetHuntGroupObject2(ApiModel):
    #: A unique identifier for the hunt group.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12347781
    esn: Optional[str] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language for hunt group.
    #: example: English
    language: Optional[str] = None
    #: Language code for hunt group.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetHuntGroupCallPolicyObject] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineHuntGroupObject1]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None


class ReadTheListOfHuntGroupsResponse1(ApiModel):
    #: Array of hunt groups.
    hunt_groups: Optional[list[ListCallQueueObject1]] = None


class CreateHuntGroupObject1(ApiModel):
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group. Either phone number or extension are required.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the hunt group. Either phone number or extension are required.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Enable the hunt group to be used as the caller ID when the agent places outgoing calls. When set to true the
    #: hunt group's caller ID will be used.
    #: example: True
    hunt_group_caller_id_for_outgoing_calls_enabled: Optional[bool] = None


class GetHuntGroupObject3(ApiModel):
    #: A unique identifier for the hunt group.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language for hunt group.
    #: example: English
    language: Optional[str] = None
    #: Language code for hunt group.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetHuntGroupCallPolicyObject] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[GetPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Whether or not the hunt group can be used as the caller ID when the agent places outgoing calls.
    #: example: True
    hunt_group_caller_id_for_outgoing_calls_enabled: Optional[bool] = None


class ModifyHuntGroupObject2(ApiModel):
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Enable the hunt group to be used as the caller ID when the agent places outgoing calls. When set to true the
    #: hunt group's caller ID will be used.
    #: example: True
    hunt_group_caller_id_for_outgoing_calls_enabled: Optional[bool] = None


class GetPagingGroupAgentObject(ApiModel):
    #: Agents ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80YTc2ZmVmNC1mZjlmLTExZWItYWYwZC00M2YwZjY1NTdjYWI
    id: Optional[str] = None
    #: Agents first name. Minimum length is 1. Maximum length is 30.
    #: example: John
    first_name: Optional[str] = None
    #: Agents last name. Minimum length is 1. Maximum length is 30.
    #: example: Doe
    last_name: Optional[str] = None
    #: Type of the person or workspace.
    #: example: PEOPLE
    type: Optional[MemberType1] = None
    #: Agents phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber or extension is mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Agents extension. Minimum length is 2. Maximum length is 6. Either phoneNumber or extension is mandatory.
    #: example: 7781
    extension: Optional[datetime] = None


class GetPagingGroupObject(ApiModel):
    #: A unique identifier for the paging group.
    #: example: Y2lzY29zcGFyazovL3VzL1BBR0lOR19HUk9VUC85ZTgzZmEzYy0yYjEzLTQ2MzEtOWE1Mi0zZjg2M2NjYWVlYzg
    id: Optional[str] = None
    #: Whether or not the paging group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: PagingGroup-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber or extension is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6. Either phoneNumber or extension is mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Paging language. Minimum length is 1. Maximum length is 40.
    #: example: English
    language: Optional[str] = None
    #: Language code.
    #: example: en_us
    language_code: Optional[str] = None
    #: First name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Paging
    first_name: Optional[str] = None
    #: Last name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Group
    last_name: Optional[str] = None
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    #: example: True
    originator_caller_id_enabled: Optional[bool] = None
    #: An array of people and/or workspaces, who may originate pages to this paging group.
    originators: Optional[list[GetPagingGroupAgentObject]] = None
    #: People, including workspaces, that are added to paging group as paging call targets.
    targets: Optional[list[GetPagingGroupAgentObject]] = None
    #: Specifies the department information.
    department: Optional[Location] = None


class ListPagingGroupObject(ApiModel):
    #: A unique identifier for the paging group.
    #: example: Y2lzY29zcGFyazovL3VzL1BBR0lOR19HUk9VUC85ZTgzZmEzYy0yYjEzLTQ2MzEtOWE1Mi0zZjg2M2NjYWVlYzg
    id: Optional[str] = None
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: PagingGroup-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber or extension is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6. Either phoneNumber or extension is mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Name of location for paging group.
    #: example: Alaska
    location_name: Optional[str] = None
    #: ID of location for paging group.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzEyMzQ1
    location_id: Optional[str] = None
    #: Specifies the department information.
    department: Optional[Location] = None


class UpdatePagingGroupObject(ApiModel):
    #: Whether or not the paging group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: PagingGroup-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber or extension is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6. Either phoneNumber or extension is mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Language code.
    #: example: en_us
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this paging group. Defaults to ".".
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this paging group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    #: example: True
    originator_caller_id_enabled: Optional[bool] = None
    #: An array of people and/or workspaces, who may originate pages to this paging group.
    originators: Optional[list[str]] = None
    #: People, including workspaces, that are added to paging group as paging call targets.
    targets: Optional[list[str]] = None
    #: Specifies the department information.
    department: Optional[DepartmentResponseWithId] = None


class ReadTheListOfPagingGroupsResponse(ApiModel):
    #: Array of paging groups.
    location_paging: Optional[list[ListPagingGroupObject]] = None


class GetPagingGroupAgentObject1(ApiModel):
    #: Agents ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80YTc2ZmVmNC1mZjlmLTExZWItYWYwZC00M2YwZjY1NTdjYWI
    id: Optional[str] = None
    #: Agents first name. Minimum length is 1. Maximum length is 30.
    #: example: John
    first_name: Optional[str] = None
    #: Agents last name. Minimum length is 1. Maximum length is 30.
    #: example: Doe
    last_name: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: Agents phone number. Minimum length is 1. Maximum length is 23.  Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Agents extension. Minimum length is 2. Maximum length is 6.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12347781
    esn: Optional[str] = None


class GetPagingGroupObject1(ApiModel):
    #: A unique identifier for the paging group.
    #: example: Y2lzY29zcGFyazovL3VzL1BBR0lOR19HUk9VUC9hSFpoWlROMk1HOHliMEEyTkRrME1USTVOeTVwYm5ReE1DNWlZMnhrTG5kbFltVjRMbU52YlE
    id: Optional[str] = None
    #: Whether or not the paging group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: PagingGroup-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6. Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12347781
    esn: Optional[str] = None
    #: Flag to indicate toll free number.
    toll_free_number: Optional[bool] = None
    #: Paging language. Minimum length is 1. Maximum length is 40.
    #: example: English
    language: Optional[str] = None
    #: Language code.
    #: example: en_us
    language_code: Optional[str] = None
    #: First name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Paging
    first_name: Optional[str] = None
    #: Last name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Group
    last_name: Optional[str] = None
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    #: example: True
    originator_caller_id_enabled: Optional[bool] = None
    #: An array of people, workspaces and virtual lines ID's who may originate pages to this paging group.
    originators: Optional[list[GetPagingGroupAgentObject1]] = None
    #: An array of people, workspaces and virtual lines ID's that are added to paging group as paging call targets.
    targets: Optional[list[GetPagingGroupAgentObject1]] = None


class ListPagingGroupObject1(ApiModel):
    #: A unique identifier for the paging group.
    #: example: Y2lzY29zcGFyazovL3VzL1BBR0lOR19HUk9VUC9hSFpoWlROMk1HOHliMEEyTkRrME1USTVOeTVwYm5ReE1DNWlZMnhrTG5kbFltVjRMbU52YlE
    id: Optional[str] = None
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: PagingGroup-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6. Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12347781
    esn: Optional[str] = None
    #: Name of location for paging group.
    #: example: Alaska
    location_name: Optional[str] = None
    #: Id of location for paging group.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzEyMzQ1
    location_id: Optional[str] = None
    #: Flag to indicate toll free number.
    toll_free_number: Optional[bool] = None


class ReadTheListOfPagingGroupsResponse1(ApiModel):
    #: Array of paging groups.
    location_paging: Optional[list[ListPagingGroupObject1]] = None


class ContactDetails(ApiModel):
    #: ID of person.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wNTUyZjY3Yi01OWE5LTQxYmItODczNi0xYjA0MWQxZGRkNWU
    person_id: Optional[str] = None
    #: First name of person.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of person.
    #: example: Doe
    last_name: Optional[str] = None
    #: Department ID of person.
    #: example: Y2lzY29zcGFyazovL3VzL0RFUEFSVE1FTlQvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    department: Optional[str] = None
    #: Phone number of person.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Extension of person.
    #: example: 5309
    extension: Optional[datetime] = None
    #: Location ID of person.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2E4Mjg5NzIyLTFiODAtNDFiNy05Njc4LTBlNzdhZThjMTA5OA
    location_id: Optional[str] = None
    #: Location feature ID of the contact. Supported location feature types are Auto Attendant, Call Queue, Hunt Group,
    #: Single Number Reach, and Paging Group.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5ULzA1NTJmNjdiLTU5YTktNDFiYi04NzM2LTFiMDQxZDFkZGQ1ZQ
    feature_id: Optional[str] = None


class PersonId(ApiModel):
    #: Person ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wNTUyZjY3Yi01OWE5LTQxYmItODczNi0xYjA0MWQxZGRkNWU
    person_id: Optional[str] = None
    #: Location feature ID.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5ULzA1NTJmNjdiLTU5YTktNDFiYi04NzM2LTFiMDQxZDFkZGQ1ZQ
    feature_id: Optional[str] = None
    #: Types of users supported in receptionist contacts are People, Auto Attendant, Call Queue, Hunt Group, Single
    #: Number Reach, and Paging Group.
    #: example: PEOPLE
    type: Optional[str] = None


class ContactPayload(ApiModel):
    #: Receptionist Contact Directory name.
    #: example: My_Directory
    name: Optional[str] = None
    #: Array of users assigned to this Receptionist Contact Directory.
    contacts: Optional[list[PersonId]] = None


class ContactPayloadForModify(ApiModel):
    #: Receptionist Contact Directory name.
    #: example: My_Directory
    name: Optional[str] = None
    #: Array of users or location features assigned to this Receptionist Contact Directory.
    #: example: ['Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wNTUyZjY3Yi01OWE5LTQxYmItODczNi0xYjA0MWQxZGRkNWU']
    contacts: Optional[list[str]] = None


class ReadListOfReceptionistContactDirectoriesResponse(ApiModel):
    #: Array of Receptionist Contact Directories.
    directories: Optional[list[Location]] = None


class GetDetailsForAReceptionistContactDirectoryResponse(ApiModel):
    #: Array of Receptionist Contact Directories.
    contacts: Optional[list[ContactDetails]] = None


class GetCallPickupObjectNotificationType(str, Enum):
    #: Notification is not sent to any member of the call pickup group.
    none_ = 'NONE'
    #: When the notificationDelayTimerSeconds number of seconds has elapsed, play an audio notification for each call
    #: pickup group member.
    audio_only = 'AUDIO_ONLY'
    #: When the notificationDelayTimerSeconds number of seconds has elapsed, provide a visual notification to every
    #: call pickup group member.
    visual_only = 'VISUAL_ONLY'
    #: When the notificationDelayTimerSeconds number of seconds has elapsed, provide a audio and visual notification to
    #: every call pickup group member.
    audio_and_visual = 'AUDIO_AND_VISUAL'


class GetUserNumberItemObject2(ApiModel):
    #: Phone number of a person or workspace.
    #: example: +19075552859
    external: Optional[str] = None
    #: Extension of a person or workspace.
    #: example: 8080
    extension: Optional[datetime] = None
    #: Flag to indicate a primary phone.
    #: example: True
    primary: Optional[bool] = None


class GetPersonPlaceVirtualLineCallPickupObject1(ApiModel):
    #: ID of a person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: First name of a person, workspace or virtual line.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of a person, workspace or virtual line.
    #: example: Brown
    last_name: Optional[str] = None
    #: Display name of a person, workspace or virtual line.
    #: example: johnBrown
    display_name: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: Email of a person, workspace or virtual line.
    #: example: john.brown@example.com
    email: Optional[str] = None
    #: List of phone numbers of a person, workspace or virtual line.
    phone_number: Optional[list[GetUserNumberItemObject2]] = None


class GetCallPickupObject1(ApiModel):
    #: A unique identifier for the call pickup.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUElDS1VQL1kyRnNiRkJwWTJ0MWNERT0
    id: Optional[str] = None
    #: Unique name for the call pickup. The maximum length is 80.
    #: example: North Alaska-Group
    name: Optional[str] = None
    #: Type of the notification when an incoming call is unanswered, the call pickup group notifies all of its members.
    #: Default: NONE.
    #: example: NONE
    notification_type: Optional[GetCallPickupObjectNotificationType] = None
    #: After the number of seconds given by the notificationDelayTimerSeconds has elapsed, notify every member of the
    #: call pickup group when an incoming call goes unanswered. The notificationType field specifies the notification
    #: method.Default: 6.
    #: example: 6.0
    notification_delay_timer_seconds: Optional[int] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallPickupObject1]] = None


class ModifyCallPickupObject(ApiModel):
    #: Unique name for the call pickup. The maximum length is 80.
    #: example: North Alaska-Group
    name: Optional[str] = None
    #: Type of the notification when an incoming call is unanswered, the call pickup group notifies all of its members.
    #: Default: NONE.
    #: example: NONE
    notification_type: Optional[GetCallPickupObjectNotificationType] = None
    #: After the number of seconds given by the notificationDelayTimerSeconds has elapsed, notify every member of the
    #: call pickup group when an incoming call goes unanswered. The notificationType field specifies the notification
    #: method.Default: 6.
    #: example: 6.0
    notification_delay_timer_seconds: Optional[int] = None
    #: An array of people, workspace, and virtual lines IDs, that are added to call pickup.
    agents: Optional[list[str]] = None


class GetLocationVoicemailGroupObjectMessageStorageStorageType(str, Enum):
    #: Store messages in internal mailbox.
    internal = 'INTERNAL'
    #: Send messages to the email address provided.
    external = 'EXTERNAL'


class GetLocationVoicemailGroupObjectMessageStorage(ApiModel):
    #: Message storage type
    #: example: EXTERNAL
    storage_type: Optional[GetLocationVoicemailGroupObjectMessageStorageStorageType] = None
    #: External email to forward the message.
    #: example: user@flex2.cisco.com
    external_email: Optional[str] = None


class GetLocationVoicemailGroupObjectNotifications(ApiModel):
    #: Enable/disable messages notification
    #: example: True
    enabled: Optional[bool] = None
    #: Notifications to be sent to provided email to SMS gateway.
    #: example: user@flex2.cisco.com
    destination: Optional[str] = None


class GetLocationVoicemailGroupObjectFaxMessage(ApiModel):
    #: Enable/disable fax messaging.
    #: example: True
    enabled: Optional[bool] = None
    #: Phone number to receive fax messages.
    #: example: +1234234324
    phone_number: Optional[str] = None
    #: Extension to receive fax messages.
    #: example: 23455.0
    extension: Optional[int] = None


class GetLocationVoicemailGroupObjectEmailCopyOfMessage(ApiModel):
    #: Enable/disable to email message copy.
    #: example: True
    enabled: Optional[bool] = None
    #: Email message copy to email address provided.
    #: example: user@flex2.cisco.com
    email_id: Optional[str] = None


class GetLocationVoicemailGroupObject(ApiModel):
    #: UUID of voicemail group of a particular location.
    #: example: a7dd4d39-4a78-4516-955f-7810dbe379cf
    id: Optional[str] = None
    #: Name of the voicemail group.
    #: example: VGName
    name: Optional[str] = None
    #: Voicemail group phone number.
    #: example: +1234234324
    phone_number: Optional[str] = None
    #: Voicemail group extension number.
    #: example: 23455.0
    extension: Optional[int] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 123423455
    esn: Optional[str] = None
    #: Voicemail group toll free number.
    toll_free_number: Optional[bool] = None
    #: Voicemail group caller ID first name.
    #: example: Customer
    first_name: Optional[str] = None
    #: Voicemail group called ID last name.
    #: example: Support
    last_name: Optional[str] = None
    #: Enable/disable voicemail group.
    #: example: True
    enabled: Optional[bool] = None
    #: Language for voicemail group audio announcement.
    #: example: en_us
    language_code: Optional[str] = None
    #: Set voicemail group greeting type.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Enabled if CUSTOM greeting is previously uploaded.
    #: example: True
    greeting_uploaded: Optional[bool] = None
    #: CUSTOM greeting for previously uploaded.
    #: example: short greeting.wav
    greeting_description: Optional[str] = None
    #: Message storage information
    message_storage: Optional[GetLocationVoicemailGroupObjectMessageStorage] = None
    #: Message notifications
    notifications: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Fax message receive settings
    fax_message: Optional[GetLocationVoicemailGroupObjectFaxMessage] = None
    #: Transfer message information
    transfer_to_number: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Message copy information
    email_copy_of_message: Optional[GetLocationVoicemailGroupObjectEmailCopyOfMessage] = None
    #: Enable/disable to forward voice message.
    #: example: True
    voice_message_forwarding_enabled: Optional[bool] = None


class GetVoicemailGroupObject(ApiModel):
    #: Voicemail Group ID.
    #: example: Y2lzY29zcGFyazovL3VzL1ZPSUNFTUFJTF9HUk9VUC8yZmQzZGMwMy0yZWRhLTQ4NmUtODdhYS0xODY1ZDI5YWExZWI
    id: Optional[str] = None
    #: Voicemail Group Name.
    #: example: test
    name: Optional[str] = None
    #: Location Name.
    #: example: San Jose
    location_name: Optional[str] = None
    #: Location ID.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx
    location_id: Optional[str] = None
    #: Extension of the voicemail group.
    #: example: 0007
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12340007
    esn: Optional[str] = None
    #: Phone number of the voicemail group.
    #: example: +1345325235
    phone_number: Optional[str] = None
    #: If enabled, incoming calls are sent to voicemail.
    #: example: True
    enabled: Optional[bool] = None
    #: Flag to indicate if the number is toll free.
    #: example: True
    toll_free_number: Optional[bool] = None


class ListVoicemailGroupResponse(ApiModel):
    #: Array of VoicemailGroups.
    voicemail_groups: Optional[list[GetVoicemailGroupObject]] = None


class ArrayOfExtensionsObject(ApiModel):
    #: Array of extensions that will be validated.
    extensions: Optional[list[str]] = None


class CallBackEffectiveLevel(str, Enum):
    #: Assigned phone number to location.
    location_number = 'LOCATION_NUMBER'
    #: Assigned number of a user or workspace in the location.
    location_member_number = 'LOCATION_MEMBER_NUMBER'
    _none_ = 'NONE'


class CallBackQuality(str, Enum):
    recommended = 'RECOMMENDED'
    not_recommended = 'NOT_RECOMMENDED'
    invalid = 'INVALID'


class CallBackSelected(str, Enum):
    #: Assigned phone number to location.
    location_number = 'LOCATION_NUMBER'
    #: Assigned number of a user or workspace in the location.
    location_member_number = 'LOCATION_MEMBER_NUMBER'


class ExtensionStatusObjectState(str, Enum):
    #: Extension is valid.
    valid = 'VALID'
    #: Extension already assigned to another group.
    duplicate = 'DUPLICATE'
    #: Extension already exists in the request body and was already verified.
    duplicate_in_list = 'DUPLICATE_IN_LIST'
    #: Extension is invalid.
    invalid = 'INVALID'


class ExtensionStatusObject(ApiModel):
    #: Unique extension which will be validated at the location level.
    #: example: 407721
    extension: Optional[str] = None
    #: State of the extension after it was validated.
    #: example: VALID
    state: Optional[ExtensionStatusObjectState] = None
    #: Error code of the state in case extension is not valid.
    #: example: 9495.0
    error_code: Optional[int] = None
    #: Message assigned to the error code.
    #: example: [Error 9495] The extension is not available. It is already assigned as a Call Park Extension: 407721.
    message: Optional[str] = None


class GetLocationCallBackNumberObjectLocationInfo(ApiModel):
    #: Assigned phone number to location.
    #: example: +12145551767
    phone_number: Optional[str] = None
    #: The name of the location.
    #: example: CPAPI_Dev_Test_Location_DND
    name: Optional[str] = None
    #: The source from which the emergency calling line ID is selected for an actual emergency call, applying fallback
    #: rules as necessary.
    #: example: LOCATION_NUMBER
    effective_level: Optional[CallBackEffectiveLevel] = None
    #: Location calling line ID number. Avaliable only when number is present and quality would be invalid.
    #: example: +12145551767
    effective_value: Optional[str] = None
    #: Used to represent whether a number is a recommended emergency callback number.
    #: example: RECOMMENDED
    quality: Optional[CallBackQuality] = None


class GetLocationCallBackNumberObjectLocationMemberInfo(ApiModel):
    #: The member phone number.
    #: example: +12145551767
    phone_number: Optional[str] = None
    #: The member first name.
    #: example: Jim
    first_name: Optional[str] = None
    #: The member last name. Always contains `.` if the member is a place.
    #: example: Grey
    last_name: Optional[str] = None
    #: Member ID of user/place within the location.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS82MmQ3YTY3MS00YmVlLTQ2MDItOGVkOC1jOTFmNjU5NjcxZGI
    member_id: Optional[str] = None
    #: Member Type.
    #: example: PEOPLE
    member_type: Optional[MemberType1] = None
    #: The source from which the emergency calling line ID is selected for an actual emergency call, applying fallback
    #: rules as necessary.
    #: example: LOCATION_MEMBER_NUMBER
    effective_level: Optional[CallBackEffectiveLevel] = None
    #: Location calling line ID number. Avaliable only when number is present and quality would be invalid.
    #: example: +12145551767
    effective_value: Optional[str] = None
    #: Used to represent whether a number is a recommended ECBN.
    #: example: RECOMMENDED
    quality: Optional[CallBackQuality] = None


class GetLocationCallBackNumberObject(ApiModel):
    #: Data relevant to this location.
    location_info: Optional[GetLocationCallBackNumberObjectLocationInfo] = None
    #: Data relevant to the user/place (member) selected for ECBN.
    location_member_info: Optional[GetLocationCallBackNumberObjectLocationMemberInfo] = None
    #: Selected number type to configure emergency call back.
    #: example: LOCATION_MEMBER_NUMBER
    selected: Optional[CallBackSelected] = None


class GetMusicOnHoldObjectGreeting(str, Enum):
    #: Play default music when call is placed on hold or parked. The system plays music to fill the silence and lets
    #: the customer know they are still connected.
    system = 'SYSTEM'
    #: Play previously uploaded custom music when call is placed on hold or parked.
    custom = 'CUSTOM'


class AudioAnnouncementFileGetObjectLevel(str, Enum):
    #: Specifies this audio file is configured across organization.
    organization = 'ORGANIZATION'
    #: Specifies this audio file is configured across location.
    location = 'LOCATION'


class AudioAnnouncementFileGetObject(ApiModel):
    #: A unique identifier for the announcement.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Audio announcement file name.
    #: example: AUDIO_FILE.wav
    file_name: Optional[str] = None
    #: Audio announcement file type.
    #: example: WAV
    media_file_type: Optional[AudioFileObjectMediaType] = None
    #: Audio announcement file type location.
    #: example: ORGANIZATION
    level: Optional[AudioAnnouncementFileGetObjectLevel] = None


class GetMusicOnHoldObject(ApiModel):
    #: If enabled, music will be played when call is placed on hold.
    #: example: True
    call_hold_enabled: Optional[bool] = None
    #: If enabled, music will be played when call is parked.
    #: example: True
    call_park_enabled: Optional[bool] = None
    #: Greeting type for the location.
    #: example: SYSTEM
    greeting: Optional[GetMusicOnHoldObjectGreeting] = None
    #: Announcement Audio File details when greeting is selected to be `CUSTOM`.
    audio_file: Optional[AudioAnnouncementFileGetObject] = None


class GetPrivateNetworkConnectObjectNetworkConnectionType(str, Enum):
    #: Use public internet for the location's connection type.
    public_internet = 'PUBLIC_INTERNET'
    #: Use private network connect for the location's connection type.
    private_network = 'PRIVATE_NETWORK'


class GetPrivateNetworkConnectObject(ApiModel):
    #: Network Connection Type for the location.
    #: example: PUBLIC_INTERNET
    network_connection_type: Optional[GetPrivateNetworkConnectObjectNetworkConnectionType] = None


class GetTelephonyLocationObjectCallingLineId(ApiModel):
    #: Group calling line ID name. By default the Org name.
    #: example: 'Denver Incoming'
    name: Optional[str] = None
    #: Directory Number / Main number in E.164 Format.
    #: example: '+12145555698'
    phone_number: Optional[str] = None


class RouteType(str, Enum):
    #: Route group must include at least one trunk with a maximum of 10 trunks per route group.
    route_group = 'ROUTE_GROUP'
    #: Connection between Webex Calling and the premises.
    trunk = 'TRUNK'


class GetTelephonyLocationObjectConnection(ApiModel):
    #: Webex Calling location only suppports `TRUNK` and `ROUTE_GROUP` connection type.
    #: example: ROUTE_GROUP
    type: Optional[RouteType] = None
    #: A unique identifier of route type.
    #: example: 'Y2lzY29zcGFyazovL3VzL1RSVU5LL2M1MGIxZjY2LTRjODMtNDAzNy04NjM1LTg2ZjlkM2VkZDQ5MQ'
    id: Optional[str] = None


class GetTelephonyLocationObject(ApiModel):
    #: A unique identifier for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfRk9SV0FSRElOR19TRUxFQ1RJVkVfUlVMRS9kR1Z6ZEZKMWJHVTA
    id: Optional[str] = None
    #: The name of the location.
    #: example: 'Denver'
    name: Optional[str] = None
    #: Location's phone announcement language.
    #: example: 'fr_fr'
    announcement_language: Optional[str] = None
    #: Location calling line information.
    calling_line_id: Optional[GetTelephonyLocationObjectCallingLineId] = None
    #: Connection details are only returned for local PSTN types of `TRUNK` or `ROUTE_GROUP`.
    connection: Optional[GetTelephonyLocationObjectConnection] = None
    #: External Caller ID Name value. Unicode characters.
    #: example: 'Big Corp Denver'
    external_caller_id_name: Optional[str] = None
    #: Limit on the number of people at the location(read-only).
    #: example: 500000.0
    user_limit: Optional[int] = None
    #: Emergency Location Identifier for a location. Set this field to provide the SIP access network information to
    #: the provider which will be used to populate the SIP P-Access-Network-Info header. This is helpful to establish
    #: the location of a device when you make an emergency call.
    #: example: 'Rcdn'
    p_access_network_info: Optional[str] = None
    #: Digit required to reach an outside line. Default: none.
    #: example: 'Rcdn'
    outside_dial_digit: Optional[str] = None
    #: Must dial a prefix when calling between locations having same extension within same location.
    #: example: '2'
    routing_prefix: Optional[datetime] = None
    #: IP Address, hostname, or domain. Read-Only.
    #: example: '98079822.int10.bcld.webex.com'
    default_domain: Optional[str] = None
    #: Chargeable number for the line placing the call. When this is set, all calls placed from this location will
    #: include a P-Charge-Info header with the selected number in the SIP INVITE.
    #: example: '+14158952369'
    charge_number: Optional[str] = None


class ListLocationObject(ApiModel):
    #: A unique identifier for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzljYTNhZmQ3LTE5MjYtNGQ0ZS05ZDA3LTk5ZDJjMGU4OGFhMA
    id: Optional[str] = None
    #: The name of the location.
    #: example: 'Denver'
    name: Optional[str] = None
    #: Digit required to reach an outside line. Default: none.
    #: example: '12'
    outside_dial_digit: Optional[datetime] = None
    #: Prefix required when calling between locations having the same extension within the same location.
    #: example: '2'
    routing_prefix: Optional[datetime] = None
    #: Location calling line information.
    calling_line_id: Optional[GetTelephonyLocationObjectCallingLineId] = None
    #: True if E911 setup is required.
    #: example: True
    e911_setup_required: Optional[bool] = None


class PostLocationAnnouncementLanguageObject(ApiModel):
    #: Set to `true` to change announcement language for existing people and workspaces.
    agent_enabled: Optional[bool] = None
    #: Set to `true` to change announcement language for existing feature configurations.
    service_enabled: Optional[bool] = None
    #: Language code.
    #: example: en_us
    announcement_language_code: Optional[str] = None


class PostLocationCallingRequestAddress(ApiModel):
    #: Address 1 of the location.
    #: example: 771 Alder Drive
    address1: Optional[str] = None
    #: Address 2 of the location.
    #: example: Cisco Site 5
    address2: Optional[str] = None
    #: City of the location.
    #: example: Milpitas
    city: Optional[str] = None
    #: State code of the location.
    #: example: CA
    state: Optional[str] = None
    #: Postal code of the location.
    #: example: 95035
    postal_code: Optional[str] = None
    #: ISO-3166 2-Letter country code of the location.
    #: example: US
    country: Optional[str] = None


class PostLocationCallingRequest(ApiModel):
    #: A unique identifier for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzljYTNhZmQ3LTE5MjYtNGQ0ZS05ZDA3LTk5ZDJjMGU4OGFhMA
    id: Optional[str] = None
    #: The name of the location.
    #: example: 'Denver'
    name: Optional[str] = None
    #: Time zone associated with this location.
    #: example: 'America/Chicago'
    time_zone: Optional[str] = None
    #: Default email language.
    #: example: 'en_us'
    preferred_language: Optional[str] = None
    #: Location's phone announcement language.
    #: example: 'fr_fr'
    announcement_language: Optional[str] = None
    #: The address of the location.
    address: Optional[PostLocationCallingRequestAddress] = None


class PostValidateExtensionResponseStatus(str, Enum):
    #: Validated succesfully.
    ok = 'OK'
    #: Validated with errors.
    errors = 'ERRORS'


class ExtentionStatusObject(ApiModel):
    #: Indicates the extention ID for the status.
    #: example: 1234
    extension: Optional[datetime] = None
    #: Indicates the status for the given extention ID.
    #: example: VALID
    state: Optional[ExtensionStatusObjectState] = None
    #: Error Code.
    #: example: 59475.0
    error_code: Optional[int] = None
    #: example: The extension is not available. It is already assigned to a virtual extension
    message: Optional[str] = None


class PostValidateExtensionResponse(ApiModel):
    #: Either `OK` or `ERRORS`.
    status: Optional[PostValidateExtensionResponseStatus] = None
    extension_status: Optional[list[ExtentionStatusObject]] = None


class PutLocationCallBackNumberObject(ApiModel):
    #: Selected number type to configure emergency call back.
    #: example: LOCATION_MEMBER_NUMBER
    selected: Optional[CallBackSelected] = None
    #: Member ID of user/place within the location. Required if `LOCATION_MEMBER_NUMBER` is selected.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9hOTc0MzVjZi0zYTZmLTRmNGYtOWU1OC00OTI2OTQ5MDkwMWY
    location_member_id: Optional[str] = None


class PutTelephonyLocationObject(ApiModel):
    #: Location's phone announcement language.
    #: example: 'fr_fr'
    announcement_language: Optional[str] = None
    #: Location calling line information.
    calling_line_id: Optional[GetTelephonyLocationObjectCallingLineId] = None
    #: Connection details can only be modified to and from local PSTN types of `TRUNK` and `ROUTE_GROUP`.
    connection: Optional[GetTelephonyLocationObjectConnection] = None
    #: Denve' (string) - External Caller ID Name value. Unicode characters.
    #: example: 'Big Corp
    external_caller_id_name: Optional[str] = None
    #: Location Identifier.
    #: example: 'Rcdn'
    p_access_network_info: Optional[str] = None
    #: Must dial to reach an outside line. Default is None.
    #: example: '12'
    outside_dial_digit: Optional[datetime] = None
    #: Must dial a prefix when calling between locations having same extension within same location; should be numeric.
    #: example: 2.0
    routing_prefix: Optional[int] = None
    #: Chargeable number for the line placing the call. When this is set, all calls placed from this location will
    #: include a P-Charge-Info header with the selected number in the SIP INVITE.
    #: example: '+14158952369'
    charge_number: Optional[str] = None


class RouteIdentity(ApiModel):
    #: ID of the route type.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQLzA1OWEyNzNlLWJiYjAtMTFlYy04NDIyLTAyNDJhYzEyMDAwMg
    id: Optional[str] = None
    #: A unique name for the route identity.
    #: example: route_identity_name
    name: Optional[str] = None
    #: Type associated with the identity.
    #: example: ROUTE_GROUP
    type: Optional[RouteType] = None


class StatusOfExtensionsObject(ApiModel):
    #: Status of the validated array of extensions
    #: example: OK
    status: Optional[PostValidateExtensionResponseStatus] = None
    #: Array of extensions statuses.
    extension_status: Optional[list[ExtensionStatusObject]] = None


class ListLocationsWebexCallingDetailsResponse(ApiModel):
    #: Array of locations.
    locations: Optional[list[ListLocationObject]] = None


class ReadTheListOfDialPatternsResponse(ApiModel):
    #: Array of dial patterns. An enterprise dial pattern is represented by a sequence of digits (1-9), followed by
    #: optional wildcard characters.
    dial_patterns: Optional[list[str]] = None


class ReadTheListOfRoutingChoicesResponse(ApiModel):
    #: Array of route identities.
    route_identities: Optional[list[RouteIdentity]] = None


class NumberObjectOwner(ApiModel):
    #: ID of the owner to which PSTN Phone number is assigned.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    id: Optional[str] = None
    #: Type of the PSTN phone number's owner
    #: example: PEOPLE
    type: Optional[str] = None
    #: First name of the PSTN phone number's owner
    #: example: Mark
    first_name: Optional[str] = None
    #: Last name of the PSTN phone number's owner
    #: example: Zand
    last_name: Optional[str] = None


class NumberObject(ApiModel):
    #: A unique identifier for the PSTN phone number.
    #: example: +12056350001
    phone_number: Optional[str] = None
    #: Extension for a PSTN phone number.
    #: example: 000
    extension: Optional[str] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 1234000
    esn: Optional[str] = None
    #: Phone number's state.
    #: example: ACTIVE
    state: Optional[str] = None
    #: Type of phone number.
    #: example: PRIMARY
    phone_number_type: Optional[str] = None
    #: Indicates if the phone number is used as location clid.
    #: example: True
    main_number: Optional[bool] = None
    #: Indicates if a phone number is a toll free number.
    #: example: True
    toll_free_number: Optional[bool] = None
    location: Optional[Location] = None
    owner: Optional[NumberObjectOwner] = None


class NumberListGetObject(ApiModel):
    #: Array of phone numbers.
    phone_numbers: Optional[list[NumberObject]] = None


class GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType(str, Enum):
    people = 'PEOPLE'
    place = 'PLACE'
    auto_attendant = 'AUTO_ATTENDANT'
    call_queue = 'CALL_QUEUE'
    group_paging = 'GROUP_PAGING'
    hunt_group = 'HUNT_GROUP'
    voice_messaging = 'VOICE_MESSAGING'
    broadworks_anywhere = 'BROADWORKS_ANYWHERE'
    contact_center_link = 'CONTACT_CENTER_LINK'
    route_list = 'ROUTE_LIST'
    voicemail_group = 'VOICEMAIL_GROUP'


class TelephonyType(str, Enum):
    #: Object is a PSTN number.
    pstn_number = 'PSTN_NUMBER'
    #: Object is a mobile number.
    mobile_number = 'MOBILE_NUMBER'


class NumberObject1(ApiModel):
    #: A unique identifier for the PSTN phone number.
    #: example: +12056350001
    phone_number: Optional[str] = None
    #: Extension for a PSTN phone number.
    #: example: 000
    extension: Optional[str] = None
    #: Phone number's state.
    #: example: ACTIVE
    state: Optional[str] = None
    #: Type of phone number.
    #: example: PRIMARY
    phone_number_type: Optional[str] = None
    #: Indicates if the phone number is used as location clid.
    #: example: True
    main_number: Optional[bool] = None
    #: Indicates if a phone number is a toll free number.
    #: example: True
    toll_free_number: Optional[bool] = None
    #: Indicates Telephony type for the number.
    #: example: MOBILE_NUMBER
    included_telephony_types: Optional[TelephonyType] = None
    #: Mobile Network for the number if number is MOBILE_NUMBER.
    #: example: mobileNetwork
    mobile_network: Optional[str] = None
    #: Routing Profile for the number if number is MOBILE_NUMBER.
    #: example: AttRtPf
    routing_profile: Optional[str] = None
    location: Optional[Location] = None
    owner: Optional[NumberObjectOwner] = None


class NumberCount(ApiModel):
    #: Count of phone numbers that are in the assigned state.
    #: example: 33.0
    assigned: Optional[int] = None
    #: Count of phone numbers which are in the un-assigned state.
    #: example: 114.0
    un_assigned: Optional[int] = None
    #: Count of phone numbers which are inactive.
    #: example: 12.0
    in_active: Optional[int] = None
    #: Count of extensions only without phone number.
    #: example: 692.0
    extension_only: Optional[int] = None
    #: Count of the toll free numbers.
    #: example: 1.0
    toll_free_numbers: Optional[int] = None
    #: Total phone numbers and extensions available.
    #: example: 839.0
    total: Optional[int] = None
    #: Count of phone numbers of type `MOBILE_NUMBER` only without `PSTN_NUMBER` and extension.
    #: example: 6.0
    mobile_number: Optional[int] = None


class NumberListGetObject1(ApiModel):
    #: Array of phone numbers.
    phone_numbers: Optional[list[NumberObject1]] = None
    #: Count of phone numbers categorized by type or their states, such as assigned or unassigned.
    count: Optional[NumberCount] = None


class NumberTypeOptions(str, Enum):
    #: Indicates a toll-free PSTN number.
    tollfree = 'TOLLFREE'
    #: Indicates a normal Direct Inward Dial (DID) PSTN number.
    did = 'DID'


class NumberStateOptions(str, Enum):
    #: Indicates number is activated and has calling capability.
    active = 'ACTIVE'
    #: Indicates a number is not yet activated and has no calling capability.
    inactive = 'INACTIVE'


class NumbersPost(ApiModel):
    #: List of phone numbers needed to be added.
    phone_numbers: Optional[list[str]] = None
    #: Type of the number.
    #: example: TOLLFREE
    number_type: Optional[NumberTypeOptions] = None
    #: Reflects the state of the number. By default the state of a number is `ACTIVE`.
    #: example: INACTIVE
    state: Optional[NumberStateOptions] = None


class NumbersRequest(ApiModel):
    #: List of phone numbers needed to be added.
    phone_numbers: Optional[list[str]] = None


class CallBridgeInfo(ApiModel):
    #: Indicates that a stutter dial tone will be played to all the participants when a person is bridged on the active
    #: shared line call.
    warning_tone_enabled: Optional[bool] = None


class CallRecordingInfoRecord(str, Enum):
    #: Incoming and outgoing calls will be recorded with no control to start, stop, pause, or resume.
    always = 'Always'
    #: Calls will not be recorded.
    never = 'Never'
    #: Calls are always recorded, but user can pause or resume the recording. Stop recording is not supported.
    always_with_pause_resume = 'Always with Pause/Resume'
    #: Records only the portion of the call after the recording start (`*44`) has been entered. Pause, resume, and stop
    #: controls are supported.
    on_demand_with_user_initiated_start = 'On Demand with User Initiated Start'


class CallRecordingInfoNotificationType(str, Enum):
    #: No notification sound played when call recording is paused or resumed.
    none_ = 'None'
    #: A beep sound is played when call recording is paused or resumed.
    beep = 'Beep'
    #: A verbal announcement is played when call recording is paused or resumed.
    play_announcement = 'Play Announcement'


class CallRecordingInfoNotification(ApiModel):
    #: Type of pause/resume notification.
    #: example: None
    type: Optional[CallRecordingInfoNotificationType] = None
    #: `true` when the notification feature is in effect. `false` indicates notification is disabled.
    enabled: Optional[bool] = None


class CallRecordingInfoRepeat(ApiModel):
    #: Interval at which warning tone "beep" will be played. This interval is an integer from 10 to 1800 seconds
    #: example: 15.0
    interval: Optional[int] = None
    #: `true` when ongoing call recording tone will be played at the designated interval. `false` indicates no warning
    #: tone will be played.
    enabled: Optional[bool] = None


class CallRecordingInfoStartStopAnnouncement(ApiModel):
    #: When `true`, an announcement is played when call recording starts and an announcement is played when call
    #: recording ends for internal calls.
    internal_calls_enabled: Optional[bool] = None
    #: When `true`, an announcement is played when call recording starts and an announcement is played when call
    #: recording ends for PSTN calls.
    pstn_calls_enabled: Optional[bool] = None


class CallRecordingInfo(ApiModel):
    #: `true` if call recording is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Call recording scenario.
    #: example: Never
    record: Optional[CallRecordingInfoRecord] = None
    #: When `true`, voicemail messages are also recorded.
    record_voicemail_enabled: Optional[bool] = None
    #: When enabled, an announcement is played when call recording starts and an announcement is played when call
    #: recording ends.
    start_stop_announcement_enabled: Optional[bool] = None
    #: Pause/resume notification settings.
    notification: Optional[CallRecordingInfoNotification] = None
    #: Beep sound plays periodically.
    repeat: Optional[CallRecordingInfoRepeat] = None
    #: Name of the service provider providing call recording service.
    #: example: WSWYZ25455
    service_provider: Optional[str] = None
    #: Group utilized by the service provider providing call recording service.
    #: example: WSWYZ25455L31161
    external_group: Optional[str] = None
    #: Unique person identifier utilized by the service provider providing call recording service.
    #: example: a34iidrh5o@64941297.int10.bcld.webex.com
    external_identifier: Optional[str] = None
    #: Call Recording starts and stops announcement settings.
    start_stop_announcement: Optional[CallRecordingInfoStartStopAnnouncement] = None


class CallRecordingPut(ApiModel):
    #: `true` if call recording is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Call recording scenario.
    #: example: Never
    record: Optional[CallRecordingInfoRecord] = None
    #: When `true`, voicemail messages are also recorded.
    record_voicemail_enabled: Optional[bool] = None
    #: When enabled, an announcement is played when call recording starts and an announcement is played when call
    #: recording ends.
    start_stop_announcement_enabled: Optional[bool] = None
    #: Pause/resume notification settings.
    notification: Optional[CallRecordingInfoNotification] = None
    #: Beep sound plays periodically.
    repeat: Optional[CallRecordingInfoRepeat] = None
    #: Call Recording starts and stops announcement settings.
    start_stop_announcement: Optional[CallRecordingInfoStartStopAnnouncement] = None


class GetPersonOrWorkspaceDetailsObject(ApiModel):
    #: Specifies the department information.
    department: Optional[Location] = None


class PutPersonOrWorkspaceDetailsObject(ApiModel):
    #: Specifies the department information.
    department: Optional[DepartmentResponseWithId] = None


class CallQueueObject(ApiModel):
    #: Indicates the Call Queue's unique identifier.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUVVFVUUvMjE3ZDU3YmEtOTMxYi00ZjczLTk1Y2EtOGY3MWFhYzc4MTE5
    id: Optional[str] = None
    #: Indicates the Call Queue's name.
    #: example: SalesQueue
    name: Optional[str] = None
    #: When not null, indicates the Call Queue's phone number.
    #: example: 4255558100
    phone_number: Optional[str] = None
    #: When not null, indicates the Call Queue's extension number.
    #: example: 8100
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12348100
    esn: Optional[str] = None


class AgentAvaliableCallQueueIdList(ApiModel):
    #: Indicates a list of Call Queues that the agent belongs and are available to be selected as the Caller ID for
    #: outgoing calls. It is empty when the agent's Call Queues have disabled the Call Queue outgoing phone number
    #: setting to be used as Caller ID. In the case where this setting is enabled the array will be populated.
    available_queues: Optional[list[CallQueueObject]] = None


class AgentCallQueueId(ApiModel):
    #: When true, indicates that this agent is using the `selectedQueue` for its Caller ID. When false, indicates that
    #: it is using the agent's configured Caller ID.
    #: example: True
    queue_caller_id_enabled: Optional[bool] = None
    #: Indicates agent's choice of using this queue's Caller ID for outgoing calls. It is empty object when
    #: `queueCallerIdEnabled` is false. When `queueCallerIdEnabled` is true this data must be populated.
    selected_queue: Optional[CallQueueObject] = None


class AvailableSharedLineMemberItem(ApiModel):
    #: A unique member identifier.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85ODhiYTQyOC0zMjMyLTRmNjItYjUyNS1iZDUzZmI4Nzc0MWE
    id: Optional[str] = None
    #: First name of member.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of member.
    #: example: Doe
    last_name: Optional[str] = None
    #: Phone number of member. Currently, E.164 format is not supported.
    #: example: 1234567890
    phone_number: Optional[str] = None
    #: Phone extension of member.
    #: example: 0000
    extension: Optional[str] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12340000
    esn: Optional[str] = None
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    #: example: SHARED_CALL_APPEARANCE
    line_type: Optional[LineType] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class AvailableSharedLineMemberList(ApiModel):
    members: Optional[list[AvailableSharedLineMemberItem]] = None


class GetSharedLineMemberItem(ApiModel):
    #: Unique identifier for the member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85ODhiYTQyOC0zMjMyLTRmNjItYjUyNS1iZDUzZmI4Nzc0MWE
    id: Optional[str] = None
    #: First name of person or workspace.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of person or workspace.
    #: example: Doe
    last_name: Optional[str] = None
    #: Phone number of a person or workspace. Currently, E.164 format is not supported. This will be supported in the
    #: future update.
    #: example: 2056852221
    phone_number: Optional[str] = None
    #: Phone extension of a person or workspace.
    #: example: 1111
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341111
    esn: Optional[datetime] = None
    #: Device port number assigned to a person or workspace.
    #: example: 1.0
    port: Optional[int] = None
    #: T.38 Fax Compression setting. Valid only for ATA Devices. Overrides user level compression options.
    #: example: True
    t38_fax_compression_enabled: Optional[bool] = None
    #: If `true` the person or the workspace is the owner of the device. Points to primary line/port of the device.
    #: example: true
    primary_owner: Optional[str] = None
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    #: example: SHARED_CALL_APPEARANCE
    line_type: Optional[LineType] = None
    #: Number of lines that have been configured for the person on the device.
    #: example: 1.0
    line_weight: Optional[int] = None
    #: Registration home IP for the line port.
    #: example: 198.168.0.1
    host_ip: Optional[str] = Field(alias='hostIP', default=None)
    #: Registration remote IP for the line port.
    #: example: 198.168.0.2
    remote_ip: Optional[str] = Field(alias='remoteIP', default=None)
    #: Configure this line to automatically call a predefined number whenever taken off-hook. Once enabled, the line
    #: can only make calls to the predefined number set in hotlineDestination.
    #: example: True
    hotline_enabled: Optional[bool] = None
    #: Preconfigured number for the hotline. Required only if `hotlineEnabled` is set to `true`.
    #: example: 1234
    hotline_destination: Optional[datetime] = None
    #: Set how a device behaves when a call is declined. When set to `true`, a call decline request is extended to all
    #: the endpoints on the device. When set to `false`, a call decline request is only declined at the current
    #: endpoint.
    #: example: True
    allow_call_decline_enabled: Optional[bool] = None
    #: Device line label.
    #: example: share line label
    line_label: Optional[str] = None
    #: Indicates if the member is of type `PEOPLE` or `PLACE`.
    member_type: Optional[MemberType1] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class GetSharedLineMemberList(ApiModel):
    #: Model name of device.
    #: example: Business Communicator - PC
    model: Optional[str] = None
    #: List of members.
    members: Optional[list[GetSharedLineMemberItem]] = None
    #: Maximum number of device ports.
    #: example: 10.0
    max_line_count: Optional[int] = None


class GetMonitoredElementsObjectMember(ApiModel):
    #: The identifier of the monitored person.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85OWNlZjRmYS03YTM5LTQ1ZDItOTNmNi1jNjA5YTRiMjgzODY
    id: Optional[str] = None
    #: The last name of the monitored person, place or virtual line.
    #: example: Nelson
    last_name: Optional[str] = None
    #: The first name of the monitored person, place or virtual line.
    #: example: John
    first_name: Optional[str] = None
    #: The display name of the monitored person, place or virtual line.
    #: example: John Nelson
    display_name: Optional[str] = None
    #: Indicates whether the type is `PEOPLE`, `PLACE` or `VIRTUAL_LINE`.
    type: Optional[MemberType] = None
    #: The email address of the monitored person, place or virtual line.
    #: example: john.nelson@gmail.com
    email: Optional[str] = None
    #: The list of phone numbers of the monitored person, place or virtual line.
    numbers: Optional[list[GetUserNumberItemObject]] = None
    #: The location name where the call park extension is.
    #: example: Dallas
    location: Optional[str] = None
    #: The ID for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzZhZjk4ZGViLWVlZGItNGFmYi1hMDAzLTEzNzgyYjdjODAxYw
    location_id: Optional[str] = None


class GetMonitoredElementsObjectCallparkextension(ApiModel):
    #: The identifier of the call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSS19FWFRFTlNJT04vZTdlZDdiMDEtN2E4Ni00NDEwLWFlODMtOWJmODMzZGEzNzQy
    id: Optional[str] = None
    #: The name used to describe the call park extension.
    #: example: Dallas-Test
    name: Optional[str] = None
    #: The extension number for the call park extension.
    #: example: 4001
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12344001
    esn: Optional[str] = None
    #: The location name where the call park extension is.
    #: example: Dallas
    location: Optional[str] = None
    #: The ID for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzZhZjk4ZGViLWVlZGItNGFmYi1hMDAzLTEzNzgyYjdjODAxYw
    location_id: Optional[str] = None


class GetMonitoredElementsObject(ApiModel):
    member: Optional[GetMonitoredElementsObjectMember] = None
    callparkextension: Optional[GetMonitoredElementsObjectCallparkextension] = None


class GetNumbersPhoneNumbers(ApiModel):
    #: Flag to indicate if the number is primary or not.
    #: example: True
    primary: Optional[bool] = None
    #: Phone number.
    #: example: 2143456789
    direct_number: Optional[str] = None
    #: Extension.
    #: example: 1234
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12341234
    esn: Optional[str] = None
    #: Optional ring pattern. Applicable only for alternate numbers.
    #: example: NORMAL
    ring_pattern: Optional[RingPatternObject] = None


class GetNumbers(ApiModel):
    #: Enable/disable a distinctive ring pattern that identifies calls coming from a specific phone number.
    #: example: True
    distinctive_ring_enabled: Optional[bool] = None
    #: Information about the number.
    phone_numbers: Optional[list[GetNumbersPhoneNumbers]] = None


class MonitoringSettings(ApiModel):
    #: Call park notification is enabled or disabled.
    #: example: True
    call_park_notification_enabled: Optional[bool] = None
    #: Settings of monitored elements which can be person, place, virtual line or call park extension.
    monitored_elements: Optional[list[GetMonitoredElementsObject]] = None


class PrivacyGet(ApiModel):
    #: When `true` auto attendant extension dialing will be enabled.
    #: example: True
    aa_extension_dialing_enabled: Optional[bool] = None
    #: When `true` auto attendant dailing by first or last name will be enabled.
    #: example: True
    aa_naming_dialing_enabled: Optional[bool] = None
    #: When `true` phone status directory privacy will be enabled.
    #: example: True
    enable_phone_status_directory_privacy: Optional[bool] = None
    #: List of people that are being monitored.
    monitoring_agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject]] = None


class PushToTalkAccessType(str, Enum):
    #: List of people that are allowed to use the Push-to-Talk feature to interact with the person being configured.
    allow_members = 'ALLOW_MEMBERS'
    #: List of people that are disallowed to interact using the Push-to-Talk feature with the person being configured.
    block_members = 'BLOCK_MEMBERS'


class PushToTalkConnectionType(str, Enum):
    #: Push-to-Talk initiators can chat with this person but only in one direction. The person you enable Push-to-Talk
    #: for cannot respond.
    one_way = 'ONE_WAY'
    #: Push-to-Talk initiators can chat with this person in a two-way conversation. The person you enable Push-to-Talk
    #: for can respond.
    two_way = 'TWO_WAY'


class PushToTalkInfo(ApiModel):
    #: Set to `true` to enable the Push-to-Talk feature.  When enabled, a person receives a Push-to-Talk call and
    #: answers the call automatically.
    #: example: True
    allow_auto_answer: Optional[bool] = None
    #: Specifies the connection type to be used.
    connection_type: Optional[PushToTalkConnectionType] = None
    #: Specifies the access type to be applied when evaluating the member list.
    access_type: Optional[PushToTalkAccessType] = None
    #: List of people that are allowed or disallowed to interact using the Push-to-Talk feature.
    members: Optional[list[GetPersonPlaceVirtualLineCallParksObject]] = None


class ReceptionInfo(ApiModel):
    #: Set to `true` to enable the Receptionist Client feature.
    #: example: True
    reception_enabled: Optional[bool] = None
    #: List of people, workspaces or virtual lines to monitor.
    monitored_members: Optional[list[GetPersonPlaceVirtualLineCallParksObject]] = None


class Action(str, Enum):
    #: Add action.
    add = 'ADD'
    #: Delete action.
    delete = 'DELETE'


class AudioAnnouncementFileGetObjectMediaFileType1(str, Enum):
    #: WAV File Extension.
    wav = 'WAV'


class AudioAnnouncementFileGetObject1(ApiModel):
    #: A unique identifier for the announcement.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Audio announcement file name.
    #: example: AUDIO_FILE.wav
    file_name: Optional[str] = None
    #: Audio announcement file type.
    #: example: WAV
    media_file_type: Optional[AudioAnnouncementFileGetObjectMediaFileType1] = None
    #: Audio announcement file location.
    #: example: ORGANIZATION
    level: Optional[AudioAnnouncementFileGetObjectLevel] = None


class GetMusicOnHoldObject1(ApiModel):
    #: Music on hold enabled or disabled for the person.
    #: example: True
    moh_enabled: Optional[bool] = None
    #: Music on hold enabled or disabled for the location. The music on hold setting returned in the response is used
    #: only when music on hold is enabled at the location level. When `mohLocationEnabled` is false and `mohEnabled`
    #: is true, music on hold is disabled for the user. When `mohLocationEnabled` is true and `mohEnabled` is false,
    #: music on hold is turned off for the user. In both cases, music on hold will not be played.
    #: example: True
    moh_location_enabled: Optional[bool] = None
    #: Greeting type for the person.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Announcement Audio File details when greeting is selected to be `CUSTOM`.
    audio_announcement_file: Optional[AudioAnnouncementFileGetObject1] = None


class PutMusicOnHoldObject1(ApiModel):
    #: Music on hold is enabled or disabled for the person.
    #: example: True
    moh_enabled: Optional[bool] = None
    #: Greeting type for the person.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Announcement Audio File details when greeting is selected to be `CUSTOM`.
    audio_announcement_file: Optional[AudioAnnouncementFileGetObject1] = None


class AgentCallerIdType(str, Enum):
    #: The associated member is a call queue.
    call_queue = 'CALL_QUEUE'
    #: The associated member is a hunt group.
    hunt_group = 'HUNT_GROUP'


class AvailableCallerIdObject(ApiModel):
    #: Call queue or hunt group's unique identifier.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUVVFVUUvMjE3ZDU3YmEtOTMxYi00ZjczLTk1Y2EtOGY3MWFhYzc4MTE5
    id: Optional[str] = None
    #: Member is of type `CALL_QUEUE` or `HUNT_GROUP`
    #: example: CALL_QUEUE
    type: Optional[AgentCallerIdType] = None
    #: Call queue or hunt group's name.
    #: example: TestCallQueue
    name: Optional[str] = None
    #: When not null, it is call queue or hunt group's phone number.
    #: example: +441234200090
    phone_number: Optional[str] = None
    #: When not null, it is call queue or hunt group's extension number.
    #: example: 6001
    extension: Optional[datetime] = None


class AvailableCallerIdList(ApiModel):
    #: A list of call queues or hunt groups that the agent belongs to and are available to be selected as the Caller ID
    #: for outgoing calls. It is empty when the agent's call queues or hunt groups have disabled the outgoing phone
    #: number setting to be used as Caller ID.
    available_caller_ids: Optional[list[AvailableCallerIdObject]] = None


class AgentCallerId(ApiModel):
    #: Indicates agent's choice of using this agent's Caller ID for outgoing calls.
    selected_caller_id: Optional[AvailableCallerIdObject] = None


class NumberOwnerType(str, Enum):
    #: PSTN phone number's owner is a workspace.
    place = 'PLACE'
    #: PSTN phone number's owner is a person.
    people = 'PEOPLE'
    #: PSTN phone number's owner is a Virtual Profile.
    virtual_line = 'VIRTUAL_LINE'
    #: PSTN phone number's owner is an auto-attendant.
    auto_attendant = 'AUTO_ATTENDANT'
    #: PSTN phone number's owner is a call queue.
    call_queue = 'CALL_QUEUE'
    #: PSTN phone number's owner is a group paging.
    group_paging = 'GROUP_PAGING'
    #: PSTN phone number's owner is a hunt group.
    hunt_group = 'HUNT_GROUP'
    #: PSTN phone number's owner is a voice messaging.
    voice_messaging = 'VOICE_MESSAGING'
    #: PSTN phone number's owner is a Single Number Reach.
    broadworks_anywhere = 'BROADWORKS_ANYWHERE'
    #: PSTN phone number's owner is a Contact Center link.
    contact_center_link = 'CONTACT_CENTER_LINK'
    #: PSTN phone number's owner is a Contact Center adapter.
    contact_center_adapter = 'CONTACT_CENTER_ADAPTER'
    #: PSTN phone number's owner is a route list.
    route_list = 'ROUTE_LIST'
    #: PSTN phone number's owner is a voice mail group.
    voicemail_group = 'VOICEMAIL_GROUP'
    #: PSTN phone number's owner is a collaborate bridge.
    collaborate_bridge = 'COLLABORATE_BRIDGE'


class NumberObjectOwner2(ApiModel):
    #: Type of the PSTN phone number's owner.
    #: example: PEOPLE
    type: Optional[NumberOwnerType] = None
    #: First name of the PSTN phone number's owner and will only be returned when the owner type is PEOPLE or PLACE or
    #: VIRTUAL_PROFILE.
    #: example: Mark
    first_name: Optional[str] = None
    #: Last name of the PSTN phone number's owner and will only be returned when the owner type is PEOPLE or PLACE or
    #: VIRTUAL_PROFILE.
    #: example: Zand
    last_name: Optional[str] = None
    #: Display name of the PSTN phone number's owner and will only be returned when the owner type is a Feature.
    #: example: Mark Zand
    display_name: Optional[str] = None


class NumberObject2(ApiModel):
    #: A unique identifier for the PSTN phone number.
    #: example: +12056350001
    phone_number: Optional[str] = None
    owner: Optional[NumberObjectOwner2] = None


class ExternalCallerIdNumberListGet(ApiModel):
    #: Array of phone numbers.
    phone_numbers: Optional[list[NumberObject2]] = None


class ListVirtualLineObjectExternalCallerIdNamePolicy(str, Enum):
    #: Shows virtual lines Caller ID name.
    direct_line = 'DIRECT_LINE'
    #: Shows virtual lines location name.
    location = 'LOCATION'
    #: Allow virtual lines first/last name to be configured.
    other = 'OTHER'


class ListVirtualLineObject(ApiModel):
    #: A unique identifier for the virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1ZJUlRVQUxfTElORS9iMTJhNTBiMi01N2NiLTQ0MzktYjc1MS1jZDQ4M2I4MjhmNmU=
    id: Optional[str] = None
    #: Last name for virtual line.
    #: example: Shen
    last_name: Optional[str] = None
    #: First name for virtual line.
    #: example: Tom
    first_name: Optional[str] = None
    #: `callerIdLastName` for virtual line.
    #: example: Shen
    caller_id_last_name: Optional[str] = None
    #: `callerIdFirstName` for virtual line.
    #: example: Tom
    caller_id_first_name: Optional[str] = None
    #: `callerIdNumber` for virtual line.
    #: example: +15558675313
    caller_id_number: Optional[str] = None
    #: `externalCallerIdNamePolicy` for the virtual line.
    #: example: DIRECT_LINE
    external_caller_id_name_policy: Optional[ListVirtualLineObjectExternalCallerIdNamePolicy] = None
    #: `customExternalCallerIdName` for virtual line.
    #: example: Tom
    custom_external_caller_id_name: Optional[str] = None
    #: Calling details of virtual line.
    number: Optional[GetUserNumberItemObject] = None
    #: Location details of virtual line.
    location: Optional[Location] = None
    #: Number of devices assigned to a virtual line.
    #: example: 1.0
    number_of_devices_assigned: Optional[int] = None
    #: Type of billing plan.
    #: example: BCOCP1
    billing_plan: Optional[str] = None


class ReadTheListOfVirtualLinesResponse(ApiModel):
    #: Array of virtual lines.
    virtual_lines: Optional[list[ListVirtualLineObject]] = None


class CallRecordingInfo1(ApiModel):
    #: `true` if call recording is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Call recording scenario.
    #: example: Never
    record: Optional[CallRecordingInfoRecord] = None
    #: When `true`, voicemail messages are also recorded.
    record_voicemail_enabled: Optional[bool] = None
    #: Pause/resume notification settings.
    notification: Optional[CallRecordingInfoNotification] = None
    #: Beep sound plays periodically.
    repeat: Optional[CallRecordingInfoRepeat] = None
    #: Name of the service provider providing call recording service.
    #: example: WSWYZ25455
    service_provider: Optional[str] = None
    #: Group utilized by the service provider providing call recording service.
    #: example: WSWYZ25455L31161
    external_group: Optional[str] = None
    #: Unique person identifier utilized by the service provider providing call recording service.
    #: example: a34iidrh5o@64941297.int10.bcld.webex.com
    external_identifier: Optional[str] = None
    #: Call Recording starts and stops announcement settings.
    start_stop_announcement: Optional[CallRecordingInfoStartStopAnnouncement] = None


class CallRecordingPut1(ApiModel):
    #: `true` if call recording is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Call recording scenario.
    #: example: Never
    record: Optional[CallRecordingInfoRecord] = None
    #: When `true`, voicemail messages are also recorded.
    record_voicemail_enabled: Optional[bool] = None
    #: Pause/resume notification settings.
    notification: Optional[CallRecordingInfoNotification] = None
    #: Beep sound plays periodically.
    repeat: Optional[CallRecordingInfoRepeat] = None
    #: Call Recording starts and stops announcement settings.
    start_stop_announcement: Optional[CallRecordingInfoStartStopAnnouncement] = None


class CatalogResponseAvailability(str, Enum):
    #: The catalog item is in stock and available to order.
    available = 'available'
    #: The catalog item is out of stock and not available to order.
    out_of_stock = 'out_of_stock'


class CatalogResponse(ApiModel):
    #: The catalog item ID.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL0NBVEFMT0dJVEVNLzZmN2QzMTFjLTc1YjEtNGM4Ny04YTMyLTIwODMwNjcyYjE4Yg
    id: Optional[str] = None
    #: The catalog item SKU.
    #: example: CP-8845-k9=
    sku: Optional[str] = None
    #: The distributor ID.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL0RJU1RSSUJVVE9SL2MwNTYzN2U3LWE3MmYtNDcxZS05N2ZhLTVjNDM1MTRkODdkNA
    distributor_id: Optional[str] = None
    #: The catalog item product name.
    #: example: Cisco IP Phone 8845. Charcoal
    product_name: Optional[str] = None
    #: The availability of catalog item.
    #: example: available
    availability: Optional[CatalogResponseAvailability] = None
    #: The catalog item manufacturer name.
    #: example: Cisco
    manufacturer_name: Optional[str] = None


class CatalogListResponse(ApiModel):
    #: An array of Catalog Response objects.
    items: Optional[list[CatalogResponse]] = None


class DistributorDetailsResponseCapabilities(str, Enum):
    #: The distributor has the capability to create orders.
    create_order = 'create_order'
    #: The distributor has the capability to edit orders.
    edit_order = 'edit_order'
    #: The distributor has the capability to cancel orders.
    cancel_order = 'cancel_order'
    #: The distributor has the capability to retrieve orders.
    retrieve_order = 'retrieve_order'


class DistributorDetailsResponse(ApiModel):
    #: The distributor ID.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL0RJU1RSSUJVVE9SL2MwNTYzN2U3LWE3MmYtNDcxZS05N2ZhLTVjNDM1MTRkODdkNA
    id: Optional[str] = None
    #: The distributor name.
    #: example: Globex Corporation
    name: Optional[str] = None
    #: The distributor capabilities for device fulfillment orders.
    #: example: create_order
    capabilities: Optional[DistributorDetailsResponseCapabilities] = None


class DistributorResponse(ApiModel):
    #: The distributor name.
    #: example: Globex Corporation
    name: Optional[str] = None
    #: The distributor details url.
    #: example: https://webexapis.com/v1/wholesale/device/fulfillment/distributors/Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL0RJU1RSSUJVVE9SL2MwNTYzN2U3LWE3MmYtNDcxZS05N2ZhLTVjNDM1MTRkODdkNA
    url: Optional[str] = None


class DistributorListResponse(ApiModel):
    #: An array of Distributor Response objects.
    items: Optional[list[DistributorResponse]] = None


class OrderShippingDetails(ApiModel):
    #: The order recipient.
    #: example: David Forbes
    name: Optional[str] = None
    #: The order recipient's phone number.
    #: example: +1 468 23456789
    phone_number: Optional[str] = None
    #: The order recipient's email address.
    #: example: dforbes@test.com
    email: Optional[str] = None
    #: The order recipient's address line 1.
    #: example: Almond Telecom
    address_line1: Optional[str] = None
    #: The order recipient's address line 2.
    #: example: 45 North Glen Eagles Street
    address_line2: Optional[str] = None
    #: The order recipient's city.
    #: example: Springfield
    city: Optional[str] = None
    #: The order recipient's state.
    #: example: PA
    state: Optional[str] = None
    #: The order recipient's zip code.
    #: example: 19064
    zip_code: Optional[str] = None
    #: The order recipient's country.
    #: example: USA
    country: Optional[str] = None


class Person(ApiModel):
    #: The person ID which the line item is associated with.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wOTA5ODFhOS04Yjc1LTRkY2QtYWU4Zi1lZjQ3NjI3NDI4ZTQ
    id: Optional[str] = None
    #: The person display name for the line item.
    #: example: Dwight Schrute
    display_name: Optional[str] = None


class OrderResponseLineItem(ApiModel):
    #: The order line item number.
    #: example: 1
    line_item_number: Optional[datetime] = None
    #: The line item catalog identifier.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL0NBVEFMT0dJVEVNLzZmN2QzMTFjLTc1YjEtNGM4Ny04YTMyLTIwODMwNjcyYjE4Yg
    catalog_id: Optional[str] = None
    #: The line item device display name.
    #: example: Cisco 8865
    display_name: Optional[str] = None
    #: The line item device SKU.
    #: example: CP-8865-K9=
    sku: Optional[str] = None
    #: The line item status.
    #: example: provisioned
    status: Optional[str] = None
    person: Optional[Person] = None
    workspace: Optional[Person] = None


class OrderResponse(ApiModel):
    #: A unique identifier for the order.
    #: example: '4560123456'
    order_number: Optional[str] = None
    #: The person ID used to place the order.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mZTc3NGJlLTFhNTUtNDM2NS05ODZhLWFiMzAyMThjYzVhYg
    ordered_by: Optional[str] = None
    #: The distributor ID
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL0RJU1RSSUJVVE9SL2MwNTYzN2U3LWE3MmYtNDcxZS05N2ZhLTVjNDM1MTRkODdkNA
    distributor_id: Optional[str] = None
    #: Descriptive name for the order.
    #: example: Almond Telecom Initial Cisco Device Order
    description: Optional[str] = None
    #: Tracking number for delivery, if available.
    tracking_number: Optional[str] = None
    #: A unique identifier for the customer.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The order delivery shipping details.
    shipping_details: Optional[OrderShippingDetails] = None
    #: The aggregated order status.
    #: example: Order Confirmed
    status: Optional[str] = None
    #: The date and time the order was created.
    #: example: 2022-11-15T10:14:44.712Z
    created: Optional[datetime] = None
    #: A list of order line items.
    line_items: Optional[list[OrderResponseLineItem]] = None


class OrderListResponse(ApiModel):
    #: An array of Order Response objects.
    items: Optional[list[OrderResponse]] = None


class OrderRequestLineItem(ApiModel):
    #: The line item catalog identifier.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL0NBVEFMT0dJVEVNLzZmN2QzMTFjLTc1YjEtNGM4Ny04YTMyLTIwODMwNjcyYjE4Yg
    catalog_id: Optional[str] = None
    #: The person ID which the line item is associated with.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wOTA5ODFhOS04Yjc1LTRkY2QtYWU4Zi1lZjQ3NjI3NDI4ZTQ
    person_id: Optional[str] = None
    #: The workspace ID which the line item is associated with.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL1BMQUNFLzg2NDc2MmI4LTVlZGYtNDc0NC04ZWNmLTEyMjQ2OGIzMzFhMA
    workspace_id: Optional[str] = None


class OrderRequest(ApiModel):
    #: Description of the order.
    #: example: Almond Telecom Initial Cisco Device Order
    description: Optional[str] = None
    #: A unique identifier for the customer.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The order delivery shipping details.
    shipping_details: Optional[OrderShippingDetails] = None
    #: A list of order line items.
    line_items: Optional[list[OrderRequestLineItem]] = None


class UserNumberItem(ApiModel):
    #: Phone number of person or workspace. Either `phoneNumber` or `extension` is mandatory.
    #: example: +19075552859
    external: Optional[str] = None
    #: Extension of person or workspace. Either `phoneNumber` or `extension` is mandatory.
    #: example: 8080
    extension: Optional[datetime] = None
    #: Routing prefix of location.
    #: example: 1234
    routing_prefix: Optional[datetime] = None
    #: Routing prefix + extension of a person or workspace.
    #: example: 12348080
    esn: Optional[str] = None
    #: Flag to indicate primary phone.
    #: example: True
    primary: Optional[bool] = None
    #: Flag to indicate toll free number.
    #: example: True
    toll_free_number: Optional[bool] = None


class MonitoredElementUser(ApiModel):
    #: ID of person or workspace.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE2NmE
    id: Optional[str] = None
    #: First name of person or workspace.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of person or workspace.
    #: example: Brown
    last_name: Optional[str] = None
    #: Display name of person or workspace.
    #: example: John Brown
    display_name: Optional[str] = None
    #: Type of the person or workspace.
    #: example: PEOPLE
    type: Optional[MemberType1] = None
    #: Email of the person or workspace.
    #: example: john.brown@gmail.com
    email: Optional[str] = None
    #: List of phone numbers of the person or workspace.
    numbers: Optional[list[UserNumberItem]] = None
    #: Name of location for call park.
    #: example: Alaska
    location: Optional[str] = None
    #: ID of the location for call park.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzEyMzQ1
    location_id: Optional[str] = None


class MonitoredElementItem(ApiModel):
    #: Monitored Call Park extension.
    callparkextension: Optional[GetMonitoredElementsObjectCallparkextension] = None
    #: Monitored member for this workspace.
    member: Optional[MonitoredElementUser] = None


class UserMonitoringGet(ApiModel):
    #: Call park notification enabled or disabled.
    #: example: True
    call_park_notification_enabled: Optional[bool] = None
    #: Monitored element items.
    monitored_elements: Optional[MonitoredElementItem] = None


class ListNumbersAssociatedWithASpecificWorkspaceResponse(ApiModel):
    #: Array of numbers (primary/alternate).
    phone_numbers: Optional[list[GetUserNumberItemObject]] = None
    #: Workspace object having a unique identifier for the Workspace.
    workspace: Optional[DepartmentResponseWithId] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None
    #: Organization object having a unique identifier for the organization and its name.
    organization: Optional[Location] = None


class AuthorizationCode(ApiModel):
    #: Indicates an access code.
    #: example: 4856
    code: Optional[datetime] = None
    #: Indicates the description of the access code.
    #: example: Marketing's access code
    description: Optional[str] = None


class ReportError(ApiModel):
    #: The error code itself.
    #: example: 2024.0
    code: Optional[int] = None
    #: A textual representation of the error code.
    #: example: Billing Report not found.
    description: Optional[str] = None


class ReportStatus(str, Enum):
    #: Report generation is in progress.
    in_progress = 'IN_PROGRESS'
    #: Report generation is complete.
    completed = 'COMPLETED'
    #: Report generation failed.
    failed = 'FAILED'


class Report(ApiModel):
    #: A unique report ID that corresponds to a billing report.
    #: example: 'Y2lzY29zcGFyazovL3VzL0JJTExJTkdfUkVQT1JULzViOGQ1MThhLThmMDAtNDUxYi1hNDA2LWVhZjQ5YjRhN2ZhOA'
    id: Optional[str] = None
    #: The year and month (`YYYY-MM`) for which the billing report was generated.
    #: example: 2021-05
    billing_period: Optional[datetime] = None
    #: The status of the billing report.
    #: example: IN_PROGRESS
    status: Optional[ReportStatus] = None
    #: The date and time the report was generated.
    #: example: 2021-06-16T12:40:33.109Z
    created: Optional[datetime] = None
    #: The person ID of the partner administrator who created the report.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wYWNkMzg3NS00ZTEyLTRkNzctYjk4MS1lMzg5ZmQ4ODQ2YzA
    created_by: Optional[str] = None
    #: The URL for partners to download the billing report.
    #: example: https://billing-reports-int-example.webexcontent.com/a366de9b-3204-4140-8181-25808d360e36/2021/06/16/340177d1-7f25-41e1-a39f-ad63ec1103a5.csv?Expires=1624978489&Signature=Syp3vrVeMx4P6MeMtm8e1bQaeAdHFe-c7NeHERWh5-qJGLZ1T8Dvl2ee-M8OsFf~z6Yepz94e2Hh1HDVailD0Uryl8SgiM~jl0cBh7L0PmSe~i9oFA0eJ0MulkqGSMVf7ZHhxY55xYMgIBZIERkWm3CqQNDg5BS4EaXapKfOnmFegf36OokCM63m5uOK8-csk08IkZhwo2Z0l1JMtuWYEaLh4dgMHoe~xgH3YmDSSCWInFYaEifUAfgi2YAYS6nP9Zq4BTliBq62XBaehOE1gBrhy4RdwD-3WSs2oD-BdpoRpuGzo3FZzDLVEvd0S2D6gTcHljOHodQKxe-u0BXPWQ__&Key-Pair-Id=APKAJADAKLCI2FW2U32Q
    temp_download_url: Optional[str] = Field(alias='tempDownloadURL', default=None)
    #: List of errors that occurred during report generation.
    #: 
    #: **Note:**
    #: 
    #: * Captures errors that occurred during asynchronous or background report generation, after the request has been
    #: accepted and a `202 OK` response is returned.
    errors: Optional[list[ReportError]] = None


class ListReport(ApiModel):
    #: A unique report ID that corresponds to a billing report.
    #: example: 'Y2lzY29zcGFyazovL3VzL0JJTExJTkdfUkVQT1JULzViOGQ1MThhLThmMDAtNDUxYi1hNDA2LWVhZjQ5YjRhN2ZhOA'
    id: Optional[str] = None
    #: The year and month (`YYYY-MM`) for which the billing report was generated.
    #: example: 2021-05
    billing_period: Optional[datetime] = None
    #: The status of the billing report.
    #: example: IN_PROGRESS
    status: Optional[ReportStatus] = None


class BillingReportsListResponse(ApiModel):
    #: An array of reports objects.
    items: Optional[list[ListReport]] = None


class Subscriber1(ApiModel):
    #: A unique Cisco identifier for the subscriber.
    #: example: 'Y2lzY29zcGFyazovL3VzL1NVQlNDUklCRVIvNjk3MGU2YmItNzQzOS00ZmZiLWFkMzQtZDNmZjAxNjdkZGFk'
    id: Optional[str] = None
    #: The Person Id of the subscriber on Webex. To be used when referencing this subscriber on other Webex APIs. Only
    #: presented when status is `provisioned`.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The user ID of the subscriber on BroadWorks.
    #: example: 95547321@sp.com
    user_id: Optional[str] = None
    #: The Service Provider supplied unique identifier for the subscriber's enterprise.
    #: example: Reseller1+acme
    sp_enterprise_id: Optional[str] = None
    #: The first name of the subscriber.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the subscriber.
    #: example: Andersen
    last_name: Optional[str] = None
    #: The email address of the subscriber.
    #: example: john.anderson@acme.com
    email: Optional[str] = None
    #: The primary phone number configured against the subscriber on BroadWorks.
    #: example: +1-240-555-1212
    primary_phone_number: Optional[str] = None
    #: The mobile phone number configured against the subscriber on BroadWorks.
    #: example: +1-818-279-1234
    mobile_phone_number: Optional[str] = None
    #: The extension number configured against the subscriber on BroadWorks.
    #: example: 1212
    extension: Optional[datetime] = None
    #: The Webex for BroadWorks Package assigned to the subscriber.
    #: example: standard
    package: Optional[SubscriberPackage] = None
    #: The provisioning status of the user.
    #: example: provisioned
    status: Optional[SubscriberStatus] = None
    #: List of errors that occurred during that last attempt to provision/update this subscriber.
    #: 
    #: *Note:*
    #: 
    #: + This list captures errors that occurred during *asynchronous or background* provisioning of the subscriber,
    #: *after* the API has been accepted and 200 OK response returned.
    #: 
    #: + Any errors that occur during initial API request validation will be captured directly in error response with
    #: appropriate HTTP status code.
    errors: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None
    #: The date and time the subscriber was provisioned.
    #: example: 2019-10-18T14:26:16.000Z
    created: Optional[datetime] = None
    #: The date and time the provisioning status of the subscriber last changed.
    #: example: 2020-03-18T16:05:34.000Z
    last_status_change: Optional[datetime] = None
    #: This Provisioning ID associated with this subscriber.
    #: example: ZjViMzYxODctYzhkZC00NzI3LThiMmYtZjljNDQ3ZjI5MDQ2OjQyODVmNTk0LTViNTEtNDdiZS05Mzk2LTZjMzZlMmFkODNhNQ
    provisioning_id: Optional[str] = None
    #: Indicates if the subscriber was self activated, rather than provisioned via these APIs.
    self_activated: Optional[bool] = None


class SubscriberListResponse1(ApiModel):
    #: An array of Subscriber objects.
    items: Optional[list[Subscriber1]] = None


class SubscriberProvisioningPrecheckResponseInfo(ApiModel):
    #: Provisioning Precheck `infoCode`.
    #: example: 100.0
    info_code: Optional[int] = None
    #: A textual description of the `infoCode`.
    #: example: Provisioning Precheck validation successful.
    description: Optional[str] = None


class SubscriberProvisioningPrecheckResponse(ApiModel):
    #: A textual representation of the Precheck response message containing the `infoCode` object in the case of a
    #: success response and the `errorCode` object in the case of failure.
    #: example: success
    message: Optional[str] = None
    #: A list of `ProvisioningPreCheckResponseInfo` objects.
    info: Optional[SubscriberProvisioningPrecheckResponseInfo] = None


class PrecheckABroadworksSubscriberProvisioningCustomerInfo(ApiModel):
    #: Email address of the customer org user to be provisioned.
    #: example: "john.anderson@example.com"
    primary_email: Optional[str] = None


class WorkspaceResponse(ApiModel):
    #: Provisioning ID that defines how this workspace is to be provisioned for Cisco Webex Services. Each Customer
    #: Template will have their own unique Provisioning ID. This ID will be displayed under the chosen Customer
    #: Template on Cisco Webex Control Hub.
    #: example: ZjViMzYxODctYzhkZC00NzI3LThiMmYtZjljNDQ3ZjI5MDQ2OjQyODVmNTk0LTViNTEtNDdiZS05Mzk2LTZjMzZlMmFkODNhNQ
    provisioning_id: Optional[str] = None
    #: The user ID of the workspace on BroadWorks.
    #: example: 95547321@sp.com
    user_id: Optional[str] = None
    #: The Service Provider supplied unique identifier for the workspace's enterprise.
    #: example: Reseller1+acme
    sp_enterprise_id: Optional[str] = None
    #: The display name of the workspace.
    #: example: Conference Room
    display_name: Optional[str] = None
    #: The primary phone number configured against the workspace on BroadWorks.
    #: example: +1-240-555-1212
    primary_phone_number: Optional[str] = None
    #: The extension number configured against the workspace on BroadWorks.
    #: example: 51212
    extension: Optional[str] = None
    #: A unique Cisco identifier for the workspace.
    #: example: Y2lzY29zcGFyazovL3VzL1BMQUNFL2RkMjJlZGZlLTlmZWYtNDdmOS05ODFkLWYxYjA3MWFmMDcwYw
    id: Optional[str] = None
    #: The date and time the workspace was provisioned.
    #: example: 2019-10-18T14:26:16.000Z
    created: Optional[datetime] = None


class CallMembershipStatus(str, Enum):
    notified = 'notified'
    joined = 'joined'
    declined = 'declined'
    left = 'left'
    waiting = 'waiting'


class CallMembershipAudio(str, Enum):
    on = 'on'
    off = 'off'


class CallMembership(ApiModel):
    #: A unique identifier for the call membership.
    #: example: Y2lzY29zcGFyazovL3VzL01FTUJFUlNISVAvMGQwYzkxYjYtY2U2MC00NzI1LWI2ZDAtMzQ1NWQ1ZDExZWYzOmNkZTFkZDQwLTJmMGQtMTFlNS1iYTljLTdiNjU1NmQyMjA3Yg
    id: Optional[str] = None
    #: The status of the call membership.
    #: example: joined
    status: Optional[CallMembershipStatus] = None
    #: The call ID.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExTLzU0MUFFMzBFLUUyQzUtNERENi04NTM4LTgzOTRDODYzM0I3MQo
    call_id: Optional[str] = None
    #: Whether or not the person referenced by this membership hosted the call.
    #: example: True
    is_host: Optional[bool] = None
    #: The fully qualified SIP address of the participant, if not a known Webex user.
    #: example: sip:john.andersen@example.com
    sip_url: Optional[str] = None
    #: The E.164 PSTN address of the participant, if not a known Webex user.
    #: example: +14155551212
    phone_number: Optional[str] = None
    #: The room ID of the call.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: List of device IDs associated to the participant.
    #: example: ['22ecb593-8408-4fe5-81bb-0d92d568f93f', '2345aea8-7a8b-4861-982a-26c792e21c17']
    device_ids: Optional[list[str]] = None
    #: Whether or not the participant is in the same organization.
    is_guest: Optional[bool] = None
    #: The organization ID of the participant if they are a guest.
    #: example: ``
    org_id: Optional[str] = None
    #: The total amount of time, in seconds, that the membership was in a "joined" state.
    #: example: 180.0
    joined_duration: Optional[int] = None
    #: The current status of the audio stream.
    #: example: on
    audio: Optional[CallMembershipAudio] = None
    #: The current status of the video stream.
    #: example: on
    video: Optional[CallMembershipAudio] = None
    #: The current status of the whiteboard stream.
    #: example: off
    slide: Optional[CallMembershipAudio] = None
    #: The date and time when the call membership was created.
    #: example: 2015-10-18T14:26:16.203Z
    created: Optional[datetime] = None


class CallMembershipCollectionResponse(ApiModel):
    items: Optional[list[CallMembership]] = None


class ListCallMembershipsCallStatus(str, Enum):
    initializing = 'initializing'
    lobby = 'lobby'
    connected = 'connected'
    terminating = 'terminating'
    disconnected = 'disconnected'


class ListCallMembershipsIsHost(str, Enum):
    true = 'true'


class VideoIn(ApiModel):
    #: The sampling interval of the downstream video quality data
    #: example: 60.0
    sampling_interval: Optional[int] = None
    #: The date and time when this video session started.
    #: example: 2016-04-18T17:00:00.000Z
    start_time: Optional[datetime] = None
    #: The date and time when this video session ended.
    #: example: 2016-04-18T17:00:00.000Z
    end_time: Optional[datetime] = None
    #: The percentage of video packet loss, in float between 0.0 and 100.0, during each sampling interval.
    #: example: [0.01, 0.1, 0.05]
    packet_loss: Optional[list[float]] = None
    #: The average latency, in milliseconds, during each sampling interval.
    #: example: [60.0, 5.0, 10.0]
    latency: Optional[list[float]] = None


class AudioInType(str, Enum):
    ip = 'IP'


class AudioIn(ApiModel):
    #: The type of audio in this media session.
    #: example: IP
    type: Optional[AudioInType] = None
    #: The sampling interval of the downstream audio quality data
    #: example: 60.0
    sampling_interval: Optional[int] = None
    #: The date and time when this audio session started.
    #: example: 2016-04-18T17:00:00.000Z
    start_time: Optional[datetime] = None
    #: The date and time when this audio session ended.
    #: example: 2016-04-18T17:00:00.000Z
    end_time: Optional[datetime] = None
    #: The percentage of audio packet loss, in float between 0.0 and 100.0, during each sampling interval. This applies
    #: to IP type only.
    #: example: [0.02, 0.1, 0.07]
    packet_loss: Optional[list[float]] = None
    #: The average latency, in milliseconds, during each sampling interval. This applies to IP type only.
    #: example: [30.0, 10.0, 5.0]
    latency: Optional[list[float]] = None
    #: The mean opinion score, in float between 0.0 and 5.0, during each sampling interval. This applies to PSTN type
    #: only.
    #: example: [1.2, 3.4, 4.9]
    mean_opinion_score: Optional[list[float]] = None


class MediaSessionQuality(ApiModel):
    #: The back references to the call where this media session belongs.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExTLzU0MUFFMzBFLUUyQzUtNERENi04NTM4LTgzOTRDODYzM0I3MQo
    call_id: Optional[str] = None
    #: The display name of the participant of this media session.
    #: example: John Doe
    display_name: Optional[str] = None
    #: The email address of the participant of this media session.
    #: example: jdoe@acme.com
    email: Optional[str] = None
    #: The date and time when this media session joined to the call.
    #: example: 2016-04-18T17:00:00.000Z
    joined: Optional[datetime] = None
    #: The total amount of time, in milliseconds, it takes for this media session to join the call.
    #: example: 500.0
    joining_time: Optional[int] = None
    #: The total amount of time, in seconds, that this media session has joined the call.
    #: example: 180.0
    joined_duration: Optional[int] = None
    #: The type of the client (and OS) used by this media session.
    #: example: Teams_Mobile_Client (iOS)
    client: Optional[str] = None
    #: The collection of downstream video quality data.
    video_in: Optional[list[VideoIn]] = None
    #: The collection of downstream audio quality data.
    audio_in: Optional[list[AudioIn]] = None


class CallsQualitiesResponse(ApiModel):
    items: Optional[list[MediaSessionQuality]] = None


class CallSourceType(str, Enum):
    #: Indicates that the call source is a route list.
    route_list = 'ROUTE_LIST'
    #: Indicates that the call source is a dial pattern.
    dial_pattern = 'DIAL_PATTERN'
    #: Indicates that the call source extension is unknown.
    unkown_extension = 'UNKOWN_EXTENSION'
    #: Indicates that the call source phone number is unknown.
    unkown_number = 'UNKOWN_NUMBER'


class CallSourceInfo(ApiModel):
    #: The type of call source.
    call_source_type: Optional[CallSourceType] = None
    #: When `originatorType` is `trunk`, `originatorId` is a valid trunk, this trunk belongs to a route group which is
    #: assigned to a route list with the name routeListA and `originatorNumber` is a number assigned to routeListA.
    #: routeListA is returned here. This element is returned when `callSourceType` is `ROUTE_LIST`.
    #: example: routeList1
    route_list_name: Optional[str] = None
    #: Foute list ID.
    #: example: NTJiZmUxNDAtYjIwMS00NTUzLWI1OGQtMmVkNDU1NTFmYTUy
    route_list_id: Optional[str] = None
    #: When `originatorType` is `trunk`, `originatorId` is a valid trunk with name trunkA, trunkA belongs to a route
    #: group which is assigned to a route list with name routeListA,  trunkA is also assigned to dialPlanA as routing
    #: choice, dialPlanA has dialPattern xxxx assigned. If the `originatorNumber` matches the `dialPattern` `xxxx`,
    #: dialPlanA is returned. This element is returned when `callSourceType` is `DIAL_PATTERN`.
    #: example: dialPlan1
    dial_plan_name: Optional[str] = None
    #: When `originatorType` is `trunk`, `originatorId` is a valid trunk with the name trunkA, trunkA belongs to a
    #: route group which is assigned to a route list with the name routeListA,  trunkA is also assigned to dialPlanA
    #: as routing choice, dialPlanA has `dialPattern` `xxxx` assigned. If the `originatorNumber` matches the
    #: `dialPattern` `xxxx`, `dialPattern` `xxxx` is returned. This element is returned when `callSourceType` is
    #: `DIAL_PATTERN`.
    #: example: *888
    dial_pattern: Optional[str] = None
    #: Dial plan ID.
    #: example: Y2lzY29zcGFyazovL3VzL0RJQUxfUExBTi8wNTlhMjczZS1iYmIwLTExZWMtODQyMi0wMjQyYWMxMjAwMDI
    dial_plan_id: Optional[str] = None


class DestinationType(str, Enum):
    #: Matching destination is a person or workspace with details in the `hostedAgent` field.
    hosted_agent = 'HOSTED_AGENT'
    #: Matching destination is a calling feature like auto-attendant or hunt group with details in the `hostedFeature`
    #: field.
    hosted_feature = 'HOSTED_FEATURE'
    #: Matching destination routes into a separate PBX with details in the `pbxUser` field.
    pbx_user = 'PBX_USER'
    #: Matching destination routes into a PSTN phone number with details in the `pstnNumber` field.
    pstn_number = 'PSTN_NUMBER'
    #: Matching destination routes into a virtual extension with details in the `virtualExtension` field.
    virtual_extension = 'VIRTUAL_EXTENSION'
    #: Matching destination routes into a virtual extension range with details in the `virtualExtensionRange` field.
    virtual_extension_range = 'VIRTUAL_EXTENSION_RANGE'
    #: Matching destination routes into a route list with details in the `routeList` field.
    route_list = 'ROUTE_LIST'
    #: Matching destination routes into a feature access code (FAC) with details in the `featureAccessCode` field.
    fac = 'FAC'
    #: Matching destination routes into an emergency service like Red Sky, with details in the `emergency` field.
    emergency = 'EMERGENCY'
    #: The route is in a repair state with routing choice details in the `repair` field.
    repair = 'REPAIR'
    #: Target extension is unknown with routing choice details in the `unknownExtension` field.
    unknown_extension = 'UNKNOWN_EXTENSION'
    #: The target phone number is unknown with routing choice details in the `unknownNumber` field.
    unknown_number = 'UNKNOWN_NUMBER'


class DeviceStatus(str, Enum):
    #: Device is online
    online = 'ONLINE'
    #: Device is offline
    offline = 'OFFLINE'
    #: Unknown. Default
    unknown = 'UNKNOWN'


class DeviceType(ApiModel):
    #: Device type assosiated with trunk configuration.
    #: example: Cisco Unified Border Element
    device_type: Optional[str] = None
    #: Minimum number of concurrent calls. Required for static certificate based trunk.
    #: example: 250.0
    min_concurrent_calls: Optional[int] = None
    #: Maximum number of concurrent calls. Required for static certificate based trunk.
    #: example: 1000.0
    max_concurrent_calls: Optional[int] = None


class DialPattern(ApiModel):
    #: A unique dial pattern.
    #: example: +5555
    dial_pattern: Optional[str] = None
    #: Action to add or delete a pattern.
    action: Optional[Action] = None


class DialPatternPut(ApiModel):
    #: Array of dial patterns to add or delete. Dial Pattern that is not present in the request is not modified.
    dial_patterns: Optional[list[DialPattern]] = None
    #: Delete all the dial patterns for a dial plan.
    #: example: True
    delete_all_dial_patterns: Optional[bool] = None


class DialPatternStatus(str, Enum):
    #: Invalid pattern
    invalid = 'INVALID'
    #: Duplicate pattern
    duplicate = 'DUPLICATE'
    #: Duplicate in input
    duplicate_in_list = 'DUPLICATE_IN_LIST'


class DialPatternValidate(ApiModel):
    #: Input dial pattern that is being validated.
    #: example: +4555
    dial_pattern: Optional[str] = None
    #: Validation status.
    pattern_status: Optional[DialPatternStatus] = None
    #: Failure details.
    #: example: invalid format for premises dial pattern +4555
    message: Optional[str] = None


class DialPatternValidateResult(ApiModel):
    #: Overall validation result status.
    status: Optional[PostValidateExtensionResponseStatus] = None
    #: Patterns validation result.
    dial_pattern_status: Optional[list[DialPatternValidate]] = None


class DialPlan(ApiModel):
    #: Unique identifier for the dial plan.
    #: example: Y2lzY29zcGFyazovL3VzL0RJQUxfUExBTi8wNTlhMjczZS1iYmIwLTExZWMtODQyMi0wMjQyYWMxMjAwMDI
    id: Optional[str] = None
    #: A unique name for the dial plan.
    #: example: dialPlanName
    name: Optional[str] = None
    #: ID of route type associated with the dial plan.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQLzA1OWEyNzNlLWJiYjAtMTFlYy04NDIyLTAyNDJhYzEyMDAwMg
    route_id: Optional[str] = None
    #: Name of route type associated with the dial plan.
    #: example: routeName
    route_name: Optional[str] = None
    #: Route Type associated with the dial plan.
    route_type: Optional[RouteType] = None


class DialPlanGet(ApiModel):
    #: Unique identifier for the dial plan.
    #: example: Y2lzY29zcGFyazovL3VzL0RJQUxfUExBTi8wNTlhMjczZS1iYmIwLTExZWMtODQyMi0wMjQyYWMxMjAwMDI
    id: Optional[str] = None
    #: A unique name for the dial plan.
    #: example: dialPlanName
    name: Optional[str] = None
    #: ID of route type associated with the dial plan.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQLzA1OWEyNzNlLWJiYjAtMTFlYy04NDIyLTAyNDJhYzEyMDAwMg
    route_id: Optional[str] = None
    #: Name of route type associated with the dial plan.
    #: example: routeName
    route_name: Optional[str] = None
    #: Route Type associated with the dial plan.
    route_type: Optional[RouteType] = None
    #: Customer information.
    customer: Optional[Location] = None


class DialPlanPost(ApiModel):
    #: A unique name for the dial plan.
    #: example: dialPlanName
    name: Optional[str] = None
    #: ID of route type associated with the dial plan.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQLzA1OWEyNzNlLWJiYjAtMTFlYy04NDIyLTAyNDJhYzEyMDAwMg
    route_id: Optional[str] = None
    #: Route Type associated with the dial plan.
    route_type: Optional[RouteType] = None
    #: An Array of dial patterns.
    #: example: ['+5555,+5556']
    dial_patterns: Optional[list[str]] = None


class DialPlanPut(ApiModel):
    #: A unique name for the dial plan.
    #: example: dialPlanName
    name: Optional[str] = None
    #: ID of route type associated with the dial plan.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQLzA1OWEyNzNlLWJiYjAtMTFlYy04NDIyLTAyNDJhYzEyMDAwMg
    route_id: Optional[str] = None
    #: Route Type associated with the dial plan.
    route_type: Optional[RouteType] = None


class Emergency(ApiModel):
    #: Indicates if RedSky is in use.
    is_red_sky: Optional[bool] = None
    #: Trunk name.
    #: example: trunkName1
    trunk_name: Optional[str] = None
    #: Trunk id.
    #: example: MDhmYzI3YTAtZWEwYy00MWQxLWJlMjMtNzg0YWQ3MjZmMmM1
    trunk_id: Optional[str] = None
    #: Route group name.
    #: example: routeGroupName1
    route_group_name: Optional[str] = None
    #: Route group ID.
    #: example: YTcwYTUwOGMtZTdhYy00YzU2LWIyM2ItZTAzMjE5ZGJjMzgy
    route_group_id: Optional[str] = None
    #: Location of the trunk; required if `trunkName` is returned.
    #: example: trunkLocationName1
    trunk_location_name: Optional[str] = None
    #: Location ID of the trunk; required if `trunkName` is returned.
    #: example: MjJhZDhiYWUtZTE3NS00YzIxLWFjYTctNWJmYjA2Y2YxZGEw
    trunk_location_id: Optional[str] = None


class FeatureAccessCode(ApiModel):
    #: FAC code.
    #: example: *70
    code: Optional[str] = None
    #: FAC name.
    #: example: Cancel Call Waiting
    name: Optional[str] = None


class HostedAgent(ApiModel):
    #: Person or workspace's ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mMjU4YjhmZi1lODIxLTQ3MDktYTI2My1mMmI4OWZjN2FlYmQ
    id: Optional[str] = None
    #: Type of agent for call destination.
    type: Optional[MemberType1] = None
    #: Person or workspace's first name.
    #: example: firstName
    first_name: Optional[str] = None
    #: Person or workspace's last name.
    #: example: lastName
    last_name: Optional[str] = None
    #: Name of location for a person or workspace.
    #: example: locationName
    location_name: Optional[str] = None
    #: Location ID for a person or workspace.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL1dLQVBRMjQ4NDczTDI0ODQ3NA
    location_id: Optional[str] = None
    #: Person or workspace's phone number.
    #: example: 9874531287
    phone_number: Optional[str] = None
    #: Person or workspace's extension.
    #: example: 111
    extension: Optional[datetime] = None


class ServiceType(str, Enum):
    #: Destination is an auto attendant.
    auto_attendant = 'AUTO_ATTENDANT'
    #: Indicates that this destination is the Office (Broadworks) Anywhere feature.
    broadworks_anywhere = 'BROADWORKS_ANYWHERE'
    #: Indicates that this destination is the Call Center feature.
    call_center = 'CALL_CENTER'
    #: Indicates that this destination is the Contact Center Link feature.
    contact_center_link = 'CONTACT_CENTER_LINK'
    #: Indicates that this destination is the Group Paging feature.
    group_paging = 'GROUP_PAGING'
    #: Indicates that this destination is the Hunt Group feature.
    hunt_group = 'HUNT_GROUP'
    #: Indicates that this destination is the Voice Messaging feature.
    voice_messaging = 'VOICE_MESSAGING'
    #: Indicates that this destination is the Voice Mail Group feature.
    voice_mail_group = 'VOICE_MAIL_GROUP'


class HostedFeature(ApiModel):
    #: Service instance type.
    type: Optional[ServiceType] = None
    #: Service instance name.
    #: example: name1
    name: Optional[str] = None
    #: Service instance ID.
    #: example: Y2lzY29zcGFyazovL3VzL0RJQUxfUExBTi8wNTlhMjczZS1iYmIwLTExZWMtODQyMi0wMjQyYWMxMjAwMDI
    id: Optional[str] = None
    #: Location of the service instance.
    #: example: locationName1
    location_name: Optional[str] = None
    #: Location ID of the service instance.
    #: example: Y2lzY29zcGFyazovL3VzL0RJQUxfUExBTi8wNTlhMjczZS1iYmIwLTExZWMtODQyMi0wMjQyYWMxMjAwMDI
    location_id: Optional[str] = None
    #: User or place's phone number.
    #: example: 9874531287
    phone_number: Optional[str] = None
    #: User or place's extension.
    #: example: 111
    extension: Optional[datetime] = None


class LocalGatewayUsageCount(ApiModel):
    #: The count where the local gateway is used as a PSTN Connection setting.
    #: example: 1.0
    pstn_connection_count: Optional[int] = None
    #: The count where the given local gateway is used as call to extension setting.
    #: example: 1.0
    call_to_extension_count: Optional[int] = None
    #: The count where the given local gateway is used by the dial plan.
    #: example: 1.0
    dial_plan_count: Optional[int] = None
    #: The count where the given local gateway is used by the route group.
    #: example: 1.0
    route_group_count: Optional[int] = None


class LocalGateways(ApiModel):
    #: ID of type local gateway.
    #: example: 'Y2lzY29zcGFyazovL3VzL1RSVU5LLzY1Zjc4YzgxLTcwMTYtNDc0Ny05M2EyLWIxMGVlZjBhMWI1Ng'
    id: Optional[str] = None
    #: Name of the local gateway.
    #: example: 'localGatewayName'
    name: Optional[str] = None
    #: Location ID to which local gateway belongs.
    #: example: 'Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL1dTV1laMjEyODA2TDIxMjgwNw'
    location_id: Optional[str] = None
    #: Prioritizes local gateways based on these numbers; the lowest number gets the highest priority.
    #: example: 1.0
    priority: Optional[int] = None


class NumberStatus(str, Enum):
    invalid = 'INVALID'
    duplicate = 'DUPLICATE'
    duplicate_in_list = 'DUPLICATE_IN_LIST'
    unavailable = 'UNAVAILABLE'


class OriginatorType(str, Enum):
    #: User
    user = 'USER'
    #: Connection between Webex Calling and the premises
    trunk = 'TRUNK'


class PbxUser(ApiModel):
    #: Dial plan name that the called string matches.
    #: example: dialPlan1
    dial_plan_name: Optional[str] = None
    #: Dial plan ID.
    #: example: NTZhMmQzZDktZDVhMC00NWQzLWE3NWYtNjY4NDA4Yzc0OWRk
    dial_plan_id: Optional[str] = None
    #: Dial pattern that the called string matches.
    #: example: 442xxx
    dial_pattern: Optional[str] = None
    #: Trunk name.
    #: example: trunkName1
    trunk_name: Optional[str] = None
    #: Trunk ID.
    #: example: MDhmYzI3YTAtZWEwYy00MWQxLWJlMjMtNzg0YWQ3MjZmMmM1
    trunk_id: Optional[str] = None
    #: Route group name.
    #: example: routeGroupName1
    route_group_name: Optional[str] = None
    #: Route group ID.
    #: example: YTcwYTUwOGMtZTdhYy00YzU2LWIyM2ItZTAzMjE5ZGJjMzgy
    route_group_id: Optional[str] = None
    #: Location of the trunk; required if `trunkName` is returned.
    #: example: trunkLocationName1
    trunk_location_name: Optional[str] = None
    #: Location ID of the trunk; required if `trunkName` is returned.
    #: example: MjJhZDhiYWUtZTE3NS00YzIxLWFjYTctNWJmYjA2Y2YxZGEw
    trunk_location_id: Optional[str] = None


class PstnNumber(ApiModel):
    #: Trunk name.
    #: example: trunkName1
    trunk_name: Optional[str] = None
    #: Trunk ID.
    #: example: MDhmYzI3YTAtZWEwYy00MWQxLWJlMjMtNzg0YWQ3MjZmMmM1
    trunk_id: Optional[str] = None
    #: Route group name.
    #: example: routeGroupName1
    route_group_name: Optional[str] = None
    #: Route group ID.
    #: example: YTcwYTUwOGMtZTdhYy00YzU2LWIyM2ItZTAzMjE5ZGJjMzgy
    route_group_id: Optional[str] = None
    #: Location of the trunk; required if `trunkName` is returned.
    #: example: trunkLocationName1
    trunk_location_name: Optional[str] = None
    #: Location ID of the trunk; required if `trunkName` is returned.
    #: example: MjJhZDhiYWUtZTE3NS00YzIxLWFjYTctNWJmYjA2Y2YxZGEw
    trunk_location_id: Optional[str] = None


class ResponseStatusType(str, Enum):
    #: Error
    error = 'ERROR'
    #: Warning
    warning = 'WARNING'


class ResponseStatus(ApiModel):
    #: Error Code. 25013 for error retrieving the outbound proxy. 25014 for error retrieving the status
    #: example: 25013.0
    code: Optional[int] = None
    #: Status type.
    type: Optional[ResponseStatusType] = None
    #: Error summary in English.
    #: example: CPAPI: Error retrieving outboundproxy.
    summary_english: Optional[str] = None
    #: Error Details.
    #: example: ['OCI-P GroupOutboundProxyGetRequest: [Error 26088] Cloud PBX Console is not configured properly., OCI-P Error code: [Error 26088] Cloud PBX Console is not configured properly.']
    detail: Optional[list[str]] = None
    #: Error Tracking ID.
    #: example: CPAPI_2da34568-1e72-4196-b613-905ce45ec592_0
    tracking_id: Optional[str] = None


class RouteGroup(ApiModel):
    #: Route group ID the Route list is associated with.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQL2ZjN2EzZDU2LTg1OGMtNDVkZC1iZDA1LTE2OWM2NGU1OTRmMQ
    id: Optional[str] = None
    #: Name of the Route group the Route list associated with.
    #: example: Route Group 01
    name: Optional[str] = None
    #: Flag to indicate if the route group is used.
    #: example: True
    in_use: Optional[bool] = None


class RouteGroupGet(ApiModel):
    #: Name of the route group.
    #: example: 'Route Group One'
    name: Optional[str] = None
    #: Organization details.
    organization: Optional[Location] = None
    #: Local Gateways that are part of this Route Group.
    local_gateways: Optional[list[LocalGateways]] = None


class RouteGroupPatch(ApiModel):
    #: A unique name for the Route Group.
    #: example: routeGroupName
    name: Optional[str] = None
    #: Local Gateways that are part of this Route Group.
    local_gateways: Optional[list[LocalGateways]] = None


class RouteGroupUsageRouteListItem(ApiModel):
    #: Route list ID.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0xJU1QvOTljNjJkMGQtNmFhYi00NGQ0LWE0ZTctZjk0MjQ4OWVhMWJj
    id: Optional[str] = None
    #: Route list name.
    #: example: routeListName
    name: Optional[str] = None
    #: Location ID for route list.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2JjNWUwNWFjLTI5ZmEtNGY0NS05MmM1LWUxZTExMDc0OTIwZg
    location_id: Optional[str] = None
    #: Location name for route list.
    #: example: locationName
    location_name: Optional[str] = None


class RouteGroupUsageRouteListGet(ApiModel):
    #: List of route lists for this route group.
    route_lists: Optional[list[RouteGroupUsageRouteListItem]] = None


class RouteList(ApiModel):
    #: Route list ID.
    #: example: ODRkYmVmMjItYTEwNC00YWZhLTg4ODMtY2QzNjhiMTAxOWZl
    id: Optional[str] = None
    #: Route list name.
    #: example: routeListName1
    name: Optional[str] = None
    #: Name of the route group the route list is associated with.
    #: example: routeGroupName1
    route_group_name: Optional[str] = None
    #: ID of the route group the route list is associated with.
    #: example: MjRlNDQwYTUtNzQ5NC00ODg2LWIyNTktMmFiM2I2M2ZiMGY0
    route_group_id: Optional[str] = None
    #: Location name of the route list.
    #: example: locationName1
    location_name: Optional[str] = None
    #: Location ID of the route list.
    #: example: NjY5YmY3ODQtNjMyZS00MTA2LWFmMWItMzYxYWNkY2M1OTFh
    location_id: Optional[str] = None


class RouteListGet(ApiModel):
    #: Route list name.
    #: example: Route List 01
    name: Optional[str] = None
    #: Location associated with the Route List.
    location: Optional[Location] = None
    #: Route group associated with the Route list.
    route_group: Optional[RouteGroup] = None


class RouteListNumberListGet(ApiModel):
    #: Numbers assigned to the Route list.
    numbers: Optional[list[str]] = None


class RouteListNumberPatch(ApiModel):
    #: Number to be deleted/added.
    #: example: +2147891122
    number: Optional[str] = None
    #: Possible value, `ADD` or `DELETE`.
    #: example: DELETE
    action: Optional[Action] = None


class RouteListNumberPatchResponse(ApiModel):
    #: Phone Number whose status is being reported.
    #: example: +2147891122
    phone_number: Optional[str] = None
    #: Status of the number. Possible values are `INVALID`, `DUPLICATE`, `DUPLICATE_IN_LIST`, or `UNAVAILABLE`.
    #: example: DUPLICATE
    number_status: Optional[NumberStatus] = None
    #: Message of the number add status.
    #: example: Invalid Number
    message: Optional[str] = None


class RouteListPatch(ApiModel):
    #: Route List new name.
    #: example: New Route List
    name: Optional[str] = None
    #: New route group ID.
    #: example: NTJiZmUxNDAtYjIwMS00NTUzLWI1OGQtMmVkNDU1NTFmYTUy
    route_group_id: Optional[str] = None


class RouteListPost(ApiModel):
    #: Name of the Route List
    #: example: RouteList01
    name: Optional[str] = None
    #: Location associated with the Route List.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2JjNWUwNWFjLTI5ZmEtNGY0NS05MmM1LWUxZTExMDc0OTIwZg
    location_id: Optional[str] = None
    #: ID of the route group associated with Route List.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQL2ZjN2EzZDU2LTg1OGMtNDVkZC1iZDA1LTE2OWM2NGU1OTRmMQ
    route_group_id: Optional[str] = None


class VirtualExtension(ApiModel):
    #: Virtual extension ID.
    #: example: OTI0NzM1OTQtZGU1Mi00ZjViLTk0YjItN2Y5MzRmY2Y2NDk3
    id: Optional[str] = None
    #: Virtual extension display first name.
    #: example: firstName1
    first_name: Optional[str] = None
    #: Virtual extension display last name.
    #: example: lastName1
    last_name: Optional[str] = None
    #: Virtual extension display name.
    #: example: displayName1
    display_name: Optional[str] = None
    #: Extension that the virtual extension is associated with.
    #: example: 0007
    extension: Optional[datetime] = None
    #: Phone number that the virtual extension is associated with.
    #: example: 8701278963
    phone_number: Optional[str] = None
    #: Location name if the virtual extension is at the location level, empty if it is at customer level.
    #: example: locationName1
    location_name: Optional[str] = None
    #: Location ID if the virtual extension is at the location level, empty if it is at customer level.
    #: example: MWU5ZmEzZmEtYTQ0ZS00MDJhLWExNDItMjJmODQxMjhkOTY4
    location_id: Optional[str] = None
    #: Trunk name.
    #: example: trunkName1
    trunk_name: Optional[str] = None
    #: Trunk ID.
    #: example: MDhmYzI3YTAtZWEwYy00MWQxLWJlMjMtNzg0YWQ3MjZmMmM1
    trunk_id: Optional[str] = None
    #: Route group name.
    #: example: routeGroupName1
    route_group_name: Optional[str] = None
    #: Route group ID.
    #: example: YTcwYTUwOGMtZTdhYy00YzU2LWIyM2ItZTAzMjE5ZGJjMzgy
    route_group_id: Optional[str] = None
    #: Location of the trunk; required if `trunkName` is returned.
    #: example: trunkLocationName1
    trunk_location_name: Optional[str] = None
    #: Location ID of the trunk; required if `trunkName` is returned.
    #: example: MjJhZDhiYWUtZTE3NS00YzIxLWFjYTctNWJmYjA2Y2YxZGEw
    trunk_location_id: Optional[str] = None


class VirtualExtensionRange(ApiModel):
    #: Virtual extension range ID.
    #: example: OTI0NzM1OTQtZGU1Mi00ZjViLTk0YjItN2Y5MzRmY2Y2NDk3
    id: Optional[str] = None
    #: Virtual extension range name.
    #: example: firstName1
    name: Optional[str] = None
    #: Prefix that the virtual extension range is associated with (Note: Standard mode must have leading '+' in prefix;
    #: BCD/Enhanced mode can have any valid prefix).
    #: example: +1214555
    prefix: Optional[str] = None
    #: Pattern associated with the virtual extension range.
    #: example: 2XXX
    pattern: Optional[str] = None
    #: Location name if the virtual extension range is at the location level, empty if it is at customer level.
    #: example: locationName1
    location_name: Optional[str] = None
    #: Location ID if the virtual extension range is at the location level, empty if it is at customer level.
    #: example: MWU5ZmEzZmEtYTQ0ZS00MDJhLWExNDItMjJmODQxMjhkOTY4
    location_id: Optional[str] = None
    #: Trunk name.
    #: example: trunkName1
    trunk_name: Optional[str] = None
    #: Trunk ID.
    #: example: MDhmYzI3YTAtZWEwYy00MWQxLWJlMjMtNzg0YWQ3MjZmMmM1
    trunk_id: Optional[str] = None
    #: Route group name.
    #: example: routeGroupName1
    route_group_name: Optional[str] = None
    #: Route group ID.
    #: example: YTcwYTUwOGMtZTdhYy00YzU2LWIyM2ItZTAzMjE5ZGJjMzgy
    route_group_id: Optional[str] = None
    #: Location of the trunk; required if `trunkName` is returned.
    #: example: trunkLocationName1
    trunk_location_name: Optional[str] = None
    #: Location ID of the trunk; required if `trunkName` is returned.
    #: example: MjJhZDhiYWUtZTE3NS00YzIxLWFjYTctNWJmYjA2Y2YxZGEw
    trunk_location_id: Optional[str] = None


class TestCallRoutingPostResponse(ApiModel):
    #: Only returned when `originatorNumber` is specified in the request.
    call_source_info: Optional[CallSourceInfo] = None
    #: Matching destination type for the call.
    destination_type: Optional[DestinationType] = None
    #: FAC code if `destinationType` is FAC. The routing address will be returned for all other destination types.
    #: example: 007
    routing_address: Optional[datetime] = None
    #: Outside access code.
    #: example: 1234
    outside_access_code: Optional[datetime] = None
    #: `true` if the call would be rejected.
    is_rejected: Optional[bool] = None
    #: Returned when `destinationType` is `HOSTED_AGENT`.
    hosted_agent: Optional[HostedAgent] = None
    #: Returned when `destinationType` is `HOSTED_FEATURE`.
    hosted_feature: Optional[HostedFeature] = None
    #: Returned when `destinationType` is `PBX_USER`.
    pbx_user: Optional[PbxUser] = None
    #: Returned when `destinationType` is `PSTN_NUMBER`.
    pstn_number: Optional[PstnNumber] = None
    #: Returned when `destinationType` is `VIRTUAL_EXTENSION`.
    virtual_extension: Optional[VirtualExtension] = None
    #: Returned when `destinationType` is `VIRTUAL_EXTENSION_RANGE`.
    virtual_extension_range: Optional[VirtualExtensionRange] = None
    #: Returned when `destinationType` is `ROUTE_LIST`.
    route_list: Optional[RouteList] = None
    #: Returned when `destinationType` is `FAC`.
    feature_access_code: Optional[FeatureAccessCode] = None
    #: Returned when `destinationType` is `EMERGENCY`.
    emergency: Optional[Emergency] = None
    #: Returned when `destinationType` is `REPAIR`.
    repair: Optional[PstnNumber] = None
    #: Returned when `destinationType` is `UNKNOWN_EXTENSION`.
    unknown_extension: Optional[PstnNumber] = None
    #: Returned when `destinationType` is `UNKNOWN_NUMBER`.
    unknown_number: Optional[PstnNumber] = None


class TrunkType(str, Enum):
    #: For Cisco CUBE Local Gateway.
    registering = 'REGISTERING'
    #: For Cisco Unified Border Element, Oracle ACME Session Border Controller, AudioCodes Session Border Controller,
    #: Ribbon Session Border Controller.
    certificate_based = 'CERTIFICATE_BASED'


class Trunk(ApiModel):
    #: Unique identifier for the trunk.
    #: example: Y2lzY29zcGFyazovL3VzL0RJQUxfUExBTi8wNTlhMjczZS1iYmIwLTExZWMtODQyMi0wMjQyYWMxMjAwMDI
    id: Optional[str] = None
    #: A unique name for the trunk.
    #: example: trunkName
    name: Optional[str] = None
    #: Location associated with the trunk.
    location: Optional[Location] = None
    #: Trunk in use flag.
    #: example: True
    in_use: Optional[bool] = None
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType] = None


class TrunkFQDNValidatePost(ApiModel):
    #: FQDN or SRV address of the trunk.
    #: example: lgw1.london
    address: Optional[str] = None
    #: Domain name of the trunk.
    #: example: acme.corp
    domain: Optional[str] = None
    #: FQDN port of the trunk.
    #: example: 5000.0
    port: Optional[int] = None


class TrunkGet(ApiModel):
    #: A unique name for the trunk.
    #: example: trunkName
    name: Optional[str] = None
    #: Customer associated with the trunk.
    customer: Optional[Location] = None
    #: Location associated with the trunk.
    location: Optional[Location] = None
    #: Unique Outgoing and Destination trunk group associated with the dial plan.
    #: example: lg1_sias10_cpapi12446_lgu
    otg_dtg_id: Optional[str] = None
    #: The Line/Port identifies a device endpoint in standalone mode or a SIP URI public identity in IMS mode.
    #: example: lg1_sias10_cpapi16004_LGU@64941297.int10.bcld.webex.com
    line_port: Optional[str] = None
    #: Locations using trunk.
    locations_using_trunk: Optional[list[Location]] = None
    #: User ID.
    #: example: lg1_sias10_cpapi12446_LGU@64941297.int10.bcld.webex.com
    pilot_user_id: Optional[str] = None
    #: Contains the body of the HTTP response received following the request to Console API and will not be set if the
    #: response has no body.
    outbound_proxy: Optional[AttachmentAction] = None
    #: User's authentication service information.
    #: example: lg1_sias10_cpapi12446_LGU
    sip_authentication_user_name: Optional[str] = None
    #: Device status.
    status: Optional[DeviceStatus] = None
    #: Error codes.
    #: example: ['errorCodes']
    error_codes: Optional[list[str]] = None
    #: Present partial error/warning status information included when the http response is 206.
    response_status: Optional[ResponseStatus] = None
    #: Determines the behavior of the From and PAI headers on outbound calls.
    #: example: True
    dual_identity_support_enabled: Optional[bool] = None
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType] = None
    #: Device type assosiated with trunk.
    #: example: Cisco Unified Border Element
    device_type: Optional[str] = None
    #: FQDN or SRV address. Required to create a static certificate-based trunk.
    #: example: lgw1.london
    address: Optional[str] = None
    #: Domain name. Required to create a static certificate based trunk.
    #: example: acme.corp
    domain: Optional[str] = None
    #: FQDN port. Required to create a static certificate-based trunk.
    #: example: 5000.0
    port: Optional[int] = None
    #: Max Concurrent call. Required to create a static certificate based trunk.
    #: example: 1000.0
    max_concurrent_calls: Optional[int] = None


class TrunkPost(ApiModel):
    #: A unique name for the trunk.
    #: example: trunkName
    name: Optional[str] = None
    #: ID of location associated with the trunk.
    #: example: Y2lzY29zcGFyazovL3VzL1JPVVRFX0dST1VQLzA1OWEyNzNlLWJiYjAtMTFlYy04NDIyLTAyNDJhYzEyMDAwMg
    location_id: Optional[str] = None
    #: A password to use on the trunk.
    #: example: password
    password: Optional[str] = None
    #: Dual Identity Support setting impacts the handling of the From header and P-Asserted-Identity header when
    #: sending an initial SIP `INVITE` to the trunk for an outbound call.
    #: example: True
    dual_identity_support_enabled: Optional[bool] = None
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType] = None
    #: Device type assosiated with trunk.
    #: example: Cisco Unified Border Element
    device_type: Optional[str] = None
    #: FQDN or SRV address. Required to create a static certificate-based trunk.
    #: example: lgw1.london
    address: Optional[str] = None
    #: Domain name. Required to create a static certificate based trunk.
    #: example: acme.corp
    domain: Optional[str] = None
    #: FQDN port. Required to create a static certificate-based trunk.
    #: example: 5000.0
    port: Optional[int] = None
    #: Max Concurrent call. Required to create a static certificate based trunk.
    #: example: 1000.0
    max_concurrent_calls: Optional[int] = None


class TrunkPut(ApiModel):
    #: A unique name for the dial plan.
    #: example: dialPlanName
    name: Optional[str] = None
    #: A password to use on the trunk.
    #: example: password
    password: Optional[str] = None
    #: Determines the behavior of the From and PAI headers on outbound calls.
    #: example: True
    dual_identity_support_enabled: Optional[bool] = None
    #: Max Concurrent call. Required to create a static certificate-based trunk.
    #: example: 1000.0
    max_concurrent_calls: Optional[int] = None


class TrunkTypeWithDeviceType(ApiModel):
    #: Trunk Type associated with the trunk.
    trunk_type: Optional[TrunkType] = None
    #: Device types for trunk configuration.
    device_types: Optional[list[DeviceType]] = None


class TrunkTypeGetList(ApiModel):
    #: Trunk type with device types.
    trunk_types: Optional[list[TrunkTypeWithDeviceType]] = None


class GetLocalGatewayDialPlanUsageForATrunkResponse(ApiModel):
    #: Array of dial Plans.
    dial_plans: Optional[list[Location]] = None


class GetLocationsUsingTheLocalGatewayAsPstnConnectionRoutingResponse(ApiModel):
    #: Array of locations.
    locations: Optional[list[Location]] = None


class GetRouteGroupsUsingTheLocalGatewayResponse(ApiModel):
    #: Array of route Groups.
    route_group: Optional[list[RouteGroup]] = None


class ReadTheListOfDialPlansResponse(ApiModel):
    #: Array of dial plans.
    dial_plans: Optional[list[DialPlan]] = None


class ReadTheListOfTrunksResponse(ApiModel):
    #: Array of trunks.
    trunks: Optional[list[Trunk]] = None


class ReadTheListOfRoutingGroupsResponse(ApiModel):
    #: Array of route groups.
    route_groups: Optional[list[RouteGroup]] = None


class ReadTheUsageOfARoutingGroupResponse(ApiModel):
    #: Number of PSTN connection locations associated to this route group.
    #: example: 1
    pstn_connection_count: Optional[datetime] = None
    #: Number of call to extension locations associated to this route group.
    #: example: 1
    call_to_extension_count: Optional[datetime] = None
    #: Number of dial plan locations associated to this route group.
    #: example: 1
    dial_plan_count: Optional[datetime] = None
    #: Number of route list locations associated to this route group.
    #: example: 1
    route_list_count: Optional[datetime] = None


class ReadTheRouteListsOfARoutingGroupResponse(ApiModel):
    #: Array of route lists.
    route_group_usage_route_list_get: Optional[list[RouteGroupUsageRouteListGet]] = None


class ReadTheListOfRouteListsResponse(ApiModel):
    #: Array of route lists.
    route_lists: Optional[list[RouteList]] = None


class ModifyNumbersForRouteListResponse(ApiModel):
    #: Array of number statuses.
    number_status: Optional[list[RouteListNumberPatchResponse]] = None


class GetVoicemailRulesObjectDefaultVoicemailPinRulesBlockRepeatedDigits(ApiModel):
    #: If enabled, passcode should not contain repeated digits.
    #: example: True
    enabled: Optional[bool] = None
    #: Maximum number of repeaed digits. The minimum value is 1. The maximum value is 6.
    #: example: 3.0
    max_: Optional[int] = None


class GetVoicemailRulesObjectDefaultVoicemailPinRulesBlockContiguousSequences(ApiModel):
    #: If enabled, passcode should not contain a numerical sequence.
    #: example: True
    enabled: Optional[bool] = None
    #: Number of ascending digits in sequence. The minimum value is 2. The maximum value is 5.
    #: example: 3.0
    number_of_ascending_digits: Optional[int] = None
    #: Number of descending digits in sequence. The minimum value is 2. The maximum value is 5.
    #: example: 3.0
    number_of_descending_digits: Optional[int] = None


class GetVoicemailRulesObjectDefaultVoicemailPinRulesLength(ApiModel):
    #: The minimum value is 2. The maximum value is 15.
    #: example: 3.0
    min: Optional[int] = None
    #: The minimum value is 3. The maximum value is 30.
    #: example: 3.0
    max_: Optional[int] = None


class GetVoicemailRulesObjectDefaultVoicemailPinRules(ApiModel):
    #: If enabled, the passcode should not contain repeated pattern.
    #: example: True
    block_repeated_patterns_enabled: Optional[bool] = None
    #: Settings for not allowing single or groups of repeated digits in passcode (for example, 22888, 121212, or
    #: 408408).
    block_repeated_digits: Optional[GetVoicemailRulesObjectDefaultVoicemailPinRulesBlockRepeatedDigits] = None
    #: Settings for not allowing numerical sequence in passcode (for example, 012345 or 987654).
    block_contiguous_sequences: Optional[GetVoicemailRulesObjectDefaultVoicemailPinRulesBlockContiguousSequences] = None
    #: Length of the passcode.
    length: Optional[GetVoicemailRulesObjectDefaultVoicemailPinRulesLength] = None
    #: If enabled, the default voicemail passcode can be set.
    #: example: True
    default_voicemail_pin_enabled: Optional[bool] = None


class GetVoicemailRulesObjectExpirePasscode(ApiModel):
    #: If enabled, passcode expires after the number of days specified.
    #: example: True
    enabled: Optional[bool] = None
    #: Number of days for password expiry. The minimum value is 15. The maximum value is 180.
    #: example: 180.0
    number_of_days: Optional[int] = None


class GetVoicemailRulesObjectBlockPreviousPasscodes(ApiModel):
    #: If enabled, set how many of the previous passcodes are not allowed to be re-used.
    #: example: True
    enabled: Optional[bool] = None
    #: Number of previous passcodes. The minimum value is 1. The maximum value is 10.
    #: example: 3.0
    number_of_passcodes: Optional[int] = None


class GetVoicemailRulesObject(ApiModel):
    #: Default voicemail passcode requirements.
    default_voicemail_pin_rules: Optional[GetVoicemailRulesObjectDefaultVoicemailPinRules] = None
    #: Settings for passcode expiry.
    expire_passcode: Optional[GetVoicemailRulesObjectExpirePasscode] = None
    #: Settings for passcode changes.
    change_passcode: Optional[GetVoicemailRulesObjectExpirePasscode] = None
    #: Settings for previous passcode usage.
    block_previous_passcodes: Optional[GetVoicemailRulesObjectBlockPreviousPasscodes] = None


class GetVoicemailSettingsObject(ApiModel):
    #: When enabled, you can set the deletion conditions for expired messages.
    message_expiry_enabled: Optional[bool] = None
    #: Number of days after which messages expire.
    #: example: 10.0
    number_of_days_for_message_expiry: Optional[int] = None
    #: When enabled, all read and unread voicemail messages will be deleted based on the time frame you set. When
    #: disabled, all unread voicemail messages will be kept.
    strict_deletion_enabled: Optional[bool] = None
    #: When enabled, people in the organization can configure the email forwarding of voicemails.
    #: example: True
    voice_message_forwarding_enabled: Optional[bool] = None


class PutVoicemailRulesObject(ApiModel):
    #: Set to `true` to enable the default voicemail passcode.
    default_voicemail_pin_enabled: Optional[bool] = None
    #: Default voicemail passcode.
    #: example: 147852
    default_voicemail_pin: Optional[str] = None
    #: Settings for passcode expiry.
    expire_passcode: Optional[GetVoicemailRulesObjectExpirePasscode] = None
    #: Settings for passcode changes.
    change_passcode: Optional[GetVoicemailRulesObjectExpirePasscode] = None
    #: Settings for previous passcode usage.
    block_previous_passcodes: Optional[GetVoicemailRulesObjectBlockPreviousPasscodes] = None


class ReadTheListOfAnnouncementLanguagesResponse(ApiModel):
    #: Array of Languages.
    languages: Optional[list[FeatureAccessCode]] = None


class Call2(ApiModel):
    #: A unique identifier for the call.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExTLzU0MUFFMzBFLUUyQzUtNERENi04NTM4LTgzOTRDODYzM0I3MQo
    id: Optional[str] = None
    #: The room ID for the call.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The current state of the call.
    #: example: connected
    status: Optional[ListCallMembershipsCallStatus] = None
    #: The current duration of the call in seconds.
    #: example: 180.0
    duration: Optional[int] = None
    #: The date and time when the call was created.
    #: example: 2016-04-21T17:00:00.000Z
    created: Optional[datetime] = None


class CallsCollectionResponse(ApiModel):
    items: Optional[list[Call2]] = None


class HydraClassification(ApiModel):
    #: Unique identifier for the org's Space Classification
    #: example: Y2lzY29zcGFyazovL3VzL0NMQVNTSUZJQ0FUSU9OL2YyMDUyZTgyLTU0ZjgtMTFlYS1hMmUzLTJlNzI4Y2U4ODEyNQ
    id: Optional[str] = None
    #: Represents the rank of the classification. A number from 0 to 4, in which 0 usually refers to "public", and is
    #: the default whenever a rank cannot be determined.
    rank: Optional[int] = None
    #: Represents the classification title to be displayed in classified spaces for org users.
    #: example: Public
    title: Optional[str] = None
    #: Space Classification enabled state.
    #: example: True
    enabled: Optional[bool] = None
    #: Classification's description.
    #: example: Does not contain private information
    description: Optional[str] = None
    #: The date and time the Space Classification was last changed.
    #: example: 2020-02-22T00:06:42.438Z
    last_modified: Optional[datetime] = None
    #: A unique identifier for the Webex organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None


class OrganizationsSpaceClassificationCollectionResponse(ApiModel):
    items: Optional[list[HydraClassification]] = None


class ConferenceStateEnum(str, Enum):
    #: The controller is an active participant.
    connected = 'connected'
    #: The controller has held the conference and so is no longer an active participant.
    held = 'held'
    #: The conference has been released.
    disconnected = 'disconnected'


class ConferenceTypeEnum(str, Enum):
    barge_in = 'bargeIn'
    silent_monitoring = 'silentMonitoring'
    coaching = 'coaching'


class ConferenceParticipant(ApiModel):
    #: The callId of the call.
    #: example: Y2lzY29z...
    call_id: Optional[str] = None
    #: Indicates if the participant has been muted.
    #: example: True
    muted: Optional[bool] = None
    #: Indicates if the participant has been deafened (i.e. media stream is not being transmitting to the participant)
    #: example: True
    deafened: Optional[bool] = None


class ConferenceDetails(ApiModel):
    #: The state of the conference.
    state: Optional[ConferenceStateEnum] = None
    #: The appearance index for the conference leg. Only present when the conference has an appearance value assigned.
    #: example: 2.0
    appearance: Optional[int] = None
    #: The conference start time in ISO 8601 format.
    #: example: 2023-03-02T15:00:00.000Z
    created: Optional[datetime] = None
    #: Indicates if the host of the conference has been muted.
    muted: Optional[bool] = None
    #: The type of conference for a non-standard conference.
    #: example: bargeIn
    type: Optional[ConferenceTypeEnum] = None
    #: The participants in the conference.
    participants: Optional[list[ConferenceParticipant]] = None


class Link(ApiModel):
    href: Optional[str] = None
    method: Optional[str] = None
    rel: Optional[str] = None


class Error3(ApiModel):
    code: Optional[int] = None
    details: Optional[AttachmentAction] = None
    internal: Optional[bool] = None
    links: Optional[list[Link]] = None


class AgentAgentDn(str, Enum):
    _653 = '653'


class AgentCurrentState(str, Enum):
    logged_in = 'LoggedIn'
    idle = 'Idle'
    available = 'Available'
    connected = 'Connected'
    wrapup = 'Wrapup'
    not_responding = 'NotResponding'
    ringing = 'Ringing'


class AgentChannelType(str, Enum):
    chat = 'chat'
    email = 'email'
    telephony = 'telephony'


class Agent(ApiModel):
    #: The endpoint on which the agent receives calls/chats/emails.
    #: example: 653
    agent_dn: Optional[AgentAgentDn] = None
    #: The ID identifies an agent.
    #: example: 295.0
    agent_id: Optional[int] = None
    #: Name of an agent, that is, a person who answers customer calls, chats or emails.
    #: example: loadAgent00001 BSFT
    agent_name: Optional[str] = None
    #: Login name with which agent logs into agent desktop.
    #: example: loadAgent00001
    agentlogin: Optional[str] = None
    #: The ID assigned to an agent's login session.
    #: example: e3db29fa-6a84-4dc3-b814-95c617b67a95
    agent_session_id: Optional[str] = None
    #: The current state of the agent.
    #: example: LoggedIn
    current_state: Optional[AgentCurrentState] = None
    #: Timestamp when the interaction started.
    #: example: 1530629440059.0
    cstts: Optional[int] = None
    #: Timestamp when the interaction ended.
    #: example: 1530629440059.0
    cetts: Optional[int] = None
    #: The ID assigned to an entry point.
    #: example: 0ba49aae-74ed-41e5-bd28-6f8524b62e04
    channel_id: Optional[str] = None
    #: The media type of the contact.
    #: example: telephony
    channel_type: Optional[AgentChannelType] = None
    #: example: 1530629440059.0
    realtime_update_timestamp: Optional[int] = None
    #: The ID assigned to a team.
    #: example: 125.0
    team_id: Optional[int] = None
    #: The name of a team, which is a group of agents at a specific site who handle a particular type of contact.
    #: example: Load_Team1
    team_name: Optional[str] = None
    #: example: AV-SuTCNizTcJ2G98gNn
    team_system_id: Optional[str] = None
    #: The ID assigned to a site, which is a call center location.
    #: example: 66.0
    site_id: Optional[int] = None
    #: The call center location to which a call was distributed.
    #: example: Load_Site_BLV
    site_name: Optional[str] = None
    #: example: AV-SuI65izTcJ2G98gNm
    site_system_id: Optional[str] = None


class AgentActivity(Agent):
    #: example: c4567c9858a74fd39497cddde50b1ac
    call_session_id: Optional[str] = None
    #: The amount of time between when the activity started and when the activity ended.
    #: example: 21.0
    duration: Optional[int] = None
    #: The ID assigned to an idle state/code.
    #: example: 95.0
    idle_code_id: Optional[int] = None
    #: The name of the idle code. Admin can configure possible values like Meeting, RONA, Dinner, Lunch, Busy
    #: example: Meeting
    idle_code_name: Optional[str] = None
    #: example: AV4s2V-PXI3EMNlP7oIm
    idle_code_system_id: Optional[str] = None
    #: Indicates whether this activity occurred while making an outdial call.
    outdial_flag: Optional[int] = None


class AgentSession(Agent):
    #: A string that identifies an agent.
    #: example: AV9-9J4KizTcJ2G98fzL
    agent_system_id: Optional[str] = None
    #: The number of times an agent went into Available state.
    #: example: 1.0
    available_count: Optional[int] = None
    #: The number of times an agent transferred without consulting first.
    #: example: 2.0
    blind_xfer_count: Optional[int] = None
    #: The number of times an agent went into an Idle state.
    #: example: 1.0
    idle_count: Optional[int] = None
    #: The amount of time an agent spent in an Available state.
    #: example: 2065.0
    total_available_time: Optional[int] = None


class CustomerCallDirection(str, Enum):
    inbound = 'inbound'
    outdial = 'outdial'


class CustomerCurrentState(str, Enum):
    new = 'new'
    parked = 'parked'
    connected = 'connected'
    ended = 'ended'
    consulting = 'consulting'


class Customer1(ApiModel):
    #: The ANI digits delivered with a call. ANI, or Automatic Number Identification, is a service provided by the
    #: phone company that delivers the caller's phone number along with the call.
    #: example: John
    ani: Optional[str] = None
    #: Flag that indicates whether this is a current session or not. 0 or 1.
    active: Optional[int] = None
    #: Name of an agent, that is, a person who answers customer calls/chats/emails
    #: example: loadAgent00001 BSFT
    agent_name: Optional[str] = None
    #: The ID assigned to an agent's login session.
    #: example: e3db29fa-6a84-4dc3-b814-95c617b67a95
    agent_session_id: Optional[str] = None
    #: Number of times a customer contacted.
    #: example: 1.0
    call_count: Optional[int] = None
    #: The current direction of the call.
    #: example: inbound
    call_direction: Optional[CustomerCallDirection] = None
    #: Timestamp when the interaction started.
    #: example: 1530629440059.0
    cstts: Optional[int] = None
    #: The media type of the contact.
    #: example: telephony
    channel_type: Optional[AgentChannelType] = None
    #: The current state of the contact.
    #: example: ended
    current_state: Optional[CustomerCurrentState] = None
    #: The DNIS digits delivered with the call. DNIS, or Dialed Number Identification Service, is a service provided by
    #: the phone company that delivers a digit string indicating the number the caller dialed along with the call.
    #: example: 11888999
    dnis: Optional[str] = None
    #: The ID assigned to an entry point.
    #: example: 11
    entrypoint_id: Optional[datetime] = None
    #: The name of the entry point, which is the landing place for customer calls on the Webex Contact Center system.
    #: Calls are moved from the entry point into a queue and are then distributed to agents.
    #: example: Apple-SalesEP
    entrypoint_name: Optional[str] = None
    #: The ID assigned to an entry point.
    #: example: AV3KrA1AXI3EMNlP7m_2
    entrypoint_system_id: Optional[str] = None
    #: Flag that indicates whether this activity occurred while making an outdial call.
    is_outdial: Optional[int] = None
    #: example: 1584547145749
    realtime_update_timestamp: Optional[str] = None
    #: example: e3cf6187-cc3f-4c6f-8ba5-6014821529e3-1584547145537-new
    sid: Optional[str] = None
    #: The ID assigned to a site, which is a call center location.
    #: example: 66.0
    site_id: Optional[int] = None
    #: The call center location to which a call was distributed.
    #: example: Load_Site_BLV
    site_name: Optional[str] = None
    #: example: AV-SuI65izTcJ2G98gNm
    site_system_id: Optional[str] = None
    #: The ID assigned to a team.
    #: example: 125.0
    team_id: Optional[int] = None
    #: The name of a team, which is a group of agents at a specific site who handle a particular type of contact.
    #: example: Load_Team1
    team_name: Optional[str] = None
    #: example: AV-SuTCNizTcJ2G98gNn
    team_system_id: Optional[str] = None
    #: example: 1.0
    tid: Optional[int] = None


class CustomerActivity(Customer1):
    #: The amount of time between when the activity started and when it was terminated.
    #: example: 154.0
    duration: Optional[int] = None
    #: If this isn't a current activity, this field shows the state of the following activity.
    #: example: ivr-connected
    next_state: Optional[str] = None


class CustomerSessionTerminatingEnd(str, Enum):
    caller = 'caller'
    agent = 'agent'


class CustomerSessionTerminationType(str, Enum):
    normal = 'normal'
    abandoned = 'abandoned'
    self_service = 'self_service'


class CustomerSession(Customer1):
    #: Number of times the contact was in IVR state.
    #: example: 1.0
    ivr_count: Optional[int] = None
    #: The amount of time, in milliseconds, during which a call was in IVR state.
    #: example: 1.0
    ivr_duration: Optional[int] = None
    #: A string that identifies a queue.
    #: example: 20
    queue_id: Optional[datetime] = None
    #: The number of queues contact entered.
    #: example: 1.0
    queue_count: Optional[int] = None
    #: The name of the current or final queue, which is holding place for contacts while they await handling by an
    #: agent. Calls are moved from an entry point into a queue and are then distributed to agents.
    #: example: Apple-SalesQueue
    queue_name: Optional[str] = None
    #: The amount of time, in milliseconds, a contact spent in queue waiting.
    #: example: 245198.0
    queue_duration: Optional[int] = None
    #: Indicates which party terminated the interaction.
    #: example: caller
    terminating_end: Optional[CustomerSessionTerminatingEnd] = None
    #: Indicates how a call was terminated.
    #: example: abandoned
    termination_type: Optional[CustomerSessionTerminationType] = None


class ActivityListDatasetMetadata(ApiModel):
    last_access_timestamp: Optional[int] = None
    #: example: 3.0
    number_of_records_found: Optional[int] = None
    #: example: 3.0
    number_of_records_in_dataset: Optional[int] = None
    #: example: true
    is_complete: Optional[str] = None


class ActivityList(ApiModel):
    dataset_metadata: Optional[ActivityListDatasetMetadata] = None
    #: An array of column IDs in the query.
    columns: Optional[list[str]] = None
    #: An array of records
    data: Optional[list[str]] = None


class Entity(ApiModel):
    #: String value of the found entity
    value: Optional[str] = None
    #: Start index of the found entity
    start_position: Optional[int] = None
    #: End index of the found entity
    end_position: Optional[int] = None
    #: Name of the entity found
    label: Optional[str] = None
    #: Confidence score of the found entity
    score: Optional[int] = None


class EntityRecognition(ApiModel):
    #: Identifier of the Organization
    org_id: Optional[str] = None
    #: Identifier of the contact.
    contact_id: Optional[str] = None
    #: Identifier of the call leg / party (caller, agent).
    party_id: Optional[str] = None
    #: Identifier of the model.
    model_id: Optional[str] = None
    #: Version of the model.
    model_version: Optional[str] = None
    #: List of found entities
    entities: Optional[list[Entity]] = None


class AnalyzeEntitiesDocument(ApiModel):
    #: The document's type.
    #: example: PLAIN_TEXT
    type: Optional[str] = None
    #: The document's content.
    #: example: My name is John Doe . I am from USA .
    content: Optional[str] = None


class Meta(ApiModel):
    #: Organization ID.
    #: example: e767c439-08bf-48fa-a03c-ac4a09eeee8f
    org_id: Optional[str] = None


class TaskAttributesStatus(str, Enum):
    created = 'created'
    queued = 'queued'
    offered = 'offered'
    assigned = 'assigned'
    abandoned = 'abandoned'
    completed = 'completed'


class TaskAttributes(ApiModel):
    #: Channel type on which the task is performed (e.g. email, telephony, chat, etc.).
    #: example: email
    channel_type: Optional[str] = None
    #: Created time of the task (epoch milliseconds).
    #: example: 1591702170000.0
    created_time: Optional[int] = None
    #: Last updated time of the task (epoch milliseconds). Updates whenever the underlying data is modified, even if
    #: the Task view of the data is the same. May also update after task "closure", so not suitable for finding a
    #: task's "closed time".
    #: example: 1591712170099.0
    last_updated_time: Optional[int] = None
    owner: Optional[Location] = None
    queue: Optional[Location] = None
    context: Optional[AttachmentAction] = None
    #: Customer's channel-specific identifier. For telephony, this is the phone number. For email and chat, this is the
    #: email address.
    #: example: chatuser@email.com
    origin: Optional[str] = None
    #: Destination the customer contacted. For telephony, this is the number the contact called. For chat, this is the
    #: URL of the page where the chat takes place. For email, it is the email address contacted.
    #: example: +18005555555
    destination: Optional[str] = None
    #: Indicates which party initiated the Task. If "inbound", call was initated by customer. If "outbound", was
    #: initiated by system as part of campaign. If "outdial", was initiated by an agent.
    #: example: inbound
    direction: Optional[str] = None
    #: Reason code specified by customer to indicate main aim of the task.
    #: example: Credit
    reason_code: Optional[str] = None
    #: Whether a capture has been requested for this Task. If this is true, a capture should eventually be available.
    #: False indicates no capture will be made available. If null, it is not yet known whether a capture has been
    #: requested.
    capture_requested: Optional[bool] = None
    #: Current status of the task.
    #: example: assigned
    status: Optional[TaskAttributesStatus] = None


class Task(ApiModel):
    #: ID of the task.
    #: example: 93912f11-6017-404b-bf14-5331890b1797
    id: Optional[str] = None
    attributes: Optional[TaskAttributes] = None


class TasksResponse(ApiModel):
    #: Response metadata.
    meta: Optional[Meta] = None
    #: List of tasks retrieved according to query parameters.
    data: Optional[list[Task]] = None


class FieldValidationError(ApiModel):
    #: example: pageSize
    field: Optional[str] = None
    #: example: Invalid pageSize parameter
    message: Optional[str] = None


class TasksValidationError(ApiModel):
    field_errors: Optional[list[FieldValidationError]] = None
    #: example: INTEGRATION-9bcdc696-57fa-4e91-b5aa-57a66a347c23
    tracking_id: Optional[str] = None
    #: example: The request was not processed
    message: Optional[str] = None
    #: example: 400.0
    code: Optional[int] = None


class AgentStatsChannelChannelType(str, Enum):
    telephony = 'telephony'
    chat = 'chat'
    email = 'email'
    social = 'social'


class AgentStatsChannel(ApiModel):
    #: Channel GUID
    #: example: 91fada7d-6be8-46e8-b6af-8598e71b7e27
    channel_id: Optional[str] = None
    #: example: telephony
    channel_type: Optional[AgentStatsChannelChannelType] = None
    #: Number of assigned tasks within this channel during the agent's session.
    #: example: 3.0
    total_assigned_tasks: Optional[int] = None
    #: Number of accepted tasks that were assigned to the agent.
    #: example: 3.0
    total_accepted_tasks: Optional[int] = None
    #: Number of rejected tasks that were assigned to the agent.
    total_rejected_tasks: Optional[int] = None
    #: Number of tasks the agent transferred to another agent.
    total_transferred_tasks: Optional[int] = None
    #: Amount of time the agent was engaged with a customer (in milliseconds).
    #: example: 40302.0
    total_engaged_duration: Optional[int] = None
    #: Amount of time the customer(s) was put on hold (in milliseconds).
    #: example: 10198.0
    total_hold_duration: Optional[int] = None
    #: Amount of time the agent spent wrapping-up customer interactions (in milliseconds).
    #: example: 3552.0
    total_wrap_up_duration: Optional[int] = None


class AgentStats(ApiModel):
    #: Time in GMT
    #: example: 1591702200000.0
    interval_start_time: Optional[int] = None
    #: Agent GUID
    #: example: 06ce7234-dd3e-49e2-8763-d93766739d3
    agent_id: Optional[str] = None
    #: example: Jim Bob
    agent_name: Optional[str] = None
    #: Team GUID
    #: example: fbf80248-b328-4c37-9ea5-4c2ec8b4d52c
    team_id: Optional[str] = None
    #: Name of team to which the agent belongs.
    #: example: Ghost Riders
    team_name: Optional[str] = None
    #: Time that the agent's status was set to 'Available'.
    #: example: 54052.0
    total_available_time: Optional[int] = None
    #: Time that the agent's status was set to 'Unavailable'.
    total_unavailable_time: Optional[int] = None
    channel: Optional[list[AgentStatsChannel]] = None


class AgentStatsResponse(ApiModel):
    #: Response metadata.
    meta: Optional[Meta] = None
    #: List of agent stats for each queried agent.
    data: Optional[list[AgentStats]] = None


class QueueStats(ApiModel):
    #: Time in GMT (milliseconds).
    #: example: 1591702200000.0
    interval_start_time: Optional[int] = None
    #: Queue ID
    #: example: 06ce7234-dd3e-49e2-8763-d93766739d3
    queue_id: Optional[str] = None
    #: example: MainInbound
    queue_name: Optional[str] = None
    #: example: telephony
    channel_type: Optional[AgentStatsChannelChannelType] = None
    #: example: 7.0
    total_offered_tasks: Optional[int] = None
    #: example: 7.0
    total_enqueued_tasks: Optional[int] = None
    #: example: 7.0
    total_assigned_tasks: Optional[int] = None
    #: example: 7.0
    total_accepted_tasks: Optional[int] = None
    total_rejected_tasks: Optional[int] = None
    total_abandoned_tasks: Optional[int] = None
    #: example: 20349.0
    average_enqueued_time: Optional[int] = None
    #: example: 93729.0
    average_handle_time: Optional[int] = None


class QueueStatsResponse(ApiModel):
    #: Response metadata.
    meta: Optional[Meta] = None
    data: Optional[list[QueueStats]] = None


class RecordingStatus(str, Enum):
    completed = 'Completed'
    pending = 'Pending'
    not_found = 'Not Found'
    error = 'Error'


class ArtifactAttributes(ApiModel):
    #: example: recording-1.wav
    file_name: Optional[str] = None
    #: Capture download url.
    #: example: https://cjp-ccone-devus1-media-storage-recording.s3.amazonaws.com/9e4895c9-787b-4615-b15f-f1b3b12c3091/
    file_path: Optional[str] = None
    #: Begin time of capture
    #: example: 1591804052000.0
    start_time: Optional[int] = None
    #: End time of capture
    #: example: 1591804562000.0
    stop_time: Optional[int] = None
    #: Comma separated list of agent Ids and masked customer contact email/phone details.
    #: example: ['140e7575-6a21-4599-a929-c407dcf36649,+*******9000']
    participants: Optional[list[str]] = None


class Artifact(ApiModel):
    #: example: 792707a1-6696-4a66-8184-9bab0a769c10
    id: Optional[str] = None
    attributes: Optional[list[ArtifactAttributes]] = None


class Recording(ApiModel):
    #: example: Completed
    status: Optional[RecordingStatus] = None
    artifacts: Optional[list[Artifact]] = None


class TaskWithCaptures(ApiModel):
    #: example: 6a64d539-4653-4c48-98d7-78fb66c1bc1d
    task_id: Optional[str] = None
    recording: Optional[Recording] = None


class ListCapturesResponse(ApiModel):
    #: Response metadata.
    meta: Optional[Meta] = None
    data: Optional[list[TaskWithCaptures]] = None


class GetAgentsStatisticsInterval(str, Enum):
    _15 = '15'
    _30 = '30'
    _60 = '60'


class ListCapturesQuery(ApiModel):
    #: Organization ID to use for this operation. If unspecified, inferred from token. Token must have permission to
    #: interact with this organization.
    #: example: 93912f11-6017-404b-bf14-5331890b1797
    org_id: Optional[str] = None
    #: Comma separated list of taskIds to gather captures for. Max of 10 taskIds per request.
    #: example: ['6a64d539-4653-4c48-98d7-78fb66c1bc1d, 9dd4a070-4047-46ac-abec-942f48f5535e']
    task_ids: Optional[list[str]] = None
    #: Expiration time of returned s3 url (in minutes). Max value is 60.
    #: example: 30.0
    url_expiration: Optional[int] = None


class DisplayCallqueueAgentSoftkeysObject(str, Enum):
    front_page = 'FRONT_PAGE'
    last_page = 'LAST_PAGE'


class AcdObject(ApiModel):
    #: Indicates whether the ACD object is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Indicates the call queue agent soft key value of an ACD object.
    #: example: LAST_PAGE
    display_callqueue_agent_softkeys: Optional[DisplayCallqueueAgentSoftkeysObject] = None


class ActivationStates(str, Enum):
    #: Indicates a device is activating.
    activating = 'ACTIVATING'
    #: Indicates a device is activated.
    activated = 'ACTIVATED'
    #: Indicates a device is deactivated.
    deactivated = 'DEACTIVATED'


class SelectionType(str, Enum):
    #: Indicates the regional selection type for audio codec priority.
    regional = 'REGIONAL'
    #: Indicates the custom selection type for audio codec priority.
    custom = 'CUSTOM'


class AudioCodecPriorityObject(ApiModel):
    #: Indicates the selection of an Audio Codec Priority Object.
    #: example: REGIONAL
    selection: Optional[SelectionType] = None
    #: Indicates the primary Audio Codec.
    #: example: G711a
    primary: Optional[str] = None
    #: Indicates the secondary Audio Codec.
    #: example: G711u
    secondary: Optional[str] = None
    #: Indicates the tertiary Audio Codec.
    #: example: G729a
    tertiary: Optional[str] = None


class AtaDtmfModeObject(str, Enum):
    #: A DTMF digit requires an extra hold time after detection and the DTMF level threshold is raised to -20 dBm.
    strict = 'STRICT'
    #: Normal threshold mode.
    normal = 'NORMAL'


class AtaDtmfMethodObject(str, Enum):
    #: Sends DTMF by using the audio path.
    inband = 'INBAND'
    #: Audio video transport. Sends DTMF as AVT events.
    avt = 'AVT'
    #: Uses InBand or AVT based on the outcome of codec negotiation.
    auto = 'AUTO'


class DectVlanObject(ApiModel):
    #: Denotes whether the VLAN object of DECT is enabled.
    enabled: Optional[bool] = None
    #: Value of the VLAN Object of DECT.
    value: Optional[int] = None


class SnmpObject(ApiModel):
    #: Denotes whether the Simple Network Management Protocol of an ATA is enabled.
    enabled: Optional[bool] = None
    #: Trusted IPv4 address and subnet mask in this order: 0.0.0.0/0.0.0.0.
    #: example: 10.0.0.45
    trusted_ip: Optional[str] = Field(alias='trustedIP', default=None)
    #: Read-only community string that allows/denies access to other device's statistics. Default value is `public`.
    #: example: public
    get_community: Optional[str] = None
    #: Read-write community string that protects the device against unauthorized changes. Must never be set to
    #: `public`.
    #: example: private
    set_community: Optional[str] = None
    #: Denotes whether the SNMPv3 security is enabled.
    snmp_v3_enabled: Optional[bool] = None


class AtaObject(ApiModel):
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[AudioCodecPriorityObject] = None
    #: DTMF Detection Tx Mode selection for Cisco ATA devices.
    ata_dtmf_mode: Optional[AtaDtmfModeObject] = None
    #: Method for transmitting DTMF signals to the far end.
    #: example: AVT
    ata_dtmf_method: Optional[AtaDtmfMethodObject] = None
    #: Enable/disable Cisco Discovery Protocol for local devices.
    #: example: True
    cdp_enabled: Optional[bool] = None
    #: Enable/disable Link Layer Discovery Protocol for local devices.
    #: example: True
    lldp_enabled: Optional[bool] = None
    #: Enable/disable quality of service tagging of packets from the local device to the Webex Calling platform.
    #: example: True
    qos_enabled: Optional[bool] = None
    #: Specify a numeric Virtual LAN ID for devices.
    vlan: Optional[DectVlanObject] = None
    #: Enable/disable user level web access to the local device.
    #: example: True
    web_access_enabled: Optional[bool] = None
    #: Enable/disable the automatic nightly configuration resync of the MPP device.
    #: example: True
    nightly_resync_enabled: Optional[bool] = None
    #: Specify values needed to enable use of the SNMP service from the phone.
    snmp: Optional[SnmpObject] = None


class DectObject(ApiModel):
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[AudioCodecPriorityObject] = None
    #: Enable/disable Cisco Discovery Protocol for local devices.
    #: example: True
    cdp_enabled: Optional[bool] = None
    #: Specify the destination number to be dialled from the DECT Handset top button when pressed.
    dect6825_handset_emergency_number: Optional[str] = None
    #: Enable/disable Link Layer Discovery Protocol for local devices.
    #: example: True
    lldp_enabled: Optional[bool] = None
    #: Specify up to 3 multicast group URLs each with a unique listening port.
    multicast: Optional[str] = None
    #: Enable/disable quality of service tagging of packets from the local device to the Webex Calling platform.
    #: example: True
    qos_enabled: Optional[bool] = None
    #: Specify a numeric Virtual LAN ID for devices.
    vlan: Optional[DectVlanObject] = None
    #: Enable/disable user level web access to the local device.
    #: example: True
    web_access_enabled: Optional[bool] = None
    #: Enable/disable phone's default behavior regarding the nightly maintenance synchronization with the Webex Calling
    #: platform.
    #: example: True
    nightly_resync_enabled: Optional[bool] = None


class MppAudioCodecPriorityObject(ApiModel):
    #: Indicates the selection of the Audio Codec Priority Object for an MPP object.
    #: example: CUSTOM
    selection: Optional[str] = None
    #: Indicates the primary Audio Codec for an MPP object.
    #: example: OPUS
    primary: Optional[str] = None
    #: Indicates the secondary Audio Codec for an MPP object.
    #: example: G722
    secondary: Optional[str] = None
    #: Indicates the tertiary Audio Codec for an MPP object.
    #: example: G711u
    tertiary: Optional[str] = None


class BacklightTimerObject(str, Enum):
    #: Set the phone's backlight to be on for one minute.
    one_min = 'ONE_MIN'
    #: Set the phone's backlight to be on for five minutes.
    five_min = 'FIVE_MIN'
    #: Set the phone's backlight to be on for thirty minutes.
    thirty_min = 'THIRTY_MIN'
    #: Keep the phone's backlight always on.
    always_on = 'ALWAYS_ON'


class BackgroundImage(str, Enum):
    #: Indicates that there will be no background image set for the devices.
    none_ = 'NONE'
    #: Indicates that dark blue background image will be set for the devices.
    dark_blue = 'DARK_BLUE'
    #: Indicates that Cisco themed dark blue background image will be set for the devices.
    cisco_dark_blue = 'CISCO_DARK_BLUE'
    #: Indicates that Cisco Webex dark blue background image will be set for the devices.
    webex_dark_blue = 'WEBEX_DARK_BLUE'
    #: Indicates that a custom background image will be set for the devices.
    custom_background = 'CUSTOM_BACKGROUND'
    #: When this option is selected, a field 'Custom Background URL' needs to be added with the image url. URLs
    #: provided must link directly to an image file and be in HTTP, HTTPS, or filepath format.
    custom_url = 'customUrl'


class DisplayNameSelection(str, Enum):
    #: Indicates that devices will display the person's phone number, or if a person doesn't have a phone number, the
    #: location number will be displayed.
    person_number = 'PERSON_NUMBER'
    #: Indicates that devices will display the name in first name then last name format.
    person_first_then_last_name = 'PERSON_FIRST_THEN_LAST_NAME'
    #: Indicates that devices will display the name in last name then first name format.
    person_last_then_first_name = 'PERSON_LAST_THEN_FIRST_NAME'


class DefaultLoggingLevelObject(str, Enum):
    #: Enables standard logging.
    standard = 'STANDARD'
    #: Enables detailed debugging logging.
    debugging = 'DEBUGGING'


class LineKeyLabelSelection(str, Enum):
    #: This will display the person extension, or if a person doesn't have an extension, the person's first name will
    #: be displayed.
    person_extension = 'PERSON_EXTENSION'
    #: Indicates that devices will display the name in first name then last name format.
    person_first_then_last_name = 'PERSON_FIRST_THEN_LAST_NAME'
    #: Indicates that devices will display the name in last name then first name format.
    person_last_then_first_name = 'PERSON_LAST_THEN_FIRST_NAME'


class LineKeyLEDPattern(str, Enum):
    default = 'DEFAULT'
    preset_1 = 'PRESET_1'


class PhoneLanguage(str, Enum):
    #: Indicates a person's announcement language.
    person_language = 'PERSON_LANGUAGE'
    arabic = 'ARABIC'
    bulgarian = 'BULGARIAN'
    catalan = 'CATALAN'
    chinese_simplified = 'CHINESE_SIMPLIFIED'
    chinese_traditional = 'CHINESE_TRADITIONAL'
    croatian = 'CROATIAN'
    czech = 'CZECH'
    danish = 'DANISH'
    dutch = 'DUTCH'
    english_united_states = 'ENGLISH_UNITED_STATES'
    english_united_kingdom = 'ENGLISH_UNITED_KINGDOM'
    finnish = 'FINNISH'
    french_canada = 'FRENCH_CANADA'
    french_france = 'FRENCH_FRANCE'
    german = 'GERMAN'
    greek = 'GREEK'
    hebrew = 'HEBREW'
    hungarian = 'HUNGARIAN'
    italian = 'ITALIAN'
    japanese = 'JAPANESE'
    korean = 'KOREAN'
    norwegian = 'NORWEGIAN'
    polish = 'POLISH'
    portuguese_portugal = 'PORTUGUESE_PORTUGAL'
    russian = 'RUSSIAN'
    spanish_colombia = 'SPANISH_COLOMBIA'
    spanish_spain = 'SPANISH_SPAIN'
    slovak = 'SLOVAK'
    swedish = 'SWEDISH'
    slovenian = 'SLOVENIAN'
    turkish = 'TURKISH'
    ukraine = 'UKRAINE'


class PoeMode(str, Enum):
    #: Use normal power consumption.
    normal = 'NORMAL'
    #: Use maximum power consumption.
    maximum = 'MAXIMUM'


class MppVlanObject(ApiModel):
    #: Indicates whether the VLAN object of an MPP is enabled.
    enabled: Optional[bool] = None
    #: Indicates the value of a VLAN object for an MPP object.
    #: example: 1.0
    value: Optional[int] = None
    #: Indicates the PC port value of a VLAN object for an MPP object.
    #: example: 1.0
    pc_port: Optional[int] = None


class AuthenticationMethodObject(str, Enum):
    #: No authentication.
    none_ = 'NONE'
    #: Extensible Authentication Protocol-Flexible Authentication via Secure Tunneling. Requires username and password
    #: authentication.
    eap_fast = 'EAP_FAST'
    #: Protected Extensible Authentication Protocol - Generic Token Card. Requires username and password
    #: authentication.
    peap_gtc = 'PEAP_GTC'
    #: Protected Extensible Authentication Protocol - Microsoft Challenge Handshake Authentication Protocol version 2.
    #: Requires username and password authentication.
    peap_mschapv2 = 'PEAP_MSCHAPV2'
    #: Pre-Shared Key. Requires shared passphrase for authentication.
    psk = 'PSK'
    #: Wired Equivalent Privacy. Requires encryption key for authentication.
    wep = 'WEP'


class WifiNetworkObject(ApiModel):
    #: Indicates whether the wifi network is enabled.
    enabled: Optional[bool] = None
    #: Authentication method of wifi network.
    authentication_method: Optional[AuthenticationMethodObject] = None
    #: SSID name of the wifi network.
    #: example: my_wifi_network
    ssid_name: Optional[str] = None
    #: User Id of the wifi network.
    #: example: test-user
    user_id: Optional[str] = None


class CallHistoryMethod(str, Enum):
    #: Set call history to use the unified call history from all of the end user's devices.
    webex_unified_call_history = 'WEBEX_UNIFIED_CALL_HISTORY'
    #: Set call history to use local device information only.
    local_call_history = 'LOCAL_CALL_HISTORY'


class DirectoryMethod(str, Enum):
    #: Set directory services to use standard XSI query method from the device.
    xsi_directory = 'XSI_DIRECTORY'
    #: Set directory services to use the Webex Enterprise directory.
    webex_directory = 'WEBEX_DIRECTORY'


class VolumeSettingsObject(ApiModel):
    #: Specify a ringer volume level through a numeric value between 0 and 15.
    #: example: 9.0
    ringer_volume: Optional[int] = None
    #: Specify a speaker volume level through a numeric value between 0 and 15.
    #: example: 11.0
    speaker_volume: Optional[int] = None
    #: Specify a handset volume level through a numeric value between 0 and 15.
    #: example: 10.0
    handset_volume: Optional[int] = None
    #: Specify a headset volume level through a numeric value between 0 and 15.
    #: example: 10.0
    headset_volume: Optional[int] = None
    #: Enable/disable the wireless headset hookswitch control.
    #: example: True
    e_hook_enabled: Optional[bool] = None
    #: Enable/disable to preserve the existing values on the phone and not the values defined for the device settings.
    #: example: True
    allow_end_user_override_enabled: Optional[bool] = None


class CallForwardExpandedSoftKey(str, Enum):
    #: Set the default call forward expanded soft key behavior to single option.
    only_the_call_forward_all = 'ONLY_THE_CALL_FORWARD_ALL'
    #: Set the default call forward expanded soft key behavior to multiple menu option.
    all_call_forwards = 'ALL_CALL_FORWARDS'


class HttpProxyObjectMode(str, Enum):
    off = 'OFF'
    auto = 'AUTO'
    manual = 'MANUAL'


class HttpProxyObject(ApiModel):
    #: Mode of the HTTP proxy.
    #: example: OFF
    mode: Optional[HttpProxyObjectMode] = None
    #: Enable/disable auto discovery of the URL.
    #: example: True
    auto_discovery_enabled: Optional[bool] = None
    #: Specify the host URL if the HTTP mode is set to `MANUAL`.
    #: example: www.example.wxc
    host: Optional[str] = None
    #: Specify the port if the HTTP mode is set to `MANUAL`.
    #: example: 3128
    port: Optional[datetime] = None
    #: Specify PAC URL if auto discovery is disabled.
    #: example: www.example.wxc
    pack_url: Optional[str] = None
    #: Enable/disable authentication settings.
    #: example: True
    auth_settings_enabled: Optional[bool] = None
    #: Specify a username if authentication settings are enabled.
    #: example: john
    username: Optional[str] = None
    #: Specify a password if authentication settings are enabled.
    #: example: private
    password: Optional[str] = None


class BluetoothObjectMode(str, Enum):
    phone = 'PHONE'
    hands_free = 'HANDS_FREE'
    both = 'BOTH'


class BluetoothObject(ApiModel):
    #: Enable/disable Bluetooth.
    #: example: True
    enabled: Optional[bool] = None
    #: Select a Bluetooth mode.
    #: example: PHONE
    mode: Optional[BluetoothObjectMode] = None


class NoiseCancellationObject(ApiModel):
    #: Enable/disable the Noise Cancellation.
    #: example: True
    enabled: Optional[bool] = None
    #: Enable/disable to preserve the existing values on the phone and not the value defined for the device setting.
    #: example: True
    allow_end_user_override_enabled: Optional[bool] = None


class SoftKeyMenuObject(ApiModel):
    #: Specify the idle key list.
    #: example: guestin|;guestout|;acd_login|;acd_logout|;astate|;redial|;newcall|;cfwd|;recents|;dnd|;unpark|;psk1|;gpickup|;pickup|;dir|4;miss|5;selfview|;messages
    idle_key_list: Optional[str] = None
    #: Specify the off hook key list.
    #: example: endcall|1;redial|2;dir|3;lcr|4;unpark|5;pickup|6;gpickup|7
    off_hook_key_list: Optional[str] = None
    #: Specify the dialing input key list.
    #: example: dial|1;cancel|2;delchar|3;left|5;right|6
    dialing_input_key_list: Optional[str] = None
    #: Specify the progressing key list.
    #: example: endcall|2
    progressing_key_list: Optional[str] = None
    #: Specify the connected key list.
    #: example: hold;endcall;xfer;conf;xferLx;confLx;bxfer;phold;redial;dir;park;crdstart;crdstop;crdpause;crdresume
    connected_key_list: Optional[str] = None
    #: Specify the connected video key list.
    #: example: hold;endcall;xfer;conf;xferLx;confLx;bxfer;phold;redial;dir;park;crdstart;crdstop;crdpause;crdresume
    connected_video_key_list: Optional[str] = None
    #: Start the transfer key list.
    #: example: endcall|2;xfer|3
    start_transfer_key_list: Optional[str] = None
    #: Start the conference key list.
    #: example: endcall|2;conf|3
    start_conference_key_list: Optional[str] = None
    #: Specify the conferencing key list.
    #: example: endcall;join;crdstart;crdstop;crdpause;crdresume
    conferencing_key_list: Optional[str] = None
    #: Specify the releasing key list.
    #: example: endcall|2
    releasing_key_list: Optional[str] = None
    #: Specify the hold key list.
    #: example: resume|1;endcall|2;newcall|3;redial|4;dir|5
    hold_key_list: Optional[str] = None
    #: Specify the ringing key list.
    #: example: answer|1;ignore|2
    ringing_key_list: Optional[str] = None
    #: Specify the shared active key list.
    #: example: newcall|1;psk1|2;dir|3;back|4
    shared_active_key_list: Optional[str] = None
    #: Specify the shared held key list.
    #: example: resume|1;dir|4
    shared_held_key_list: Optional[str] = None


class PskObject(ApiModel):
    #: Specify PSK1.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk1: Optional[str] = None
    #: Specify PSK2.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk2: Optional[str] = None
    #: Specify PSK3.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk3: Optional[str] = None
    #: Specify PSK4.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk4: Optional[str] = None
    #: Specify PSK5.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk5: Optional[str] = None
    #: Specify PSK6.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk6: Optional[str] = None
    #: Specify PSK7.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk7: Optional[str] = None
    #: Specify PSK8.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk8: Optional[str] = None
    #: Specify PSK9.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk9: Optional[str] = None
    #: Specify PSK10.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk10: Optional[str] = None
    #: Specify PSK11.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk11: Optional[str] = None
    #: Specify PSK12.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk12: Optional[str] = None
    #: Specify PSK13.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk13: Optional[str] = None
    #: Specify PSK14.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk14: Optional[str] = None
    #: Specify PSK15.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk15: Optional[str] = None
    #: Specify PSK16.
    #: example: fnc=sd;ext=*11;nme=Call Pull
    psk16: Optional[str] = None


class SoftKeyLayoutObject(ApiModel):
    #: Customize SoftKey menu settings.
    soft_key_menu: Optional[SoftKeyMenuObject] = None
    #: Customize PSK.
    psk: Optional[PskObject] = None
    #: Default SoftKey menu settings.
    soft_key_menu_defaults: Optional[SoftKeyMenuObject] = None
    #: Default PSK.
    psk_defaults: Optional[PskObject] = None


class BackgroundImageColor(str, Enum):
    #: Indicates that dark cyan background image will be set for the devices.
    cyan_dark = 'CYAN_DARK'
    #: Indicates the dark purple background image will be set for the devices.
    purple_dark = 'PURPLE_DARK'
    #: Indicates the dark blue background image will be set for the devices.
    blue_dark = 'BLUE_DARK'
    #: Indicates the dark violet background image will be set for the devices.
    violet_dark = 'VIOLET_DARK'
    #: Indicates the light blue background image will be set for the devices.
    blue_light = 'BLUE_LIGHT'
    #: Indicates the light violet background image will be set for the devices.
    violet_light = 'VIOLET_LIGHT'


class BacklightTimer68XX(str, Enum):
    #: Keep the phone's backlight always on.
    always_on = 'ALWAYS_ON'
    #: Set the phone's backlight to be on for ten seconds.
    ten_sec = 'TEN_SEC'
    #: Set the phone's backlight to be on for twenty seconds.
    twenty_sec = 'TWENTY_SEC'
    #: Set the phone's backlight to be on for thirty seconds.
    thirty_sec = 'THIRTY_SEC'
    #: Keep the phone's backlight off.
    off = 'OFF'


class MppObject(ApiModel):
    #: Indicates whether the PNAC of MPP object is enabled or not.
    #: example: True
    pnac_enabled: Optional[bool] = None
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[MppAudioCodecPriorityObject] = None
    #: Choose the length of time (in minutes) for the phone's backlight to remain on.
    #: example: ONE_MIN
    backlight_timer: Optional[BacklightTimerObject] = None
    #: Holds the background object of MPP Object.
    background: Optional[BackgroundImage] = None
    #: The display name that appears on the phone screen.
    #: example: PERSON_NUMBER
    display_name_format: Optional[DisplayNameSelection] = None
    #: Allows you to enable/disable CDP for local devices.
    cdp_enabled: Optional[bool] = None
    #: Choose the desired logging level for an MPP devices.
    #: example: STANDARD
    default_logging_level: Optional[DefaultLoggingLevelObject] = None
    #: Enable/disable Do-Not-Disturb capabilities for Multi-Platform Phones.
    #: example: True
    dnd_services_enabled: Optional[bool] = None
    #: Holds the Acd object value.
    acd: Optional[AcdObject] = None
    #: Indicates the short inter digit timer value.
    #: example: 14.0
    short_interdigit_timer: Optional[int] = None
    #: Indicates the long inter digit timer value..
    #: example: 16.0
    long_interdigit_timer: Optional[int] = None
    #: Line key labels define the format of what's shown next to line keys.
    #: example: PERSON_EXTENSION
    line_key_label_format: Optional[LineKeyLabelSelection] = None
    #: LED patterns define lighting schemes for the line keys on the MPP devices. Note that this parameter is not
    #: supported on the MPP 8875
    #: example: DEFAULT
    line_key_ledpattern: Optional[LineKeyLEDPattern] = Field(alias='lineKeyLEDPattern', default=None)
    #: Enable/disable Link Layer Discovery Protocol for local devices.
    lldp_enabled: Optional[bool] = None
    #: Enable/disable user-level access to the web interface of Multi-Platform Phones.
    #: example: True
    mpp_user_web_access_enabled: Optional[bool] = None
    #: Select up to 10 Multicast Group URLs (each with a unique Listening Port).
    #: example: ['["192.86.108.226:22"]']
    multicast: Optional[list[str]] = None
    #: Specify the amount of time (in seconds) that a phone can remain off-hook.
    #: example: 30.0
    off_hook_timer: Optional[int] = None
    #: Select the language for your MPP phone. Setting this overrides the default language setting in place for your
    #: provisioned location.
    #: example: RUSSIAN
    phone_language: Optional[PhoneLanguage] = None
    #: Enable/disable the Power-Over-Ethernet mode for Multi-Platform Phones.
    poe_mode: Optional[PoeMode] = None
    #: Allows you to enable/disable tagging of packets from the local device to the Webex Calling platform.
    #: example: True
    qos_enabled: Optional[bool] = None
    #: Specify the amount of inactive time needed (in seconds) before the phone's screen saver activates.
    screen_timeout: Optional[DectVlanObject] = None
    #: Enable/disable the use of the USB ports on Multi-Platform phones.
    #: example: True
    usb_ports_enabled: Optional[bool] = None
    #: Specify a numeric Virtual LAN ID for devices.
    vlan: Optional[MppVlanObject] = None
    #: Specify the Wi-Fi SSID and password for wireless-enabled MPP phones.
    wifi_network: Optional[WifiNetworkObject] = None
    #: Specify the call history information to use. Only applies to user devices.
    call_history: Optional[CallHistoryMethod] = None
    #: Specify the directory services to use.
    contacts: Optional[DirectoryMethod] = None
    #: Enable/disable the availability of the webex meetings functionality from the phone.
    #: example: True
    webex_meetings_enabled: Optional[bool] = None
    #: Specify all volume level values on the phone.
    volume_settings: Optional[VolumeSettingsObject] = None
    #: Specify the call forward expanded soft key behavior.
    cf_expanded_soft_key: Optional[CallForwardExpandedSoftKey] = None
    #: Specify HTTP Proxy values.
    http_proxy: Optional[HttpProxyObject] = None
    #: Enable/disable the visibility of the bluetooth menu on the MPP device.
    bluetooth: Optional[BluetoothObject] = None
    #: Enable/disable the use of the PC passthrough ethernet port on supported phone models.
    #: example: True
    pass_through_port_enabled: Optional[bool] = None
    #: Enable/disable the ability for an end user to set a local password on the phone to restrict local access to the
    #: device.
    #: example: True
    user_password_override_enabled: Optional[bool] = None
    #: Enable/disable the default screen behavior when inbound calls are received.
    #: example: True
    active_call_focus_enabled: Optional[bool] = None
    #: Enable/disable peer firmware sharing.
    #: example: True
    peer_firmware_enabled: Optional[bool] = None
    #: Enable/disable local noise cancellation on active calls from the device.
    noise_cancellation: Optional[NoiseCancellationObject] = None
    #: Enable/disable visibility of the Accessibility Voice Feedback menu on the MPP device.
    #: example: True
    voice_feedback_accessibility_enabled: Optional[bool] = None
    #: Enable/disable availability of dial assist feature on the phone.
    #: example: True
    dial_assist_enabled: Optional[bool] = None
    #: Specify the number of calls per unique line appearance on the phone.
    #: example: 9.0
    calls_per_line: Optional[int] = None
    #: Enable/disable automatic nightly configuration resync of the MPP device.
    #: example: True
    nightly_resync_enabled: Optional[bool] = None
    #: Enable/disable the visual indication of missed calls.
    #: example: True
    missed_call_notification_enabled: Optional[bool] = None
    #: Specify the softkey layout per phone menu state.
    soft_key_layout: Optional[SoftKeyLayoutObject] = None
    #: Specify the image option for the MPP 8875 phone background.
    background_image8875: Optional[BackgroundImageColor] = None
    #: Specify the use of the backlight feature on 6800 nad 7800 series devices.
    backlight_timer68_xx78_xx: Optional[BacklightTimer68XX] = Field(alias='backlightTimer68XX78XX', default=None)


class CommSecurityType(str, Enum):
    #: Sets the LDAP server security protocol to None.
    none_ = 'NONE'
    #: Sets the LDAP server security protocol to SSL.
    ssl = 'SSL'
    #: Sets the LDAP server security protocol to STARTTLS.
    starttls = 'STARTTLS'


class LdapObject(ApiModel):
    #: Sets the values needed to enable use of the LDAP service on the phone.
    enabled: Optional[bool] = None
    #: Sets the values needed to enable use of the LDAP service on the phone.
    #: example: localhost
    server_address: Optional[str] = None
    #: Sets the values needed to enable use of the LDAP service on the phone.
    #: example: 8080.0
    server_port: Optional[int] = None
    #: Indicates the selection of the protocol for LDAP service on the phone.
    #: example: SSL
    comm_security_type: Optional[CommSecurityType] = None
    #: Sets the values needed to enable use of the LDAP service on the phone.
    #: example: bindDn
    bind_dn: Optional[str] = None
    #: Sets the values needed to enable use of the LDAP service on the phone.
    #: example: bindPw
    bind_pw: Optional[str] = None
    #: Sets the values needed to enable use of the LDAP service on the phone.
    #: example: baseDn
    base_dn: Optional[str] = None
    #: Sets the values needed to enable use of the LDAP service on the phone.
    #: example: primaryEmailAttribute
    primary_email_attribute: Optional[str] = None
    #: Sets the values needed to enable use of the LDAP service on the phone.
    #: example: alternateEmailAttribute
    alternate_email_attribute: Optional[str] = None


class WebAccessObject(ApiModel):
    #: Ability to enable or disable the web browser access for the 840/860.
    enabled: Optional[bool] = None
    #: Ability to set a Web Server Password.
    #: example: password
    password: Optional[str] = None


class WifiObject(ApiModel):
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[AudioCodecPriorityObject] = None
    #: Set the values needed to enable use of the LDAP service on the phone.
    ldap: Optional[LdapObject] = None
    #: Set the availability of the local end user web access for an 840/860 WiFi phone.
    web_access: Optional[WebAccessObject] = None
    #: Set the local security password on an 840/860 WiFi phone.
    #: example: phoneSecurityPwd
    phone_security_pwd: Optional[str] = None


class CustomizationObject(ApiModel):
    #: Settings that are applicable to ATA devices.
    ata: Optional[AtaObject] = None
    #: Settings that are applicable to DECT devices.
    dect: Optional[DectObject] = None
    #: Settings that are applicable to MPP devices.
    mpp: Optional[MppObject] = None
    #: Settings that are applicable to WiFi.
    wifi: Optional[WifiObject] = None


class AdminBatchStartJobObjectLocationCustomizations(ApiModel):
    #: Location within an organization where changes of device setings will be applied to all the devices within it.
    #: example: 'Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2E4Mjg5NzIyLTFiODAtNDFiNy05Njc4LTBlNzdhZThjMTA5OA'
    location_id: Optional[str] = None
    #: Indicates if all the devices within this location will be customized with new requested customizations(if set to
    #: `true`) or will be overridden with the one at organization level (if set to `false` or any other value). This
    #: field has no effect when the job is being triggered at organization level.
    location_customizations_enabled: Optional[bool] = None
    #: Indicates the settings for ATA devices, DECT devices and MPP devices.
    customizations: Optional[CustomizationObject] = None


class CountObject(ApiModel):
    #: Indicates the total number of phone numbers requested to be moved.
    total_numbers: Optional[int] = None
    #: Indicates the total number of phone numbers successfully deleted.
    numbers_deleted: Optional[int] = None
    #: Indicates the total number of phone numbers successfully moved.
    numbers_moved: Optional[int] = None
    #: Indicates the total number of phone numbers failed.
    numbers_failed: Optional[int] = None


class CustomizationDeviceLevelObject(ApiModel):
    #: Applicable device settings for an ATA device.
    ata: Optional[AtaObject] = None
    #: Applicable device settings for an MPP device.
    mpp: Optional[MppObject] = None
    #: Applicable device settings for a WiFi device.
    wifi: Optional[WifiObject] = None


class UsbPortsObject(ApiModel):
    #: New Control to Enable/Disable the side USB port.
    enabled: Optional[bool] = None
    #: Enable/disable use of the side USB port on the MPP device. Enabled by default.
    #: example: True
    side_usb_enabled: Optional[bool] = None
    #: Enable/disable use of the rear USB port on the MPP device.
    #: example: True
    rear_usb_enabled: Optional[bool] = None


class MppObjectDevice(ApiModel):
    #: Indicates whether the PNAC of MPP object is enabled or not.
    #: example: True
    pnac_enabled: Optional[bool] = None
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[AudioCodecPriorityObject] = None
    #: Choose the length of time (in minutes) for the phone's backlight to remain on.
    #: example: ONE_MIN
    backlight_timer: Optional[BacklightTimerObject] = None
    #: Holds the background object of MPP Object.
    background: Optional[BackgroundImage] = None
    #: The display name that appears on the phone screen.
    #: example: PERSON_NUMBER
    display_name_format: Optional[DisplayNameSelection] = None
    #: Allows you to enable/disable CDP for local devices.
    cdp_enabled: Optional[bool] = None
    #: Choose the desired logging level for an MPP devices.
    #: example: STANDARD
    default_logging_level: Optional[DefaultLoggingLevelObject] = None
    #: Enable/disable Do-Not-Disturb capabilities for Multi-Platform Phones.
    #: example: True
    dnd_services_enabled: Optional[bool] = None
    #: Holds the Acd object value.
    acd: Optional[AcdObject] = None
    #: Indicates the short inter digit timer value.
    #: example: 14.0
    short_interdigit_timer: Optional[int] = None
    #: Indicates the long inter digit timer value..
    #: example: 16.0
    long_interdigit_timer: Optional[int] = None
    #: Line key labels define the format of what's shown next to line keys.
    #: example: PERSON_EXTENSION
    line_key_label_format: Optional[LineKeyLabelSelection] = None
    #: LED patterns define lighting schemes for the line keys on the MPP devices. Note that this parameter is not
    #: supported on the MPP 8875
    #: example: DEFAULT
    line_key_ledpattern: Optional[LineKeyLEDPattern] = Field(alias='lineKeyLEDPattern', default=None)
    #: Enable/disable Link Layer Discovery Protocol for local devices.
    lldp_enabled: Optional[bool] = None
    #: Enable/disable user-level access to the web interface of Multi-Platform Phones.
    #: example: True
    mpp_user_web_access_enabled: Optional[bool] = None
    #: Select up to 10 Multicast Group URLs (each with a unique Listening Port).
    #: example: ['["192.86.108.226:22"]']
    multicast: Optional[list[str]] = None
    #: Specify the amount of time (in seconds) that a phone can remain off-hook.
    #: example: 30.0
    off_hook_timer: Optional[int] = None
    #: Select the language for your MPP phone. Setting this overrides the default language setting in place for your
    #: provisioned location.
    #: example: RUSSIAN
    phone_language: Optional[PhoneLanguage] = None
    #: Enable/disable the Power-Over-Ethernet mode for Multi-Platform Phones.
    poe_mode: Optional[PoeMode] = None
    #: Allows you to enable/disable tagging of packets from the local device to the Webex Calling platform.
    #: example: True
    qos_enabled: Optional[bool] = None
    #: Specify the amount of inactive time needed (in seconds) before the phone's screen saver activates.
    screen_timeout: Optional[DectVlanObject] = None
    #: Enable/disable the use of the USB ports on Multi-Platform phones.
    #: example: True
    usb_ports_enabled: Optional[bool] = None
    #: By default the Side USB port is enabled to support KEMs and other peripheral devices. Use the option to disable
    #: use of this port.
    usb_ports: Optional[UsbPortsObject] = None
    #: Specify a numeric Virtual LAN ID for devices.
    vlan: Optional[MppVlanObject] = None
    #: Specify the Wi-Fi SSID and password for wireless-enabled MPP phones.
    wifi_network: Optional[WifiNetworkObject] = None
    #: Specify the call history information to use. Only applies to user devices.
    call_history: Optional[CallHistoryMethod] = None
    #: Specify the directory services to use.
    contacts: Optional[DirectoryMethod] = None
    #: Enable/disable the availability of the webex meetings functionality from the phone.
    #: example: True
    webex_meetings_enabled: Optional[bool] = None
    #: Specify all volume level values on the phone.
    volume_settings: Optional[VolumeSettingsObject] = None
    #: Specify the call forward expanded soft key behavior.
    cf_expanded_soft_key: Optional[CallForwardExpandedSoftKey] = None
    #: Specify HTTP Proxy values.
    http_proxy: Optional[HttpProxyObject] = None
    #: Enable/disable the visibility of the bluetooth menu on the MPP device.
    bluetooth: Optional[BluetoothObject] = None
    #: Enable/disable the use of the PC passthrough ethernet port on supported phone models.
    #: example: True
    pass_through_port_enabled: Optional[bool] = None
    #: Enable/disable the ability for an end user to set a local password on the phone to restrict local access to the
    #: device.
    #: example: True
    user_password_override_enabled: Optional[bool] = None
    #: Enable/disable the default screen behavior when inbound calls are received.
    #: example: True
    active_call_focus_enabled: Optional[bool] = None
    #: Enable/disable peer firmware sharing.
    #: example: True
    peer_firmware_enabled: Optional[bool] = None
    #: Enable/disable local noise cancellation on active calls from the device.
    noise_cancellation: Optional[NoiseCancellationObject] = None
    #: Enable/disable visibility of the Accessibility Voice Feedback menu on the MPP device.
    #: example: True
    voice_feedback_accessibility_enabled: Optional[bool] = None
    #: Enable/disable availability of dial assist feature on the phone.
    #: example: True
    dial_assist_enabled: Optional[bool] = None
    #: Specify the number of calls per unique line appearance on the phone.
    #: example: 9.0
    calls_per_line: Optional[int] = None
    #: Enable/disable automatic nightly configuration resync of the MPP device.
    #: example: True
    nightly_resync_enabled: Optional[bool] = None
    #: Enable/disable the visual indication of missed calls.
    #: example: True
    missed_call_notification_enabled: Optional[bool] = None
    #: Specify the softkey layout per phone menu state.
    soft_key_layout: Optional[SoftKeyLayoutObject] = None
    #: Specify the image option for the MPP 8875 phone background.
    background_image8875: Optional[BackgroundImageColor] = None
    #: Specify the use of the backlight feature on 6800 nad 7800 series devices.
    backlight_timer68_xx78_xx: Optional[BacklightTimer68XX] = Field(alias='backlightTimer68XX78XX', default=None)


class WifiObjectDevice(ApiModel):
    #: Choose up to three predefined codec priority options available for your region.
    audio_codec_priority: Optional[MppAudioCodecPriorityObject] = None
    #: Set the values needed to enable use of the LDAP service on the phone.
    ldap: Optional[LdapObject] = None
    #: Set the availability of the local end user web access for an 840/860 WiFi phone.
    web_access: Optional[WebAccessObject] = None
    #: Set the local security password on an 840/860 WiFi phone.
    #: example: phoneSecurityPwd
    phone_security_pwd: Optional[str] = None


class CustomizationDeviceLevelObjectDevice(ApiModel):
    #: Applicable device settings for an ATA device.
    ata: Optional[AtaObject] = None
    #: Applicable device settings for an MPP device.
    mpp: Optional[MppObjectDevice] = None
    #: Applicable device settings for a WiFi device.
    wifi: Optional[WifiObjectDevice] = None


class DectDeviceList(ApiModel):
    #: Model name of the device.
    #: example: DMS Cisco DBS110
    model: Optional[str] = None
    #: Display name of the device.
    #: example: Cisco DECT 210 Base
    display_name: Optional[str] = None
    #: Indicates number of base stations.
    #: example: 250.0
    number_of_base_stations: Optional[int] = None
    #: Indicates number of port lines,
    #: example: 1000.0
    number_of_line_ports: Optional[int] = None
    #: Indicates number of supported registrations.
    #: example: 30.0
    number_of_registrations_supported: Optional[int] = None


class TypeObject(str, Enum):
    #: Cisco Multiplatform Phone
    mpp = 'MPP'
    #: Analog Telephone Adapters
    ata = 'ATA'
    #: GENERIC Session Initiation Protocol
    generic_sip = 'GENERIC_SIP'
    #: Esim Supported Webex Go
    esim = 'ESIM'


class ManufacturerObject(str, Enum):
    #: Devices manufactured by Cisco.
    cisco = 'CISCO'
    #: Devices manufactured by a third-party that are approved by a Cisco account manager to be enabled for
    #: provisioning in the control hub.
    third_party = 'THIRD_PARTY'


class ManagedByObject(str, Enum):
    #: Devices managed by Cisco.
    cisco = 'CISCO'
    #: Devices managed by a customer that are approved by a Cisco account manager to be enabled for provisioning in the
    #: control hub.
    customer = 'CUSTOMER'


class OnboardingMethodObject(str, Enum):
    mac_address = 'MAC_ADDRESS'
    activation_code = 'ACTIVATION_CODE'
    none_ = 'NONE'


class KemModuleTypeObject(str, Enum):
    kem_14_keys = 'KEM_14_KEYS'
    kem_18_keys = 'KEM_18_KEYS'


class DeviceObject(ApiModel):
    #: Model name of the device.
    #: example: 2N Customer Managed
    model: Optional[str] = None
    #: Display name of the device.
    #: example: 2N Customer Managed
    display_name: Optional[str] = None
    #: Type of the device.
    #: example: GENERIC_SIP
    type: Optional[TypeObject] = None
    #: Manufacturer of the device.
    #: example: THIRD_PARTY
    manufacturer: Optional[ManufacturerObject] = None
    #: Users who manage the device.
    #: example: CUSTOMER
    managed_by: Optional[ManagedByObject] = None
    #: List of places the device is supported for.
    supported_for: Optional[list[MemberType1]] = None
    #: Onboarding method.
    onboarding_method: Optional[list[OnboardingMethodObject]] = None
    #: Enables / Disables layout configuration for devices.
    allow_configure_layout_enabled: Optional[bool] = None
    #: Number of port lines.
    number_of_line_ports: Optional[int] = None
    #: Indicates whether Kem support is enabled or not.
    #: example: True
    kem_support_enabled: Optional[bool] = None
    #: Module count.
    kem_module_count: Optional[int] = None
    #: Key expansion module type of the device.
    kem_module_type: Optional[list[KemModuleTypeObject]] = None
    #: Enables / Disables the upgrade channel.
    upgrade_channel_enabled: Optional[bool] = None
    #: The default upgrade channel.
    default_upgrade_channel: Optional[str] = None
    #: Enables / disables the additional primary line appearances.
    additional_primary_line_appearances_enabled: Optional[bool] = None
    #: Enables / disables Basic emergency nomadic.
    basic_emergency_nomadic_enabled: Optional[bool] = None
    #: Enables / disables customized behavior support on devices.
    customized_behaviors_enabled: Optional[bool] = None
    #: Enables / disables configuring port support on device.
    allow_configure_ports_enabled: Optional[bool] = None
    #: Enables / disables customizable line label.
    customizable_line_label_enabled: Optional[bool] = None


class DeviceSettingsObject(ApiModel):
    #: Indicates the customization object of the device settings.
    customizations: Optional[CustomizationDeviceLevelObject] = None
    #: Indicates if customization is allowed at a location level. If `true`, customized at a location level. If
    #: `false`, not customized; uses customer-level configuration.
    #: example: True
    custom_enabled: Optional[bool] = None
    #: Customer devices setting update status. If `true`, an update is in progress (no further changes are allowed).
    #: `If false`, no update in progress (changes are allowed).
    #: example: True
    update_in_progress: Optional[bool] = None
    #: Number of devices that will be updated.
    #: example: 9.0
    device_count: Optional[int] = None
    #: Indicates the last updated time.
    #: example: 1659624763665.0
    last_update_time: Optional[int] = None


class DeviceSettingsObjectForDeviceLevel(ApiModel):
    #: Indicates the customization object of the device settings.
    customizations: Optional[CustomizationDeviceLevelObjectDevice] = None
    #: Indicates if customization is allowed at a device level. If `true`, customized at a device level. If `false`,
    #: not customized; uses customer-level configuration.
    #: example: True
    custom_enabled: Optional[bool] = None
    #: Customer devices setting update status. If `true`, an update is in progress (no further changes are allowed).
    #: `If false`, no update in progress (changes are allowed).
    #: example: True
    update_in_progress: Optional[bool] = None
    #: Number of devices that will be updated.
    #: example: 9.0
    device_count: Optional[int] = None
    #: Indicates the last updated time.
    #: example: 1659624763665.0
    last_update_time: Optional[int] = None


class ItemObject(ApiModel):
    #: Phone number
    item: Optional[str] = None
    #: Index of error number.
    item_number: Optional[int] = None
    #: Unique identifier to track the HTTP requests.
    tracking_id: Optional[str] = None
    error: Optional[Error1] = None


class ErrorResponseObject(ApiModel):
    items: Optional[list[ItemObject]] = None


class MemberObject1(ApiModel):
    #: Unique identifier for the member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    id: Optional[str] = None
    #: First name of a person or workspace.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of a person or workspace.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone Number of a person or workspace. In some regions phone numbers are not returned in E.164 format. This will
    #: be supported in a future update.
    #: example: 2055552221
    phone_number: Optional[str] = None
    #: Extension of a person or workspace.
    #: example: 000
    extension: Optional[str] = None
    #: This field indicates whether the person or the workspace is the owner of the device, and points to a primary
    #: Line/Port of the device.
    #: example: True
    primary_owner: Optional[bool] = None
    #: Port number assigned to person or workspace.
    #: example: 1.0
    port: Optional[int] = None
    #: T.38 Fax Compression setting and is available only for ATA Devices. Choose T.38 fax compression if the device
    #: requires this option. This will override user level compression options.
    t38_fax_compression_enabled: Optional[bool] = None
    #: Line type is used to differentiate Primary and SCA, at which endpoint it is assigned.
    line_type: Optional[LineType] = None
    #: Number of lines that have been configured for the person on the device.
    #: example: 1.0
    line_weight: Optional[int] = None
    #: Registration Host IP address for the line port.
    #: example: 10.0.0.45
    host_ip: Optional[str] = Field(alias='hostIP', default=None)
    #: Registration Remote IP address for the line port.
    #: example: 192.102.12.84
    remote_ip: Optional[str] = Field(alias='remoteIP', default=None)
    #: Enable Hotline. Configure this line to automatically call a predefined number whenever taken off-hook. Once
    #: enabled, the line can only make calls to the predefined number set in hotlineDestination.
    #: example: True
    hotline_enabled: Optional[bool] = None
    #: The preconfigured number for Hotline. Required only if `hotlineEnabled` is set to true.
    #: example: +12055552222
    hotline_destination: Optional[str] = None
    #: Set how a person's device behaves when a call is declined. When set to true, a call decline request is extended
    #: to all the endpoints on the device. When set to false, a call decline request only declines the current
    #: endpoint.
    #: example: True
    allow_call_decline_enabled: Optional[bool] = None
    #: Device line label.
    #: example: share line label
    line_label: Optional[str] = None
    #: SIP username used in SIP signaling, for example, in registration.
    #: example: evypzco5ds@55552222.int10.bcld.webex.com
    line_port: Optional[str] = None
    #: Indicates if the member is of type `PEOPLE` or `PLACE`.
    member_type: Optional[MemberType1] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class GetMemberResponse1(ApiModel):
    #: Model type of the device.
    #: example: DMS Cisco 192
    model: Optional[str] = None
    #: List of members that appear on the device.
    members: Optional[list[MemberObject1]] = None
    #: Maximum number of lines available for the device.
    #: example: 10.0
    max_line_count: Optional[int] = None


class Hoteling(ApiModel):
    #: Enable/Disable hoteling Host. Enabling the device for hoteling means that a guest(end user) can log into this
    #: host(workspace device) and use this device
    #: 
    #: as if it were their own. This is useful when traveling to a remote office but still needing to place/receive
    #: calls with their telephone number and access features normally available to them on their office phone.
    enabled: Optional[bool] = None
    #: Enable limiting the time a guest can use the device. The time limit is configured via `guestHoursLimit`.
    limit_guest_use: Optional[bool] = None
    #: Time Limit in hours until hoteling is enabled. Mandatory if `limitGuestUse` is enabled.
    guest_hours_limit: Optional[int] = None


class JobExecutionStatusObject(ApiModel):
    #: Unique identifier that identifies each instance of the job.
    id: Optional[int] = None
    #: Last updated time (in UTC format) post one of the step execution completion.
    last_updated: Optional[str] = None
    #: Displays status for overall steps that are part of the job.
    status_message: Optional[str] = None
    #: Exit Code for a job.
    exit_code: Optional[str] = None
    #: Job creation time in UTC format.
    created_time: Optional[str] = None
    #: Time lapsed since the job execution started.
    time_elapsed: Optional[str] = None
    #: Status of each step within a job.
    step_execution_statuses: Optional[list[StepExecutionStatuses]] = None


class JobExecutionStatusObject1(ApiModel):
    #: Unique identifier that identifies each instance of the job.
    id: Optional[int] = None
    #: Last updated time (in UTC format) post one of the step execution completion.
    last_updated: Optional[str] = None
    #: Displays status for overall steps that are part of the job.
    status_message: Optional[str] = None
    #: Exit Code for a job.
    exit_code: Optional[str] = None
    #: Job creation time in UTC format.
    created_time: Optional[str] = None
    #: Time lapsed since the job execution started.
    time_elapsed: Optional[str] = None


class StartJobResponse(ApiModel):
    #: Job name.
    name: Optional[str] = None
    #: Unique identifier of the job.
    id: Optional[str] = None
    #: Job type.
    job_type: Optional[str] = None
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str] = None
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str] = None
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str] = None
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str] = None
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int] = None
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatusObject1]] = None
    #: Indicates the most recent status (STARTING, STARTED, COMPLETED, FAILED) of the job at the time of invocation.
    latest_execution_status: Optional[str] = None
    #: Indicates operation type that was carried out.
    operation_type: Optional[str] = None
    #: Unique location identifier for which the job was run.
    source_location_id: Optional[str] = None
    #: Unique location identifier for which the numbers have been moved.
    target_location_id: Optional[str] = None
    #: Job statistics.
    counts: Optional[CountObject] = None


class JobListResponse(ApiModel):
    #: Lists all jobs for the customer in order of most recent one to oldest one irrespective of its status.
    items: Optional[list[StartJobResponse]] = None


class ListDectDeviceType(ApiModel):
    #: Contains a list of devices.
    devices: Optional[list[DectDeviceList]] = None


class ListDeviceSettingsObject(ApiModel):
    #: Customization object of the device settings.
    customizations: Optional[CustomizationObject] = None
    #: Progress of the device update.
    update_in_progress: Optional[bool] = None
    #: Device count.
    #: example: 22.0
    device_count: Optional[int] = None
    #: Last updated time.
    #: example: 1659624763665.0
    last_update_time: Optional[int] = None


class MacStatusObjectState(str, Enum):
    #: The requested MAC address is available.
    available = 'AVAILABLE'
    #: The requested MAC address is unavailable.
    unavailable = 'UNAVAILABLE'
    #: The requested MAC address is duplicated.
    duplicate_in_list = 'DUPLICATE_IN_LIST'
    #: The requested MAC address is invalid.
    invalid = 'INVALID'


class MacStatusObject(ApiModel):
    #: MAC address.
    #: example: 00005E0053B4
    mac: Optional[str] = None
    #: State of the MAC address.
    #: example: UNAVAILABLE
    state: Optional[MacStatusObjectState] = None
    #: MAC address validation error code.
    #: example: 5675.0
    error_code: Optional[int] = None
    #: Provides a status message about the MAC address.
    #: example: [Error 5675] MAC Address is in use.
    message: Optional[str] = None


class MACAddressResponse(ApiModel):
    #: Status of MAC address.
    #: example: ERRORS
    status: Optional[PostValidateExtensionResponseStatus] = None
    #: Contains an array of all the MAC address provided and their statuses.
    mac_status: Optional[list[MacStatusObject]] = None


class PutDeviceSettingsRequest(ApiModel):
    #: Indicates the customization object of the device settings.
    customizations: Optional[CustomizationDeviceLevelObjectDevice] = None
    #: Indicates if customization is allowed at a device level. If true, customized at a device level. If false, not
    #: customized; uses customer-level configuration.
    #: example: True
    custom_enabled: Optional[bool] = None


class PutMemberObject(ApiModel):
    #: Person's assigned port number.
    #: example: 1.0
    port: Optional[int] = None
    #: Unique identifier for the member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9jODhiZGIwNC1jZjU5LTRjMjMtODQ4OC00NTNhOTE3ZDFlMjk
    id: Optional[str] = None
    #: T.38 Fax Compression setting and is available only for ATA Devices. Choose T.38 fax compression if the device
    #: requires this option. This will override user level compression options.
    t38_fax_compression_enabled: Optional[bool] = None
    #: Whether the user is the owner of the device or not, and points to a primary Line/Port of device.
    #: example: True
    primary_owner: Optional[bool] = None
    #: Line type is used to differentiate Primary and SCA, at which endpoint it is assigned.
    line_type: Optional[LineType] = None
    #: Number of lines that have been configured for the person on the device.
    #: example: 1.0
    line_weight: Optional[int] = None
    #: Enable Hotline. Configure this line to automatically call a predefined number whenever taken off-hook. Once
    #: enabled, the line can only make calls to the predefined number set in hotlineDestination.
    #: example: True
    hotline_enabled: Optional[bool] = None
    #: The preconfigured number for Hotline. Required only if `hotlineEnabled` is set to true.
    #: example: +12055552222
    hotline_destination: Optional[str] = None
    #: Set how a person's device behaves when a call is declined. When set to true, a call decline request is extended
    #: to all the endpoints on the device. When set to false, a call decline request only declines the current
    #: endpoint.
    #: example: True
    allow_call_decline_enabled: Optional[bool] = None
    #: Device line label.
    #: example: share line label
    line_label: Optional[str] = None


class PutMembersRequest(ApiModel):
    #: If the member's list is missing then all the users are removed except the primary user.
    members: Optional[list[PutMemberObject]] = None


class ValidateMACRequest(ApiModel):
    #: MAC addresses to be validated.
    #: example: ['{["ab125678cdef"', '"00005E0053B4"]}']
    macs: Optional[list[str]] = None


class DeviceOwner(ApiModel):
    #: Unique identifier of a person or a workspace.
    id: Optional[str] = None
    #: Enumeration that indicates if the member is of type `PEOPLE` or `PLACE`.
    type: Optional[MemberType1] = None
    #: First name of device owner.
    first_name: Optional[str] = None
    #: Last name of device owner.
    last_name: Optional[str] = None


class Devices(ApiModel):
    #: Unique identifier for a device.
    id: Optional[str] = None
    #: Comma separated array of tags used to describe device.
    description: Optional[list[str]] = None
    #: Identifier for device model.
    model: Optional[str] = None
    #: MAC address of device.
    mac: Optional[str] = None
    #: IP address of device.
    ip_address: Optional[str] = None
    #: Indicates whether the person or the workspace is the owner of the device, and points to a primary Line/Port of
    #: the device.
    primary_owner: Optional[bool] = None
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    type: Optional[LineType] = None
    #: Hoteling settings, which are available when the device is the user's primary device and device type is PRIMARY
    hoteling: Optional[Hoteling] = None
    #: Owner of device.
    owner: Optional[DeviceOwner] = None
    #: Activation state of device.
    activation_state: Optional[ActivationStates] = None


class DeviceList(ApiModel):
    #: Array of devices available to person.
    devices: Optional[list[Devices]] = None
    #: Maximum number of devices a person can be assigned to.
    max_device_count: Optional[int] = None


class JobIdResponseObject(ApiModel):
    #: Job name.
    name: Optional[str] = None
    #: Unique identifier of the job.
    id: Optional[str] = None
    #: Job type.
    job_type: Optional[str] = None
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str] = None
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str] = None
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str] = None
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str] = None
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int] = None
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatusObject]] = None
    #: Indicates the most recent status (STARTING, STARTED, COMPLETED, FAILED) of the job at the time of invocation.
    latest_execution_status: Optional[str] = None
    #: Indicates the operation type that was carried out.
    operation_type: Optional[str] = None
    #: Unique location identifier for which the job was run.
    source_location_id: Optional[str] = None
    #: Unique location identifier for which the numbers have been moved.
    target_location_id: Optional[str] = None
    #: The location name for which the job was run.
    source_location_name: Optional[str] = None
    #: The location name for which the numbers have been moved.
    target_location_name: Optional[str] = None
    #: Job statistics.
    counts: Optional[CountObject] = None


class SupportedDevicesObject(ApiModel):
    #: List of supported devices.
    devices: Optional[list[DeviceObject]] = None


class GetLineKeyTemplateResponse(ApiModel):
    #: Unique identifier for the Line Key Template.
    #: example: Y2lzY29zcGFyazovL3VzL0RFVklDRV9MSU5FX0tFWV9URU1QTEFURS81NzVhMWY3Zi03MjRkLTRmZGUtODk4NC1mNjNhNDljMzYxZmQ
    id: Optional[str] = None
    #: Name of the Line Key Template.
    #: example: Basic Template
    template_name: Optional[str] = None
    #: The Device Model for which the Line Key Template is applicable.
    #: example: 'DMS Cisco 6821'
    device_model: Optional[str] = None
    #: The friendly display name used to represent the device model in Control Hub.
    #: example: Cisco 6821
    model_display_name: Optional[str] = None
    #: Indicates whether user can reorder the line keys.
    user_reorder_enabled: Optional[bool] = None


class LineKeyType(str, Enum):
    #: PRIMARY_LINE is the user's primary extension. This is the default assignment for Line Key Index 1 and cannot be
    #: modified.
    primary_line = 'PRIMARY_LINE'
    #: Shows the appearance of other users on the owner's phone.
    shared_line = 'SHARED_LINE'
    #: Enables User and Call Park monitoring.
    monitor = 'MONITOR'
    #: Allows users to reach a telephone number, extension or a SIP URI.
    speed_dial = 'SPEED_DIAL'
    #: An open key will automatically take the configuration of a monitor button starting with the first open key.
    #: These buttons are also usable by the user to configure speed dial numbers on these keys.
    open = 'OPEN'
    #: Button not usable but reserved for future features.
    closed = 'CLOSED'


class ApplyLineKeyTemplateJobDetails(ApiModel):
    #: Job name.
    name: Optional[str] = None
    #: Unique identifier of the job.
    id: Optional[str] = None
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str] = None
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str] = None
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str] = None
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str] = None
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int] = None
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatusObject]] = None
    #: Indicates the most recent status (`STARTING`, `STARTED`, `COMPLETED`, `FAILED`) of the job at the time of
    #: invocation.
    latest_execution_status: Optional[str] = None
    #: Indicates the progress of the job.
    percentage_complete: Optional[str] = None
    #: Number of job steps completed.
    updated_count: Optional[str] = None
    #: Number of job steps completed with advisories.
    advisory_count: Optional[str] = None


class ApplyLineKeyTemplateJobList(ApiModel):
    #: List of Apply Line Key Template jobs.
    items: Optional[list[ApplyLineKeyTemplateJobDetails]] = None


class ApplyLineKeyTemplateJobErrors(ApiModel):
    #: Unique identifier to track the HTTP requests.
    tracking_id: Optional[str] = None
    #: Description of errors in the job.
    error: Optional[ErrorMessage] = None


class PostApplyLineKeyTemplateRequestAction(str, Enum):
    #: Used to apply LinekeyTemplate to devices.
    apply_template = 'APPLY_TEMPLATE'
    #: Used to reset devices to its default Linekey Template configurations.
    apply_default_templates = 'APPLY_DEFAULT_TEMPLATES'


class PostApplyLineKeyTemplateRequest(ApiModel):
    #: Line key Template action to perform.
    #: example: APPLY_TEMPLATE
    action: Optional[PostApplyLineKeyTemplateRequestAction] = None
    #: `templateId` is required for `APPLY_TEMPLATE` action.
    #: example: Y2lzY29zcGFyazovL1VTL0RFVklDRV9MSU5FX0tFWV9URU1QTEFURS9kNDUzM2MwYi1hZGRmLTRjODUtODk0YS1hZTVkOTAyYzAyMDM=
    template_id: Optional[str] = None
    #: Used to search for devices only in the given locations.
    location_ids: Optional[list[str]] = None
    #: Indicates whether to exclude devices with custom layout.
    exclude_devices_with_custom_layout: Optional[bool] = None
    #: Include devices only with these tags.
    include_device_tags: Optional[list[str]] = None
    #: Exclude devices with these tags.
    exclude_device_tags: Optional[list[str]] = None
    #: Refine search by warnings for More shared appearances than shared users.
    #: example: True
    more_shared_appearances_enabled: Optional[bool] = None
    #: Refine search by warnings for Fewer shared appearances than shared users.
    #: example: True
    few_shared_appearances_enabled: Optional[bool] = None
    #: Refine search by warnings for more monitor appearances than monitors.
    #: example: True
    more_monitor_appearances_enabled: Optional[bool] = None


class ProgrammableLineKeys(ApiModel):
    #: An index representing a Line Key. Index starts from 1 representing the first key on the left side of the phone.
    #: example: 2.0
    line_key_index: Optional[int] = None
    #: The action that would be performed when the Line Key is pressed.
    #: example: SPEED_DIAL
    line_key_type: Optional[LineKeyType] = None
    #: This is applicable only when the lineKeyType is `SPEED_DIAL`.
    #: example: Help Line
    line_key_label: Optional[str] = None
    #: This is applicable only when the lineKeyType is `SPEED_DIAL` and the value must be a valid Telephone Number,
    #: Ext, or SIP URI (format: user@host using A-Z,a-z,0-9,-_ .+ for user and host).
    #: example: 5646
    line_key_value: Optional[datetime] = None


class PostLineKeyTemplateRequest(ApiModel):
    #: Name of the Line Key Template.
    #: example: template for 8845
    template_name: Optional[str] = None
    #: The Device Model for which the Line Key Template is applicable.
    #: example: DMS Cisco 8845
    device_model: Optional[str] = None
    #: User Customization Enabled.
    #: example: True
    user_reorder_enabled: Optional[bool] = None
    #: Contains a mapping of Line Keys and their corresponding actions.
    line_keys: Optional[list[ProgrammableLineKeys]] = None


class PutLineKeyTemplateRequest(ApiModel):
    #: Indicates whether the user can reorder the line keys.
    #: example: True
    user_reorder_enabled: Optional[bool] = None
    #: List of line keys that are being updated.
    line_keys: Optional[list[ProgrammableLineKeys]] = None


class LineKeyTemplatesResponse(ApiModel):
    #: Unique identifier for the Line Key Template.
    #: example: Y2lzY29zcGFyazovL1VTL0RFVklDRV9MSU5FX0tFWV9URU1QTEFURS9kNDUzM2MwYi1hZGRmLTRjODUtODk0YS1hZTVkOTAyYzAyMDM=
    id: Optional[str] = None
    #: Name of the Line Key Template.
    #: example: template for 8845
    template_name: Optional[str] = None
    #: The Device Model for which the Line Key Template is applicable.
    #: example: DMS Cisco 8845
    device_model: Optional[str] = None
    #: The friendly display name used to represent the device model in Control Hub.
    #: example: Cisco 8845
    model_display_name: Optional[str] = None


class GetThirdPartyDeviceObject(ApiModel):
    #: Manufacturer of the device.
    #: example: THIRD_PARTY
    manufacturer: Optional[str] = None
    #: The Line/Port identifies a device endpoint in standalone mode or a SIP URI public identity in IMS mode.
    #: example: lg1_sias10_cpapi16004_LGU@64941297.int10.bcld.webex.com
    line_port: Optional[str] = None
    #: Contains the body of the HTTP response received following the request to the Console API. Not set if the
    #: response has no body.
    #: example: hs17.hosted-int.bcld.webex.com
    outbound_proxy: Optional[str] = None
    #: Device manager(s).
    #: example: CUSTOMER
    managed_by: Optional[str] = None
    #: SIP authentication user name for the owner of the device.
    #: example: 392829
    sip_user_name: Optional[str] = None


class PutThirdPartyDevice(ApiModel):
    #: Password to be updated.
    #: example: Test4Password123&
    sip_password: Optional[str] = None


class ReadTheListOfLineKeyTemplatesResponse(ApiModel):
    #: Array of Line Key Templates.
    line_key_templates: Optional[list[LineKeyTemplatesResponse]] = None


class PreviewApplyLineKeyTemplateResponse(ApiModel):
    #: Number of devices affected.
    device_count: Optional[int] = None


class ActivationCode(ApiModel):
    #: The activation code.
    #: example: 5414011256173816
    code: Optional[str] = None
    #: The date and time the activation code expires.
    #: example: 2017-11-16T23:38:03.215Z
    expiry_time: Optional[datetime] = None


class DeviceConnectionStatus(str, Enum):
    connected = 'connected'
    disconnected = 'disconnected'
    connected_with_issues = 'connected_with_issues'
    offline_expired = 'offline_expired'
    activating = 'activating'
    unknown = 'unknown'


class NetworkConnectivityType(str, Enum):
    wired = 'wired'


class ManagedBy(str, Enum):
    cisco = 'CISCO'
    customer = 'CUSTOMER'
    partner = 'PARTNER'


class Device(ApiModel):
    #: A unique identifier for the device.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMV9pbnQxMy9ERVZJQ0UvNTEwMUIwN0ItNEY4Ri00RUY3LUI1NjUtREIxOUM3QjcyM0Y3
    id: Optional[str] = None
    #: A friendly name for the device.
    #: example: SFO12-3-PanHandle
    display_name: Optional[str] = None
    #: The placeId field has been deprecated. Please use workspaceId instead.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83MTZlOWQxYy1jYTQ0LTRmZWQtOGZjYS05ZGY0YjRmNDE3ZjU
    place_id: Optional[str] = None
    #: The workspace associated with the device.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83MTZlOWQxYy1jYTQ0LTRmZWQtOGZjYS05ZGY0YjRmNDE3ZjU
    workspace_id: Optional[str] = None
    #: The person associated with the device.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83MTZlOWQxYy1jYTQ0LTRmZWQtOGZjYS05ZGY0YjRmNDE3ZjU
    person_id: Optional[str] = None
    #: The organization associated with the device.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The capabilities of the device.
    #: example: ['xapi']
    capabilities: Optional[list[str]] = None
    #: The permissions the user has for this device. For example, `xapi` means this user is entitled to using the
    #: `xapi` against this device.
    #: example: ['xapi']
    permissions: Optional[list[str]] = None
    #: The connection status of the device.
    #: example: connected
    connection_status: Optional[DeviceConnectionStatus] = None
    #: The product name. A display friendly version of the device's `model`.
    #: example: Cisco Webex DX80
    product: Optional[str] = None
    #: The product type.
    #: example: roomdesk
    type: Optional[str] = None
    #: Tags assigned to the device.
    #: example: ['First Tag', 'Second Tag']
    tags: Optional[list[str]] = None
    #: The current IP address of the device.
    #: example: 100.110.120.130
    ip: Optional[str] = None
    #: The current network connectivty for the device.
    #: example: wired
    active_interface: Optional[NetworkConnectivityType] = None
    #: The unique address for the network adapter.
    #: example: 11:22:33:44:AA:FF
    mac: Optional[str] = None
    #: The primary SIP address to dial this device.
    #: example: sample_device@sample_workspacename.orgname.org
    primary_sip_url: Optional[str] = None
    #: All SIP addresses to dial this device.
    #: example: ['sample_device@sample_workspacename.orgname.org', 'another_device@sample_workspacename.orgname.org']
    sip_urls: Optional[list[str]] = None
    #: Serial number for the device.
    #: example: FOC1923NVVN
    serial: Optional[str] = None
    #: The operating system name data and version tag.
    #: example: RoomOS 2018-06-01 608dcdbb6e1
    software: Optional[str] = None
    #: The upgrade channel the device is assigned to.
    #: example: beta
    upgrade_channel: Optional[str] = None
    #: The date and time that the device was registered, in ISO8601 format.
    #: example: 2016-04-21T17:00:00.000Z
    created: Optional[datetime] = None
    #: The workspace location associated with the device.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    workspace_location_id: Optional[str] = None
    #: Error codes coming from the device.
    #: example: ['sipprofileregistration']
    error_codes: Optional[list[str]] = None
    #: Timestamp of the first time device sent a status post.
    #: example: 2021-02-24T09:08:38.822Z
    first_seen: Optional[datetime] = None
    #: Timestamp of the last time device sent a status post.
    #: example: 2023-08-15T14:04:00.444Z
    last_seen: Optional[datetime] = None
    #: Entity managing the device configuration.
    #: example: CISCO
    managed_by: Optional[ManagedBy] = None


class DeviceCollectionResponse(ApiModel):
    items: Optional[list[Device]] = None


class DevicePermissions(str, Enum):
    xapi_readonly = 'xapi:readonly'
    xapi_all = 'xapi:all'


class DeviceCapabilities(str, Enum):
    xapi = 'xapi'


class ListDevicesProduct(str, Enum):
    dx_80 = 'DX-80'
    room_kit = 'RoomKit'
    sx_80 = 'SX-80'


class ListDevicesType(str, Enum):
    roomdesk = 'roomdesk'
    phone = 'phone'
    accessory = 'accessory'
    webexgo = 'webexgo'
    unknown = 'unknown'


class ModifyDeviceTagsOp(str, Enum):
    #: Add all specified tags to the existing device tags list.
    add = 'add'
    #: Remove all tags that the device currently has.
    remove = 'remove'
    #: Replace the tags currently on the device with the specified list.
    replace = 'replace'


class ECMFolderRoomType(str, Enum):
    #: 1:1 room
    direct = 'direct'
    #: group room
    group = 'group'


class ECMFolder(ApiModel):
    #: A unique identifier for the folder.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL1RBQlMvZDg1ZTYwNj
    id: Optional[str] = None
    #: A unique identifier for the room to which the folder should be linked to.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The room type.
    #: example: group
    room_type: Optional[ECMFolderRoomType] = None
    #: Sharepoint or OneDrive drive id. It can be queried via MS Graph APIs.
    #: example: 123
    drive_id: Optional[datetime] = None
    #: Sharepoint or OneDrive item id. It can be queried via MS Graph APIs.
    #: example: 456
    item_id: Optional[datetime] = None
    #: Indicates if this is the default content storage for the room.
    #: example: false
    default_folder: Optional[str] = None
    #: This should match the folder name in the ECM backend.
    #: example: OneDrive folder for shared documents
    display_name: Optional[str] = None
    #: Folder's content URL.
    #: example: https://cisco-my.sharepoint.com/personal/naalluri/123
    content_url: Optional[str] = None
    #: The person ID of the person who created this folder link.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    creator_id: Optional[str] = None
    #: The date and time when the folder link was created.
    #: example: 2015-10-18T14:26:16.203Z
    created: Optional[datetime] = None


class ECMFolderCollectionResponse(ApiModel):
    items: Optional[list[ECMFolder]] = None


class EventData(ApiModel):
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    id: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: example: group
    room_type: Optional[str] = None
    #: example: PROJECT UPDATE - A new project plan has been published: http://example.com/s/lf5vj. The PM for this project is Mike C. and the Engineering Manager is Jane W.
    text: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: example: matt@example.com
    person_email: Optional[str] = None
    #: example: 2016-05-16T21:34:59.324Z
    created: Optional[datetime] = None


class EventResourceEnum(str, Enum):
    #: State changed on the messages resource.
    messages = 'messages'
    #: State changed on the memberships resource.
    memberships = 'memberships'


class EventTypeEnum(str, Enum):
    #: The resource has been created.
    created = 'created'
    #: A property on the resource has been updated.
    updated = 'updated'
    #: The resource has been deleted.
    deleted = 'deleted'


class Event(ApiModel):
    #: The unique identifier for the event.
    #: example: Y2lzY29zcGFyazovL3VzL0VWRU5UL2JiY2ViMWFkLTQzZjEtM2I1OC05MTQ3LWYxNGJiMGM0ZDE1NAo
    id: Optional[str] = None
    #: The type of resource in the event.
    #: example: messages
    resource: Optional[EventResourceEnum] = None
    #: The action which took place in the event.
    #: example: created
    type: Optional[EventTypeEnum] = None
    #: The ID of the application for the event.
    #: example: null
    app_id: Optional[str] = None
    #: The ID of the person who performed the action.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    actor_id: Optional[str] = None
    #: The ID of the organization for the event.
    #: example: OTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    org_id: Optional[str] = None
    #: The date and time of the event.
    #: example: 2016-05-16T21:34:59.324Z
    created: Optional[datetime] = None
    #: The event's data representation. This object will contain the event's `resource`, such as `memberships
    #: <https://developer.webex.com/docs/api/v1/memberships/get-membership-details>`_ or
    #: `messages
    #: <https://developer.webex.com/docs/api/v1/messages/get-message-details>`_, at the time the event took place.
    data: Optional[EventData] = None


class EventCollectionResponse(ApiModel):
    items: Optional[list[Event]] = None


class EventData1(ApiModel):
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    id: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: example: group
    room_type: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi9jZTg2MWZiYS02ZTJmLTQ5ZjktOWE4NC1iMzU0MDA4ZmFjOWU
    org_id: Optional[str] = None
    #: example: PROJECT UPDATE - A new project plan has been published on Box: http://box.com/s/lf5vj. The PM for this project is Mike C. and the Engineering Manager is Jane W.
    text: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: example: matt@example.com
    person_email: Optional[str] = None
    #: example: 16ce696f75844d24b2d4fab04b4419af_I_183979003076423608
    meeting_id: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS82YWE2ZGE5OS0xYzdlLTQ4MWItODY3YS03MWY2NTIwNDk0MzM
    creator_id: Optional[str] = None
    #: The meeting's host data
    host: Optional[AttachmentAction] = None
    #: Common Identity (CI) authenticated meeting attendees
    attendees: Optional[list[str]] = None
    #: indicates whether or not the Voice Assistant was enabled during the meeting. If `true` a transcript should be
    #: available a couple minutes after the meeting ended at the `meetingTranscripts resource
    #: <https://developer.webex.com/docs/api/v1/meeting-transcripts>`_
    transcription_enabled: Optional[str] = None
    #: indicates if recording was enabled for all or parts of the meeting. If `true` a recording should be available
    #: shortly after the meeting ended at the `recordings resource
    #: <https://developer.webex.com/docs/api/v1/recordings>`_
    recording_enabled: Optional[str] = None
    #: indicates if chat messages were exchanged during the meeting in the meetings client (not the unified client). If
    #: `true` these messages can be accessed by a compliance officer at the `postMeetingsChat
    #: <https://developer.webex.com/docs/api/v1/meetings-chat>`_ resource. Meetings chat
    #: collection must be custom enabled.
    has_post_meetings_chat: Optional[str] = None
    #: example: 2016-05-16T21:34:59.324Z
    created: Optional[datetime] = None


class EventResourceEnum1(str, Enum):
    #: State changed on a messages resource
    messages = 'messages'
    #: State changed on a memberships resource
    memberships = 'memberships'
    #: State change on a meeting ( here combined with type = 'ended' )
    meetings = 'meetings'
    #: State change on a automatic transcript resource for Webex Assistant
    meeting_transcripts = 'meetingTranscripts'
    #: State changed on a meeting message, i.e. message exchanged as part of a meeting
    meeting_messages = 'meetingMessages'
    #: State changed on a room tabs in a space
    tabs = 'tabs'
    #: State changed on a space classification
    rooms = 'rooms'
    #: State changed on a card attachment
    attachment_actions = 'attachmentActions'
    #: State changed on a file download
    files = 'files'
    #: State change on a file preview
    file_transcodings = 'file_transcodings'


class EventTypeEnum1(str, Enum):
    #: The resource has been created
    created = 'created'
    #: A property on the resource has been updated
    updated = 'updated'
    #: The resource has been deleted
    deleted = 'deleted'
    #: The meeting has ended
    ended = 'ended'


class Event1(ApiModel):
    #: The unique identifier for the event.
    #: example: Y2lzY29zcGFyazovL3VzL0VWRU5UL2JiY2ViMWFkLTQzZjEtM2I1OC05MTQ3LWYxNGJiMGM0ZDE1NAo
    id: Optional[str] = None
    #: The type of resource in the event.
    #: example: messages
    resource: Optional[EventResourceEnum1] = None
    #: The action which took place in the event.
    #: example: created
    type: Optional[EventTypeEnum1] = None
    #: The ID of the application for the event.
    #: example: null
    app_id: Optional[str] = None
    #: The ID of the person who performed the action.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    actor_id: Optional[str] = None
    #: The ID of the organization for the event.
    #: example: OTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    org_id: Optional[str] = None
    #: The date and time of the event.
    #: example: 2016-05-16T21:34:59.324Z
    created: Optional[datetime] = None
    #: The event's data representation. This object will contain the event's `resource`, such as `memberships
    #: <https://developer.webex.com/docs/api/v1/memberships/get-membership-details>`_, `messages
    #: `meetings
    #: <https://developer.webex.com/docs/api/v1/meetings>`_, `tabs
    data: Optional[EventData1] = None


class EventCollectionResponse1(ApiModel):
    items: Optional[list[Event1]] = None


class GetCallForwardAlwaysSettingObject(ApiModel):
    #: `Always` call forwarding is enabled or disabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Destination for `Always` call forwarding. Required if field `enabled` is set to `true`.
    #: example: +19705550006
    destination: Optional[str] = None
    #: If `true`, a brief tone will be played on the person's phone when a call has been forwarded.
    ring_reminder_enabled: Optional[bool] = None
    #: Indicates enabled or disabled state of sending incoming calls to voicemail when the destination is an internal
    #: phone number and that number has the voicemail service enabled.
    send_to_voicemail_enabled: Optional[bool] = None


class CallForwardRulesObject(ApiModel):
    #: Unique ID for the rule.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfRk9SV0FSRElOR19TRUxFQ1RJVkVfUlVMRS9WR1Z6ZENCU2RXeGw
    id: Optional[str] = None
    #: Unique name of rule.
    #: example: Test Rule
    name: Optional[str] = None
    #: Comma-separated list of incoming call numbers that, when matched, will not be forwarded. A Limit of 12 numbers
    #: is allowed. Use `Any private Number` in the comma-separated value to indicate rules that match incoming calls
    #: from a private number. Use `Any unavailable number` in the comma-separated value to match incoming calls from
    #: an unavailable number.
    #: example: Any private number
    calls_from: Optional[str] = None
    #: Comma-separated list of the types of numbers being matched for incoming call destination.
    #: example: +19705550006
    calls_to: Optional[str] = None
    #: Number to which calls will be forwarded if the rule is of type "Forward To" and the incoming call is matched.
    #: example: +19705550026
    forward_to: Optional[str] = None
    #: Reflects if rule is enabled.
    #: example: True
    enabled: Optional[bool] = None


class AutoAttendantCallForwardSettingsDetailsObject(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[GetCallForwardAlwaysSettingObject] = None
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[GetCallForwardAlwaysSettingObject] = None
    #: Rules for selectively forwarding calls.
    rules: Optional[list[CallForwardRulesObject]] = None


class CallForwardRulesModifyObject(ApiModel):
    #: A unique identifier for the auto attendant call forward selective rule.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfRk9SV0FSRElOR19TRUxFQ1RJVkVfUlVMRS9WR1Z6ZENCU2RXeGw
    id: Optional[str] = None
    #: Flag to indicate if always call forwarding selective rule criteria is active. If not set, flag will be set to
    #: false.
    #: example: True
    enabled: Optional[bool] = None


class AutoAttendantCallForwardSettingsModifyDetailsObject(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[GetCallForwardAlwaysSettingObject] = None
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[GetCallForwardAlwaysSettingObject] = None
    #: Rules for selectively forwarding calls. (Rules which are omitted in the list will not be deleted.)
    rules: Optional[list[CallForwardRulesModifyObject]] = None


class CallForwardSelectiveCallsFromCustomNumbersObject(ApiModel):
    #: Match if caller ID indicates the call is from a private number.
    #: example: True
    private_number_enabled: Optional[bool] = None
    #: Match if callerID is unavailable.
    unavailable_number_enabled: Optional[bool] = None
    #: Array of number strings to be matched against incoming caller ID.
    #: example: ['["+12147691003", "+12147691004"]']
    numbers: Optional[list[str]] = None


class CallForwardSelectiveCallsFromObjectSelection(str, Enum):
    #: Rule matches for calls from any number.
    any = 'ANY'
    #: Rule matches based on the numbers and options in customNumbers.
    custom = 'CUSTOM'


class CallForwardSelectiveCallsFromObject(ApiModel):
    #: If `CUSTOM`, use `customNumbers` to specify which incoming caller ID values cause this rule to match. `ANY`
    #: means any incoming call matches assuming the rule is in effect based on the associated schedules.
    #: example: CUSTOM
    selection: Optional[CallForwardSelectiveCallsFromObjectSelection] = None
    #: Custom rules for matching incoming caller ID information. Mandatory if the selection option is set to `CUSTOM`.
    custom_numbers: Optional[CallForwardSelectiveCallsFromCustomNumbersObject] = None


class CallForwardSelectiveCallsToNumbersObjectType(str, Enum):
    #: Indicates that the given `phoneNumber` or `extension` associated with this rule's containing object is a primary
    #: number or extension.
    primary = 'PRIMARY'
    #: Indicates that the given `phoneNumber` or `extension` associated with this rule's containing object is an
    #: alternate number or extension.
    alternate = 'ALTERNATE'


class CallForwardSelectiveCallsToNumbersObject(ApiModel):
    #: AutoCalls To phone number. Either phone number or extension should be present as mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Calls To extension.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: Calls to type options.
    #: example: PRIMARY
    type: Optional[CallForwardSelectiveCallsToNumbersObjectType] = None


class CallForwardSelectiveCallsToObject(ApiModel):
    #: Array of numbers to be matched against the calling destination number.
    numbers: Optional[list[CallForwardSelectiveCallsToNumbersObject]] = None


class CallForwardSelectiveForwardToObjectSelection(str, Enum):
    #: When the rule matches, forward to the destination for the auto attendant.
    forward_to_default_number = 'FORWARD_TO_DEFAULT_NUMBER'
    #: When the rule matches, forward to the destination for this rule.
    forward_to_specified_number = 'FORWARD_TO_SPECIFIED_NUMBER'
    #: When the rule matches, do not forward to another number.
    do_not_forward = 'DO_NOT_FORWARD'


class CallForwardSelectiveForwardToObject(ApiModel):
    #: Phone number used if selection is `FORWARD_TO_SPECIFIED_NUMBER`.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Controls what happens when the rule matches.
    #: example: FORWARD_TO_DEFAULT_NUMBER
    selection: Optional[CallForwardSelectiveForwardToObjectSelection] = None


class GetAutoAttendantCallForwardSelectiveRuleObject(ApiModel):
    #: Unique ID for the rule.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfRk9SV0FSRElOR19TRUxFQ1RJVkVfUlVMRS9WR1Z6ZENCU2RXeGw
    id: Optional[str] = None
    #: Unique name for the selective rule in the auto attendant.
    #: example: Test Rule
    name: Optional[str] = None
    #: Reflects if rule is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Name of the location's business schedule which determines when this selective call forwarding rule is in effect.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    business_schedule: Optional[str] = None
    #: Name of the location's holiday schedule which determines when this selective call forwarding rule is in effect.
    #: example: AUTOATTENDANT-HOLIDAY
    holiday_schedule: Optional[str] = None
    #: Controls what happens when the rule matches including the destination number for the call forwarding.
    forward_to: Optional[CallForwardSelectiveForwardToObject] = None
    #: Settings related to the rule matching based on incoming caller ID.
    calls_from: Optional[CallForwardSelectiveCallsFromObject] = None
    #: Settings related to the rule matching based on the destination number.
    calls_to: Optional[CallForwardSelectiveCallsToObject] = None


class GetAutoAttendantCallForwardSettingsObject(ApiModel):
    #: Settings related to `Always`, `Busy`, and `No Answer` call forwarding.
    call_forwarding: Optional[AutoAttendantCallForwardSettingsDetailsObject] = None


class KeyConfigurationsGetObjectAction(str, Enum):
    #: Plays a recorded message and then returns to the current Auto Attendant menu.
    play_announcement = 'PLAY_ANNOUNCEMENT'
    #: Transfers the call to the specified number, without playing a transfer prompt.
    transfer_with_prompt = 'TRANSFER_WITH_PROMPT'
    #: Plays the message and then transfers the call to the specified number.
    transfer_without_prompt = 'TRANSFER_WITHOUT_PROMPT'
    #: Plays the message and then transfers the call to the specified operator number.
    transfer_to_operator = 'TRANSFER_TO_OPERATOR'
    #: Prompts the user for an extension, and transfers the user to voice mailbox of the dialed extension.
    transfer_to_mailbox = 'TRANSFER_TO_MAILBOX'
    #: Brings the user into the automated name directory.
    name_dialing = 'NAME_DIALING'
    #: Prompts the user for an extension, and transfers the user.
    extension_dialing = 'EXTENSION_DIALING'
    #: Replays the Auto Attendant greeting.
    repeat_menu = 'REPEAT_MENU'
    #: Terminates the call.
    exit = 'EXIT'
    #: Return back to the previous menu.
    return_to_previous_menu = 'RETURN_TO_PREVIOUS_MENU'


class KeyConfigurationsGetObject(ApiModel):
    #: Key assigned to specific menu configuration.
    #: example: 0
    key: Optional[KeyConfigurationsObjectKey] = None
    #: Action assigned to specific menu key configuration.
    #: example: EXIT
    action: Optional[KeyConfigurationsGetObjectAction] = None
    #: The description of each menu key.
    #: example: Exit the menu
    description: Optional[str] = None
    #: Value based on actions.
    #: example: +19705550006
    value: Optional[str] = None
    #: Pre-configured announcement audio files when PLAY_ANNOUNCEMENT is set.
    audio_announcement_file: Optional[AudioAnnouncementFileGetObject] = None


class HoursMenuGetObject(ApiModel):
    #: Greeting type defined for the auto attendant.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Flag to indicate if auto attendant extension is enabled or not.
    #: example: True
    extension_enabled: Optional[bool] = None
    #: Announcement Audio File details.
    audio_announcement_file: Optional[AudioAnnouncementFileGetObject] = None
    #: Key configurations defined for the auto attendant.
    key_configurations: Optional[KeyConfigurationsGetObject] = None


class GetAutoAttendantObject2(ApiModel):
    #: A unique identifier for the auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Unique name for the auto attendant.
    #: example: Main Line AA - Test
    name: Optional[str] = None
    #: Flag to indicate if auto attendant number is enabled or not.
    #: example: True
    enabled: Optional[bool] = None
    #: Auto attendant phone number.  Either `phoneNumber` or `extension` is mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool] = None
    #: First name defined for an auto attendant.
    #: example: Main Line AA
    first_name: Optional[str] = None
    #: Last name defined for an auto attendant.
    #: example: Test
    last_name: Optional[str] = None
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]] = None
    #: Language for the auto attendant.
    #: example: English
    language: Optional[str] = None
    #: Language code for the auto attendant.
    #: example: en_us
    language_code: Optional[str] = None
    #: Business hours defined for the auto attendant.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    business_schedule: Optional[str] = None
    #: Holiday defined for the auto attendant.
    #: example: AUTOATTENDANT-HOLIDAY
    holiday_schedule: Optional[str] = None
    #: Extension dialing setting. If the values are not set default will be set as `ENTERPRISE`.
    #: example: ENTERPRISE
    extension_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Name dialing setting. If the values are not set default will be set as `ENTERPRISE`.
    #: example: ENTERPRISE
    name_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Time zone defined for the auto attendant.
    #: example: America/Los_Angeles
    time_zone: Optional[str] = None
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[HoursMenuGetObject] = None
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[HoursMenuGetObject] = None


class ListAutoAttendantObject2(ApiModel):
    #: A unique identifier for the auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Unique name for the auto attendant.
    #: example: Main Line AA - Test
    name: Optional[str] = None
    #: Name of location for auto attendant.
    #: example: Houston
    location_name: Optional[str] = None
    #: ID of location for auto attendant.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzI2NDE1MA
    location_id: Optional[str] = None
    #: Auto attendant phone number.  Either `phoneNumber` or `extension` is mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: Flag to indicate if auto attendant number is toll-free number.
    toll_free_number: Optional[bool] = None


class ModifyAutoAttendantCallForwardSelectiveRuleObject(ApiModel):
    #: Unique name for the selective rule in the auto attendant.
    #: example: Test Rule New Name
    name: Optional[str] = None
    #: Reflects if rule is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Name of the location's business schedule which determines when this selective call forwarding rule is in effect.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    business_schedule: Optional[str] = None
    #: Name of the location's holiday schedule which determines when this selective call forwarding rule is in effect.
    #: example: AUTOATTENDANT-HOLIDAY
    holiday_schedule: Optional[str] = None
    #: Controls what happens when the rule matches including the destination number for the call forwarding.
    forward_to: Optional[CallForwardSelectiveForwardToObject] = None
    #: Settings related the rule matching based on incoming caller ID.
    calls_from: Optional[CallForwardSelectiveCallsFromObject] = None
    #: Settings related to the rule matching based on the destination number.
    calls_to: Optional[CallForwardSelectiveCallsToObject] = None


class ModifyAutoAttendantCallForwardSettingsObject(ApiModel):
    #: Settings related to `Always`, `Busy`, and `No Answer` call forwarding.
    call_forwarding: Optional[AutoAttendantCallForwardSettingsModifyDetailsObject] = None


class ModifyAutoAttendantObject1(ApiModel):
    #: Unique name for the auto attendant.
    #: example: Main Line IA - Test
    name: Optional[str] = None
    #: Auto attendant phone number.  Either `phoneNumber` or `extension` is mandatory.
    #: example: +19705550028
    phone_number: Optional[str] = None
    #: Auto attendant extension.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 1001
    extension: Optional[datetime] = None
    #: First name defined for an auto attendant.
    #: example: Main Line AA
    first_name: Optional[str] = None
    #: Last name defined for an auto attendant.
    #: example: Test
    last_name: Optional[str] = None
    #: Alternate numbers defined for the auto attendant.
    alternate_numbers: Optional[list[AlternateNumbersObject]] = None
    #: Language code for the auto attendant.
    #: example: en_us
    language_code: Optional[str] = None
    #: Business hours defined for the auto attendant.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    business_schedule: Optional[str] = None
    #: Holiday defined for the auto attendant.
    #: example: AUTOATTENDANT-HOLIDAY
    holiday_schedule: Optional[str] = None
    #: Extension dialing setting. If the values are not set default will be set as `ENTERPRISE`.
    #: example: ENTERPRISE
    extension_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Name dialing setting. If the values are not set default will be set as `ENTERPRISE`.
    #: example: ENTERPRISE
    name_dialing: Optional[GetAutoAttendantObjectExtensionDialing] = None
    #: Time zone defined for the auto attendant.
    #: example: America/Los_Angeles
    time_zone: Optional[str] = None
    #: Business hours menu defined for the auto attendant.
    business_hours_menu: Optional[HoursMenuGetObject] = None
    #: After hours menu defined for the auto attendant.
    after_hours_menu: Optional[HoursMenuGetObject] = None


class ReadTheListOfAutoAttendantsResponse2(ApiModel):
    #: Array of auto attendants.
    auto_attendants: Optional[list[ListAutoAttendantObject2]] = None


class CallParkSettingsObject(ApiModel):
    #: Ring pattern for when this callpark is called.
    #: example: NORMAL
    ring_pattern: Optional[RingPatternObject] = None
    #: Amount of time within 30 and 600 seconds the Call Park will be parked. If the call isn't picked up within the
    #: set time, then the call will be recalled based on the Call Park Recall setting.
    #: example: 60.0
    recall_time: Optional[int] = None
    #: Amount of time within 30 and 600 seconds the Call Park will be parked. If the call isn't picked up, the call
    #: will revert back to the hunt group (after the person who parked the call is alerted).
    #: example: 60.0
    hunt_wait_time: Optional[int] = None


class GetCallParkExtensionObject1(ApiModel):
    #: The extension for the call park extension.
    #: example: 1415
    extension: Optional[datetime] = None
    #: Unique name for the call park extension.
    #: example: 14159265
    name: Optional[str] = None


class GetPersonPlaceVirtualLineCallParksObject1(ApiModel):
    #: ID of a person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE2NmE
    id: Optional[str] = None
    #: First name of a person, workspace or virtual line.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of a person, workspace or virtual line.
    #: example: Brown
    last_name: Optional[str] = None
    #: Display name of a person, workspace or virtual line.
    #: example: johnBrown
    display_name: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: Email of a person or workspace.
    #: example: john.brown@example.com
    email: Optional[str] = None
    #: List of phone numbers of a person, workspace or virtual line.
    numbers: Optional[list[GetUserNumberItemObject2]] = None


class ListCPCallParkExtensionObject1(ApiModel):
    #: Unique identifier for the call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSS19FWFRFTlNJT04vMGYzZTkwNGItYzliNC00ODNmLWI4MWItZmI0ZjkyMWcxNDUzCg
    id: Optional[str] = None
    #: The extension for the call park.
    #: example: 1415
    extension: Optional[datetime] = None
    #: A unique name for the call park extension.
    #: example: 14159265
    name: Optional[str] = None


class GetCallParkObject1(ApiModel):
    #: A unique identifier for the call park.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSSy9kR1ZqYUc1cFkyRnNJSE4xY0hCdmNuUWdMU0JwYm5OMWNtRnVZMlVnTFNCamRYTjBiMjFsY2lBeA==
    id: Optional[str] = None
    #: Unique name for the call park. The maximum length is 80.
    #: example: technical support - insurance - customer 1
    name: Optional[str] = None
    #: Recall options that are added to call park.
    recall: Optional[GetRecallHuntGroupObject] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject1]] = None
    #: Whether or not the calls will be parked on agents as a destination.
    park_on_agents_enabled: Optional[bool] = None
    #: Array of call park extensions assigned to a call park.
    call_park_extensions: Optional[list[ListCPCallParkExtensionObject1]] = None


class GetCallParkSettingsObject(ApiModel):
    #: Recall options that are added to call park.
    call_park_recall: Optional[GetRecallHuntGroupObject] = None
    #: Setting controlling call park behavior.
    call_park_settings: Optional[CallParkSettingsObject] = None


class ListCallParkExtensionObject1(ApiModel):
    #: Unique identifier for the call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSS19FWFRFTlNJT04vMGYzZTkwNGItYzliNC00ODNmLWI4MWItZmI0ZjkyMWcxNDUzCg
    id: Optional[str] = None
    #: The extension for the call park extension.
    #: example: 1415
    extension: Optional[datetime] = None
    #: A unique name for the call park extension.
    #: example: 14159265
    name: Optional[str] = None
    #: ID of location for call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx
    location_id: Optional[str] = None
    #: Name of location for call park extension.
    #: example: WXCSIVDKCPAPIC4S1
    location_name: Optional[str] = None


class ModifyCallExtensionParkObject(ApiModel):
    #: Name for the call park extension. The maximum length is 30.
    #: example: Illinois, Call Park Extension
    name: Optional[str] = None
    #: Unique extension which will be assigned to call park extension. The minimum length is 2, maximum length is 6.
    #: example: 407721
    extension: Optional[str] = None


class PutRecallHuntGroupObject(ApiModel):
    #: Alternate user which is a hunt group ID for call park recall alternate destination.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvZEdWamFHNXBZMkZzTFhOMWNIQnZjblF0TlRVMU9EWTNOVE13T1VCbmJXRnBiQzVqYjIwPQ
    hunt_group_id: Optional[str] = None
    #: Call park recall options.
    #: example: ALERT_PARKING_USER_FIRST_THEN_HUNT_GROUP
    option: Optional[GetRecallHuntGroupObjectOption] = None


class ModifyCallParkObject(ApiModel):
    #: Unique name for the call park. The maximum length is 80.
    #: example: technical support - insurance - customer 1
    name: Optional[str] = None
    #: Recall options that are added to call park.
    recall: Optional[PutRecallHuntGroupObject] = None
    #: Array of ID strings of people, workspaces and virtual lines that are added to call park.
    agents: Optional[list[str]] = None


class ModifyCallParkSettingsObject(ApiModel):
    #: Recall options that are added to call park.
    call_park_recall: Optional[PutRecallHuntGroupObject] = None
    #: Setting controlling call park behavior.
    call_park_settings: Optional[CallParkSettingsObject] = None


class ReadTheListOfCallParksResponse(ApiModel):
    #: Array of call parks.
    call_parks: Optional[list[RouteGroupUsageRouteListItem]] = None


class GetAvailableAgentsFromCallParksResponse1(ApiModel):
    #: Array of agents.
    agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject1]] = None


class GetAvailableRecallHuntGroupsFromCallParksResponse(ApiModel):
    #: Array of available recall hunt groups.
    hunt_groups: Optional[list[Location]] = None


class ReadTheListOfCallParkExtensionsResponse1(ApiModel):
    #: Array of call park extensions.
    call_park_extensions: Optional[list[ListCallParkExtensionObject1]] = None


class GetCallPickupObject2(ApiModel):
    #: A unique identifier for the call pickup.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUElDS1VQL1kyRnNiRkJwWTJ0MWNERT0
    id: Optional[str] = None
    #: Unique name for the call pickup. The maximum length is 80.
    #: example: North Alaska-Group
    name: Optional[str] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallPickupObject1]] = None


class ModifyCallPickupObject1(ApiModel):
    #: Unique name for the call pickup. The maximum length is 80.
    #: example: North Alaska-Group
    name: Optional[str] = None
    #: An array of people, workspace, and virtual lines IDs, that are added to call pickup.
    agents: Optional[list[str]] = None


class ReadTheListOfCallPickupsResponse(ApiModel):
    #: Array of call pickups.
    call_pickups: Optional[list[RouteGroupUsageRouteListItem]] = None


class GetAvailableAgentsFromCallPickupsResponse1(ApiModel):
    #: Array of agents.
    agents: Optional[list[GetPersonPlaceVirtualLineCallPickupObject1]] = None


class AnnouncementAudioFileGetLevel(str, Enum):
    location = 'LOCATION'
    organization = 'ORGANIZATION'
    entity = 'ENTITY'


class AnnouncementAudioFileGet(ApiModel):
    #: Unique identifier of the Announcement file.
    #: example: Y2lzY29zcGFyazovL3VzL0FOTk9VTkNFTUVOVC8zMjAxNjRmNC1lNWEzLTQxZmYtYTMyNi02N2MwOThlNDFkMWQ
    id: Optional[str] = None
    #: Name of the announcement file.
    #: example: Public_Announcement.wav
    name: Optional[str] = None
    #: Media file type of announcement file.
    #: example: WAV
    media_file_type: Optional[str] = None
    #: The level at which this announcement exists.
    #: example: LOCATION
    level: Optional[AnnouncementAudioFileGetLevel] = None


class AudioAnnouncementFileFeatureGetObject(ApiModel):
    #: A unique identifier for the announcement.
    #: example: Y2lzY29zcGFyazovL3VzL0FVVE9fQVRURU5EQU5UL2QzVjBPWFIxWjJkM2FFQm1iR1Y0TWk1amFYTmpieTVqYjIw
    id: Optional[str] = None
    #: Audio announcement file name.
    #: example: AUDIO_FILE.wav
    file_name: Optional[str] = None
    #: Audio announcement file type.
    #: example: WAV
    media_file_type: Optional[AudioFileObjectMediaType] = None
    #: Audio announcement file type location.
    #: example: ORGANIZATION
    level: Optional[AnnouncementAudioFileGetLevel] = None


class CallForwardRulesGet(ApiModel):
    #: Unique ID for the rule.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfRk9SV0FSRElOR19TRUxFQ1RJVkVfUlVMRS9kR1Z6ZEZKMWJHVTA
    id: Optional[str] = None
    #: Unique name of rule.
    #: example: My Rule
    name: Optional[str] = None
    #: Comma-separated list of incoming call numbers that, when matched, will not be forwarded. A Limit of 12 numbers
    #: is allowed. Use `Any private Number` in the comma-separated value to indicate rules that match incoming calls
    #: from a private number. Use `Any unavailable number` in the comma-separated value to match incoming calls from
    #: an unavailable number.
    #: example: Any private Number,2025551212
    call_from: Optional[str] = None
    #: Comma-separated list of the types of numbers being matched for incoming call destination.
    #: example: Primary
    calls_to: Optional[str] = None
    #: Number to which calls will be forwarded if the rule is of type "Forward To" and the incoming call is matched.
    #: example: 2025557736
    forward_to: Optional[str] = None
    #: Reflects if rule is enabled.
    #: example: True
    enabled: Optional[bool] = None


class CallForwardSettingsGetCallForwardingAlways(ApiModel):
    #: `Always` call forwarding is enabled or disabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Destination for "Always" call forwarding.
    #: example: 2225551212
    destination: Optional[str] = None
    #: If `true`, a brief tone will be played on the person's phone when a call has been forwarded.
    ring_reminder_enabled: Optional[bool] = None
    #: Indicates enabled or disabled state of sending incoming calls to voicemail when the destination is an internal
    #: phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool] = None


class CallForwardSettingsGetCallForwarding(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[CallForwardSettingsGetCallForwardingAlways] = None
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[CallForwardSettingsGetCallForwardingAlways] = None
    #: Rules for selectively forwarding calls.
    rules: Optional[list[CallForwardRulesGet]] = None


class CallForwardSettingsGet(ApiModel):
    #: Settings related to `Always`, `Busy`, and `No Answer` call forwarding.
    call_forwarding: Optional[CallForwardSettingsGetCallForwarding] = None


class CallQueueAudioFilesObject(ApiModel):
    #: Name of the file.
    #: example: AudioFile1.wav
    file_name: Optional[str] = None
    #: Media Type of the audio file.
    #: example: WAV
    media_file_type: Optional[AudioFileObjectMediaType] = None


class CallQueueHolidaySchedulesObject(ApiModel):
    #: Name of the schedule configured for a holiday service.
    #: example: 2022 All Holidays
    schedule_name: Optional[str] = None
    #: Specifies whether the schedule mentioned in `scheduleName` is org or location specific.
    #: example: LOCATION
    schedule_level: Optional[AudioAnnouncementFileGetObjectLevel] = None


class CallQueueQueueSettingsGetObjectOverflow(ApiModel):
    #: Indicates how to handle new calls when the queue is full.
    #: example: PERFORM_BUSY_TREATMENT
    action: Optional[CallQueueQueueSettingsObjectOverflowAction] = None
    #: When `true`, forwards all calls to a voicemail service of an internal number. This option is ignored when an
    #: external `transferNumber` is entered.
    send_to_voicemail: Optional[bool] = None
    #: Destination number for overflow calls when `action` is set to `TRANSFER_TO_PHONE_NUMBER`.
    #: example: +15555551212
    transfer_number: Optional[str] = None
    #: After calls wait for the configured number of seconds and no agent is available, the overflow treatment is
    #: triggered.
    #: example: True
    overflow_after_wait_enabled: Optional[bool] = None
    #: Number of seconds to wait before the overflow treatment is triggered when no agent is available. The minimum
    #: value 0, The maximum value is 7200 seconds.
    #: example: 20.0
    overflow_after_wait_time: Optional[int] = None
    #: Indicate overflow audio to be played, otherwise, callers will hear the hold music until the call is answered by
    #: a user.
    #: example: True
    play_overflow_greeting_enabled: Optional[bool] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement files to be played as `overflow` greetings. These files are from the list of announcement
    #: files associated with this call queue. For `CUSTOM` announcement, a minimum of 1 file is mandatory, and the
    #: maximum is 4.
    audio_announcement_files: Optional[list[AnnouncementAudioFileGet]] = None


class CallQueueQueueSettingsGetObjectWelcomeMessage(ApiModel):
    #: If enabled play entrance message. The default value is `true`.
    #: example: True
    enabled: Optional[bool] = None
    #: Mandatory entrance message. The default value is `false`.
    always_enabled: Optional[bool] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement files to be played as `welcomeMessage` greetings. These files are from the list of
    #: announcement files associated with this call queue. For `CUSTOM` announcement, a minimum of 1 file is
    #: mandatory, and the maximum is 4.
    audio_announcement_files: Optional[list[AnnouncementAudioFileGet]] = None


class CallQueueQueueSettingsGetObjectComfortMessage(ApiModel):
    #: If enabled play periodic comfort message.
    #: example: True
    enabled: Optional[bool] = None
    #: The interval in seconds between each repetition of the comfort message played to queued users. The minimum time
    #: is 10 seconds.The maximum time is 600 seconds.
    #: example: 10.0
    time_between_messages: Optional[int] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement files to be played as `comfortMessage` greetings. These files are from the list of
    #: announcement files associated with this call queue. For `CUSTOM` announcement, a minimum of 1 file is
    #: mandatory, and the maximum is 4.
    audio_announcement_files: Optional[list[AnnouncementAudioFileGet]] = None


class CallQueueQueueSettingsGetObjectComfortMessageBypass(ApiModel):
    #: If enabled play comfort bypass message.
    #: example: True
    enabled: Optional[bool] = None
    #: The interval in seconds between each repetition of the comfort bypass message played to queued users. The
    #: minimum time is 1 seconds. The maximum time is 120 seconds.
    #: example: 10.0
    call_waiting_age_threshold: Optional[int] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement files to be played as `comfortMessageBypass` greetings. These files are from the list of
    #: announcements files associated with this call queue. For `CUSTOM` announcement, a minimum of 1 file is
    #: mandatory, and the maximum is 4.
    audio_announcement_files: Optional[list[AnnouncementAudioFileGet]] = None


class CallQueueQueueSettingsGetObjectMohMessageNormalSource(ApiModel):
    #: Enable media on hold for queued calls.
    #: example: True
    enabled: Optional[bool] = None
    #: Indicates how to handle new calls when the queue is full.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Array of announcement files to be played as `mohMessage` greetings. These files are from the list of
    #: announcement files associated with this call queue. For `CUSTOM` announcement, a minimum of 1 file is
    #: mandatory, and the maximum is 4.
    audio_announcement_files: Optional[list[AnnouncementAudioFileGet]] = None


class CallQueueQueueSettingsGetObjectMohMessage(ApiModel):
    normal_source: Optional[CallQueueQueueSettingsGetObjectMohMessageNormalSource] = None
    alternate_source: Optional[CallQueueQueueSettingsGetObjectMohMessageNormalSource] = None


class CallQueueQueueSettingsGetObject(ApiModel):
    #: The maximum number of calls for this call queue. Once this number is reached, the `overflow` settings are
    #: triggered.
    #: example: 50.0
    queue_size: Optional[int] = None
    #: Play ringing tone to callers when their call is set to an available agent.
    #: example: True
    call_offer_tone_enabled: Optional[bool] = None
    #: Reset caller statistics upon queue entry.
    reset_call_statistics_enabled: Optional[bool] = None
    #: Settings for incoming calls exceed queueSize.
    overflow: Optional[CallQueueQueueSettingsGetObjectOverflow] = None
    #: Play a message when callers first reach the queue. For example, Thank you for calling. An agent will be with
    #: you shortly. It can be set as mandatory. If the mandatory option is not selected and a caller reaches the call
    #: queue while there is an available agent, the caller will not hear this announcement and is transferred to an
    #: agent. The welcome message feature is enabled by default.
    welcome_message: Optional[CallQueueQueueSettingsGetObjectWelcomeMessage] = None
    #: Notify the caller with either their estimated wait time or position in the queue. If this option is enabled, it
    #: plays after the welcome message and before the comfort message. By default, it is not enabled.
    wait_message: Optional[CallQueueQueueSettingsObjectWaitMessage] = None
    #: Play a message after the welcome message and before hold music. This is typically a `CUSTOM` announcement that
    #: plays information, such as current promotions or information about products and services.
    comfort_message: Optional[CallQueueQueueSettingsGetObjectComfortMessage] = None
    #: Play a shorter comfort message instead of the usual Comfort or Music On Hold announcement to all the calls that
    #: should be answered quickly. This feature prevents a caller from hearing a short portion of the standard comfort
    #: message that abruptly ends when they are connected to an agent.
    comfort_message_bypass: Optional[CallQueueQueueSettingsGetObjectComfortMessageBypass] = None
    #: Play music after the comforting message in a repetitive loop.
    moh_message: Optional[CallQueueQueueSettingsGetObjectMohMessage] = None
    #: Play a message to the agent immediately before the incoming call is connected. The message typically announces
    #: the identity of the call queue from which the call is coming.
    whisper_message: Optional[CallQueueQueueSettingsGetObjectMohMessageNormalSource] = None


class PostPersonPlaceVirtualLineCallQueueObject(ApiModel):
    #: ID of person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: Weight of person, workspace or virtual line. Only applied when call policy is `WEIGHTED`.
    #: example: 50
    weight: Optional[datetime] = None
    #: Skill level of person, workspace or virtual line. Only applied when call routing type is `SKILL_BASED`.
    #: example: 1.0
    skill_level: Optional[int] = None


class CreateCallQueueObject(ApiModel):
    #: Unique name for the call queue.
    #: example: CallQueue-1
    name: Optional[str] = None
    #: Primary phone number of the call queue. Either a `phoneNumber` or `extension` is mandatory.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Primary phone extension of the call queue. Either a `phoneNumber` or extension is mandatory.
    #: example: 5309
    extension: Optional[datetime] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to ".".
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to `phoneNumber` if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the call queue.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to `agents`.
    call_policies: Optional[GetCallQueueCallPolicyObject1] = None
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsGetObject] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[PostPersonPlaceVirtualLineCallQueueObject]] = None
    #: Whether or not to allow agents to join or unjoin a queue.
    allow_agent_join_enabled: Optional[bool] = None
    #: When true, indicates that the agent's configuration allows them to use the queue's Caller ID for outgoing calls.
    #: example: True
    phone_number_for_outgoing_calls_enabled: Optional[bool] = None


class MediaType(str, Enum):
    #: WMA File Extension.
    wma = 'WMA'
    #: WAV File Extension.
    wav = 'WAV'
    #: 3GP File Extension.
    gp = 'GP'
    #: MOV File Extension.
    mov = 'MOV'


class GetAnnouncementFileInfo(ApiModel):
    #: ID of the announcement.
    #: example: Y2lzY29zcGFyazovL3VzL0FOTk9VTkNFTUVOVC9kODc5YWZlZC1jNTRhLTQyOTctOGY0Mi02ZmEyMDJjN2E1M2E
    id: Optional[str] = None
    #: Name of greeting file.
    #: example: Greeting-1.wav
    file_name: Optional[str] = None
    #: Size of greeting file in kilo-bytes.
    #: example: 33456
    file_size: Optional[str] = None
    #: Media file type of the announcement.
    #: example: WAV
    media_file_type: Optional[MediaType] = None
    #: Level where the announcement is created.
    #: example: ORGANIZATION
    level: Optional[AnnouncementAudioFileGetLevel] = None


class GetCallQueueForcedForwardObject(ApiModel):
    #: Whether or not the call queue forced forward routing policy setting is enabled.
    #: example: True
    forced_forward_enabled: Optional[bool] = None
    #: Call gets transferred to this number when action is set to `TRANSFER`. This can also be an extension.
    #: example: 1235557890
    transfer_phone_number: Optional[str] = None
    #: Specifies if an announcement plays to callers before applying the action.
    #: example: True
    play_announcement_before_enabled: Optional[bool] = None
    #: Specifies what type of announcement to be played.
    #: example: DEFAULT
    audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List of Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
    audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None


class GetCallQueueHolidayObjectAction(str, Enum):
    #: The caller hears a fast-busy tone.
    busy = 'BUSY'
    #: Transfers the call to number specified in `transferPhoneNumber`.
    transfer = 'TRANSFER'


class GetCallQueueHolidayObject(ApiModel):
    #: Whether or not the call queue holiday service routing policy is enabled.
    #: example: True
    holiday_service_enabled: Optional[bool] = None
    #: Specifies call processing action type.
    #: example: BUSY
    action: Optional[GetCallQueueHolidayObjectAction] = None
    #: Specifies whether the schedule mentioned in `holidayScheduleName` is org or location specific. (Must be from
    #: `holidaySchedules` list)
    #: example: LOCATION
    holiday_schedule_level: Optional[AudioAnnouncementFileGetObjectLevel] = None
    #: Name of the schedule configured for a holiday service as one of from `holidaySchedules` list.
    #: example: 2022 Holidays Period
    holiday_schedule_name: Optional[str] = None
    #: Call gets transferred to this number when action is set to `TRANSFER`. This can also be an extension.
    #: example: 1235557890
    transfer_phone_number: Optional[str] = None
    #: Specifies if an announcement plays to callers before applying the action.
    #: example: True
    play_announcement_before_enabled: Optional[bool] = None
    #: Specifies what type of announcement to be played.
    #: example: DEFAULT
    audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List of Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
    audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None
    #: Lists the pre-configured holiday schedules.
    holiday_schedules: Optional[list[CallQueueHolidaySchedulesObject]] = None


class GetCallQueueNightServiceObjectAnnouncementMode(str, Enum):
    #: Plays announcement as per `audioMessageSelection`.
    normal = 'NORMAL'
    #: Plays announcement as per `manualAudioMessageSelection`.
    manual = 'MANUAL'


class GetCallQueueNightServiceObject(ApiModel):
    #: Whether or not the call queue night service routing policy is enabled.
    #: example: True
    night_service_enabled: Optional[bool] = None
    #: Specifies call processing action type.
    #: example: TRANSFER
    action: Optional[GetCallQueueHolidayObjectAction] = None
    #: Call gets transferred to this number when action is set to `TRANSFER`. This can also be an extension.
    #: example: 1234
    transfer_phone_number: Optional[datetime] = None
    #: Specifies if an announcement plays to callers before applying the action.
    #: example: True
    play_announcement_before_enabled: Optional[bool] = None
    #: Specifies the type of announcements to played.
    #: example: NORMAL
    announcement_mode: Optional[GetCallQueueNightServiceObjectAnnouncementMode] = None
    #: Specifies what type of announcements to be played when `announcementMode` is `NORMAL`.
    #: example: DEFAULT
    audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List of Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
    audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None
    #: Name of the schedule configured for a night service as one of from `businessHourSchedules` list.
    #: example: Working Hour
    business_hours_name: Optional[str] = None
    #: Specifies whether the above mentioned schedule is org or location specific. (Must be from
    #: `businessHourSchedules` list).
    #: example: ORGANIZATION
    business_hours_level: Optional[AudioAnnouncementFileGetObjectLevel] = None
    #: Lists the pre-configured business hour schedules.
    business_hour_schedules: Optional[list[CallQueueHolidaySchedulesObject]] = None
    #: Force night service regardless of business hour schedule.
    #: example: True
    force_night_service_enabled: Optional[bool] = None
    #: Specifies what type of announcement to be played when `announcementMode` is `MANUAL`.
    #: example: DEFAULT
    manual_audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List Of Audio Files.
    manual_audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None


class GetPersonPlaceVirtualLineCallQueueObject1(ApiModel):
    #: ID of person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE1NmE
    id: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: First name of person, workspace or virtual line.
    #: example: Hakim
    first_name: Optional[str] = None
    #: First name of person, workspace or virtual line.
    #: example: Smith
    last_name: Optional[str] = None
    #: Phone number of person, workspace or virtual line.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Extension of person, workspace or virtual line.
    #: example: 5309
    extension: Optional[datetime] = None
    #: Weight of person, workspace or virtual line. Only applied when call policy is `WEIGHTED`.
    #: example: 50
    weight: Optional[datetime] = None
    #: Skill level of person, workspace or virtual line. Only applied when the call `routingType` is `SKILL_BASED`.
    #: example: 1.0
    skill_level: Optional[int] = None
    #: Indicates the join status of the agent for this queue. The default value while creating call queue is `true`.
    #: example: True
    join_enabled: Optional[bool] = None


class GetCallQueueObject2(ApiModel):
    #: A unique identifier for the call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the call queue.
    #: example: CallQueue-1
    name: Optional[str] = None
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Language for the call queue.
    #: example: English
    language: Optional[str] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to the `phoneNumber` if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the call queue.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Extension of the call queue.
    #: example: 5309
    extension: Optional[datetime] = None
    #: When true, indicates that the agent's configuration allows them to use the queue's Caller ID for outgoing calls.
    #: example: True
    phone_number_for_outgoing_calls_enabled: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a call queue. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the call queue.
    alternate_number_settings: Optional[GetCallQueueObjectAlternateNumberSettings] = None
    #: Policy controlling how calls are routed to `agents`.
    call_policies: Optional[GetCallQueueCallPolicyObject1] = None
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsGetObject] = None
    #: Flag to indicate whether call waiting is enabled for `agents`.
    allow_call_waiting_for_agents_enabled: Optional[bool] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[GetPersonPlaceVirtualLineCallQueueObject1]] = None
    #: Whether or not to allow agents to join or unjoin a queue.
    allow_agent_join_enabled: Optional[bool] = None


class GetCallQueueStrandedCallsObjectAction(str, Enum):
    #: Call remains in the queue.
    none_ = 'NONE'
    #: Calls are removed from the queue and are provided with the Busy treatment. If the queue is configured with the
    #: Call Forwarding Busy or the Voice Messaging service, then the call is handled accordingly.
    busy = 'BUSY'
    #: Calls are removed from the queue and are transferred to the configured `transferPhoneNumber`.
    transfer = 'TRANSFER'
    #: Calls are handled according to the Night Service configuration. If the Night Service action is set to `none`,
    #: then this is equivalent to this policy being set to `none` (that is, calls remain in the queue).
    night_service = 'NIGHT_SERVICE'
    #: Calls are removed from the queue and are provided with ringing until the caller releases the call. The ringback
    #: tone played to the caller is localized according to the country code of the caller.
    ringing = 'RINGING'
    #: Calls are removed from the queue and are provided with an announcement that is played in a loop until the caller
    #: releases the call.
    announcement = 'ANNOUNCEMENT'


class GetCallQueueStrandedCallsObject(ApiModel):
    #: Specifies call processing action type.
    #: example: BUSY
    action: Optional[GetCallQueueStrandedCallsObjectAction] = None
    #: Call gets transferred to this number when action is set to `TRANSFER`. This can also be an extension.
    #: example: 1235557890
    transfer_phone_number: Optional[str] = None
    #: Specifies what type of announcement to be played.
    #: example: DEFAULT
    audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List of Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
    audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None


class ListCallQueueObject2(ApiModel):
    #: A unique identifier for the call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUVVFVUUvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the call queue.
    #: example: 5714328359
    name: Optional[str] = None
    #: Name of location for call queue.
    #: example: WXCSIVDKCPAPIC4S1
    location_name: Optional[str] = None
    #: ID of location for call queue.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx
    location_id: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Primary phone extension of the call queue.
    #: example: 5309
    extension: Optional[datetime] = None
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None


class ModifyCallForwardingObjectCallForwarding(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[CallForwardSettingsGetCallForwardingAlways] = None
    #: Selectively forward calls to a designated number, depending on criteria rules. You'll need to have at least one
    #: rule for forwarding applied for call forwarding to be active.
    selective: Optional[CallForwardSettingsGetCallForwardingAlways] = None
    #: Rules for selectively forwarding calls.
    rules: Optional[list[CallForwardRulesModifyObject]] = None


class ModifyCallForwardingObject(ApiModel):
    #: Settings related to `Always`, `Busy`, and `No Answer` call forwarding.
    call_forwarding: Optional[ModifyCallForwardingObjectCallForwarding] = None


class ModifyCallQueueHolidayObject(ApiModel):
    #: Enable or Disable the call queue holiday service routing policy.
    #: example: True
    holiday_service_enabled: Optional[bool] = None
    #: Specifies call processing action type.
    #: example: BUSY
    action: Optional[GetCallQueueHolidayObjectAction] = None
    #: Specifies whether the schedule mentioned in `holidayScheduleName` is org or location specific. (Must be from
    #: `holidaySchedules` list)
    #: example: LOCATION
    holiday_schedule_level: Optional[AudioAnnouncementFileGetObjectLevel] = None
    #: Name of the schedule configured for a holiday service as one of from `holidaySchedules` list.
    #: example: 2022 Holidays Period
    holiday_schedule_name: Optional[str] = None
    #: Call gets transferred to this number when action is set to `TRANSFER`. This can also be an extension.
    #: example: 1235557890
    transfer_phone_number: Optional[str] = None
    #: Specifies if an announcement plays to callers before applying the action.
    #: example: True
    play_announcement_before_enabled: Optional[bool] = None
    #: Specifies what type of announcement to be played.
    #: example: DEFAULT
    audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List of pre-configured Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
    audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None


class ModifyPersonPlaceVirtualLineCallQueueObject(ApiModel):
    #: ID of person, workspace or virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1BMQUNFLzgzYjQ0OTIyLWZlOWYtMTFlYi1hNGI4LTMzNjI3YmVkNjdiNQ
    id: Optional[str] = None
    #: Weight of person, workspace or virtual line. Only applied when call policy is `WEIGHTED`.
    #: example: 50
    weight: Optional[datetime] = None
    #: Skill level of person, workspace or virtual line. Only applied when call routing type is `SKILL_BASED`.
    #: example: 1.0
    skill_level: Optional[int] = None
    #: Indicates the join status of the agent for this queue. The default value for newly added agents is `true`.
    #: example: True
    join_enabled: Optional[bool] = None


class ModifyCallQueueObject1(ApiModel):
    #: Whether or not the call queue is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Unique name for the call queue.
    #: example: CallQueue-1
    name: Optional[str] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this call queue. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this call queue. Defaults to the `phoneNumber` if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Primary phone number of the call queue.
    #: example: +12225555309
    phone_number: Optional[str] = None
    #: Extension of the call queue.
    #: example: 5309
    extension: Optional[datetime] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a call queue. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the call queue.
    alternate_number_settings: Optional[GetCallQueueObjectAlternateNumberSettings] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetCallQueueCallPolicyObject1] = None
    #: Overall call queue settings.
    queue_settings: Optional[CallQueueQueueSettingsGetObject] = None
    #: Flag to indicate whether call waiting is enabled for agents.
    allow_call_waiting_for_agents_enabled: Optional[bool] = None
    #: People, workspaces and virtual lines that are eligible to receive calls.
    agents: Optional[list[ModifyPersonPlaceVirtualLineCallQueueObject]] = None
    #: Whether or not to allow agents to join or unjoin a queue.
    allow_agent_join_enabled: Optional[bool] = None
    #: When `true`, indicates that the agent's configuration allows them to use the queue's Caller ID for outgoing
    #: calls.
    #: example: True
    phone_number_for_outgoing_calls_enabled: Optional[bool] = None


class PatchCallQueueNightServiceObject(ApiModel):
    #: Enable or disable call queue night service routing policy.
    #: example: True
    night_service_enabled: Optional[bool] = None
    #: Specifies call processing action type.
    #: example: TRANSFER
    action: Optional[GetCallQueueHolidayObjectAction] = None
    #: Call gets transferred to this number when action is set to `TRANSFER`. This can also be an extension.
    #: example: 1234
    transfer_phone_number: Optional[datetime] = None
    #: Specifies if an announcement plays to callers before applying the action.
    #: example: True
    play_announcement_before_enabled: Optional[bool] = None
    #: Specifies the type of announcements to played.
    #: example: NORMAL
    announcement_mode: Optional[GetCallQueueNightServiceObjectAnnouncementMode] = None
    #: Specifies what type of announcements to be played when `announcementMode` is `NORMAL`.
    #: example: DEFAULT
    audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List of pre-configured Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
    audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None
    #: Name of the schedule configured for a night service as one of from `businessHourSchedules` list.
    #: example: Working Hour
    business_hours_name: Optional[str] = None
    #: Specifies whether the above mentioned schedule is org or location specific. (Must be from
    #: `businessHourSchedules` list)
    #: example: ORGANIZATION
    business_hours_level: Optional[AudioAnnouncementFileGetObjectLevel] = None
    #: Force night service regardless of business hour schedule.
    #: example: True
    force_night_service_enabled: Optional[bool] = None
    #: Specifies what type of announcement to be played when `announcementMode` is `MANUAL`.
    #: example: DEFAULT
    manual_audio_message_selection: Optional[HoursMenuObjectGreeting] = None
    #: List Of pre-configured Audio Files.
    manual_audio_files: Optional[list[AudioAnnouncementFileFeatureGetObject]] = None


class ReadTheListOfCallQueuesResponse2(ApiModel):
    #: Array of call queues.
    queues: Optional[list[ListCallQueueObject2]] = None


class ReadTheListOfCallQueueAnnouncementFilesResponse(ApiModel):
    #: Array of announcements for this call queue.
    announcements: Optional[list[GetAnnouncementFileInfo]] = None


class GetCallRecordingObject(ApiModel):
    #: Details of the organization.
    organization: Optional[Location] = None
    #: Whether or not the call recording is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: A unique identifier for the vendor.
    #: example: Y2lzY29zcGFyazovL3VzL1JFQ09SRElOR19WRU5ET1IvNTNkYzRjODctODQwOC00ODgyLTk1NzAtZGNhMmJjZGI5Mjgw
    vendor_id: Optional[str] = None
    #: A unique name for the vendor.
    #: example: Dubber
    vendor_name: Optional[str] = None
    #: Url where can be found terms of service for the vendor.
    #: example: https://www.dubber.net/terms
    terms_of_service_url: Optional[str] = None


class GetCallRecordingTermsOfServiceObject(ApiModel):
    #: A unique identifier for the vendor.
    #: example: Y2lzY29zcGFyazovL3VzL1JFQ09SRElOR19WRU5ET1IvNTNkYzRjODctODQwOC00ODgyLTk1NzAtZGNhMmJjZGI5Mjgw
    vendor_id: Optional[str] = None
    #: A unique name for the vendor.
    #: example: Dubber
    vendor_name: Optional[str] = None
    #: Whether or not the call recording terms of service are enabled.
    #: example: True
    terms_of_service_enabled: Optional[bool] = None
    #: Url where can be found terms of service for the vendor.
    #: example: https://www.dubber.net/terms
    terms_of_service_url: Optional[str] = None


class ModifyCallRecordingSettingsObject(ApiModel):
    #: Whether or not the call recording is enabled.
    #: example: True
    enabled: Optional[bool] = None


class ModifyCallRecordingTermsOfServiceObject(ApiModel):
    #: Whether or not the call recording terms of service are enabled.
    #: example: True
    terms_of_service_enabled: Optional[bool] = None


class CreateHuntGroupObject2(ApiModel):
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group. Either phone number or extension are required.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the hunt group. Either phone number or extension are required.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None


class GetHuntGroupObject4(ApiModel):
    #: A unique identifier for the hunt group.
    #: example: Y2lzY29zcGFyazovL3VzL0hVTlRfR1JPVVAvYUhaaFpUTjJNRzh5YjBBMk5EazBNVEk1Tnk1cGJuUXhNQzVpWTJ4a0xuZGxZbVY0TG1OdmJRPT0
    id: Optional[str] = None
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language for hunt group.
    #: example: English
    language: Optional[str] = None
    #: Language code for hunt group.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[GetHuntGroupCallPolicyObject] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[GetPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None


class ModifyHuntGroupObject3(ApiModel):
    #: Unique name for the hunt group.
    #: example: 5558675309-Group
    name: Optional[str] = None
    #: Primary phone number of the hunt group.
    #: example: 5558675309
    phone_number: Optional[str] = None
    #: Primary phone extension of the hunt group.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Whether or not the hunt group has the distinctive ring option enabled.
    #: example: True
    distinctive_ring: Optional[bool] = None
    #: The alternate numbers feature allows you to assign multiple phone numbers or extensions to a hunt group. Each
    #: number will reach the same greeting and each menu will function identically to the main number. The alternate
    #: numbers option enables you to have up to ten (10) phone numbers ring into the hunt group.
    alternate_numbers: Optional[list[AlternateNumbersWithPattern]] = None
    #: Language code.
    #: example: en-US
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Time zone for the hunt group.
    #: example: America/Chicago
    time_zone: Optional[str] = None
    #: Policy controlling how calls are routed to agents.
    call_policies: Optional[PostHuntGroupCallPolicyObject] = None
    #: People, workspaces and virtual lines that are eligible to  receive calls.
    agents: Optional[list[PostPersonPlaceObject]] = None
    #: Whether or not the hunt group is enabled.
    #: example: True
    enabled: Optional[bool] = None


class ReadTheListOfHuntGroupsResponse2(ApiModel):
    #: Array of hunt groups.
    hunt_groups: Optional[list[ListCallQueueObject2]] = None


class GetPagingGroupAgentObject2(ApiModel):
    #: Agents ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80YTc2ZmVmNC1mZjlmLTExZWItYWYwZC00M2YwZjY1NTdjYWI
    id: Optional[str] = None
    #: Agents first name. Minimum length is 1. Maximum length is 30.
    #: example: John
    first_name: Optional[str] = None
    #: Agents last name. Minimum length is 1. Maximum length is 30.
    #: example: Doe
    last_name: Optional[str] = None
    #: Type of the person, workspace or virtual line.
    #: example: PEOPLE
    type: Optional[MemberType] = None
    #: Agents phone number. Minimum length is 1. Maximum length is 23.  Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Agents extension. Minimum length is 2. Maximum length is 6.  Either `phoneNumber` or `extension` is mandatory.
    #: example: 7781
    extension: Optional[datetime] = None


class GetPagingGroupObject2(ApiModel):
    #: A unique identifier for the paging group.
    #: example: Y2lzY29zcGFyazovL3VzL1BBR0lOR19HUk9VUC9hSFpoWlROMk1HOHliMEEyTkRrME1USTVOeTVwYm5ReE1DNWlZMnhrTG5kbFltVjRMbU52YlE
    id: Optional[str] = None
    #: Whether or not the paging group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: PagingGroup-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23. Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6. Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Flag to indicate toll free number.
    toll_free_number: Optional[bool] = None
    #: Paging language. Minimum length is 1. Maximum length is 40.
    #: example: English
    language: Optional[str] = None
    #: Language code.
    #: example: en_us
    language_code: Optional[str] = None
    #: First name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Paging
    first_name: Optional[str] = None
    #: Last name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Group
    last_name: Optional[str] = None
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    #: example: True
    originator_caller_id_enabled: Optional[bool] = None
    #: An array of people, workspaces and virtual lines ID's who may originate pages to this paging group.
    originators: Optional[list[GetPagingGroupAgentObject2]] = None
    #: An array of people, workspaces and virtual lines ID's that are added to paging group as paging call targets.
    targets: Optional[list[GetPagingGroupAgentObject2]] = None


class PostPagingGroupObject(ApiModel):
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: PagingGroup-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23.  Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6.  Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Language code.
    #: example: en_us
    language_code: Optional[str] = None
    #: First name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Paging
    first_name: Optional[str] = None
    #: Last name that displays when a group page is performed. Minimum length is 1. Maximum length is 30.
    #: example: Group
    last_name: Optional[str] = None
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    #: example: True
    originator_caller_id_enabled: Optional[bool] = None
    #: An array of people, workspace, and virtual lines IDs who can originate pages to this paging group.
    originators: Optional[list[str]] = None
    #: An array of people, workspaces and virtual lines IDs will add to a paging group as paging call targets.
    targets: Optional[list[str]] = None


class UpdatePagingGroupObject1(ApiModel):
    #: Whether or not the paging group is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
    #: example: CallQueue-1
    name: Optional[str] = None
    #: Paging group phone number. Minimum length is 1. Maximum length is 23.  Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: +15558675309
    phone_number: Optional[str] = None
    #: Paging group extension. Minimum length is 2. Maximum length is 6.  Either `phoneNumber` or `extension` is
    #: mandatory.
    #: example: 7781
    extension: Optional[datetime] = None
    #: Language code.
    #: example: en_us
    language_code: Optional[str] = None
    #: First name to be shown when calls are forwarded out of this paging group. Defaults to ".".
    #: example: Hakim
    first_name: Optional[str] = None
    #: Last name to be shown when calls are forwarded out of this paging group. Defaults to the phone number if set,
    #: otherwise defaults to call group name.
    #: example: Smith
    last_name: Optional[str] = None
    #: Determines what is shown on target users caller ID when a group page is performed. If true shows page originator
    #: ID.
    #: example: True
    originator_caller_id_enabled: Optional[bool] = None
    #: An array of people and/or workspaces, who may originate pages to this paging group.
    originators: Optional[list[str]] = None
    #: People, including workspaces, that are added to paging group as paging call targets.
    targets: Optional[list[str]] = None


class ReadTheListOfPagingGroupsResponse2(ApiModel):
    #: Array of paging groups.
    location_paging: Optional[list[ListAutoAttendantObject2]] = None


class FileExternalContent(ApiModel):
    #: example: Screen Shot 2019-02-08 at 8.55.10 AM.png
    original_filename: Optional[str] = None
    #: example: 39164
    original_file_size: Optional[str] = None
    #: example: image/png
    mime_type: Optional[str] = None
    #: example: ecm
    link_type: Optional[str] = None
    #: example: oneDriveForBusiness
    ecm_type: Optional[str] = None
    #: example: 2019-04-11T18:22:18.626Z
    created: Optional[datetime] = None


class File(ApiModel):
    #: example: Y2lzY29zcGFyazovL3VzL0ZJTEUvMTk1ZmY1MDAtNGYzOS0xMWU5LWI0ZDMtZjE1YWVjOWVjYWRiLzA
    id: Optional[str] = None
    #: example: https://example-my.sharepoint.com/:i:/p/jandersen/ERIEW6cL4DlDrAoUHM6_K1cBvRNcNEood98f2EgCFpbdSA
    content_url: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNWEzZTI4YzAtMzUzNi0xMWU5LTgyN2QtZTMyNWFhYmU1Y2M5
    room_id: Optional[str] = None
    #: example: group
    room_type: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvMTk1ZmY1MDAtNGYzOS0xMWU5LWI0ZDMtZjE1YWVjOWVjYWRi
    message_id: Optional[str] = None
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wMGZhZTA2My02ODEyLTQ3ZmQtYmJjNi1hNzVlMjlhNWM1ZjA
    person_id: Optional[str] = None
    #: example: external
    content_type: Optional[str] = None
    external_content: Optional[FileExternalContent] = None


class Member(ApiModel):
    #: Person ID of the group member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xOTUzOTdhMi03MTU5LTRjNTgtYTBiOC00NmQ2ZWZlZTdkMTM
    id: Optional[str] = None
    #: Member type.
    #: example: user
    type: Optional[str] = None
    #: example: Jane Smith
    display_name: Optional[str] = None


class PatchMemberWithOperation(ApiModel):
    #: Person ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xOTUzOTdhMi03MTU5LTRjNTgtYTBiOC00NmQ2ZWZlZTdkMTM
    id: Optional[str] = None
    #: Operation type. The default operation is `add` if no operation is specified.
    #: example: add
    operation: Optional[str] = None


class PostGroup(ApiModel):
    #: The name of the group.
    #: example: Sales Group
    display_name: Optional[str] = None
    #: The ID of the organization to which this group belongs. If not specified, the organization ID from the OAuth
    #: token is used.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNDhhZGI4MS0yOGY5LTRhYjUtYjJkNi1lOWI0OTRlNzJhMDY
    org_id: Optional[str] = None
    #: Description of the group.
    #: example: Salas Group in San Jose
    description: Optional[str] = None
    #: An array of members. Maximum of 500 members can be provided. To add more members, use the `Update a Group
    #: <https://developer.webex.com/docs/api/v1/groups/update-a-group>`_ API to
    #: add additional members.
    members: Optional[list[DepartmentResponseWithId]] = None


class PatchGroup(ApiModel):
    #: The name of the group.
    #: example: New Sales Group
    display_name: Optional[str] = None
    #: Description of the group.
    #: example: Sales Group in LA
    description: Optional[str] = None
    #: An array of members operations.
    members: Optional[list[PatchMemberWithOperation]] = None


class GroupResponse(ApiModel):
    #: A unique identifier for the group.
    #: example: Y2lzY29zcGFyazovL3VzL1NDSU1fR1JPVVAvMjUxMDRiZTAtZjg3NC00MzQzLTk2MDctZGYwMmRmMzdiNWMxOjM0OGFkYjgxLTI4ZjktNGFiNS1iMmQ2LWU5YjQ5NGU3MmEwNg
    id: Optional[str] = None
    #: The name of the group.
    #: example: Sales Group
    display_name: Optional[str] = None
    #: The ID of the organization to which this group belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNDhhZGI4MS0yOGY5LTRhYjUtYjJkNi1lOWI0OTRlNzJhMDY
    org_id: Optional[str] = None
    #: The timestamp indicating creation date/time of group
    #: example: 2022-02-17T02:13:29.706Z
    created: Optional[datetime] = None
    #: The timestamp indicating lastModification time of group
    #: example: 2022-02-17T02:13:29.706Z
    last_modified: Optional[datetime] = None
    #: example: 1.0
    member_size: Optional[int] = None
    #: An array of members
    members: Optional[list[Member]] = None


class GroupsCollectionResponse(ApiModel):
    #: Total number of groups returned in the response.
    #: example: 3.0
    total_results: Optional[int] = None
    #: example: 1.0
    start_index: Optional[int] = None
    #: example: 10.0
    items_per_page: Optional[int] = None
    #: An array of group objects.
    groups: Optional[list[GroupResponse]] = None


class HistoricalDataRelatedToMessagingResponseMetricsSharing(ApiModel):
    #: example: [1,2]
    total_files_shared: Optional[str] = None
    #: example: `[6,7]` ## Bytes
    file_share_size: Optional[str] = None


class HistoricalDataRelatedToMessagingResponseMetrics(ApiModel):
    #: An Array containing the UTC dates for which the data is returned.
    #: example: ['2020-08-01','2020-08-02']
    dates: Optional[str] = None
    #: An array containing the aggregated values for each day for which the data is returned.
    #: example: [200, 300]
    daily_active_users: Optional[str] = None
    #: example: [2000, 3000]
    total_messages_sent: Optional[str] = None
    #: example: [289, 456]
    desk_top_messages_sent: Optional[str] = None
    #: example: [122, 233]
    mobile_messages_sent: Optional[str] = None
    #: example: [2,3]
    total_active_spaces: Optional[str] = None
    #: example: [3,4]
    group_active_spaces: Optional[str] = None
    #: example: [5,6]
    one2one_active_spaces: Optional[str] = None
    video: Optional[str] = None
    sharing: Optional[HistoricalDataRelatedToMessagingResponseMetricsSharing] = None
    recording: Optional[str] = None
    audio: Optional[str] = None


class HistoricalDataRelatedToMessagingResponse(ApiModel):
    #: UTC start date of the data set.
    #: example: 2020-08-01
    start_date: Optional[datetime] = None
    #: UTC end date of the data set.
    #: example: 2020-08-03
    end_date: Optional[datetime] = None
    metrics: Optional[HistoricalDataRelatedToMessagingResponseMetrics] = None


class HistoricalDataRelatedToRoomDevicesResponseMetricsSharing(ApiModel):
    #: example: [1,1]
    localsharingcable_usage_duration: Optional[str] = None
    #: example: [2,2]
    localsharingwireless_usage_duration: Optional[str] = None


class HistoricalDataRelatedToRoomDevicesResponseMetrics(ApiModel):
    #: An Array containing the UTC dates for which the data is returned
    #: example: ['2020-08-01','2020-08-02']
    dates: Optional[str] = None
    #: An array containing the aggregated values for each day for which the data is returned.
    #: example: [200,300]
    total_active_devices: Optional[str] = None
    #: example: [2,3]
    total_assistant_commands: Optional[str] = None
    #: example: [100,100]
    total_usage_hours: Optional[str] = None
    #: example: [50,50]
    incall_usage_duration: Optional[str] = None
    #: example: [1,1]
    signage_usage_duration: Optional[str] = None
    #: example: [1,2]
    usbpassthrough_usage_duration: Optional[str] = None
    #: example: [3,4]
    whiteboarding_usage_duration: Optional[str] = None
    video: Optional[str] = None
    sharing: Optional[HistoricalDataRelatedToRoomDevicesResponseMetricsSharing] = None
    recording: Optional[str] = None
    audio: Optional[str] = None


class HistoricalDataRelatedToRoomDevicesResponse(ApiModel):
    #: Data is returned starting from this UTC date.
    #: example: 2020-08-01
    start_date: Optional[datetime] = None
    #: Data is returned up to this UTC date.
    #: example: 2020-08-03
    end_date: Optional[datetime] = None
    metrics: Optional[HistoricalDataRelatedToRoomDevicesResponseMetrics] = None


class HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByJoinMethods(ApiModel):
    #: example: 123.0
    web_app: Optional[int] = None
    #: example: 123.0
    cloud_video_device: Optional[int] = None
    #: example: 123.0
    mobile_meetings_app: Optional[int] = None


class HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByRoles(ApiModel):
    #: example: 123.0
    host: Optional[int] = None
    #: example: 123.0
    attendee: Optional[int] = None


class HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByLocation(ApiModel):
    #: example: United States
    country: Optional[str] = None
    #: example: 123.0
    total_participants: Optional[int] = None


class HistoricalDataRelatedToMeetingsResponseMetrics(ApiModel):
    #: Total number of meetings held over the selected date range. includes Webex Meetings, Webex Events, Webex
    #: Support, and Webex Training sessions
    #: example: 123.0
    total_meetings: Optional[int] = None
    #: Total number of joins by participant and devices from all Webex meetings over the selected date range
    #: example: 123.0
    total_participants: Optional[int] = None
    #: Total number of unique hosts who started at least one webex meeting over the selected date range
    #: example: 123.0
    total_unique_hosts: Optional[int] = None
    #: Total number of minutes for all meetings over selected date range
    #: example: 1234.0
    total_meeting_minutes: Optional[int] = None
    #: Total number of VoIP and telephony minutes used during meetings over the selected date range
    #: example: 1234.0
    total_audio_minutes: Optional[int] = None
    #: example: 1234.0
    total_telephone_minutes: Optional[int] = None
    #: example: 1234.0
    total_vo_ipminutes: Optional[int] = Field(alias='totalVoIPMinutes', default=None)
    #: Total number of meetings held where at least one participant enabled video for any amount of time
    #: example: 123.0
    video_meetings: Optional[int] = None
    #: Total number of meetings held where at least one participant enabled sharing for any amount of time
    #: example: 123.0
    sharing_meetings: Optional[int] = None
    #: Total number of meetings held where at least one participant enable recording for any amount of time
    #: example: 123.0
    recording_meetings: Optional[int] = None
    #: Participant Count for each join/client type. This list is dynamic and can change
    participants_by_join_methods: Optional[HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByJoinMethods] = None
    #: Participant Count for each Role
    participants_by_roles: Optional[HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByRoles] = None
    #: Participant Count for each Location. This is a json array of countries
    participants_by_location: Optional[list[HistoricalDataRelatedToMeetingsResponseMetricsParticipantsByLocation]] = None


class HistoricalDataRelatedToMeetingsResponse(ApiModel):
    #: Site related to which the data is returned.
    #: example: cisco.webex.com
    site_url: Optional[str] = None
    #: UTC start date of the data set.
    #: example: 2020-08-01
    start_date: Optional[datetime] = None
    #: UTC end date of the data set.
    #: example: 2020-08-03
    end_date: Optional[datetime] = None
    metrics: Optional[HistoricalDataRelatedToMeetingsResponseMetrics] = None


class Cluster(ApiModel):
    #: A unique identifier for the cluster.
    #: example: Y2lZY76123abbb
    id: Optional[str] = None
    #: The ID of the organization to which this hybrid cluster belongs.
    #: example: Y2lzY29zcGFyazovL3
    org_id: Optional[str] = None
    #: The name of the cluster.
    #: example: EMEA Oslo 1
    name: Optional[str] = None
    #: The ID of the resource group this cluster belongs to.
    #: example: Y2lzY29zcGFyazovL3
    resource_group_id: Optional[str] = None


class ClusterCollection(ApiModel):
    #: An array of hybrid cluster objects.
    items: Optional[list[Cluster]] = None


class ConnectorStatus(str, Enum):
    #: Indicates that the connector is working as it should.
    operational = 'operational'
    #: Indicates that the connector has problems with one or more dependent components.
    impaired = 'impaired'
    #: Indicates that the connector is completely non-functional.
    outage = 'outage'
    #: Reports the current maintenance mode state of the connector.
    maintenance_mode = 'maintenanceMode'


class ConnectorType(str, Enum):
    expressway_management = 'expresswayManagement'
    calendar = 'calendar'
    call = 'call'
    message = 'message'
    expressway_serviceability = 'expresswayServiceability'
    ecp_serviceability = 'ecpServiceability'
    video_mesh = 'videoMesh'
    data_security = 'dataSecurity'
    care = 'care'
    care_management = 'careManagement'


class AlarmSeverity(str, Enum):
    critical = 'critical'
    warning = 'warning'
    alert = 'alert'
    error = 'error'


class Alarm(ApiModel):
    #: A unique identifier for the alarm.
    #: example: Y2lZY76123af234bbYY
    id: Optional[str] = None
    #: The date and time the alarm was raised.
    #: example: 2017-09-15T15:53:00Z
    created: Optional[datetime] = None
    #: The severity level of the alarm:
    #: 
    #: - `critical`
    #: 
    #: - `error`
    #: 
    #: - `warning`
    #: 
    #: - `alert`
    #: example: warning
    severity: Optional[AlarmSeverity] = None
    #: The title of the alarm.
    #: example: Something is wrong
    title: Optional[str] = None
    #: A description of the alarm.
    #: example: More detail about something being wrong
    description: Optional[str] = None
    #: The ID of the connector the alarm is raised on.
    #: example: Y2lZY76123af234bb
    hybrid_connector_id: Optional[str] = None


class Connector(ApiModel):
    #: A unique identifier for the connector.
    #: example: Y2lZY76123
    id: Optional[str] = None
    #: The ID of the organization to which this hybrid connector belongs.
    #: example: Y2lzY29zcGFyazovL3
    org_id: Optional[str] = None
    #: The ID of the cluster this connector belongs to.
    #: example: Y2lZY76123abbb
    hybrid_cluster_id: Optional[str] = None
    #: The hostname of the system the connector is running on.
    #: example: foo.example.org
    hostname: Optional[str] = None
    #: The status of the connector:
    #: 
    #: - `operational` indicates that the connector is working as it should.
    #: 
    #: - `impaired` indicates that the connector has problems with one or more dependent components.
    #: 
    #: - `outage` indicates that the connector is completely non-functional.
    #: 
    #: - `maintenanceMode` reports the current maintenance mode state of the connector.
    #: example: operational
    status: Optional[ConnectorStatus] = None
    #: The date and time the connector was created.
    #: example: 2017-09-15T15:53:00Z
    created: Optional[datetime] = None
    #: The type of connector.
    #: example: calendar
    type: Optional[ConnectorType] = None
    #: The version of the software installed.
    #: example: 1.9_foo_zz
    version: Optional[str] = None
    #: A list of alarms raised on the connector.
    alarms: Optional[list[Alarm]] = None


class ConnectorCollection(ApiModel):
    #: An array of hybrid connector objects.
    items: Optional[list[Connector]] = None


class AlarmCollection(ApiModel):
    items: Optional[list[Alarm]] = None


class IssueType(str, Enum):
    #: Issue type for general comments.
    comment = 'COMMENT'
    #: Issue type for reporting defects.
    defect = 'DEFECT'
    #: Issue type for feature requests.
    feature = 'FEATURE'
    #: Issue type for reporting new problems. (default)
    problem = 'PROBLEM'
    #: Issue type for questions that need answers.
    question = 'QUESTION'


class IssueStatus(str, Enum):
    #: Status for issues sssigned to a support person.
    assigned = 'ASSIGNED'
    #: Status for issues that were closed without resolving.
    closed = 'CLOSED'
    #: Status for issues that were escalated to another support team.
    escalated = 'ESCALATED'
    #: Status for open issues. (default)
    new = 'NEW'
    #: Status for issues that were fixed and resolved.
    resolved = 'RESOLVED'


class Issue(ApiModel):
    #: A unique identifier for the issue.
    #: example: Y2lzY29zcGFyazovL3VzL0lTU1VFLzIyNWE0YWY0LTIxYTctNDY2OC05NjhhLWI5NWU2MjlhMjBlNg
    id: Optional[str] = None
    #: A shorter identifier for the issue, unique only to the organization it belongs to.
    #: example: 123.0
    short_key: Optional[int] = None
    #: The subject summary for the issue.
    #: example: No audio during meeting from Webex client.
    subject: Optional[str] = None
    #: The full description of the issue.
    #: example: I could not hear any audio during a Webex Meeting I joined from my Webex for Android client.
    description: Optional[str] = None
    #: The person ID of user the issue was created for.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    created_for: Optional[str] = None
    #: The organization the issue belongs to.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: The type for the issue, such as `PROBLEM` or `DEFECT`.
    #: example: PROBLEM
    type: Optional[IssueType] = None
    #: The status for the issue, such as `NEW` or `CLOSED`.
    #: example: NEW
    status: Optional[IssueStatus] = None
    #: The person ID of user assigned to resolve the issue.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    assignee: Optional[str] = None
    #: A description of how the issue was resolved.
    #: example: The end user's Bluetooth headset was not paired successfully with her Android phone. Re-paring fixed the issue.
    resolution: Optional[str] = None
    #: Date and time issue was created.
    #: example: 2019-06-01T00:00:00.000Z
    created: Optional[datetime] = None
    #: Date and time issue was last modified.
    #: example: 2019-06-01T00:00:00.000Z
    last_modified: Optional[datetime] = None
    #: The person ID of user that last modified the issue.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    last_modified_by: Optional[str] = None
    #: The log ID submitted by webex clients when a user triggers feedback.
    #: example: 99e71be2-25a6-4628-9b77-37002fe40f47
    log_id: Optional[str] = None
    #: The meeting ID related to the issue.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    meeting_id: Optional[str] = None
    #: The space ID created to collaborate on the issue.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    space_id: Optional[str] = None
    #: Any custom identifier associated with the issue, such as from an external ticketing system.
    #: example: TICKET-12345
    external_key: Optional[str] = None


class IssuesCollectionResponse(ApiModel):
    #: An array of issue objects.
    items: Optional[list[Issue]] = None


class LicenseSiteType(str, Enum):
    #: The site is managed by Webex Control Hub.
    control_hub_managed_site = 'Control Hub managed site'
    #: The site is a linked site.
    linked_site = 'Linked site'
    #: The site is managed by Site Administration.
    site_admin_managed_site = 'Site Admin managed site'


class License(ApiModel):
    #: A unique identifier for the license.
    #: example: Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: Name of the licensed feature.
    #: example: Meeting - Webex Meeting Center
    name: Optional[str] = None
    #: Total number of license units allocated.
    #: example: 50.0
    total_units: Optional[int] = None
    #: Total number of license units consumed.
    #: example: 5.0
    consumed_units: Optional[int] = None
    #: The subscription ID associated with this license. This ID is used in other systems, such as Webex Control Hub.
    #: example: Sub-hydraOct26a
    subscription_id: Optional[str] = None
    #: The Webex Meetings site associated with this license.
    #: example: site1-example.webex.com
    site_url: Optional[str] = None
    #: The type of site associated with this license.
    #: example: Control Hub managed site
    site_type: Optional[LicenseSiteType] = None


class LicenseCollectionResponse(ApiModel):
    items: Optional[list[License]] = None


class Users(ApiModel):
    #: A unique identifier for the user.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    id: Optional[str] = None
    #: Indicates if the user is internal or external to the organization.
    #: example: INTERNAL
    type: Optional[GetLocationVoicemailGroupObjectMessageStorageStorageType] = None
    #: The full name of the user.
    #: example: John Andersen
    display_name: Optional[str] = None


class LicensewithUsers(ApiModel):
    #: A unique identifier for the license.
    #: example: Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: Name of the licensed feature.
    #: example: Meeting - Webex Meeting Center
    name: Optional[str] = None
    #: Total number of license units allocated.
    #: example: 50.0
    total_units: Optional[int] = None
    #: Total number of license units consumed.
    #: example: 5.0
    consumed_units: Optional[int] = None
    #: The subscription ID associated with this license. This ID is used in other systems, such as Webex Control Hub.
    #: example: Sub-hydraOct26a
    subscription_id: Optional[str] = None
    #: The Webex Meetings site associated with this license.
    #: example: site1-example.webex.com
    site_url: Optional[str] = None
    #: The type of site associated with this license.
    #: example: Control Hub managed site
    site_type: Optional[LicenseSiteType] = None
    #: A list of users to whom the license is assigned to.
    users: Optional[list[Users]] = None


class LicenseRequestOperation(str, Enum):
    #: Remove the license from the user
    remove = 'remove'
    #: Assign the license to the user
    add = 'add'


class LicenseProperties(ApiModel):
    #: The ID of the location for this user. Applicable to Webex Calling license.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzYzNzE1
    location_id: Optional[str] = None
    #: Work phone number for the user. Applicable to Webex Calling license.
    #: example: 14085267209
    phone_number: Optional[str] = None
    #: Webex Calling extension of the user. Applicable to Webex Calling license.
    #: example: 133
    extension: Optional[datetime] = None


class LicenseRequest(ApiModel):
    #: A unique identifier for the license.
    #: example: Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: Operation type. The default operation is `add` if no operation is specified.
    #: example: add
    operation: Optional[LicenseRequestOperation] = None
    #: Properties for the license. Either `phoneNumber` or `extension` are mandatory for assigning Webex Calling
    #: licenses. If `phoneNumber` is not provided then `locationId` is mandatory.
    properties: Optional[LicenseProperties] = None


class SiteUrlsRequestAccountType(str, Enum):
    #: Attendee role on the siteUrl
    attendee = 'attendee'


class SiteUrlsRequest(ApiModel):
    #: Attendee access on the site.
    #: example: mysite.webex.com
    site_url: Optional[str] = None
    #: Account type. Only `attendee` type is supported. For host account, remove attendee and assign the license on
    #: that site.
    #: example: attendee
    account_type: Optional[SiteUrlsRequestAccountType] = None
    #: Operation type. The default operation is `add` if no operation is specified.
    #: example: add
    operation: Optional[LicenseRequestOperation] = None


class PatchUserLicenses(ApiModel):
    #: Email address of the user.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: A unique identifier for the user.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The ID of the organization to which the licenses and siteUrls belong. If not specified, the organization ID from
    #: the OAuth token is used.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: An array of licenses to be assigned to the user.
    licenses: Optional[list[LicenseRequest]] = None
    #: An array of siteUrls to be assigned to the user.
    site_urls: Optional[list[SiteUrlsRequest]] = None


class SiteResponseAccountType(str, Enum):
    #: Attendee account on the site.
    attendee = 'attendee'
    #: Host account on the site.
    host = 'host'


class SiteResponse(ApiModel):
    #: `siteUrl` assigned to the user.
    #: example: mysite.webex.com
    site_url: Optional[str] = None
    #: Account Type of the site.
    #: example: attendee
    account_type: Optional[SiteResponseAccountType] = None


class UserLicensesResponse(ApiModel):
    #: The ID of the organization to which this user belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: A unique identifier for the user.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of this user.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: An array of license strings that are assigned to this user.
    #: example: ['Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh', 'Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi', 'Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LTIzNDItMGY0NTU2YWRlZXJm']
    licenses: Optional[list[str]] = None
    #: An array of `siteUrls` and their `accountType` that are assigned to this user.
    site_urls: Optional[list[SiteResponse]] = None
    #: An array of license strings that are in pending state. This is only applicable to users outside the
    #: organization.
    #: example: ['Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYWJj', 'Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWFiY2Rl']
    pending_licenses: Optional[list[str]] = None
    #: An array of `siteUrls` and their `accountType` that are in pending state. This is only applicable to users
    #: outside the organization.
    pending_site_urls: Optional[list[SiteResponse]] = None


class GetLicenseDetailsIncludeAssignedTo(str, Enum):
    user = 'user'


class CallingPermissionObjectCallType(str, Enum):
    #: Controls calls within your own company.
    internal_call = 'INTERNAL_CALL'
    #: Controls calls to a telephone number that is billed for all arriving calls instead of incurring charges to the
    #: originating caller, usually free of charge from a landline.
    toll_free = 'TOLL_FREE'
    #: Controls calls to locations outside of the Long Distance areas that require an international calling code before
    #: the number is dialed.
    international = 'INTERNATIONAL'
    #: Controls calls requiring Operator Assistance.
    operator_assisted = 'OPERATOR_ASSISTED'
    #: Controls calls to Directory Assistant companies that require a charge to connect the call.
    chargeable_directory_assisted = 'CHARGEABLE_DIRECTORY_ASSISTED'
    #: Controls calls to carrier-specific number assignments to special services or destinations.
    special_services_i = 'SPECIAL_SERVICES_I'
    #: Controls calls to carrier-specific number assignments to special services or destinations.
    special_services_ii = 'SPECIAL_SERVICES_II'
    #: Controls calls used to provide information or entertainment for a fee charged directly to the caller.
    premium_services_i = 'PREMIUM_SERVICES_I'
    #: Controls calls used to provide information or entertainment for a fee charged directly to the caller.
    premium_services_ii = 'PREMIUM_SERVICES_II'
    #: Controls calls that are National.
    national = 'NATIONAL'


class CallingPermissionObjectAction(str, Enum):
    #: Callers at this location can make these types of calls.
    allow = 'ALLOW'
    #: Callers at this location can't make these types of calls.
    block = 'BLOCK'
    #: Callers must enter the authorization code that you set before placing an outgoing call.
    auth_code = 'AUTH_CODE'
    #: If you select this, then these types of calls are transferred automatically to the configured auto transfer
    #: number `autoTransferNumber1`.
    transfer_number_1 = 'TRANSFER_NUMBER_1'
    #: If you select this, then these types of calls are transferred automatically to the configured auto transfer
    #: number `autoTransferNumber2`.
    transfer_number_2 = 'TRANSFER_NUMBER_2'
    #: If you select this, then these types of calls are transferred automatically to the configured auto transfer
    #: number `autoTransferNumber3`.
    transfer_number_3 = 'TRANSFER_NUMBER_3'


class CallingPermissionObject(ApiModel):
    #: Below are the call type values.
    #: example: INTERNAL_CALL
    call_type: Optional[CallingPermissionObjectCallType] = None
    #: Allows to configure settings for each call type.
    #: example: ALLOW
    action: Optional[CallingPermissionObjectAction] = None
    #: If enabled, allow the person to transfer or forward internal calls.
    #: example: True
    transfer_enabled: Optional[bool] = None


class GeneratePasswordPostResponse(ApiModel):
    #: Example password.
    #: example: xyz123!
    example_sip_password: Optional[str] = None


class GetAutoTransferNumberObject(ApiModel):
    #: Calls placed meeting the criteria in an outbound rule whose `action` is `TRANSFER_NUMBER_1` will be transferred
    #: to this number.
    #: example: 1234456789
    auto_transfer_number1: Optional[str] = None
    #: Calls placed meeting the criteria in an outbound rule whose `action` is `TRANSFER_NUMBER_2` will be transferred
    #: to this number.
    #: example: 2234567891
    auto_transfer_number2: Optional[str] = None
    #: Calls placed meeting the criteria in an outbound rule whose `action` is `TRANSFER_NUMBER_3` will be transferred
    #: to this number.
    #: example: 3234567891
    auto_transfer_number3: Optional[str] = None


class GetLocationAccessCodeObject(ApiModel):
    #: Access code details
    access_codes: Optional[AuthorizationCode] = None


class GetLocationInterceptObjectIncomingType(str, Enum):
    #: Intercept all inbound calls.
    intercept_all = 'INTERCEPT_ALL'
    #: Allow all inbound calls.
    allow_all = 'ALLOW_ALL'


class GetLocationInterceptObjectIncomingAnnouncements(ApiModel):
    #: Greeting type for location intercept.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: If set to `CUSTOM` for greeting, filename of previously uploaded file.
    #: example: .wav
    file_name: Optional[str] = None
    #: Settings for new number announcement.
    new_number: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Transfer number details.
    zero_transfer: Optional[GetLocationVoicemailGroupObjectNotifications] = None


class GetLocationInterceptObjectIncoming(ApiModel):
    #: Select inbound call options.
    #: example: INTERCEPT_ALL
    type: Optional[GetLocationInterceptObjectIncomingType] = None
    #: Enable/disable to route voice mail.
    #: example: True
    voicemail_enabled: Optional[bool] = None
    #: Announcements details.
    announcements: Optional[GetLocationInterceptObjectIncomingAnnouncements] = None


class GetLocationInterceptObjectOutgoingType(str, Enum):
    #: Intercept all outbound calls.
    intercept_all = 'INTERCEPT_ALL'
    #: Allow local outbound calls.
    allow_local_only = 'ALLOW_LOCAL_ONLY'


class GetLocationInterceptObjectOutgoing(ApiModel):
    #: Outbound call modes
    #: example: INTERCEPT_ALL
    type: Optional[GetLocationInterceptObjectOutgoingType] = None
    #: Enable/disable to route all outbound calls to phone number.
    #: example: True
    transfer_enabled: Optional[bool] = None
    #: If enabled, set outgoing destination phone number.
    #: example: 2147691007
    destination: Optional[str] = None


class GetLocationInterceptObject(ApiModel):
    #: Enable/disable location intercept. Enable this feature to override any Location's Call Intercept settings that
    #: person configures.
    #: example: True
    enabled: Optional[bool] = None
    #: Inbound call details.
    incoming: Optional[GetLocationInterceptObjectIncoming] = None
    #: Outbound Call details
    outgoing: Optional[GetLocationInterceptObjectOutgoing] = None


class InternalDialingGet(ApiModel):
    #: When enabled, calls made by users at the location to an unknown extension (between 2-6 digits) are routed to the
    #: selected route group/trunk as premises calls.
    #: example: True
    enable_unknown_extension_route_policy: Optional[bool] = None
    #: The selected route group/trunk as premises calls.
    unknown_extension_route_identity: Optional[RouteIdentity] = None


class InternalDialingPut(ApiModel):
    #: When enabled, calls made by users at the location to an unknown extension (between 2-6 digits) are routed to the
    #: selected route group/trunk as premises calls.
    #: example: True
    enable_unknown_extension_route_policy: Optional[bool] = None
    #: Type associated with the identity.
    unknown_extension_route_identity: Optional[GetTelephonyLocationObjectConnection] = None


class PasswordGenerate(str, Enum):
    #: SIP password setting
    sip = 'SIP'


class PutAccessCodeLocationObject(ApiModel):
    #: Array of string to delete access codes. For example, ["1234","2345"]
    delete_codes: Optional[list[str]] = None


class GetLocationOutgoingPermissionResponse(ApiModel):
    #: Array of calling permissions.
    calling_permissions: Optional[list[CallingPermissionObject]] = None


class RecurWeeklyObject(ApiModel):
    #: Frequency of occurrence in weeks and select the day - Sunday.
    #: example: True
    sunday: Optional[bool] = None
    #: Frequency of occurrence in weeks and select the day - Monday.
    #: example: True
    monday: Optional[bool] = None
    #: Frequency of occurrence in weeks and select the day - Tuesday.
    #: example: True
    tuesday: Optional[bool] = None
    #: Frequency of occurrence in weeks and select the day - Wednesday.
    #: example: True
    wednesday: Optional[bool] = None
    #: Frequency of occurrence in weeks and select the day - Thursday.
    #: example: True
    thursday: Optional[bool] = None
    #: Frequency of occurrence in weeks and select the day - Friday.
    #: example: True
    friday: Optional[bool] = None
    #: Frequency of occurrence in weeks and select the day - Saturday.
    #: example: True
    saturday: Optional[bool] = None


class RecurYearlyByDateObjectMonth(str, Enum):
    january = 'JANUARY'
    february = 'FEBRUARY'
    march = 'MARCH'
    april = 'APRIL'
    may = 'MAY'
    june = 'JUNE'
    july = 'JULY'
    august = 'AUGUST'
    september = 'SEPTEMBER'
    october = 'OCTOBER'
    november = 'NOVEMBER'
    december = 'DECEMBER'


class RecurYearlyByDateObject(ApiModel):
    #: Schedule the event on a specific day of the month.
    #: example: 1.0
    day_of_month: Optional[int] = None
    #: Schedule the event on a specific month of the year.
    #: example: JANUARY
    month: Optional[RecurYearlyByDateObjectMonth] = None


class RecurYearlyByDayObjectDay(str, Enum):
    sunday = 'SUNDAY'
    monday = 'MONDAY'
    tuesday = 'TUESDAY'
    wednesday = 'WEDNESDAY'
    thursday = 'THURSDAY'
    friday = 'FRIDAY'
    saturday = 'SATURDAY'


class RecurYearlyByDayObjectWeek(str, Enum):
    first = 'FIRST'
    second = 'SECOND'
    third = 'THIRD'
    fourth = 'FOURTH'
    last = 'LAST'


class RecurYearlyByDayObject(ApiModel):
    #: Schedule the event on a specific day.
    #: example: SUNDAY
    day: Optional[RecurYearlyByDayObjectDay] = None
    #: Schedule the event on a specific week.
    #: example: SECOND
    week: Optional[RecurYearlyByDayObjectWeek] = None
    #: Schedule the event on a specific month.
    #: example: JANUARY
    month: Optional[RecurYearlyByDateObjectMonth] = None


class RecurrenceObject(ApiModel):
    #: Flag to indicate if event will recur forever.
    recur_for_ever: Optional[bool] = None
    #: End date of recurrence.
    #: example: 2021-11-30
    recur_end_date: Optional[datetime] = None
    #: Weekly recurrence definition.
    recur_weekly: Optional[RecurWeeklyObject] = None
    #: Recurrence definition yearly by date.
    recur_yearly_by_date: Optional[RecurYearlyByDateObject] = None
    #: Recurrence definition yearly by day.
    recur_yearly_by_day: Optional[RecurYearlyByDayObject] = None


class GetScheduleEventObject(ApiModel):
    #: A unique identifier for the schedule event.
    #: example: Y2lzY29zcGFyazovL3VzL1NDSEVEVUxFX0VWRU5UL1RXOXVaR0Y1VTJOb1pXUjFiR1U
    id: Optional[str] = None
    #: Name for the event.
    #: example: MondaySchedule
    name: Optional[str] = None
    #: Start Date of Event.
    #: example: 2021-11-01
    start_date: Optional[datetime] = None
    #: End Date of Event.
    #: example: 2021-11-30
    end_date: Optional[datetime] = None
    #: Start time of event.
    #: example: 12:20
    start_time: Optional[datetime] = None
    #: End time of event.
    #: example: 14:20
    end_time: Optional[datetime] = None
    #: An indication of whether given event is an all-day event or not.
    all_day_enabled: Optional[bool] = None
    #: Recurrence definition.
    recurrence: Optional[RecurrenceObject] = None


class GetScheduleObjectType(str, Enum):
    #: Business hours schedule type.
    business_hours = 'businessHours'
    #: Holidays schedule type.
    holidays = 'holidays'


class GetScheduleObject(ApiModel):
    #: A unique identifier for the schedule.
    #: example: Y2lzY29zcGFyazovL3VzL1NDSEVEVUxFL1FWVlVUMEZVVkVWT1JFRk9WQzFDVlZOSlRrVlRVeTFJVDFWU1V3
    id: Optional[str] = None
    #: Unique name for the schedule.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    name: Optional[str] = None
    #: Type of the schedule.
    #: example: businessHours
    type: Optional[GetScheduleObjectType] = None
    #: List of schedule events.
    events: Optional[list[GetScheduleEventObject]] = None


class ListScheduleObject(ApiModel):
    #: A unique identifier for the schedule.
    #: example: Y2lzY29zcGFyazovL3VzL1NDSEVEVUxFL1FWVlVUMEZVVkVWT1JFRk9WQzFDVlZOSlRrVlRVeTFJVDFWU1V3
    id: Optional[str] = None
    #: Unique name for the schedule.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    name: Optional[str] = None
    #: Type of the schedule.
    #: example: businessHours
    type: Optional[GetScheduleObjectType] = None
    #: Name of location for schedule.
    #: example: Alaska
    location_name: Optional[str] = None
    #: ID of the location for the schedule.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzEyMzQ1
    location_id: Optional[str] = None


class ModifyScheduleEventListObject(ApiModel):
    #: Current name for the event.
    #: example: Schedule
    name: Optional[str] = None
    #: New name for the event.
    #: example: MondaySchedule
    new_name: Optional[str] = None
    #: Start date of event.
    #: example: 2021-11-01
    start_date: Optional[datetime] = None
    #: End date of event.
    #: example: 2021-11-30
    end_date: Optional[datetime] = None
    #: Start time of event. Mandatory if the event is not all day.
    #: example: 12:20
    start_time: Optional[datetime] = None
    #: End time of event. Mandatory if the event is not all day.
    #: example: 14:20
    end_time: Optional[datetime] = None
    #: An indication of whether given event is an all-day event or not. Mandatory if the `startTime` and `endTime` are
    #: not defined.
    all_day_enabled: Optional[bool] = None
    #: Recurrence definition.
    recurrence: Optional[RecurrenceObject] = None


class ModifyScheduleEventObject(ApiModel):
    #: Name for the event.
    #: example: MondaySchedule
    name: Optional[str] = None
    #: Start date of event.
    #: example: 2021-11-01
    start_date: Optional[datetime] = None
    #: End date of event.
    #: example: 2021-11-30
    end_date: Optional[datetime] = None
    #: Start time of event. Mandatory if the event is not all day.
    #: example: 12:20
    start_time: Optional[datetime] = None
    #: End time of event. Mandatory if the event is not all day.
    #: example: 14:20
    end_time: Optional[datetime] = None
    #: An indication of whether given event is an all-day event or not. Mandatory if the `startTime` and `endTime` are
    #: not defined.
    all_day_enabled: Optional[bool] = None
    #: Recurrence definition.
    recurrence: Optional[RecurrenceObject] = None


class ModifyScheduleObject(ApiModel):
    #: Unique name for the schedule.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    name: Optional[str] = None
    #: List of schedule events.
    events: Optional[list[ModifyScheduleEventListObject]] = None


class PostScheduleObject(ApiModel):
    #: Type of the schedule.
    #: example: businessHours
    type: Optional[GetScheduleObjectType] = None
    #: Unique name for the schedule.
    #: example: AUTOATTENDANT-BUSINESS-HOURS
    name: Optional[str] = None
    #: List of schedule events.
    events: Optional[list[ModifyScheduleEventObject]] = None


class ReadTheListOfSchedulesResponse(ApiModel):
    #: Array of schedules.
    schedules: Optional[list[ListScheduleObject]] = None


class GetLocationVoicemailGroupObject1(ApiModel):
    #: UUID of voicemail group of a particular location.
    #: example: a7dd4d39-4a78-4516-955f-7810dbe379cf
    id: Optional[str] = None
    #: Name of the voicemail group.
    #: example: VGName
    name: Optional[str] = None
    #: Voicemail group phone number.
    #: example: +1234234324
    phone_number: Optional[str] = None
    #: Voicemail group extension number.
    #: example: 23455.0
    extension: Optional[int] = None
    #: Voicemail group toll free number.
    toll_free_number: Optional[bool] = None
    #: Voicemail group caller ID first name.
    #: example: Customer
    first_name: Optional[str] = None
    #: Voicemail group called ID last name.
    #: example: Support
    last_name: Optional[str] = None
    #: Enable/disable voicemail group.
    #: example: True
    enabled: Optional[bool] = None
    #: Language for voicemail group audio announcement.
    #: example: en_us
    language_code: Optional[str] = None
    #: Set voicemail group greeting type.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Enabled if CUSTOM greeting is previously uploaded.
    #: example: True
    greeting_uploaded: Optional[bool] = None
    #: CUSTOM greeting for previously uploaded.
    #: example: short greeting.wav
    greeting_description: Optional[str] = None
    #: Message storage information
    message_storage: Optional[GetLocationVoicemailGroupObjectMessageStorage] = None
    #: Message notifications
    notifications: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Fax message receive settings
    fax_message: Optional[GetLocationVoicemailGroupObjectFaxMessage] = None
    #: Transfer message information
    transfer_to_number: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Message copy information
    email_copy_of_message: Optional[GetLocationVoicemailGroupObjectEmailCopyOfMessage] = None
    #: Enable/disable to forward voice message.
    #: example: True
    voice_message_forwarding_enabled: Optional[bool] = None


class GetLocationVoicemailObject(ApiModel):
    #: Set to `true` to enable voicemail transcription.
    #: example: True
    voicemail_transcription_enabled: Optional[bool] = None


class GetVoicePortalObject(ApiModel):
    #: Voice Portal ID
    #: example: Y2lzY29zcGFyazovL3VzL1ZPSUNFTUFJTF9HUk9VUC8yZmQzZGMwMy0yZWRhLTQ4NmUtODdhYS0xODY1ZDI5YWExZWI
    id: Optional[str] = None
    #: Voice Portal Name.
    #: example: test voicePortal
    name: Optional[str] = None
    #: Language for audio announcements.
    #: example: English
    language: Optional[str] = None
    #: Language code for voicemail group audio announcement.
    #: example: en_us
    language_code: Optional[str] = None
    #: Extension of incoming call.
    #: example: 0007
    extension: Optional[datetime] = None
    #: Phone Number of incoming call.
    #: example: +1345325235
    phone_number: Optional[str] = None
    #: Caller ID First Name.
    #: example: firstName
    first_name: Optional[str] = None
    #: Caller ID Last Name.
    #: example: lastName
    last_name: Optional[str] = None


class GetVoicePortalPasscodeRuleObjectFailedAttempts(ApiModel):
    #: If enabled, allows specified number of attempts before locking voice portal access.
    #: example: True
    enabled: Optional[bool] = None
    #: Number of failed attempts allowed.
    #: example: 3.0
    attempts: Optional[int] = None


class GetVoicePortalPasscodeRuleObject(ApiModel):
    #: Settings for passcode expiry.
    expire_passcode: Optional[GetVoicemailRulesObjectExpirePasscode] = None
    #: Number of failed attempts allowed.
    failed_attempts: Optional[GetVoicePortalPasscodeRuleObjectFailedAttempts] = None
    #: Settings for previous passcode usage.
    block_previous_passcodes: Optional[GetVoicemailRulesObjectBlockPreviousPasscodes] = None
    #: Settings for not allowing single or groups of repeated digits in passcode (for example, 22888, 121212, or
    #: 408408).
    #: 
    #: + enabled: true (boolean) - If enabled, passcode should not contain repeated digits.
    #: + max: `3` (number) - Maximum number of digits to be considered as a repeated sequence. The minimum value is 1.
    #: The maximum value is 6.
    block_repeated_digits: Optional[AttachmentAction] = None
    #: Settings for not allowing numerical sequence in passcode (for example, 012345 or 987654).
    #: 
    #: + enabled: true (boolean) - If enabled, do not allow the specified number of ascending or descending digits in a
    #: row.
    #: + numberOfAscendingDigits: `3` (number) -  Number of ascending digits in sequence. The minimum value is 2. The
    #: maximum value is 5.
    #: + numberOfDescendingDigits: `3` (number) -  Number of descending digits in sequence. The minimum value is 2. The
    #: maximum value is 5.
    block_contiguous_sequences: Optional[AttachmentAction] = None
    #: Allowed length of the passcode.
    length: Optional[GetVoicemailRulesObjectDefaultVoicemailPinRulesLength] = None
    #: If enabled, the passcode do not contain repeated pattern.
    #: example: True
    block_repeated_patterns_enabled: Optional[bool] = None
    #: If enabled, the passcode do not allow user phone number or extension.
    #: example: True
    block_user_number_enabled: Optional[bool] = None
    #: If enabled, the passcode do not allow revered phone number or extension.
    #: example: True
    block_reversed_user_number_enabled: Optional[bool] = None
    #: If enabled, the passcode do not allow setting reversed old passcode.
    #: example: True
    block_reversed_old_passcode_enabled: Optional[bool] = None


class GetVoicemailGroupObject1(ApiModel):
    #: Voicemail Group ID.
    #: example: Y2lzY29zcGFyazovL3VzL1ZPSUNFTUFJTF9HUk9VUC8yZmQzZGMwMy0yZWRhLTQ4NmUtODdhYS0xODY1ZDI5YWExZWI
    id: Optional[str] = None
    #: Voicemail Group Name.
    #: example: test
    name: Optional[str] = None
    #: Location Name.
    #: example: San Jose
    location_name: Optional[str] = None
    #: Location ID.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzMxMTYx
    location_id: Optional[str] = None
    #: Extension of the voicemail group.
    #: example: 0007
    extension: Optional[datetime] = None
    #: Phone number of the voicemail group.
    #: example: +1345325235
    phone_number: Optional[str] = None
    #: If enabled, incoming calls are sent to voicemail.
    #: example: True
    enabled: Optional[bool] = None
    #: Flag to indicate if the number is toll free.
    #: example: True
    toll_free_number: Optional[bool] = None


class PostLocationVoicemailGroupObject(ApiModel):
    #: Set name to create new voicemail group for a particular location for a customer.
    #: example: VGName
    name: Optional[str] = None
    #: Set voicemail group phone number for this particular location.
    #: example: +1234234324
    phone_number: Optional[str] = None
    #: Set unique voicemail group extension number for this particular location.
    #: example: 23455.0
    extension: Optional[int] = None
    #: Set voicemail group caller ID first name.
    #: example: Customer
    first_name: Optional[str] = None
    #: Set voicemail group called ID last name.
    #: example: Support
    last_name: Optional[str] = None
    #: Set passcode to access voicemail group when calling.
    #: example: 1234.0
    passcode: Optional[int] = None
    #: Language code for voicemail group audio announcement.
    #: example: en_us
    language_code: Optional[str] = None
    #: Message storage information
    message_storage: Optional[GetLocationVoicemailGroupObjectMessageStorage] = None
    #: Message notifications
    notifications: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Fax message information
    fax_message: Optional[GetLocationVoicemailGroupObjectFaxMessage] = None
    #: Transfer message information
    transfer_to_number: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Message copy information
    email_copy_of_message: Optional[GetLocationVoicemailGroupObjectEmailCopyOfMessage] = None


class PutLocationVoicemailGroupObject(ApiModel):
    #: Set the name of the voicemail group.
    #: example: VGName
    name: Optional[str] = None
    #: Set voicemail group phone number.
    #: example: +1234234324
    phone_number: Optional[str] = None
    #: Set unique voicemail group extension number.
    #: example: 23455.0
    extension: Optional[int] = None
    #: Set the voicemail group caller ID first name.
    #: example: Customer
    first_name: Optional[str] = None
    #: Set the voicemail group called ID last name.
    #: example: Support
    last_name: Optional[str] = None
    #: Set to `true` to enable the voicemail group.
    #: example: True
    enabled: Optional[bool] = None
    #: Set passcode to access voicemail group when calling.
    #: example: 1234.0
    passcode: Optional[int] = None
    #: Language code for the voicemail group audio announcement.
    #: example: en_us
    language_code: Optional[str] = None
    #: Voicemail group greeting type.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: CUSTOM greeting for previously uploaded.
    #: example: short greeting.wav
    greeting_description: Optional[str] = None
    #: Message storage information
    message_storage: Optional[GetLocationVoicemailGroupObjectMessageStorage] = None
    #: Message notifications
    notifications: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Fax message receive settings
    fax_message: Optional[GetLocationVoicemailGroupObjectFaxMessage] = None
    #: Transfer message information
    transfer_to_number: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Message copy information
    email_copy_of_message: Optional[GetLocationVoicemailGroupObjectEmailCopyOfMessage] = None


class PutVoicePortalObjectPasscode(ApiModel):
    #: New passcode.
    #: example: testPass123
    new_passcode: Optional[str] = None
    #: Confirm new passcode.
    #: example: testPass123
    confirm_passcode: Optional[str] = None


class PutVoicePortalObject(ApiModel):
    #: Voice Portal Name.
    #: example: test voicePortal
    name: Optional[str] = None
    #: Language code for voicemail group audio announcement.
    #: example: en_us
    language_code: Optional[str] = None
    #: Extension of incoming call.
    #: example: 0007
    extension: Optional[datetime] = None
    #: Phone Number of incoming call.
    #: example: +1345325235
    phone_number: Optional[str] = None
    #: Caller ID First Name.
    #: example: firstName
    first_name: Optional[str] = None
    #: Caller ID Last Name.
    #: example: lastName
    last_name: Optional[str] = None
    #: Voice Portal Admin Passcode.
    passcode: Optional[PutVoicePortalObjectPasscode] = None


class ListVoicemailGroupResponse1(ApiModel):
    #: Array of VoicemailGroups.
    voicemail_groups: Optional[list[GetVoicemailGroupObject1]] = None


class PutTelephonyLocationObject1(ApiModel):
    #: Location's phone announcement language.
    #: example: 'fr_fr'
    announcement_language: Optional[str] = None
    #: Location calling line information.
    calling_line_id: Optional[GetTelephonyLocationObjectCallingLineId] = None
    #: Connection details can only be modified to and from local PSTN types of `TRUNK` and `ROUTE_GROUP`.
    connection: Optional[GetTelephonyLocationObjectConnection] = None
    #: Denve' (string) - External Caller ID Name value. Unicode characters.
    #: example: 'Big Corp
    external_caller_id_name: Optional[str] = None
    #: Location Identifier.
    #: example: 'Rcdn'
    p_access_network_info: Optional[str] = None
    #: Must dial to reach an outside line. Default is None.
    #: example: '12'
    outside_dial_digit: Optional[datetime] = None
    #: Must dial a prefix when calling between locations having same extension within same location; should be numeric.
    #: example: '2'
    routing_prefix: Optional[datetime] = None
    #: Chargeable number for the line placing the call. When this is set, all calls placed from this location will
    #: include a P-Charge-Info header with the selected number in the SIP INVITE.
    #: example: '+14158952369'
    charge_number: Optional[str] = None


class Location7(ApiModel):
    #: A unique identifier for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2M5N2VlMDQ5LTM1OWItNGM3OC04NDU0LTA1OGMyZWRlMjU2Mw
    id: Optional[str] = None
    #: The name of the location.
    #: example: Denver
    name: Optional[str] = None
    #: The ID of the organization to which this location belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: Time zone associated with this location.
    #: example: 'America/Chicago'
    time_zone: Optional[str] = None
    #: The address of the location.
    address: Optional[PostLocationCallingRequestAddress] = None
    #: Latitude
    #: example: 12.935784
    latitude: Optional[datetime] = None
    #: Longitude
    #: example: 77.697332
    longitude: Optional[datetime] = None
    #: Notes
    #: example: 123 Some St. Denver Location
    notes: Optional[str] = None


class PutCommonLocationObject(ApiModel):
    #: The name of the location.
    #: example: 'Denver'
    name: Optional[str] = None
    #: Time zone associated with this location, refer to this `link
    #: <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_ for format.
    #: example: 'America/Chicago'
    time_zone: Optional[str] = None
    #: Default email language.
    #: example: 'en_us'
    preferred_language: Optional[str] = None
    #: The address of the location.
    address: Optional[PostLocationCallingRequestAddress] = None


class PostCommonLocationObject(ApiModel):
    #: The name of the location.
    #: example: 'Denver'
    name: Optional[str] = None
    #: Time zone associated with this location, refer to this `link
    #: <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_ for format.
    #: example: 'America/Chicago'
    time_zone: Optional[str] = None
    #: Default email language.
    #: example: 'en_us'
    preferred_language: Optional[str] = None
    #: Location's phone announcement language.
    #: example: 'fr_fr'
    announcement_language: Optional[str] = None
    #: The address of the location.
    address: Optional[PostLocationCallingRequestAddress] = None
    #: Latitude
    #: example: 12.935784
    latitude: Optional[datetime] = None
    #: Longitude
    #: example: 77.697332
    longitude: Optional[datetime] = None
    #: Notes
    #: example: 123 Some St. Denver Location
    notes: Optional[str] = None


class LocationsCollectionResponse(ApiModel):
    items: Optional[list[Location7]] = None


class Floor(ApiModel):
    #: Unique identifier for the floor.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMl9hL1dPUktTUEFDRV9MT0NBVElPTl9GTE9PUi83NDhkZDNmMS1iYmE5LTQxMDItODk5NC00M2IyOTM2MzNlNjY
    id: Optional[str] = None
    #: Unique identifier for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2E4NjczZDIwLWM0M2EtNDQ5Ni1iYWIxLTNiMjhhZGJjMjViYQ
    location_id: Optional[str] = None
    #: The floor number.
    #: example: -1.0
    floor_number: Optional[int] = None
    #: The floor display name.
    #: example: The basement
    display_name: Optional[str] = None


class FloorCreationRequest(ApiModel):
    #: The floor number.
    #: example: -1.0
    floor_number: Optional[int] = None
    #: The floor display name.
    #: example: The basement
    display_name: Optional[str] = None


class FloorCollectionResponse(ApiModel):
    #: An array of floor objects.
    items: Optional[list[Floor]] = None


class ChatObjectSender(ApiModel):
    #: Email address of the sender of the meeting chat snippet.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Display name for the sender.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: A unique identifier for the sender.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS81YmVkZWUyMC1hNjI3LTQ4YTUtODg0Yi04NjVhODhlZmFhNzM
    person_id: Optional[str] = None
    #: The ID of the organization to which the sender belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi81OWU2NzUyNy00NjUxLTRjOTAtYjJmMC00Zjg2YzNiYjY2MDg
    org_id: Optional[str] = None


class ChatObject(ApiModel):
    #: A unique identifier for the chat snippet.
    #: example: 1aea8390-e375-4547-b7ff-58ecd9e0b03d
    id: Optional[str] = None
    #: Chat time for the chat snippet in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:22:34Z
    chat_time: Optional[datetime] = None
    #: The text of the chat snippet.
    #: example: hi
    text: Optional[str] = None
    #: A unique identifier for the `meeting instance
    #: <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the chat belongs.
    #: example: a2f95f5073e347489f7611492dbd6ad5_I_199075330905867928
    meeting_id: Optional[str] = None
    #: Whether the type of the chat is private, public or group. Private chat is for the 1:1 chat. Public chat is for
    #: the message which is sent to all the people in the meeting. Group chat is for the message which is sent to a
    #: small group of people, like a message to "host and presenter".
    #: example: private
    type: Optional[str] = None
    #: Information of the sender of the chat snippet.
    sender: Optional[ChatObjectSender] = None
    #: Information of the receivers of the chat snippet.
    receivers: Optional[list[ChatObjectSender]] = None


class ListMeetingChatsResponse(ApiModel):
    #: Chat array
    items: Optional[list[ChatObject]] = None


class ClosedCaptionObject(ApiModel):
    #: A unique identifier for the closed caption.
    #: example: 195d64646ad14be2924ea50f541fd91d
    id: Optional[str] = None
    #: Unique identifier for the `meeting instance
    #: <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ which the closed captions belong to.
    #: example: 0ed74a1c0551494fb7a04e2881bf50ae_I_166022169160077044
    meeting_id: Optional[str] = None
    #: The download link for the closed caption vtt file.
    #: example: http://site-example.webex.com/v1/meetingClosedCaptions/195d64646ad14be2924ea50f541fd91d/download?format=vtt
    vtt_download_link: Optional[str] = None
    #: The download link for the closed caption txt file.
    #: example: http://site-example.webex.com/v1/meetingClosedCaptions/195d64646ad14be2924ea50f541fd91d/download?format=txt
    txt_download_link: Optional[str] = None
    #: Start time for the meeting closed caption in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2020-06-01T20:30:15.042Z
    start: Optional[datetime] = None


class SnippetObject(ApiModel):
    #: A unique identifier for the closed caption snippet.
    #: example: 195d64646ad14be2924ea50f541fd91d_00001
    id: Optional[str] = None
    #: Unique identifier for the `meeting instance
    #: <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ which the closed captions belong to.
    #: example: 0ed74a1c0551494fb7a04e2881bf50ae_I_166022169160077044
    meeting_id: Optional[str] = None
    #: Text for the snippet.
    #: example: Hello everyone
    text: Optional[str] = None
    #: Name of the person who spoke.
    #: example: John Andersen
    person_name: Optional[str] = None
    #: Email address of the person who spoke.
    #: example: john.andersen@example.com
    person_email: Optional[str] = None
    #: The unique identifier for the person speaking.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    people_id: Optional[str] = None
    #: Start time for the snippet.
    #: example: 2019-11-01T12:30:05Z
    start: Optional[datetime] = None
    #: Offset from the beginning of the closed captions in milliseconds indicating the start time of the snippet.
    #: example: 1000
    offset_millisecond: Optional[datetime] = None
    #: Duration of the snippet in milliseconds.
    #: example: 2000
    duration_millisecond: Optional[datetime] = None
    #: Original language of the snippet.
    #: example: en
    language: Optional[str] = None


class ListMeetingClosedCaptionsResponse(ApiModel):
    #: Closed caption array
    items: Optional[list[ClosedCaptionObject]] = None


class ListMeetingClosedCaptionSnippetsResponse(ApiModel):
    #: Closed caption snippet array
    items: Optional[list[SnippetObject]] = None


class DownloadMeetingClosedCaptionSnippetsFormat(str, Enum):
    vtt = 'vtt'
    txt = 'txt'


class UpdateInviteeObject(ApiModel):
    #: Email address for meeting invitee.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Display name for meeting invitee. The maximum length of `displayName` is 128 characters. In the Webex app, if
    #: the email has been associated with an existing Webex account, the display name associated with the Webex
    #: account will be used; otherwise, the `email` will be used as `displayName`. In a Webex site, if `displayName`
    #: is specified, it will show `displayName`. If `displayName` is not specified, and the `email` has been
    #: associated with an existing Webex account, the display name associated with the Webex account will be used;
    #: otherwise, the `email` will be used as `displayName`.
    #: 
    #: If the invitee has an existing Webex account, the `displayName` shown in the meeting will be the `displayName`
    #: associated with the Webex account; otherwise, `displayName` shown in the meeting will be the `displayName`
    #: which is specified by the invitee who does not have a Webex account.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: Whether or not the invitee is a designated alternate host for the meeting. See
    #: `Add Alternate Hosts for Cisco Webex Meetings
    #: <https://help.webex.com/b5z6he/>`_ for more details.
    co_host: Optional[bool] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage
    #: to be the meeting host.
    #: example: brenda.song@example.com
    host_email: Optional[str] = None
    #: If `true`, send an email to the invitee.
    #: example: True
    send_email: Optional[bool] = None
    #: If `true`, the invitee is a designated panelist for the event meeting.
    panelist: Optional[bool] = None


class CreateInviteeObject(ApiModel):
    #: Unique identifier for the meeting to which a person is being invited. This attribute only applies to meeting
    #: series and scheduled meeting. If it's a meeting series, the meeting invitee is invited to the entire meeting
    #: series; if it's a scheduled meeting, the meeting invitee is invited to this individual scheduled meeting. It
    #: doesn't apply to an ended or ongoing meeting instance. The meeting ID of a scheduled `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is
    #: not supported for this API.
    #: example: 870f51ff287b41be84648412901e0402
    meeting_id: Optional[str] = None
    #: Email address for meeting invitee.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Display name for meeting invitee. The maximum length of `displayName` is 128 characters. In the Webex app, if
    #: the email has been associated with an existing Webex account, the display name associated with the Webex
    #: account will be used; otherwise, the `email` will be used as `displayName`. In a Webex site, if `displayName`
    #: is specified, it will show `displayName`. If `displayName` is not specified, and the `email` has been
    #: associated with an existing Webex account, the display name associated with the Webex account will be used;
    #: otherwise, the `email` will be used as `displayName`.
    #: 
    #: If the invitee has an existing Webex account, the `displayName` shown in the meeting will be the `displayName`
    #: associated with the Webex account; otherwise, `displayName` shown in the meeting will be the `displayName`
    #: which is specified by the invitee who does not have a Webex account.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: Whether or not the invitee is a designated alternate host for the meeting. See
    #: `Add Alternate Hosts for Cisco Webex Meetings
    #: <https://help.webex.com/b5z6he/>`_ for more details.
    co_host: Optional[bool] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage
    #: to be the meeting host.
    #: example: brenda.song@example.com
    host_email: Optional[str] = None
    #: If `true`, send an email to the invitee.
    #: example: True
    send_email: Optional[bool] = None
    #: If `true`, the invitee is a designated panelist for the event meeting.
    panelist: Optional[bool] = None


class CreateInviteesItemResponseObject(ApiModel):
    #: Unique identifier for meeting invitee.
    #: example: 870f51ff287b41be84648412901e0402_2628962
    id: Optional[str] = None
    #: Unique identifier for the meeting to which a person is being invited. This attribute only applies to meeting
    #: series and scheduled meeting. If it's a meeting series, the meeting invitee is invited to the entire meeting
    #: series; if it's a scheduled meeting, the meeting invitee is invited to this individual scheduled meeting. It
    #: doesn't apply to an ended or ongoing meeting instance.
    #: example: 870f51ff287b41be84648412901e0402
    meeting_id: Optional[str] = None
    #: Email address for meeting invitee.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Display name for meeting invitee. The maximum length of `displayName` is 128 characters. In the Webex App, if
    #: the email has been associated with an existing Webex account, the display name associated with the Webex
    #: account will be used; otherwise, the `email` will be used as `displayName`. In Webex site, if `displayName` is
    #: specified, it will show `displayName`. If `displayName` is not specified, and the `email` has been associated
    #: with an existing Webex account, the display name associated with the Webex account will be used; otherwise, the
    #: `email` will be used as `displayName`.
    #: 
    #: If the invitee has an existing Webex account, the `displayName` shown in the meeting will be the `displayName`
    #: associated with the Webex account; otherwise, `displayName` shown in the meeting will be the `displayName`
    #: which is specified by the invitee who does not have a Webex account.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: Whether or not the invitee is a designated alternate host for the meeting. See
    #: `Add Alternate Hosts for Cisco Webex Meetings
    #: <https://help.webex.com/b5z6he/>`_ for more details.
    co_host: Optional[bool] = None
    #: If `true`, the invitee is a designated panelist for the event meeting.
    panelist: Optional[bool] = None


class CreateInviteesItemObject(ApiModel):
    #: Email address for meeting invitee.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Display name for meeting invitee. The maximum length of `displayName` is 128 characters. In Webex App, if the
    #: email has been associated with an existing Webex account, the display name associated with the Webex account
    #: will be used; otherwise, the `email` will be used as `displayName`. In Webex site, if `displayName` is
    #: specified, it will show `displayName`. If `displayName` is not specified, and the `email` has been associated
    #: with an existing Webex account, the display name associated with the Webex account will be used; otherwise, the
    #: `email` will be used as `displayName`.
    #: 
    #: Please note that if the invitee has an existing Webex account, the `displayName` shown in the meeting will be
    #: the `displayName` associated with the Webex account; otherwise, `displayName` shown in the meeting will be the
    #: `displayName` which is specified by the invitee who does not have a Webex account.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: Whether or not invitee is a designated alternate host for the meeting. See
    #: `Add Alternate Hosts for Cisco Webex Meetings
    #: <https://help.webex.com/b5z6he/>`_ for more details.
    co_host: Optional[bool] = None
    #: If `true`, send an email to the invitee.
    #: example: True
    send_email: Optional[bool] = None
    #: If `true`, the invitee is a designated panelist for the event meeting.
    panelist: Optional[bool] = None


class CreateInviteesObject(ApiModel):
    #: Unique identifier for the meeting to which the people are being invited. This attribute only applies to meeting
    #: series and scheduled meetings. If it's a meeting series, the meeting invitees are invited to the entire meeting
    #: series; if it's a scheduled meeting, the meeting invitees are invited to this individual scheduled meeting. It
    #: doesn't apply to an ended or ongoing meeting instance. The meeting ID of a scheduled `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is
    #: not supported for this API.
    #: example: 870f51ff287b41be84648412901e0402
    meeting_id: Optional[str] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage
    #: to be the meeting host.
    #: example: brenda.song@example.com
    host_email: Optional[str] = None
    #: Meeting invitees to be inserted.
    items: Optional[list[CreateInviteesItemObject]] = None


class CreateInviteesResponse(ApiModel):
    #: Meeting invitees inserted.
    items: Optional[list[CreateInviteesItemResponseObject]] = None


class ParticipantState(str, Enum):
    #: The participant is waiting in the meeting lobby.
    lobby = 'lobby'
    #: The participant has left the meeting.
    end = 'end'
    #: The participant has joined the meeting and is in the main session.
    joined = 'joined'
    #: The participant has joined a breakout session.
    breakout_session = 'breakoutSession'


class DeviceAudioType(str, Enum):
    #: `PSTN`
    pstn = 'pstn'
    #: `VoIP`
    voip = 'voip'
    #: The participant is not connected to audio.
    inactive = 'inactive'


class DeviceCallType(str, Enum):
    #: Connect audio by dialing a toll or toll-free phone number provided by the meeting.
    call_in = 'callIn'
    #: Connect audio by dialing out a phone number from the meeting.
    call_back = 'callBack'


class Device1(ApiModel):
    #: An internal ID that is associated with each join.
    #: example: 8ccced6c-b812-4dff-a5dd-4c5c28f8d47d
    correlation_id: Optional[str] = None
    #: The type of the device.
    #: example: webex_meeting_center_mac
    device_type: Optional[str] = None
    #: The audio type that the participant is using.
    #: example: pstn
    audio_type: Optional[DeviceAudioType] = None
    #: The time the device joined the meeting. If the field is non-existent or shows `1970-01-    01T00:00:00.000Z` the
    #: meeting may be still ongoing and the `joinedTime` will be filled in after the meeting ended. If you need
    #: real-time joined     events, please refer to the webhooks guide.
    #: example: 2019-04-23T17:31:00.000Z
    joined_time: Optional[datetime] = None
    #: The time the device left the meeting, `leftTime` is the exact moment when a specific devi    ce left the
    #: meeting. If the field is non-existent or shows `1970-01-01T00:00:00.000Z` the meeting may be still ongoing and
    #: the `leftTime` will     be filled in after the meeting ended. If you need real-time left events, please refer
    #: to the webhooks guide.
    #: example: 2019-04-23T17:32:00.000Z
    left_time: Optional[datetime] = None
    #: The duration in seconds the device stayed in the meeting.
    #: example: 60.0
    duration_second: Optional[int] = None
    #: The PSTN call type in which the device joined the meeting.
    #: example: callIn
    call_type: Optional[DeviceCallType] = None
    #: The PSTN phone number from which the device joined the meeting. Only `compliance officer
    #: <https://developer.webex.com/docs/compliance#compliance>`_ can retrieve the
    #: `phoneNumber`. The meeting host and admin users cannot retrieve it. NOTE: The `phoneNumber` will be returned
    #: after the meeting ends; it is not returned while the meeting is in progress.
    #: example: 745273328
    phone_number: Optional[str] = None


class Participant(ApiModel):
    #: The ID that identifies the meeting and the participant.
    #: example: 560d7b784f5143e3be2fc3064a5c4999_3c2e2338-e950-43bf-b588-573773ee43d1
    id: Optional[str] = None
    #: The ID that identifies the organization. It only applies to participants of ongoing meetings.
    #: example: 1eb65fdf-9643-417f-9974-ad72cae0e10f
    org_id: Optional[str] = None
    #: Whether or not the participant is the host of the meeting.
    #: example: True
    host: Optional[bool] = None
    #: Whether or not the participant has host privilege in the meeting.
    co_host: Optional[bool] = None
    #: Whether or not the participant is the team space moderator. This field returns only if the meeting is associated
    #: with a Webex space.
    space_moderator: Optional[bool] = None
    #: The email address of the participant.
    #: example: joeDoe@cisco.com
    email: Optional[str] = None
    #: The name of the participant.
    #: example: Joe Doe
    display_name: Optional[str] = None
    #: Whether or not the participant is invited to the meeting.
    invitee: Optional[bool] = None
    #: Whether or not the participant's audio is muted.
    muted: Optional[bool] = None
    #: The time the meeting started.
    #: example: 2020-10-02T17:31:00Z
    meeting_start_time: Optional[datetime] = None
    #: The status of the participant's video.
    #: example: on
    video: Optional[CallMembershipAudio] = None
    #: The status of the participant in the meeting. The value of `state` is `breakoutSession` which is only returned
    #: when the meeting is in progress and the breakout session is enabled.
    #: example: lobby
    state: Optional[ParticipantState] = None
    #: The time the participant joined the meeting. If the field is non-existent or shows `1970-01-01T00:00:00.000Z`
    #: the meeting may be still ongoing and the `joinedTime` will be filled in after the meeting ended. If you need
    #: real-time join events, please refer to the webhooks guide.
    #: example: 2022-10-25T09:00:00Z
    joined_time: Optional[datetime] = None
    #: The time the participant left the meeting. If the field is non-existent or shows `1970-01-01T00:00:00.000Z` the
    #: meeting may be still ongoing and the `leftTime` will be filled in after the meeting ended. If you need
    #: real-time left events, please refer to the webhooks guide.
    #: example: 2022-10-25T09:30:00Z
    left_time: Optional[datetime] = None
    #: The site URL.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: A unique identifier for the meeting which the participant belongs to.
    #: example: 3a688f62840346e8b87dde2b50703511_I_197977258267247872
    meeting_id: Optional[str] = None
    #: The email address of the host.
    #: example: janeDoe@cisco.com
    host_email: Optional[str] = None
    devices: Optional[list[Device1]] = None
    #: The source ID of the participant. The `sourceId` is from the `Create Invitation Sources
    #: <https://developer.webex.com/docs/api/v1/meetings/create-invitation-sources>`_ API.
    #: example: cisco
    source_id: Optional[str] = None


class InProgressParticipantState(str, Enum):
    #: The participant is waiting in the meeting lobby.
    lobby = 'lobby'
    #: The participant has joined the meeting.
    joined = 'joined'


class InProgressDevice(ApiModel):
    #: An internal ID that is associated with each join.
    #: example: 8ccced6c-b812-4dff-a5dd-4c5c28f8d47d
    correlation_id: Optional[str] = None
    #: The type of device.
    #: example: mac
    device_type: Optional[str] = None
    #: The audio type that the participant is using.
    #: example: pstn
    audio_type: Optional[DeviceAudioType] = None
    #: The time the device joined the meeting. If the field is non-existent or shows `1970-01-01T00:00:00.000Z` the
    #: meeting may be still ongoing and the `joinedTime` will be filled in after the meeting ended. If you need
    #: real-time joined events, please refer to the webhooks guide.
    #: example: 2019-04-23T17:31:00.000Z
    joined_time: Optional[datetime] = None
    #: The time the device left the meeting, `leftTime` is the exact moment when a specific device left the meeting. If
    #: the field is non-existent or shows `1970-01-01T00:00:00.000Z` the meeting may be still ongoing and the
    #: `leftTime` will be filled in after the meeting ended. If you need real-time left events, please refer to the
    #: webhooks guide.
    #: example: 2019-04-23T17:32:00.000Z
    left_time: Optional[datetime] = None


class InProgressParticipant(ApiModel):
    #: The participant ID that identifies the meeting and the participant.
    #: example: 560d7b784f5143e3be2fc3064a5c4999_3c2e2338-e950-43bf-b588-573773ee43d1
    id: Optional[str] = None
    #: The ID that identifies the organization.
    #: example: 1eb65fdf-9643-417f-9974-ad72cae0e10f
    org_id: Optional[str] = None
    #: Whether or not the participant is the host of the meeting.
    #: example: True
    host: Optional[bool] = None
    #: Whether or not the participant has host privilege in the meeting.
    co_host: Optional[bool] = None
    #: Whether or not the participant is the team space moderator. This field returns only if the meeting is associated
    #: with a Webex space.
    space_moderator: Optional[bool] = None
    #: The email address of the participant.
    #: example: joeDoe@cisco.com
    email: Optional[str] = None
    #: The name of the participant.
    #: example: Joe Doe
    display_name: Optional[str] = None
    #: Whether or not the participant is invited to the meeting.
    invitee: Optional[bool] = None
    #: The status of the participant's video.
    #: example: on
    video: Optional[CallMembershipAudio] = None
    #: Whether or not the participant's audio is muted.
    muted: Optional[bool] = None
    #: The status of the participant in the meeting.
    #: example: lobby
    state: Optional[InProgressParticipantState] = None
    #: The site URL.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: A unique identifier for the meeting which the participant belongs to.
    #: example: 3a688f62840346e8b87dde2b50703511_I_197977258267247872
    meeting_id: Optional[str] = None
    #: The email address of the host.
    #: example: janeDoe@cisco.com
    host_email: Optional[str] = None
    devices: Optional[list[InProgressDevice]] = None


class AdmitParticipant(ApiModel):
    #: The ID that identifies the meeting participant.
    #: example: 560d7b784f5143e3be2fc3064a5c4999_I_204252993233618782_23e16d67-17f3-3ef1-b830-f33d17c0232e
    participant_id: Optional[str] = None
    #: The breakout session ID that identifies which breakout session to admit the participant into. Admit into the
    #: main session if the value is empty.
    #: example: 23e16d67-17f3-3ef1-b830-f33d17c0232e
    breakout_session_id: Optional[str] = None


class AdmitParticipantsObject(ApiModel):
    items: Optional[list[AdmitParticipant]] = None


class ListMeetingParticipantsResponse(ApiModel):
    items: Optional[list[Participant]] = None


class Participant1(ApiModel):
    #: The ID that identifies the meeting and the participant.
    #: example: 560d7b784f5143e3be2fc3064a5c4999_3c2e2338-e950-43bf-b588-573773ee43d1
    id: Optional[str] = None
    #: The ID that identifies the organization. It only applies to participants of ongoing meetings.
    #: example: 1eb65fdf-9643-417f-9974-ad72cae0e10f
    org_id: Optional[str] = None
    #: Whether or not the participant is the host of the meeting.
    #: example: True
    host: Optional[bool] = None
    #: Whether or not the participant has host privilege in the meeting.
    co_host: Optional[bool] = None
    #: Whether or not the participant is the team space moderator. This field returns only if the meeting is associated
    #: with a Webex space.
    space_moderator: Optional[bool] = None
    #: The email address of the participant.
    #: example: joeDoe@cisco.com
    email: Optional[str] = None
    #: The name of the participant.
    #: example: Joe Doe
    display_name: Optional[str] = None
    #: Whether or not the participant is invited to the meeting.
    invitee: Optional[bool] = None
    #: Whether or not the participant's audio is muted.
    muted: Optional[bool] = None
    #: The time the meeting started.
    #: example: 2020-10-02T17:31:00Z
    meeting_start_time: Optional[datetime] = None
    #: The status of the participant's video.
    #: example: on
    video: Optional[CallMembershipAudio] = None
    #: The status of the participant in the meeting. The value of `state` is `breakoutSession` which is only returned
    #: when the meeting is in progress and the breakout session is enabled.
    #: example: lobby
    state: Optional[ParticipantState] = None
    #: The ID of the breakout session including the participant.
    #: example: 2e373567-465b-8530-a18a-7025e1871d40
    breakout_session_id: Optional[str] = None
    #: The time the participant joined the meeting. If the field is non-existent or shows `1970-01-01T00:00:00.000Z`
    #: the meeting may be still ongoing and the `joinedTime` will be filled in after the meeting ended. If you need
    #: real-time join events, please refer to the webhooks guide.
    #: example: 2022-10-25T09:00:00Z
    joined_time: Optional[datetime] = None
    #: The time the participant left the meeting. If the field is non-existent or shows `1970-01-01T00:00:00.000Z` the
    #: meeting may be still ongoing and the `leftTime` will be filled in after the meeting ended. If you need
    #: real-time left events, please refer to the webhooks guide.
    #: example: 2022-10-25T09:30:00Z
    left_time: Optional[datetime] = None
    #: The site URL.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: A unique identifier for the meeting which the participant belongs to.
    #: example: 3a688f62840346e8b87dde2b50703511_I_197977258267247872
    meeting_id: Optional[str] = None
    #: The email address of the host.
    #: example: janeDoe@cisco.com
    host_email: Optional[str] = None
    devices: Optional[list[Device1]] = None
    #: The source ID of the participant. The `sourceId` is from the `Create Invitation Sources
    #: <https://developer.webex.com/docs/api/v1/meetings/create-invitation-sources>`_ API.
    #: example: cisco
    source_id: Optional[str] = None


class ParticipantID(ApiModel):
    #: The ID that identifies the meeting participant.
    #: example: 560d7b784f5143e3be2fc3064a5c4999_I_204252993233618782_23e16d67-17f3-3ef1-b830-f33d17c0232e
    participant_id: Optional[str] = None


class AdmitParticipantsObject1(ApiModel):
    items: Optional[list[ParticipantID]] = None


class ListMeetingParticipantsResponse1(ApiModel):
    items: Optional[list[Participant1]] = None


class QuestionType(str, Enum):
    #: A single-answer question.
    single = 'single'
    #: A multiple-answer question.
    multiple = 'multiple'
    #: A text answer.
    short = 'short'


class Option(ApiModel):
    #: The order of the option.
    #: example: 1
    order: Optional[datetime] = None
    #: The value of the option.
    #: example: China
    value: Optional[str] = None
    #: Whether or not the option is correct.
    #: example: True
    is_correct: Optional[bool] = None


class Question(ApiModel):
    #: A unique identifier for the question.
    #: example: 6f31147e-dd69-4ea9-8b75-2c5834b72ba2
    id: Optional[str] = None
    #: The order of the question.
    #: example: 1
    order: Optional[datetime] = None
    #: The question.
    #: example: Where is Webex exclusively sold through local partners?
    title: Optional[str] = None
    #: The type of the question.
    #: example: single
    type: Optional[QuestionType] = None
    #: Question's options.
    options: Optional[list[Option]] = None


class Poll(ApiModel):
    #: A unique identifier for the poll.
    #: example: 1aea8390-e375-4547-b7ff-58ecd9e0b03d
    id: Optional[str] = None
    #: A unique identifier for the `meeting instance
    #: <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the poll belongs.
    #: example: a2f95f5073e347489f7611492dbd6ad5_I_199075330905867928
    meeting_id: Optional[str] = None
    #: The date and time the poll started in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:22:34Z
    start_time: Optional[datetime] = None
    #: The date and time the poll ended in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:25:51Z
    end_time: Optional[datetime] = None
    #: The length of time in the alarm box, in seconds.
    #: example: 300.0
    timer_duration: Optional[int] = None
    #: The name of the poll coordinator.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The email of the poll coordinator.
    #: example: john.andersen@example.co
    email: Optional[str] = None
    #: The ID of the polling coordinator.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xYTY5MmE2Mi00MTNmLTRjYWEtYjdkOS0wYzg0ZDZmMDdlNzY
    person_id: Optional[str] = None
    #: Poll's questions.
    questions: Optional[list[Question]] = None


class PollCollectionResponse(ApiModel):
    items: Optional[list[Poll]] = None


class AnswerSummaryItem(ApiModel):
    #: The order of the answer in the question.
    #: example: 1
    order: Optional[datetime] = None
    #: The content of the answer.
    #: example: China
    value: Optional[str] = None
    #: The total number of people who selected this answer.
    #: example: 10.0
    total_respondents: Optional[int] = None
    #: Whether the answer is correct.
    #: example: True
    is_correct: Optional[bool] = None


class Link1(ApiModel):
    #: Link to the previous question's respondents.
    #: example: https://webexapis.com/v1/meetings/polls/1d4959fe-682e-4107-a346-0e1feac7b899_M_7b789da198e531ce0c4d84243abd9fee_I_231245894851233679/questions/6f31147e-dd69-4ea9-8b75-2c5834b72ba2/respondents?meetingId=7b789da198e531ce0c4d84243abd9fee_I_231245894851233679&offset=0&max=5
    prev: Optional[str] = None
    #: Link to the current question's respondents.
    #: example: https://webexapis.com/v1/meetings/polls/1d4959fe-682e-4107-a346-0e1feac7b899_M_7b789da198e531ce0c4d84243abd9fee_I_231245894851233679/questions/6f31147e-dd69-4ea9-8b75-2c5834b72ba2/respondents?meetingId=7b789da198e531ce0c4d84243abd9fee_I_231245894851233679&offset=5&max=5
    self: Optional[str] = None
    #: Link to the next page question's respondents.
    #: example: https://webexapis.com/v1/meetings/polls/1d4959fe-682e-4107-a346-0e1feac7b899_M_7b789da198e531ce0c4d84243abd9fee_I_231245894851233679/questions/6f31147e-dd69-4ea9-8b75-2c5834b72ba2/respondents?meetingId=7b789da198e531ce0c4d84243abd9fee_I_231245894851233679&offset=10&max=5
    next: Optional[str] = None


class Respondent(ApiModel):
    #: The name of the person who answers the question.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The email of the person who answers the question.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: An array of answers. Single answer or text questions contain only a single answer.
    #: example: ['Green']
    answers: Optional[list[str]] = None


class RespondentsReferenceLinks(ApiModel):
    #: The pagination links of this question's respondent.
    links: Optional[Link1] = None
    #: An array of answers.
    items: Optional[list[Respondent]] = None


class QuestionResult(ApiModel):
    #: A unique identifier of the question.
    #: example: 6f31147e-dd69-4ea9-8b75-2c5834b72ba2
    id: Optional[str] = None
    #: The order of the question in the poll.
    #: example: 1
    order: Optional[datetime] = None
    #: The question.
    #: example: What colors do you like?
    title: Optional[str] = None
    #: The type of the question.
    #: example: single
    type: Optional[QuestionType] = None
    #: Summary of all answers.
    answer_summary: Optional[list[AnswerSummaryItem]] = None
    #: Question's respondents.
    respondents: Optional[RespondentsReferenceLinks] = None


class PollResult(ApiModel):
    #: A unique identifier for the poll.
    #: example: 1aea8390-e375-4547-b7ff-58ecd9e0b03d
    id: Optional[str] = None
    #: A unique identifier for the `meeting instance
    #: <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the poll belongs.
    #: example: a2f95f5073e347489f7611492dbd6ad5_I_199075330905867928
    meeting_id: Optional[str] = None
    #: The total number of attendees in the meeting.
    #: example: 10.0
    total_attendees: Optional[int] = None
    #: The total number of respondents in the poll.
    #: example: 10.0
    total_respondents: Optional[int] = None
    #: The date and time the poll started in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:25:34Z
    start_time: Optional[datetime] = None
    #: The date and time the poll ended in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:28:34Z
    end_time: Optional[datetime] = None
    #: The duration of the poll, in seconds.
    #: example: 300.0
    timer_duration: Optional[int] = None
    #: The name of the poll coordinator.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The email of the poll coordinator.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: The ID of the the poll coordinator.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xYTY5MmE2Mi00MTNmLTRjYWEtYjdkOS0wYzg0ZDZmMDdlNzY
    person_id: Optional[str] = None
    #: An array of questions in this poll.
    questions: Optional[list[QuestionResult]] = None


class PollResultCollectionResponse(ApiModel):
    items: Optional[list[PollResult]] = None


class RespondentCollectionResponse(ApiModel):
    items: Optional[list[Respondent]] = None


class MeetingPreferenceObjectPersonalMeetingRoomCoHosts(ApiModel):
    #: Email address for cohost. This attribute can be modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Display name for cohost. This attribute can be modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    #: example: John Andersen
    display_name: Optional[str] = None


class MeetingPreferenceObjectPersonalMeetingRoomTelephonyCallInNumbersTollType(str, Enum):
    toll = 'toll'
    toll_free = 'tollFree'


class MeetingPreferenceObjectPersonalMeetingRoomTelephonyCallInNumbers(ApiModel):
    #: Label for call-in number.
    #: example: Call-in toll-free number (US/Canada)
    label: Optional[str] = None
    #: Call-in number to join teleconference from a phone.
    #: example: 123456789
    call_in_number: Optional[str] = None
    #: Type of toll for the call-in number.
    #: example: tollFree
    toll_type: Optional[MeetingPreferenceObjectPersonalMeetingRoomTelephonyCallInNumbersTollType] = None


class MeetingPreferenceObjectPersonalMeetingRoomTelephony(ApiModel):
    #: Code for authenticating a user to join teleconference. Users join the teleconference using the call-in number or
    #: the global call-in number, followed by the value of the `accessCode`.
    #: example: 1234567890
    access_code: Optional[str] = None
    #: Array of call-in numbers for joining teleconference from a phone.
    call_in_numbers: Optional[list[MeetingPreferenceObjectPersonalMeetingRoomTelephonyCallInNumbers]] = None
    #: `HATEOAS
    #: <https://en.wikipedia.org/wiki/HATEOAS>`_ information of global call-in numbers for joining teleconference from a phone.
    links: Optional[Link] = None


class MeetingPreferenceObjectPersonalMeetingRoom(ApiModel):
    #: Personal Meeting Room topic. The length of `topic` must be between 1 and 128 characters. This attribute can be
    #: modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    #: example: John's PMR
    topic: Optional[str] = None
    #: PIN for joining the room as host. The host PIN must be digits of a predefined length, e.g. 4 digits. It cannot
    #: contain sequential digits, such as 1234 or 4321, or repeated digits of the predefined length, such as 1111. The
    #: predefined length for host PIN can be viewed in user's `My Personal Room` page. This attribute can be modified
    #: with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    #: example: 4325
    host_pin: Optional[datetime] = None
    #: Personal Meeting Room link. It cannot be empty. ***Note***: This is a read-only attribute.
    #: example: https://site4-example.webex.com/meet/john
    personal_meeting_room_link: Optional[str] = None
    #: Option to automatically lock the Personal Room a number of minutes after a meeting starts. When a room is
    #: locked, invitees cannot enter until the owner admits them. The period after which the meeting is locked is
    #: defined by `autoLockMinutes`. This attribute can be modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    enabled_auto_lock: Optional[bool] = None
    #: Number of minutes after which the Personal Room is locked if `enabledAutoLock` is enabled. Valid options are 0,
    #: 5, 10, 15 and 20. This attribute can be modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    auto_lock_minutes: Optional[int] = None
    #: Flag to enable notifying the owner of a Personal Room when someone enters the Personal Room lobby while the
    #: owner is not in the room. This attribute can be modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    enabled_notify_host: Optional[bool] = None
    #: Flag allowing other invitees to host a meeting in the Personal Room without the owner. This attribute can be
    #: modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    support_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: Personal Room. The target site is user's preferred site. This attribute can be modified with the
    #: `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    support_anyone_as_co_host: Optional[bool] = None
    #: Whether or not to allow the first attendee with a host account on the target site to become a cohost when
    #: joining the Personal Room. The target site is user's preferred site. This attribute can be modified with the
    #: `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the user's organization to start or join the meeting
    #: without a prompt. This attribute can be modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Array defining cohosts for the room if both `supportAnyoneAsCoHost` and `allowFirstUserToBeCoHost` are `false`
    #: This attribute can be modified with the `Update Personal Meeting Room Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-personal-meeting-room-options>`_ API.
    co_hosts: Optional[list[MeetingPreferenceObjectPersonalMeetingRoomCoHosts]] = None
    #: SIP address for callback from a video system.
    #: example: john.andersen@example.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Information for callbacks from meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingPreferenceObjectPersonalMeetingRoomTelephony] = None


class MeetingPreferenceObjectAudioDefaultAudioType(str, Enum):
    #: Webex audio. This supports telephony and VoIP.
    webex_audio = 'webexAudio'
    #: Support only VoIP.
    voip_only = 'voipOnly'
    #: Other teleconference service. Details are defined in the `otherTeleconferenceDescription` parameter.
    other_teleconference_service = 'otherTeleconferenceService'
    #: No audio.
    none_ = 'none'
    none_ = 'none'


class MeetingPreferenceObjectAudioOfficeNumber(ApiModel):
    #: Country code for the phone number. This attribute can be modified with the with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    country_code: Optional[str] = None
    #: Phone number. It cannot be longer than 30 characters. This attribute can be modified with the with the
    #: `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    number: Optional[str] = None
    #: Flag identifying the phone number as the one that will be used to dial into a teleconference. This attribute can
    #: be modified with the with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    enabled_call_in_authentication: Optional[bool] = None
    #: Flag to enable/disable Call Me number display on the meeting client. This attribute can be modified with the
    #: with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API. ***Note***: This feature is only effective if the site supports the ***Call
    #: Me*** feature.
    enabled_call_me: Optional[bool] = None


class MeetingPreferenceObjectAudio(ApiModel):
    #: Default audio type. This attribute can be modified with the with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    default_audio_type: Optional[MeetingPreferenceObjectAudioDefaultAudioType] = None
    #: Phone number and other information for the teleconference provider to be used, along with instructions for
    #: invitees. This attribute can be modified with the with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    other_teleconference_description: Optional[str] = None
    #: Flag to enable/disable global call ins. ***Note***: If the site does not support global call-ins, you cannot set
    #: this option. This attribute can be modified with the with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    enabled_global_call_in: Optional[bool] = None
    #: Flag to enable/disable call-ins from toll-free numbers.  ***Note***: If the site does not support calls from
    #: toll-free numbers, you cannot set this option. This attribute can be modified with the with the
    #: `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    enabled_toll_free: Optional[bool] = None
    #: Flag to enable/disable automatically connecting to audio using a computer. The meeting host can enable/disable
    #: this option. When this option is set to `true`, the user is automatically connected to audio via a computer
    #: when they start or join a Webex Meetings meeting on a desktop. `This attribute can be modified with the with
    #: the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    enabled_auto_connection: Optional[bool] = None
    #: PIN to provide a secondary level of authentication for calls where the host is using the phone and may need to
    #: invite additional invitees. It must be exactly 4 digits. It cannot contain sequential digits, such as 1234 or
    #: 4321, or repeat a digit 4 times, such as 1111. This attribute can be modified with the with the
    #: `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    audio_pin: Optional[str] = None
    #: Office phone number. We recommend that phone numbers be specified to facilitate connecting via audio. This
    #: attribute can be modified with the with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    office_number: Optional[MeetingPreferenceObjectAudioOfficeNumber] = None
    #: Mobile phone number. We recommend that phone numbers be specified to facilitate connecting via audio. This
    #: attribute can be modified with the with the `Update Audio Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
    mobile_number: Optional[MeetingPreferenceObjectAudioOfficeNumber] = None


class MeetingPreferenceObjectVideoVideoDevices(ApiModel):
    #: Video system name. It cannot be empty. This attribute can be modified with the `Update Video Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-video-options>`_ API.
    #: example: device1
    device_name: Optional[str] = None
    #: Video address. It cannot be empty and must be in valid email format. This attribute can be modified with the
    #: `Update Video Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-video-options>`_ API.
    #: example: device1@example.com
    device_address: Optional[str] = None
    #: Flag identifying the device as the default video device. If user's video device list is not empty, one and only
    #: one device must be set as default. This attribute can be modified with the `Update Video Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-video-options>`_ API.
    #: example: True
    is_default: Optional[bool] = None


class MeetingPreferenceObjectVideo(ApiModel):
    #: Array of video devices. This attribute can be modified with the `Update Video Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-video-options>`_ API.
    video_devices: Optional[list[MeetingPreferenceObjectVideoVideoDevices]] = None


class MeetingPreferenceObjectSites(ApiModel):
    #: Access URL for the site. ***Note***: This is a read-only attribute. The value can be assigned as user's default
    #: site with the `Update Default Site
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-default-site>`_ API.
    #: example: site1-example.webex.com
    site_url: Optional[str] = None
    #: Flag identifying the site as the default site. Users can list meetings and recordings, and create meetings on
    #: the default site.
    default: Optional[bool] = None


class SchedulingOptionsObject(ApiModel):
    #: Flag to enable/disable ***Join Before Host***. The period during which invitees can join before the start time
    #: is defined by `autoLockMinutes`. This attribute can be modified with the `Update Scheduling Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
    #: ***Note***: This feature is only effective if the site supports the ***Join Before Host*** feature. This
    #: attribute can be modified with the `Update Scheduling Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Number of minutes before the start time that an invitee can join a meeting if `enabledJoinBeforeHost` is true.
    #: Valid options are 0, 5, 10 and 15. This attribute can be modified with the `Update Scheduling Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
    join_before_host_minutes: Optional[int] = None
    #: Flag to enable/disable the automatic sharing of the meeting recording with invitees when it is available. This
    #: attribute can be modified with the `Update Scheduling Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
    enabled_auto_share_recording: Optional[bool] = None
    #: Flag to automatically enable Webex Assistant whenever you start a meeting. This attribute can be modified with
    #: the `Update Scheduling Options
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
    enabled_webex_assistant_by_default: Optional[bool] = None


class MeetingPreferenceObject(ApiModel):
    #: Personal Meeting Room options.
    personal_meeting_room: Optional[MeetingPreferenceObjectPersonalMeetingRoom] = None
    #: Audio Preferences. ***Note***: These audio settings do not apply to Personal Room meetings
    audio: Optional[MeetingPreferenceObjectAudio] = None
    #: Information for video conferencing systems used to connect to Webex meetings. ***Note***: The ***Call My Video
    #: System*** feature is available only if it has been purchased for your site and your administrator has enabled
    #: it.
    video: Optional[MeetingPreferenceObjectVideo] = None
    #: Meeting scheduling options.
    scheduling_options: Optional[SchedulingOptionsObject] = None
    #: List of user's Webex meeting sites including default site.
    sites: Optional[list[MeetingPreferenceObjectSites]] = None


class SitesObject(ApiModel):
    #: Array of sites for the user. Users can have one site or multiple sites. This concept is specific to Webex
    #: Meetings. Any `siteUrl` in the site list can be assigned as user's default site with the `Update Default Site
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/update-default-site>`_
    #: API.
    sites: Optional[list[MeetingPreferenceObjectSites]] = None


class DefaultSiteObject(ApiModel):
    #: Access URL for the site.
    #: example: site1-example.webex.com
    site_url: Optional[str] = None


class UpdatePMRObject(ApiModel):
    #: Personal Meeting Room topic to be updated.
    #: example: John's PMR
    topic: Optional[str] = None
    #: Updated PIN for joining the room as host. The host PIN must be digits of a predefined length, e.g. 4 digits. It
    #: cannot contain sequential digits, such as 1234 or 4321, or repeated digits of the predefined length, such as
    #: 1111. The predefined length for host PIN can be viewed in user's `My Personal Room` page and it can only be
    #: changed by site administrator.
    #: example: 4325
    host_pin: Optional[datetime] = None
    #: Update for option to automatically lock the Personal Room a number of minutes after a meeting starts. When a
    #: room is locked, invitees cannot enter until the owner admits them. The period after which the meeting is locked
    #: is defined by `autoLockMinutes`.
    enabled_auto_lock: Optional[bool] = None
    #: Updated number of minutes after which the Personal Room is locked if `enabledAutoLock` is enabled. Valid options
    #: are 0, 5, 10, 15 and 20.
    auto_lock_minutes: Optional[int] = None
    #: Update for flag to enable notifying the owner of a Personal Room when someone enters the Personal Room lobby
    #: while the owner is not in the room.
    #: example: True
    enabled_notify_host: Optional[bool] = None
    #: Update for flag allowing other invitees to host a meetingCoHost in the Personal Room without the owner.
    #: example: True
    support_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: Personal Room. The target site is user's preferred site.
    support_anyone_as_co_host: Optional[bool] = None
    #: Whether or not to allow the first attendee with a host account on the target site to become a cohost when
    #: joining the Personal Room. The target site is user's preferred site.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the user's organization to start or join the meeting
    #: without a prompt.
    allow_authenticated_devices: Optional[bool] = None
    #: Updated array defining cohosts for the room if both `supportAnyoneAsCoHost` and `allowFirstUserToBeCoHost` are
    #: `false`
    co_hosts: Optional[list[MeetingPreferenceObjectPersonalMeetingRoomCoHosts]] = None


class PMRIDObject(ApiModel):
    #: Email address of the meeting host whose personal room ID will be refreshed.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Unique identifier for the meeting host whose personal room ID will be refreshed.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8yNWJiZjgzMS01YmU5LTRjMjUtYjRiMC05YjU5MmM4YTA4NmI
    person_id: Optional[str] = None
    #: Whether or not to automatically refresh the personal room ID by the site's settings. Refresh the personal room
    #: ID by the site's settings automatically if `systemGenerated` is true; otherwise, replace the existing personal
    #: room ID with the specified value if `systemGenerated` is false or not specified.
    system_generated: Optional[bool] = None
    #: New personal room ID specified by the admin user.
    #: example: prABCD23670651
    personal_meeting_room_id: Optional[str] = None


class BatchRefreshPMRIDObject(ApiModel):
    #: Site URL to refresh the personal room IDs.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Information of whose personal room IDs are to be refreshed and how to refresh. The maximum size of `items` is
    #: 100.
    personal_meeting_room_ids: Optional[list[PMRIDObject]] = None


class PMRIDResponseObject(ApiModel):
    #: Email address for the meeting host whose personal room ID has been refreshed.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Unique identifier for the meeting host whose personal room ID has been refreshed.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8yNWJiZjgzMS01YmU5LTRjMjUtYjRiMC05YjU5MmM4YTA4NmI
    person_id: Optional[str] = None
    #: Refreshed personal room ID.
    #: example: prABCD23670651
    personal_meeting_room_id: Optional[str] = None


class BatchRefreshPMRIDResponseObject(ApiModel):
    #: URL of the Webex site.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Information for the refreshed personal room IDs.
    personal_meeting_room_ids: Optional[list[PMRIDResponseObject]] = None


class AnswerObject(ApiModel):
    #: The name of the person who answered the question.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The email of the person who answered the question.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: The ID of the person who answered the question. Only present for authenticated users.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xYTY5MmE2Mi00MTNmLTRjYWEtYjdkOS0wYzg0ZDZmMDdlNzY
    person_id: Optional[str] = None
    #: The content of the answer.
    #: example: ['Fine, thank you.']
    answer: Optional[list[str]] = None
    #: Whether or not the question was answered.
    #: example: True
    answered: Optional[bool] = None


class QAObjectAnswers(ApiModel):
    #: The pagination links of the question's answers.
    links: Optional[Link1] = None
    #: An array of answer objects for this question.
    items: Optional[list[AnswerObject]] = None


class QAObject(ApiModel):
    #: A unique identifier for the question.
    #: example: 1aea8390-e375-4547-b7ff-58ecd9e0b03d
    id: Optional[str] = None
    #: A unique identifier for the `meeting instance
    #: <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the Q&A belongs.
    #: example: a2f95f5073e347489f7611492dbd6ad5_I_199075330905867928
    meeting_id: Optional[str] = None
    #: The total number of attendees in the meeting.
    #: example: 10.0
    total_attendees: Optional[int] = None
    #: The total number of respondents in the meeting.
    #: example: 10.0
    total_respondents: Optional[int] = None
    #: The name of the user who asked the question.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The email of the user who asked the question.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: The question that was asked.
    #: example: Are you ok?
    question: Optional[str] = None
    #: Question's answers.
    answers: Optional[QAObjectAnswers] = None


class ListMeetingQAndAResponse(ApiModel):
    #: An array of Q&A objects.
    items: Optional[list[QAObject]] = None


class ListAnswersOfAQuestionResponse(ApiModel):
    #: An array of answers to a specific question.
    items: Optional[list[AnswerObject]] = None


class MediaSessionQualityNetworkType(str, Enum):
    wifi = 'wifi'
    cellular = 'cellular'
    ethernet = 'ethernet'
    unknown = 'unknown'


class VideoInTransportType(str, Enum):
    udp = 'UDP'
    tcp = 'TCP'


class VideoIn1(ApiModel):
    #: The sampling interval, in seconds, of the downstream video quality data.
    #: example: 60.0
    sampling_interval: Optional[int] = None
    #: The date and time when this video session started.
    #: example: 2020-04-10T17:00:00.000Z
    start_time: Optional[datetime] = None
    #: The date and time when this video session ended.
    #: example: 2020-04-10T18:00:00.000Z
    end_time: Optional[datetime] = None
    #: The percentage of video packet loss, as a float between 0.0 and 100.0, during each sampling interval.
    #: example: [0.01, 0.1, 0.05]
    packet_loss: Optional[list[float]] = None
    #: The average latency, in milliseconds, during each sampling interval.
    #: example: [60.0, 5.0, 10.0]
    latency: Optional[list[float]] = None
    #: The pixel height of the incoming video.
    #: example: [90.0, 90.0, 90.0]
    resolution_height: Optional[list[float]] = None
    #: The frames per second of the incoming video.
    #: example: [25.940000534057617, 21.040000915527344, 18.84000015258789]
    frame_rate: Optional[list[float]] = None
    #: The bit rate of the incoming video.
    #: example: [51880.0, 74519.0, 55285.0]
    media_bit_rate: Optional[list[float]] = None
    #: The incoming video codec.
    #: example: H.264 BP
    codec: Optional[str] = None
    #: The incoming video jitter.
    #: example: [170.0, 130.0, 40.0]
    jitter: Optional[list[float]] = None
    #: The network protocol used for video transmission.
    #: example: UDP
    transport_type: Optional[VideoInTransportType] = None


class Resources(ApiModel):
    #: The average percent CPU for the process.
    #: example: [6.0, 8.0, 6.0]
    process_average_cpu: Optional[list[float]] = Field(alias='processAverageCPU', default=None)
    #: The max percent CPU for the process.
    #: example: [14.0, 15.0, 14.0]
    process_max_cpu: Optional[list[float]] = Field(alias='processMaxCPU', default=None)
    #: The average percent CPU for the system.
    #: example: [19.0, 21.0, 18.0]
    system_average_cpu: Optional[list[float]] = Field(alias='systemAverageCPU', default=None)
    #: The max percent CPU for the system.
    #: example: [27.0, 36.0, 30.0]
    system_max_cpu: Optional[list[float]] = Field(alias='systemMaxCPU', default=None)


class MediaSessionQuality1(ApiModel):
    #: The meeting identifier for the specific meeting instance.
    #: example: e5dba9613a9d455aa49f6ffdafb6e7db_I_191395283063545470
    meeting_instance_id: Optional[str] = None
    #: The display name of the participant of this media session.
    #: example: John Andersen
    webex_user_name: Optional[str] = None
    #: The email address of the participant of this media session.
    #: example: john.andersen@example.com
    webex_user_email: Optional[str] = None
    #: The date and time when this participant joined the meeting.
    #: example: 2020-04-10T17:00:00.000Z
    join_time: Optional[datetime] = None
    #: The date and time when this participant left the meeting.
    #: example: 2020-04-10T17:02:00.000Z
    leave_time: Optional[datetime] = None
    #: The join meeting time of the participant.
    #: example: 5.793
    join_meeting_time: Optional[datetime] = None
    #: The type of the client (and OS) used by this media session.
    #: example: Teams_Mobile_Client (iOS)
    client_type: Optional[str] = None
    #: The version of the client used by this media session.
    #: example: 40.5.0.210
    client_version: Optional[str] = None
    #: The operating system used for the client.
    #: example: mac
    os_type: Optional[str] = None
    #: The version of the operating system used for the client.
    #: example: Version 10.14.6 (Build 18G3020)
    os_version: Optional[str] = None
    #: The type of hardware used to attend the meeting
    #: example: mac book
    hardware_type: Optional[str] = None
    #: A description of the speaker used in the meeting.
    #: example: MacBook Pro Speakers
    speaker_name: Optional[str] = None
    #: The type of network.
    #: example: wifi
    network_type: Optional[MediaSessionQualityNetworkType] = None
    #: The local IP address of the client.
    #: example: 10.24.72.54
    local_ip: Optional[str] = Field(alias='localIP', default=None)
    #: The public IP address of the client.
    #: example: 10.24.72.54
    public_ip: Optional[str] = Field(alias='publicIP', default=None)
    #: The masked local IP address of the client.
    #: example: 10.24.72.54
    masked_local_ip: Optional[str] = Field(alias='maskedLocalIP', default=None)
    #: The masked public IP address of the client.
    #: example: 10.24.72.54
    masked_public_ip: Optional[str] = Field(alias='maskedPublicIP', default=None)
    #: A description of the camera used in the meeting.
    #: example: FaceTime HD Camera
    camera: Optional[str] = None
    #: A description of the microphone used in the meeting.
    #: example: External Microphone
    microphone: Optional[str] = None
    #: The server region.
    #: example: San Jose, USA
    server_region: Optional[str] = None
    #: The video mesh cluster name.
    #: example: Mesh Cluster One
    video_mesh_cluster: Optional[str] = None
    #: The video mesh server name.
    #: example: server.example.com
    video_mesh_server: Optional[str] = None
    #: Identifies the participant.
    #: example: 8635cbf0ca1a4573b27348e560679b25_I_158174534545967299_57
    participant_id: Optional[str] = None
    #: Identifies a specific session the participant has in a given meeting.
    #: example: 3324C9D0-9EA7-45A2-B249-5B62A384AFEF
    participant_session_id: Optional[str] = None
    #: The collection of downstream (sent to the client) video quality data.
    video_in: Optional[list[VideoIn1]] = None
    #: The collection of upstream (sent from the client) video quality data.
    video_out: Optional[list[VideoIn1]] = None
    #: The collection of downstream (sent to the client) audio quality data.
    audio_in: Optional[list[VideoIn1]] = None
    #: The collection of upstream (sent from the client) audio quality data.
    audio_out: Optional[list[VideoIn1]] = None
    #: The collection of downstream (sent to the client) share quality data.
    share_in: Optional[list[VideoIn1]] = None
    #: The collection of upstream (sent from the client) share quality data.
    share_out: Optional[list[VideoIn1]] = None
    #: Device resources such as CPU and memory.
    resources: Optional[list[Resources]] = None


class MeetingQualitiesResponse(ApiModel):
    items: Optional[list[MediaSessionQuality1]] = None


class SiteSessionTypeType(str, Enum):
    #: Meeting Center.
    meeting = 'meeting'
    #: Webinar meeting.
    webinar = 'webinar'
    #: Private meeting.
    private_meeting = 'privateMeeting'
    #: Event Center.
    event_center = 'EventCenter'
    #: Support Center.
    support_center = 'SupportCenter'
    #: Training Center.
    train_center = 'TrainCenter'


class SiteSessionType(ApiModel):
    #: The ID of the session type.
    #: example: 3
    id: Optional[datetime] = None
    #: The short name of the session type.
    #: example: PRO
    short_name: Optional[str] = None
    #: Site URL for the session type.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: The name of the session type.
    #: example: Pro Meeting
    name: Optional[str] = None
    #: The meeting type of meeting that you can create with the session type.
    #: example: meeting
    type: Optional[SiteSessionTypeType] = None


class SessionType(ApiModel):
    #: The ID of the session type.
    #: example: 3
    id: Optional[datetime] = None
    #: The short name of the session type.
    #: example: PRO
    short_name: Optional[str] = None
    #: The name of the session type.
    #: example: Pro Meeting
    name: Optional[str] = None
    #: The meeting type of meeting that you can create with the session type.
    #: example: meeting
    type: Optional[SiteSessionTypeType] = None


class UserSessionTypes(ApiModel):
    #: A unique identifier for the user.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8yNWJiZjgzMS01YmU5LTRjMjUtYjRiMC05YjU5MmM4YTA4NmI
    person_id: Optional[str] = None
    #: The email of the user.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Site URL for the user.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: All session types are supported by the user on the site.
    session_types: Optional[list[SessionType]] = None


class UpdateUserSessionType(ApiModel):
    #: Site URL for the session type.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: A unique identifier for the user.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8yNWJiZjgzMS01YmU5LTRjMjUtYjRiMC05YjU5MmM4YTA4NmI
    person_id: Optional[str] = None
    #: The email of the user.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: An array of the session type ID.
    #: example: ['3', '9']
    session_type_ids: Optional[list[str]] = None


class ListSiteSessionTypesResponse(ApiModel):
    #: An array of the site's session types.
    items: Optional[list[SiteSessionType]] = None


class ListUserSessionTypeResponse(ApiModel):
    #: An array of the user's session types.
    items: Optional[list[UserSessionTypes]] = None


class TranscriptObjectStatus(str, Enum):
    #: Transcript is available.
    available = 'available'
    #: Transcript has been deleted.
    deleted = 'deleted'
    none_ = 'none'


class TranscriptObject(ApiModel):
    #: A unique identifier for the transcript.
    #: example: 195d64646ad14be2924ea50f541fd91d
    id: Optional[str] = None
    #: URL of the Webex site from which the API lists meeting transcripts.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Start time for the meeting transcript in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2020-06-01T20:30:15.042Z
    start_time: Optional[datetime] = None
    #: The meeting's topic.
    #: example: John's Meeting
    meeting_topic: Optional[str] = None
    #: Unique identifier for the `meeting instance
    #: <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the transcripts belong.
    #: example: 0ed74a1c0551494fb7a04e2881bf50ae_I_166022169160077044
    meeting_id: Optional[str] = None
    #: Unique identifier for scheduled meeting with which the current meeting is associated. Only apples to a meeting
    #: instance which is happening or has happened. This is the `id` of the scheduled meeting with which the instance
    #: is associated.
    #: example: 0ed74a1c0551494fb7a04e2881bf50ae_20210401T232500Z
    scheduled_meeting_id: Optional[str] = None
    #: Unique identifier for the parent meeting series to which the recording belongs.
    #: example: 0ed74a1c0551494fb7a04e2881bf50ae
    meeting_series_id: Optional[str] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: The download link for the transcript vtt file.
    #: example: http://site-example.webex.com/v1/meetingTranscripts/195d64646ad14be2924ea50f541fd91d/download?format=vtt
    vtt_download_link: Optional[str] = None
    #: The download link for the transcript txt file.
    #: example: http://site-example.webex.com/v1/meetingTranscripts/195d64646ad14be2924ea50f541fd91d/download?format=txt
    txt_download_link: Optional[str] = None
    status: Optional[TranscriptObjectStatus] = None


class SnippetObject1(ApiModel):
    #: A unique identifier for the snippet.
    #: example: 195d64646ad14be2924ea50f541fd91d_00001
    id: Optional[str] = None
    #: Text for the snippet.
    #: example: Hello everyone
    text: Optional[str] = None
    #: Name of the person generating the speech for the snippet.
    #: example: John Andersen
    person_name: Optional[str] = None
    #: Email address of the person generating the speech for the snippet.
    #: example: john.andersen@example.com
    person_email: Optional[str] = None
    #: Offset from the beginning of the parent transcript in milliseconds indicating the start time of the snippet.
    #: example: 1000.0
    offset_millisecond: Optional[int] = None
    #: Duration of the snippet in milliseconds.
    #: example: 2000.0
    duration_millisecond: Optional[int] = None


class UpdateSnippetObject(ApiModel):
    #: Reason for snippet update; only required for Compliance Officers.
    #: example: audit
    reason: Optional[str] = None
    #: Text for the snippet.
    #: example: Hello everybody
    text: Optional[str] = None


class DeleteTranscriptObject(ApiModel):
    #: Reason for deleting a transcript. Only required when a Compliance Officer is operating on another user's
    #: transcript.
    #: example: audit
    reason: Optional[str] = None
    #: Explanation for deleting a transcript. The comment can be a maximum of 255 characters long.
    #: example: Maintain data privacy
    comment: Optional[str] = None


class ListMeetingTranscriptsResponse(ApiModel):
    #: Transcript array.
    items: Optional[list[TranscriptObject]] = None


class ListSnippetsOfAMeetingTranscriptResponse(ApiModel):
    #: Transcript snippet array
    items: Optional[list[SnippetObject1]] = None


class MeetingUsageReportObjectScheduledType(str, Enum):
    #: Regular meeting.
    meeting = 'meeting'
    #: Webinar meeting.
    webinar = 'webinar'


class MeetingUsageReportObjectServiceType(str, Enum):
    #: The service type for the usage report is meeting.
    meeting_center = 'MeetingCenter'
    #: The service type for the usage report is the event.
    event_center = 'EventCenter'
    #: The service type for the usage report is the training session.
    training_center = 'TrainingCenter'
    #: The service type for the usage report is the support meeting.
    support_center = 'SupportCenter'


class MeetingUsageReportTrackingCodeObject(ApiModel):
    #: Name of the tracking code.
    #: example: Department
    name: Optional[str] = None
    #: Value of the tracking code.
    #: example: Engineering
    value: Optional[str] = None


class MeetingUsageReportObject(ApiModel):
    #: Unique identifier for the meeting.
    #: example: 089b137c3cf34b578896941e2d49dfe8_I_146987372776523573
    meeting_id: Optional[str] = None
    #: Meeting number.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title.
    #: example: John's Meeting
    meeting_title: Optional[str] = None
    #: The date and time when the meeting was started. It's in the timezone specified in the request header or in the
    #: `UTC` timezone if timezone is not specified.
    #: example: 2023-01-18T10:26:30+08:00
    start: Optional[datetime] = None
    #: The date and time when the meeting was ended. It's in the timezone specified in the request header or in the
    #: `UTC` timezone if timezone is not specified.
    #: example: 2023-01-18T10:46:30+08:00
    end: Optional[datetime] = None
    #: Duration of the meeting in minutes.
    #: example: 20.0
    duration: Optional[int] = None
    #: Scheduled type for the meeting.
    #: example: meeting
    scheduled_type: Optional[MeetingUsageReportObjectScheduledType] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Aggregated attendee minutes.
    #: example: 60.0
    total_people_minutes: Optional[int] = None
    #: Aggregated attendee PSTN call-in minutes.
    #: example: 60.0
    total_call_in_minutes: Optional[int] = None
    #: Aggregated attendee domestic PSTN call-out minutes.
    #: example: 60.0
    total_call_out_domestic: Optional[int] = None
    #: Aggregated attendee toll-free PSTN call-in minutes.
    #: example: 60.0
    total_call_in_toll_free_minutes: Optional[int] = None
    #: Aggregated attendee international PSTN call-out minutes.
    #: example: 60.0
    total_call_out_international: Optional[int] = None
    #: Aggregated attendee VoIP minutes.
    #: example: 60.0
    total_voip_minutes: Optional[int] = None
    #: Total number of participants of the meeting.
    #: example: 30.0
    total_participants: Optional[int] = None
    #: Total number of VoIP participants of the meeting.
    #: example: 10.0
    total_participants_voip: Optional[int] = None
    #: Total number of PSTN call-in participants of the meeting.
    #: example: 10.0
    total_participants_call_in: Optional[int] = None
    #: Total number of PSTN call-out participants of the meeting.
    #: example: 10.0
    total_participants_call_out: Optional[int] = None
    #: Peak number of attendees throughout the meeting.
    #: example: 30.0
    peak_attendee: Optional[int] = None
    #: Total number of registrants of the meeting.
    #: example: 30.0
    total_registered: Optional[int] = None
    #: Total number of invitees of the meeting.
    #: example: 30.0
    total_invitee: Optional[int] = None
    #: The service type for the meeting usage report.
    #: example: MeetingCenter
    service_type: Optional[MeetingUsageReportObjectServiceType] = None
    #: Tracking codes of the meeting.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None


class MeetingAttendeeReportObject(ApiModel):
    #: Unique identifier for the meeting.
    #: example: 089b137c3cf34b578896941e2d49dfe8_I_146987372776523573
    meeting_id: Optional[str] = None
    #: Meeting number.
    #: example: 123456789.0
    meeting_number: Optional[int] = None
    #: Meeting title.
    #: example: John's Meeting
    meeting_title: Optional[str] = None
    #: Attendee's display name.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: Attendee's email.
    #: example: John Andersen
    email: Optional[str] = None
    #: The date and time when the attendee joined the meeting. It's in the timezone specified in the request header or
    #: in the `UTC` timezone if timezone is not specified.
    #: example: 2023-01-18T10:26:30+08:00
    joined_time: Optional[datetime] = None
    #: The date and time when the attendee left the meeting. It's in the timezone specified in the request header or in
    #: the `UTC` timezone if timezone is not specified.
    #: example: 2023-01-18T10:46:30+08:00
    left_time: Optional[datetime] = None
    #: Duration of the attendee in the meeting in minutes.
    #: example: 20.0
    duration: Optional[int] = None
    #: The attendee's role in the meeting.
    #: example: host
    participant_type: Optional[SiteResponseAccountType] = None
    #: IP address of the attendee when he attended the meeting.
    #: example: 172.16.244.151
    ip_address: Optional[str] = None
    #: Information of the attendee's operating system and application when he attended the meeting.
    #: example: WINDOWS,IE
    client_agent: Optional[str] = None
    #: Attendee's company.
    #: example: ExampleCompany
    company: Optional[str] = None
    #: Attendee's phone number.
    #: example: 85763644
    phone_number: Optional[str] = None
    #: Attendee's address, part one.
    #: example: 85763644
    address1: Optional[str] = None
    #: Attendee's address, part two.
    #: example: 85763644
    address2: Optional[str] = None
    #: Attendee's city.
    #: example: 85763644
    city: Optional[str] = None
    #: Attendee's state.
    #: example: 85763644
    state: Optional[str] = None
    #: Attendee's country.
    #: example: 85763644
    country: Optional[str] = None
    #: Attendee's zip code.
    #: example: 85763644
    zip_code: Optional[str] = None
    #: Whether or not the attendee has registered the meeting.
    registered: Optional[bool] = None
    #: Whether or not the attendee has been invited to the meeting.
    invited: Optional[bool] = None


class ListMeetingUsageReportsResponse(ApiModel):
    #: An array of meeting usage report objects.
    items: Optional[list[MeetingUsageReportObject]] = None


class ListMeetingAttendeeReportsResponse(ApiModel):
    #: An array of meeting attendee report objects.
    items: Optional[list[MeetingAttendeeReportObject]] = None


class OptionsForTrackingCodeObject(ApiModel):
    #: The value of a tracking code option.
    value: Optional[str] = None
    #: Whether or not the option is the default option of a tracking code.
    default_value: Optional[bool] = None


class GetTrackingCodeObjectInputMode(str, Enum):
    #: Text input.
    text = 'text'
    #: Drop down list which requires `options`.
    select = 'select'
    #: Both text input and select from list.
    editable_select = 'editableSelect'
    #: An input method is only available for the host profile and sign-up pages.
    host_profile_select = 'hostProfileSelect'
    none_ = 'none'


class GetTrackingCodeObjectHostProfileCode(str, Enum):
    #: Available to be chosen but not compulsory.
    optional = 'optional'
    #: Officially compulsory.
    required = 'required'
    #: The value is set by admin.
    admin_set = 'adminSet'
    #: The value cannot be used.
    not_used = 'notUsed'
    none_ = 'none'


class ScheduleStartCodeObjectService(str, Enum):
    #: Tracking codes apply to all services.
    all = 'All'
    #: Users can set tracking codes when scheduling a meeting.
    meeting_center = 'MeetingCenter'
    #: Users can set tracking codes when scheduling an event.
    event_center = 'EventCenter'
    #: Users can set tracking codes when scheduling a training session.
    training_center = 'TrainingCenter'
    #: Users can set tracking codes when scheduling a support meeting.
    support_center = 'SupportCenter'
    none_ = 'none'


class ScheduleStartCodeObjectType(str, Enum):
    #: Available to be chosen but not compulsory.
    optional = 'optional'
    #: Officially compulsory.
    required = 'required'
    #: The value is set by admin. This value only applies when `hostProfileCode` is `adminSet`.
    admin_set = 'adminSet'
    #: The value cannot be used.
    not_used = 'notUsed'
    #: This value only applies to the service of `All`. When the type of `All` for a tracking code is `notApplicable`,
    #: there are different types for different services. For example, `required` for `MeetingCenter`, `optional` for
    #: `EventCenter` and `notUsed` for others.
    not_applicable = 'notApplicable'
    none_ = 'none'


class ScheduleStartCodeObject(ApiModel):
    #: Service for schedule or sign up pages
    service: Optional[ScheduleStartCodeObjectService] = None
    #: Type for meeting scheduler or meeting start pages.
    type: Optional[ScheduleStartCodeObjectType] = None


class GetTrackingCodeObject(ApiModel):
    #: Unique identifier for tracking code.
    #: example: 1
    id: Optional[datetime] = None
    #: Name for tracking code.
    #: example: Department
    name: Optional[str] = None
    #: Site URL for the tracking code.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Tracking code option list.
    options: Optional[list[OptionsForTrackingCodeObject]] = None
    #: An option for how an admin user can provide a code value.
    input_mode: Optional[GetTrackingCodeObjectInputMode] = None
    #: Type for the host profile.
    host_profile_code: Optional[GetTrackingCodeObjectHostProfileCode] = None
    #: Specify how tracking codes are used for each service on the meeting scheduler or meeting start pages.
    schedule_start_codes: Optional[list[ScheduleStartCodeObject]] = None


class GetTrackingCodesObject(ApiModel):
    #: Tracking codes information.
    items: Optional[list[GetTrackingCodeObject]] = None


class CreateOrUpdateTrackingCodeObject(ApiModel):
    #: Name for tracking code. The name cannot be empty and the maximum size is 120 characters.
    #: example: Department
    name: Optional[str] = None
    #: Site URL for the tracking code.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Tracking code option list. The maximum size of `options` is 500.
    options: Optional[list[OptionsForTrackingCodeObject]] = None
    #: Select an option for how users can provide a code value. Please note that if users set `inputMode` as
    #: `hostProfileSelect`, `scheduleStartCode` should be `null`, which means `hostProfileSelect` only applies to
    #: "Host Profile".
    input_mode: Optional[GetTrackingCodeObjectInputMode] = None
    #: Type for the host profile.
    host_profile_code: Optional[GetTrackingCodeObjectHostProfileCode] = None
    #: Specify how tracking codes are used for each service on the meeting scheduler or meeting start pages. The
    #: maximum size of `scheduleStartCodes` is 5.
    schedule_start_codes: Optional[list[ScheduleStartCodeObject]] = None


class GetTrackingCodeItemForUserObject(ApiModel):
    #: Unique identifier for tracking code.
    #: example: 1
    id: Optional[datetime] = None
    #: Name for tracking code.
    #: example: Department
    name: Optional[str] = None
    #: Value for tracking code.
    value: Optional[str] = None


class GetTrackingCodeForUserObject(ApiModel):
    #: Site URL for the tracking code.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Unique identifier for the user.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xOGJiOWNjMC0zMWM2LTQ3MzYtYmE4OC0wMDk5ZmQzNDNmODE
    person_id: Optional[str] = None
    #: Email address for the user.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Tracking code information.
    tracking_codes: Optional[list[GetTrackingCodeItemForUserObject]] = None


class UpdateTrackingCodeForUserObject(ApiModel):
    #: Site URL for the tracking code.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Unique identifier for the user. At least one parameter of `personId` or `email` is required. `personId` must
    #: precede `email` if both are specified.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8xOGJiOWNjMC0zMWM2LTQ3MzYtYmE4OC0wMDk5ZmQzNDNmODE
    person_id: Optional[str] = None
    #: Email address for the user. At least one parameter of `personId` or `email` is required. `personId` must precede
    #: `email` if both are specified.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: Tracking code information for updates.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None


class InviteeObjectForCreateMeeting(ApiModel):
    #: Email address of meeting invitee.
    #: example: brenda.song@example.com
    email: Optional[str] = None
    #: Display name of meeting invitee. The maximum length of `displayName` is 128 characters. If not specified but the
    #: email has been registered, user's registered name for the email will be taken as `displayName`. If not
    #: specified and the email hasn't been registered, the email will be taken as `displayName`.
    #: example: Brenda Song
    display_name: Optional[str] = None
    #: Whether or not invitee is allowed to be a cohost for the meeting. `coHost` for each invitee is `true` by default
    #: if `roomId` is specified when creating a meeting, and anyone in the invitee list that is not qualified to be a
    #: cohost will be invited as a non-cohost invitee.
    co_host: Optional[bool] = None
    #: Whether or not an invitee is allowed to be a panelist. Only applies to webinars.
    panelist: Optional[bool] = None


class InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting(ApiModel):
    #: Unique identifier for meeting interpreter.
    #: example: OGQ0OGRiM2U3ZTAxNDZiMGFjYzJjMzYxNDNmNGZhN2RfZTA5MTJiZDBjNWVlNDA4YjgxMTZlMjU4Zjg2NWIzZmM
    id: Optional[str] = None
    #: Forms a set of simultaneous interpretation channels together with `languageCode2`. Standard language format from
    #: `ISO 639-1
    #: <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_ code. Read `ISO 639-1
    #: example: en
    language_code1: Optional[str] = None
    #: Forms a set of simultaneous interpretation channels together with `languageCode1`. Standard language format from
    #: `ISO 639-1
    #: <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_ code. Read `ISO 639-1
    #: example: de
    language_code2: Optional[str] = None
    #: Email address of meeting interpreter.
    #: example: marcus.hoffmann@example.com
    email: Optional[str] = None
    #: Display name of meeting interpreter.
    #: example: Hoffmann
    display_name: Optional[str] = None


class InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting(ApiModel):
    #: Forms a set of simultaneous interpretation channels together with `languageCode2`. Standard language format from
    #: `ISO 639-1
    #: <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_ code. Read `ISO 639-1
    #: example: en
    language_code1: Optional[str] = None
    #: Forms a set of simultaneous interpretation channels together with `languageCode1`. Standard language format from
    #: `ISO 639-1
    #: <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_ code. Read `ISO 639-1
    #: example: de
    language_code2: Optional[str] = None
    #: Email address of meeting interpreter.
    #: example: marcus.hoffmann@example.com
    email: Optional[str] = None
    #: Display name of meeting interpreter.
    #: example: Hoffmann
    display_name: Optional[str] = None


class MeetingSeriesObjectMeetingType(str, Enum):
    #: Primary instance of a scheduled series of meetings which consists of one or more scheduled meetings based on a
    #: `recurrence` rule. When a non-recurring meeting is scheduled with no `recurrence`, its `meetingType` is also
    #: `meetingSeries` which is a meeting series with only one occurrence in Webex meeting modeling.
    meeting_series = 'meetingSeries'
    #: Instance from a primary meeting series.
    scheduled_meeting = 'scheduledMeeting'
    #: Meeting instance that is in progress or has completed.
    meeting = 'meeting'


class MeetingSeriesObjectState(str, Enum):
    #: Only applies to a meeting series. Indicates that one or more future scheduled meetings exist for this meeting
    #: series.
    active = 'active'
    #: Only applies to scheduled meeting. Indicates that the meeting is scheduled in the future.
    scheduled = 'scheduled'
    #: Only applies to scheduled meeting. Indicates that this scheduled meeting is ready to start or join immediately.
    ready = 'ready'
    #: Only applies to meeting instances. Indicates that a locked meeting has been joined by participants, but no hosts
    #: have joined.
    lobby = 'lobby'
    #: Applies to meeting series and meeting instances. For a meeting series, indicates that an instance of this series
    #: is happening now. For a meeting instance, indicates that the meeting has been joined and unlocked.
    in_progress = 'inProgress'
    #: Applies to scheduled meetings and meeting instances. For scheduled meetings, indicates that the meeting was
    #: started and is now over. For meeting instances, indicates that the meeting instance has concluded.
    ended = 'ended'
    #: This state only applies to scheduled meetings. Indicates that the meeting was scheduled in the past but never
    #: happened.
    missed = 'missed'
    #: This state only applies to a meeting series. Indicates that all scheduled meetings of this series have passed.
    expired = 'expired'


class MeetingSeriesObjectUnlockedMeetingJoinSecurity(str, Enum):
    #: If the value of `unlockedMeetingJoinSecurity` attribute is `allowJoin`, people can join the unlocked meeting
    #: directly.
    allow_join = 'allowJoin'
    #: If the value of `unlockedMeetingJoinSecurity` attribute is `allowJoinWithLobby`, people will wait in the lobby
    #: until the host admits them.
    allow_join_with_lobby = 'allowJoinWithLobby'
    #: If the value of `unlockedMeetingJoinSecurity` attribute is `blockFromJoin`, people can't join the unlocked
    #: meeting.
    block_from_join = 'blockFromJoin'


class MeetingSeriesObjectScheduledType(str, Enum):
    #: If the value of `scheduledType` attribute is `meeting`, it is a regular meeting.
    meeting = 'meeting'
    #: If the value of `scheduledType` attribute is `webinar`, it is a webinar meeting.
    webinar = 'webinar'
    #: If the value of `scheduledType` attribute is `personalRoomMeeting`, it is a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    personal_room_meeting = 'personalRoomMeeting'


class MeetingSeriesObjectTelephony(ApiModel):
    #: Code for authenticating a user to join teleconference. Users join the teleconference using the call-in number or
    #: the global call-in number, followed by the value of the `accessCode`.
    #: example: 1234567890
    access_code: Optional[str] = None
    #: Array of call-in numbers for joining a teleconference from a phone.
    call_in_numbers: Optional[list[MeetingPreferenceObjectPersonalMeetingRoomTelephonyCallInNumbers]] = None
    #: `HATEOAS
    #: <https://en.wikipedia.org/wiki/HATEOAS>`_ information of global call-in numbers for joining a teleconference from a phone.
    links: Optional[list[Link]] = None


class MeetingSeriesObjectMeetingOptionsNoteType(str, Enum):
    #: If the value of `noteType` attribute is `allowAll`, all participants can take notes.
    allow_all = 'allowAll'
    #: If the value of `noteType` attribute is `allowOne`, only a single note taker is allowed.
    allow_one = 'allowOne'


class MeetingSeriesObjectMeetingOptions(ApiModel):
    #: Whether or not to allow any attendee to chat in the meeting. Also depends on the session type.
    #: example: True
    enabled_chat: Optional[bool] = None
    #: Whether or not to allow any attendee to have video in the meeting. Also depends on the session type.
    #: example: True
    enabled_video: Optional[bool] = None
    #: Whether or not to allow any attendee to poll in the meeting. Can only be set `true` for a webinar. The value of
    #: this attribute depends on the session type for a meeting. Please contact your site admin if this attribute is
    #: not available.
    enabled_polling: Optional[bool] = None
    #: Whether or not to allow any attendee to take notes in the meeting. The value of this attribute also depends on
    #: the session type.
    #: example: True
    enabled_note: Optional[bool] = None
    #: Whether note taking is enabled. If the value of `enabledNote` is false, users can not set this attribute and get
    #: default value `allowAll`.
    #: example: allowAll
    note_type: Optional[MeetingSeriesObjectMeetingOptionsNoteType] = None
    #: Whether or not to allow any attendee to have closed captions in the meeting. The value of this attribute also
    #: depends on the session type.
    enabled_closed_captions: Optional[bool] = None
    #: Whether or not to allow any attendee to transfer files in the meeting. The value of this attribute also depends
    #: on the session type.
    enabled_file_transfer: Optional[bool] = None
    #: Whether or not to allow any attendee to share `Universal Communications Format
    #: <https://www.cisco.com/c/en/us/td/docs/collaboration/training_center/wbs30/WebEx_BK_TE1FB6C1_00_training-center-frequently-asked-questions/WebEx_BK_TE1FB6C1_00_training-center-frequently-asked-questions_chapter_0110.pdf>`_ media files in the meeting. The
    #: value of this attribute also depends on the sessionType.
    enabled_ucfrich_media: Optional[bool] = Field(alias='enabledUCFRichMedia', default=None)


class MeetingSeriesObjectAttendeePrivileges(ApiModel):
    #: Whether or not to allow any attendee to share content in the meeting.
    #: example: True
    enabled_share_content: Optional[bool] = None
    #: Whether or not to allow any attendee to save shared documents, slides, or whiteboards when they are shared as
    #: files in the content viewer instead of in a window or application.
    enabled_save_document: Optional[bool] = None
    #: Whether or not to allow any attendee to print shared documents, slides, or whiteboards when they are shared as
    #: files in the content viewer instead of in a window or application.
    enabled_print_document: Optional[bool] = None
    #: Whether or not to allow any attendee to annotate shared documents, slides, or whiteboards when they are shared
    #: as files in the content viewer instead of in a window or application.
    enabled_annotate: Optional[bool] = None
    #: Whether or not to allow any attendee to view participants.
    #: example: True
    enabled_view_participant_list: Optional[bool] = None
    #: Whether or not to allow any attendee to see a small preview image of any page of shared documents or slides when
    #: they are shared as files in the content viewer instead of in a window or application.
    enabled_view_thumbnails: Optional[bool] = None
    #: Whether or not to allow any attendee to control applications, web browsers, or desktops remotely.
    #: example: True
    enabled_remote_control: Optional[bool] = None
    #: Whether or not to allow any attendee to view any shared documents or slides when they are shared as files in the
    #: content viewer instead of in a window or application.
    enabled_view_any_document: Optional[bool] = None
    #: Whether or not to allow any attendee to scroll through any page of shared documents or slides when they are
    #: shared as files in the content viewer instead of in a window or application.
    enabled_view_any_page: Optional[bool] = None
    #: Whether or not to allow any attendee to contact the operator privately.
    enabled_contact_operator_privately: Optional[bool] = None
    #: Whether or not to allow any attendee to chat with the host in private.
    #: example: True
    enabled_chat_host: Optional[bool] = None
    #: Whether or not to allow any attendee to chat with the presenter in private.
    #: example: True
    enabled_chat_presenter: Optional[bool] = None
    #: Whether or not to allow any attendee to chat with other participants in private.
    #: example: True
    enabled_chat_other_participants: Optional[bool] = None


class CustomizedQuestionForCreateMeetingType(str, Enum):
    #: Single line text box.
    single_line_text_box = 'singleLineTextBox'
    #: Multiple line text box.
    multi_line_text_box = 'multiLineTextBox'
    #: Check box which requires `options`.
    checkbox = 'checkbox'
    #: Drop down list box which requires `options`.
    dropdown_list = 'dropdownList'
    #: Single radio button which requires `options`.
    radio_buttons = 'radioButtons'
    none_ = 'none'


class QuestionOptionObject(ApiModel):
    #: Unique identifier for the question option.
    #: example: 1.0
    id: Optional[int] = None
    #: Value for the question option.
    #: example: Yes
    value: Optional[str] = None


class CustomizedQuestionForCreateMeetingRulesCondition(str, Enum):
    #: The content of the answer contains the value.
    contains = 'contains'
    #: The content of the answer does not contain the value
    not_contains = 'notContains'
    #: The content of the answer begins with the value.
    begins_with = 'beginsWith'
    #: The content of the answer ends with the value.
    ends_with = 'endsWith'
    #: The content of the answer is the same as the value.
    equals = 'equals'
    #: The content of the answer is not the same as the value.
    not_equals = 'notEquals'


class CustomizedQuestionForCreateMeetingRulesResult(str, Enum):
    #: If the user's registration value meets the criteria, the registration form will be automatically approved.
    approve = 'approve'
    #: If the user's registration value meets the criteria, the registration form will be automatically rejected.
    reject = 'reject'


class CustomizedQuestionForGetMeetingRules(ApiModel):
    #: Judgment expression for approval rules.
    #: example: contains
    condition: Optional[CustomizedQuestionForCreateMeetingRulesCondition] = None
    #: The keyword for the approval rule. If the rule matches the keyword, the corresponding action will be executed.
    #: example: tom
    value: Optional[str] = None
    #: The automatic approval result for the approval rule.
    #: example: approve
    result: Optional[CustomizedQuestionForCreateMeetingRulesResult] = None
    #: Whether to check the case of values.
    #: example: True
    match_case: Optional[bool] = None
    #: The priority number of the approval rule. Approval rules for standard questions and custom questions need to be
    #: ordered together.
    #: example: 1.0
    order: Optional[int] = None


class CustomizedQuestionForGetMeeting(ApiModel):
    #: Unique identifier for the question.
    #: example: 330521.0
    id: Optional[int] = None
    #: Title of the customized question.
    #: example: How are you
    question: Optional[str] = None
    #: Whether or not the customized question is required to be answered by participants.
    #: example: True
    required: Optional[bool] = None
    #: Type of the question being asked.
    type: Optional[CustomizedQuestionForCreateMeetingType] = None
    #: The maximum length of a string that can be entered by the user, ranging from `0` to `999`. Only required by
    #: `singleLineTextBox` and `multiLineTextBox`.
    max_length: Optional[int] = None
    #: TThe content of `options`. Required if the question type is one of `checkbox`, `dropdownList`, or
    #: `radioButtons`.
    options: Optional[list[QuestionOptionObject]] = None
    #: The automatic approval rules for customized questions.
    rules: Optional[list[CustomizedQuestionForGetMeetingRules]] = None


class StandardRegistrationApproveRuleQuestion(str, Enum):
    #: If the value is `lastName`, this approval rule applies to the standard question of "Last Name".
    last_name = 'lastName'
    #: If the value is `email`, this approval rule applies to the standard question of "Email".
    email = 'email'
    #: If the value is `jobTitle`, this approval rule applies to the standard question of "Job Title".
    job_title = 'jobTitle'
    #: If the value is `companyName`, this approval rule applies to the standard question of "Company Name".
    company_name = 'companyName'
    #: If the value is `address1`, this approval rule applies to the standard question of "Address 1".
    address1 = 'address1'
    #: If the value is `address2`, this approval rule applies to the standard question of "Address 2".
    address2 = 'address2'
    #: If the value is `city`, this approval rule applies to the standard question of "City".
    city = 'city'
    #: If the value is `state`, this approval rule applies to the standard question of "State".
    state = 'state'
    #: If the value is `zipCode`, this approval rule applies to the standard question of "Zip/Post Code".
    zip_code = 'zipCode'
    #: If the value is `countryRegion`, this approval rule applies to the standard question of "Country Region".
    country_region = 'countryRegion'
    #: If the value is `workPhone`, this approval rule applies to the standard question of "Work Phone".
    work_phone = 'workPhone'
    #: If the value is `fax`, this approval rule applies to the standard question of "Fax".
    fax = 'fax'


class StandardRegistrationApproveRule(ApiModel):
    #: Name for standard question.
    #: example: state
    question: Optional[StandardRegistrationApproveRuleQuestion] = None
    #: Judgment expression for approval rules.
    #: example: contains
    condition: Optional[CustomizedQuestionForCreateMeetingRulesCondition] = None
    #: The keyword for the approval rule. If the rule matches the keyword, the corresponding action will be executed.
    #: example: tom
    value: Optional[str] = None
    #: The automatic approval result for the approval rule.
    #: example: approve
    result: Optional[CustomizedQuestionForCreateMeetingRulesResult] = None
    #: Whether to check the case of values.
    #: example: True
    match_case: Optional[bool] = None
    #: The priority number of the approval rule. Approval rules for standard questions and custom questions need to be
    #: ordered together.
    #: example: 1.0
    order: Optional[int] = None


class MeetingSeriesObjectRegistration(ApiModel):
    #: Whether or not meeting registration requests are accepted automatically.
    auto_accept_request: Optional[bool] = None
    #: Whether or not a registrant's first name is required for meeting registration.
    #: example: True
    require_first_name: Optional[bool] = None
    #: Whether or not a registrant's last name is required for meeting registration.
    #: example: True
    require_last_name: Optional[bool] = None
    #: Whether or not a registrant's email is required for meeting registration.
    #: example: True
    require_email: Optional[bool] = None
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool] = None
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool] = None
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool] = None
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool] = None
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool] = None
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool] = None
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool] = None
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool] = None
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool] = None
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool] = None
    #: Maximum number of meeting registrations. This only applies to meetings. The maximum number of participants for
    #: meetings and webinars, with the limit based on the user capacity and controlled by a toggle at the site level.
    #: The default maximum number of participants for webinars is 10000, but the actual maximum number of participants
    #: is limited by the user capacity.
    #: example: 1000.0
    max_register_num: Optional[int] = None
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForGetMeeting]] = None
    #: The approval rules for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]] = None


class MeetingSeriesObjectSimultaneousInterpretation(ApiModel):
    #: Whether or not simultaneous interpretation is enabled.
    enabled: Optional[bool] = None
    #: Interpreters for meeting.
    interpreters: Optional[list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]] = None


class MeetingSeriesObjectAudioConnectionOptionsAudioConnectionType(str, Enum):
    #: Provide a hybrid audio option, allowing attendees to join using their computer audio or a phone.
    webex_audio = 'webexAudio'
    #: Only restricts attendees to join the audio portion of the meeting using their computer instead of a telephone
    #: option.
    vo_ip = 'VoIP'
    #: Other teleconference services.
    other = 'other'
    #: The way of attendees join the audio portion of the meeting is the default value.
    none_ = 'none'


class MeetingSeriesObjectAudioConnectionOptionsEntryAndExitTone(str, Enum):
    #: All call-in users joining the meeting will hear the beep.
    beep = 'beep'
    #: All call-in users joining the meeting will hear their names.
    announce_name = 'announceName'
    #: Turn off beeps and name announcements.
    no_tone = 'noTone'


class MeetingSeriesObjectAudioConnectionOptions(ApiModel):
    #: Choose how meeting attendees join the audio portion of the meeting.
    #: example: webexAudio
    audio_connection_type: Optional[MeetingSeriesObjectAudioConnectionOptionsAudioConnectionType] = None
    #: Whether or not to show toll-free call-in numbers.
    #: example: True
    enabled_toll_free_call_in: Optional[bool] = None
    #: Whether or not to show global call-in numbers to attendees.
    #: example: True
    enabled_global_call_in: Optional[bool] = None
    #: Whether or not to allow attendees to receive a call-back and call-in is available. Can only be set `true` for a
    #: webinar.
    enabled_audience_call_back: Optional[bool] = None
    #: Select the sound you want users who have a phone audio connection to hear when someone enters or exits the
    #: meeting.
    #: example: beep
    entry_and_exit_tone: Optional[MeetingSeriesObjectAudioConnectionOptionsEntryAndExitTone] = None
    #: Whether or not to allow the host to unmute participants.
    allow_host_to_unmute_participants: Optional[bool] = None
    #: Whether or not to allow attendees to unmute themselves.
    #: example: True
    allow_attendee_to_unmute_self: Optional[bool] = None
    #: Whether or not to auto-mute attendees when attendees enter meetings.
    mute_attendee_upon_entry: Optional[bool] = None


class MeetingSeriesObject(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: meetingSeries
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: active
    state: Optional[MeetingSeriesObjectState] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ of `start` and `end`, conforming with the `IANA time zone database
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meeting is a meeting series, `start` is the date and
    #: time the first meeting of the series starts. If the meeting is a meeting series and the `current` filter is
    #: true, `start` is the date and time the upcoming or ongoing meeting of the series starts. If the meeting is a
    #: scheduled meeting from a meeting series, `start` is the date and time when that scheduled meeting starts. If
    #: the meeting is a meeting instance that has happened or is happening, `start` is the date and time that the
    #: instance actually starts. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in ISO 8601 compliant format. If the meeting is a meeting series, `end` is the date and
    #: time the first meeting of the series ends. If the meeting is a meeting series and the current filter is true,
    #: `end` is the date and time the upcoming or ongoing meeting of the series ends. If the meeting is a scheduled
    #: meeting from a meeting series, `end` is the date and time when that scheduled meeting ends. If the meeting is a
    #: meeting instance that has happened, `end` is the date and time that instance actually ends. If a meeting
    #: instance is in progress, `end` is not available. Can be modified for a meeting series or a scheduled meeting
    #: using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Can be modified for a meeting series using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only
    #: the first day or date specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12"
    #: is not supported and it will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10". For a
    #: non-recurring meeting which has no `recurrence`, its `meetingType` is also `meetingSeries` which is a meeting
    #: series with only one occurrence in Webex meeting modeling.
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=10
    recurrence: Optional[str] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join a webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingSeriesObjectTelephony] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information in order
    #: to join the meeting. Meeting invitees will receive an email with a registration link for the registration. When
    #: the registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a `recurrence` field or no password, or the `Join Before
    #: Host` option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details.
    registration: Optional[MeetingSeriesObjectRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for a meeting.
    simultaneous_interpretation: Optional[MeetingSeriesObjectSimultaneousInterpretation] = None
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool] = None
    #: `HATEOAS
    #: <https://en.wikipedia.org/wiki/HATEOAS>`_ Breakout Sessions information for meeting.
    links: Optional[list[Link]] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class MeetingSeriesObjectWithAdhocRegistration(ApiModel):
    #: Whether or not meeting registration requests are accepted automatically.
    auto_accept_request: Optional[bool] = None
    #: Whether or not a registrant's first name is required for meeting registration.
    #: example: True
    require_first_name: Optional[bool] = None
    #: Whether or not a registrant's last name is required for meeting registration.
    #: example: True
    require_last_name: Optional[bool] = None
    #: Whether or not a registrant's email is required for meeting registration.
    #: example: True
    require_email: Optional[bool] = None
    #: Whether or not a registrant's job title is required for meeting registration.
    require_job_title: Optional[bool] = None
    #: Whether or not a registrant's company name is required for meeting registration.
    require_company_name: Optional[bool] = None
    #: Whether or not a registrant's first address field is required for meeting registration.
    require_address1: Optional[bool] = None
    #: Whether or not a registrant's second address field is required for meeting registration.
    require_address2: Optional[bool] = None
    #: Whether or not a registrant's city is required for meeting registration.
    require_city: Optional[bool] = None
    #: Whether or not a registrant's state is required for meeting registration.
    require_state: Optional[bool] = None
    #: Whether or not a registrant's postal code is required for meeting registration.
    require_zip_code: Optional[bool] = None
    #: Whether or not a registrant's country or region is required for meeting registration.
    require_country_region: Optional[bool] = None
    #: Whether or not a registrant's work phone number is required for meeting registration.
    require_work_phone: Optional[bool] = None
    #: Whether or not a registrant's fax number is required for meeting registration.
    require_fax: Optional[bool] = None
    #: Maximum number of meeting registrations. This only applies to meetings. The maximum number of participants for
    #: meetings and webinars, with the limit based on the user capacity and controlled by a toggle at the site level.
    #: The default maximum number of participants for webinars is 10000, but the actual maximum number of participants
    #: is limited by the user capacity.
    #: example: 1000.0
    max_register_num: Optional[int] = None


class MeetingSeriesObjectWithAdhoc(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: meetingSeries
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: active
    state: Optional[MeetingSeriesObjectState] = None
    #: If `true`, the meeting is ad-hoc.
    adhoc: Optional[bool] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ of `start` and `end`, conforming with the `IANA time zone database
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of this meeting is `meetingSeries`, and
    #: `current` is not specified or is `false`, `start` is the scheduled start time of the first occurrence of this
    #: series. If the meetingType of this meeting is `meetingSeries`, and `current` is not specified or is `false`,
    #: `start` is the scheduled start time of the first occurrence of this series. If the meetingType of this meeting
    #: is `meetingSeries`, and `current` is `true`, `start` is the scheduled start time of the ongoing or upcoming
    #: occurrence in this series. If the meetingType of this meeting is `scheduledMeeting`, `start` is the scheduled
    #: start time of this occurrence. If the meetingType of this meeting is `meeting`, `start` is the actual start
    #: time of this meeting instance. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meeting is a meeting series, `end` is the date and
    #: time the first meeting of the series ends. If the meetingType of this meeting is `meetingSeries`, and `current`
    #: is not specified or is `false`, `end` is the scheduled end time of the first occurrence of this series. If the
    #: meetingType of this meeting is `meetingSeries`, and `current` is `true`, `end` is the scheduled end time of the
    #: ongoing or upcoming occurrence in this series. If the meetingType of this meeting is `scheduledMeeting`, `end`
    #: is the scheduled end time of this occurrence. If the meetingType of this meeting is `meeting`, `end` is the
    #: actual end time of this meeting instance. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Can be modified for a meeting series using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only
    #: the first day or date specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12"
    #: is not supported and it will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=10
    recurrence: Optional[str] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join a webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not this meeting instance has chat.
    has_chat: Optional[bool] = None
    #: Whether or not this meeting instance has a recording.
    has_recording: Optional[bool] = None
    #: Whether or not this meeting instance has a transcription.
    has_transcription: Optional[bool] = None
    #: Whether or not this meeting instance has closed captions.
    has_closed_caption: Optional[bool] = None
    #: Whether or not this meeting instance has polls.
    has_polls: Optional[bool] = None
    #: Whether or not this meeting instance has Q&A.
    has_qa: Optional[bool] = Field(alias='hasQA', default=None)
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingPreferenceObjectPersonalMeetingRoomTelephony] = None
    #: Meeting options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information in order
    #: to join the meeting. Meeting invitees will receive an email with a registration link for the registration. When
    #: the registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a `recurrence` field or no password, or the `Join Before
    #: Host` option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details.
    registration: Optional[MeetingSeriesObjectWithAdhocRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for the meeting.
    simultaneous_interpretation: Optional[MeetingSeriesObjectSimultaneousInterpretation] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class MeetingSeriesObjectForListMeeting(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: meetingSeries
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: active
    state: Optional[MeetingSeriesObjectState] = None
    #: Time zone of `start` and `end`, conforming with the `IANA time zone database
    #: <https://www.iana.org/time-zones>`_.
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `start`
    #: is the scheduled start time of the first occurrence of this series. If the meeting is a meeting series and the
    #: `current` filter is true, `start` is the date and time the upcoming or ongoing meeting of the series starts. If
    #: the meetingType of a meeting is `scheduledMeeting`, `start` is the scheduled start time of this occurrence. If
    #: the meetingType of a meeting is `meeting`, `start` is the actual start time of the meeting instance. Can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `end`
    #: is the scheduled end time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, `end` is the date and time the upcoming or ongoing meeting of the series ends. If the
    #: meetingType of a meeting is `scheduledMeeting`, `end` is the scheduled end time of this occurrence. If the
    #: meetingType of a meeting is `meeting`, `end` is the actual end time of the meeting instance. If a meeting
    #: instance is in progress, `end` is not available. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Can be modified for a meeting series using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_
    #: API. Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only the first day or
    #: date specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported
    #: and it will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=10
    recurrence: Optional[str] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join a webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not this meeting instance has chat.
    has_chat: Optional[bool] = None
    #: Whether or not this meeting instance has a recording.
    has_recording: Optional[bool] = None
    #: Whether or not this meeting instance has a transcription.
    has_transcription: Optional[bool] = None
    #: Whether or not this meeting instance has closed captions.
    has_closed_caption: Optional[bool] = None
    #: Whether or not this meeting instance has polls.
    has_polls: Optional[bool] = None
    #: Whether or not this meeting instance has Q&A.
    has_qa: Optional[bool] = Field(alias='hasQA', default=None)
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingPreferenceObjectPersonalMeetingRoomTelephony] = None
    #: Meeting options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information in order
    #: to join the meeting. Meeting invitees will receive an email with a registration link for the registration. When
    #: the registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a `recurrence` field or no password, or the `Join Before
    #: Host` option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details.
    registration: Optional[MeetingSeriesObjectWithAdhocRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for the meeting.
    simultaneous_interpretation: Optional[MeetingSeriesObjectSimultaneousInterpretation] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class ScheduledMeetingObject(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Unique identifier for meeting series. It only apples to scheduled meeting and meeting instance. If it's a
    #: scheduled meeting from a series or a meeting instance that is happening or has happened, the `meetingSeriesId`
    #: is the `id` of the primary series.
    #: example: dfb45ece33264639a7bc3dd9535d53f7
    meeting_series_id: Optional[str] = None
    #: Unique identifier for scheduled meeting which current meeting is associated with. It only apples to meeting
    #: instance which is happening or has happened. It's the `id` of the scheduled meeting this instance is associated
    #: with.
    #: example: dfb45ece33264639a7bc3dd9535d53f7
    scheduled_meeting_id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: scheduledMeeting
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: scheduled
    state: Optional[MeetingSeriesObjectState] = None
    #: This state only applies to scheduled meeting. Flag identifying whether or not the scheduled meeting has been
    #: modified.
    is_modified: Optional[bool] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ of `start` and `end`, conforming with the `IANA time zone database
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `start`
    #: is the scheduled start time of the first occurrence of this series. If the meeting is a meeting series and the
    #: `current` filter is true, `start` is the date and time the upcoming or ongoing meeting of the series starts. If
    #: the meetingType of a meeting is `scheduledMeeting`, `start` is the scheduled start time of this occurrence. If
    #: the meetingType of a meeting is `meeting`, `start` is the actual start time of the meeting instance. Can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `end`
    #: is the scheduled end time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, `end` is the date and time the upcoming or ongoing meeting of the series ends. If the
    #: meetingType of a meeting is `scheduledMeeting`, `end` is the scheduled end time of this occurrence. If the
    #: meetingType of a meeting is `meeting`, `end` is the actual end time of the meeting instance. If a meeting
    #: instance is in progress, `end` is not available. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not this meeting instance has chat.
    has_chat: Optional[bool] = None
    #: Whether or not this meeting instance has a recording.
    has_recording: Optional[bool] = None
    #: Whether or not this meeting instance has a transcription.
    has_transcription: Optional[bool] = None
    #: Whether or not this meeting instance has closed captions.
    has_closed_caption: Optional[bool] = None
    #: Whether or not this meeting instance has polls.
    has_polls: Optional[bool] = None
    #: Whether or not this meeting instance has Q&A.
    has_qa: Optional[bool] = Field(alias='hasQA', default=None)
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingSeriesObjectTelephony] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information to join
    #: the meeting. Meeting invitees will receive an email with a registration link for the registration. When the
    #: registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a recurrence field or no password, or the Join Before
    #: Host option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details.    +
    #: autoAcceptRequest: `false` (boolean,optional) - Whether or not meeting registration requests are accepted
    #: automatically.
    registration: Optional[MeetingSeriesObjectWithAdhocRegistration] = None
    #: External keys created by an integration application in its domain, for example, Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool] = None
    #: `HATEOAS
    #: <https://en.wikipedia.org/wiki/HATEOAS>`_ Breakout Sessions information for meeting.
    links: Optional[list[Link]] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class UpdateMeetingObject(ApiModel):
    #: Meeting title. The title can be a maximum of 128 characters long.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Must conform to the site's password complexity settings. Read `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
    #: example: BgJep@43
    password: Optional[str] = None
    #: Date and time for the start of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before current date
    #: and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Refer to the `Webex Meetings
    #: <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on updating date and time for
    #: a meeting. Please note that when a meeting is being updated, `start` of the meeting will be accurate to
    #: minutes, not seconds or milliseconds. Therefore, if `start` is within the same minute as the current time,
    #: `start` will be adjusted to the upcoming minute; otherwise, `start` will be adjusted with seconds and
    #: milliseconds stripped off. For instance, if the current time is `2022-03-01T10:32:16.657+08:00`, `start` of
    #: `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00` will be adjusted to `2022-03-01T10:33:00+08:00`,
    #: and `start` of `2022-03-01T11:32:28.076+08:00` or `2022-03-01T11:32:41+08:00` will be adjusted to
    #: `2022-03-01T11:32:00+08:00`.
    #: example: 2020-05-15T20:30:00-08:00
    start: Optional[datetime] = None
    #: Date and time for the end of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before current date and
    #: time or before `start`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Refer to the `Webex Meetings
    #: <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on updating date and time for
    #: a meeting. Please note that when a meeting is being updated, `end` of the meeting will be accurate to minutes,
    #: not seconds or milliseconds. Therefore, `end` will be adjusted with seconds and milliseconds stripped off. For
    #: instance, `end` of `2022-03-01T11:52:28.076+08:00` or `2022-03-01T11:52:41+08:00` will be adjusted to
    #: `2022-03-01T11:52:00+08:00`.
    #: example: 2020-05-15T21:30:00-08:00
    end: Optional[datetime] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the `IANA time zone database
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Multiple days or dates for monthly or yearly `recurrence` rule
    #: are not supported, only the first day or date specified is taken. For example,
    #: "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported as
    #: "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=20
    recurrence: Optional[str] = None
    #: Whether or not meeting is recorded automatically.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: user's preferred site.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect audio in the meeting before the host joins the meeting. This
    #: attribute is only applicable if the `enabledJoinBeforeHost` attribute is set to true.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid options for a meeting are `0`, `5`,
    #: `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The default is `0` if not
    #: specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 30.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required while scheduling webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved by
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: user's preferred site.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not to send emails to host and invitees. It is an optional field and default value is true.
    #: example: True
    send_email: Optional[bool] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin-level scopes. When used, the admin may specify the email of a user in a site they manage to be
    #: the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: URL of the Webex site which the meeting is updated on. If not specified, the meeting is created on user's
    #: preferred site. All available Webex sites and preferred site of the user can be retrieved by `Get Site List`
    #: API.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc. The integration application queries meetings by a key in its own domain. The
    #: maximum size of `integrationTags` is 3 and each item of `integrationTags` can be a maximum of 64 characters
    #: long. Please note that an empty or null `integrationTags` will delete all existing integration tags for the
    #: meeting implicitly. Developer can update integration tags for a `meetingSeries` but he cannot update it for a
    #: `scheduledMeeting` or a `meeting` instance.
    integration_tags: Optional[list[str]] = None
    #: Whether or not breakout sessions are enabled. If the value of `enabledBreakoutSessions` is false, users can not
    #: set breakout sessions. If the value of `enabledBreakoutSessions` is true, users can update breakout sessions
    #: using the `Update Breakout Sessions
    #: <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_ API. Updating breakout sessions are not supported by this API.
    enabled_breakout_sessions: Optional[bool] = None
    #: Tracking codes information. All available tracking codes and their options for the specified site can be
    #: retrieved by `List Meeting Tracking Codes
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is missing from the `trackingCodes`
    #: array and there's a default option for this tracking code, the default option is assigned automatically. If the
    #: `inputMode` of a tracking code is `select`, its value must be one of the site-level options or the user-level
    #: value. Tracking code is not supported for a personal room meeting or an ad-hoc space meeting.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar. This option works when the value of `scheduledType`
    #: attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set if someone has already registered
    #: for the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only. This option works when the registration option is disabled and the
    #: value of `scheduledType` attribute is `webinar`. Please note that `restrictToInvitees` cannot be set to `true`
    #: if `requireAttendeeLogin` is `false`.
    restrict_to_invitees: Optional[bool] = None


class CustomizedQuestionForCreateMeetingOptions(ApiModel):
    #: The content of the option.
    #: example: green
    value: Optional[str] = None


class CustomizedQuestionForCreateMeetingRules(ApiModel):
    #: Judgment expression for approval rules.
    #: example: contains
    condition: Optional[CustomizedQuestionForCreateMeetingRulesCondition] = None
    #: The keyword for the approval rule. If the rule matches the keyword, the corresponding action will be executed.
    #: example: tom
    value: Optional[str] = None
    #: The automatic approval result for the approval rule.
    #: example: approve
    result: Optional[CustomizedQuestionForCreateMeetingRulesResult] = None
    #: Whether to check the case of values.
    #: example: True
    match_case: Optional[bool] = None


class CustomizedQuestionForCreateMeeting(ApiModel):
    #: Title of the customized question.
    #: example: How are you
    question: Optional[str] = None
    #: Whether or not the customized question is required to be answered by participants.
    #: example: True
    required: Optional[bool] = None
    #: Type of the question being asked.
    type: Optional[CustomizedQuestionForCreateMeetingType] = None
    #: The maximum length of a string that can be entered by the user, ranging from `0` to `999`. Only required by
    #: `singleLineTextBox` and `multiLineTextBox`.
    max_length: Optional[int] = None
    #: The content of `options`. Required if the question type is one of `checkbox`, `dropdownList`, or `radioButtons`.
    options: Optional[list[CustomizedQuestionForCreateMeetingOptions]] = None
    #: The automatic approval rules for customized questions.
    rules: Optional[list[CustomizedQuestionForCreateMeetingRules]] = None


class CreateMeetingObjectRegistration(ApiModel):
    #: Whether or not meeting registration request is accepted automatically.
    auto_accept_request: Optional[bool] = None
    #: Whether or not a registrant's first name is required for meeting registration. This option must always be
    #: `true`.
    #: example: True
    require_first_name: Optional[bool] = None
    #: Whether or not a registrant's last name is required for meeting registration. This option must always be `true`.
    #: example: True
    require_last_name: Optional[bool] = None
    #: Whether or not a registrant's email is required for meeting registration. This option must always be `true`.
    #: example: True
    require_email: Optional[bool] = None
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool] = None
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool] = None
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool] = None
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool] = None
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool] = None
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool] = None
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool] = None
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool] = None
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool] = None
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool] = None
    #: Maximum number of meeting registrations. This only applies to meetings. The maximum number of participants for
    #: meetings and webinars, with the limit based on the user capacity and controlled by a toggle at the site level.
    #: The default maximum number of participants for webinars is 10000, but the actual maximum number of participants
    #: is limited by the user capacity.
    #: example: 1000.0
    max_register_num: Optional[int] = None
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForCreateMeeting]] = None
    #: The approval rules for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]] = None


class CreateMeetingObjectSimultaneousInterpretation(ApiModel):
    #: Whether or not simultaneous interpretation is enabled.
    enabled: Optional[bool] = None
    #: Interpreters for meeting.
    interpreters: Optional[list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]] = None


class BreakoutSessionObject(ApiModel):
    #: Name for breakout session.
    #: example: Breakout Session Name
    name: Optional[str] = None
    #: Invitees for breakout session. Please note that one invitee cannot be assigned to more than one breakout
    #: session.
    invitees: Optional[list[str]] = None


class CreateMeetingObject(ApiModel):
    #: Whether or not to create an ad-hoc meeting for the room specified by `roomId`. When `true`, `roomId` is
    #: required.
    adhoc: Optional[bool] = None
    #: Unique identifier for the Webex space which the meeting is to be associated with. It can be retrieved by
    #: `List Rooms
    #: <https://developer.webex.com/docs/api/v1/rooms/list-rooms>`_. `roomId` is required when `adhoc` is `true`. When `roomId` is specified, the parameter `hostEmail`
    #: will be ignored.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Unique identifier for meeting template. Please note that `start` and `end` are optional when `templateId` is
    #: specified. The list of meeting templates that is available for the authenticated user can be retrieved from
    #: `List Meeting Templates
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_. This parameter is ignored for an ad-hoc meeting.
    #: example: N2Q3ZWE1ZjQyYjkyMWVhY2UwNTM4NmNhMjRhZDczMGU6VS0yMDA5NzItTUMtZW5fVVM
    template_id: Optional[str] = None
    #: Meeting title. The title can be a maximum of 128 characters long. The default value for an ad-hoc meeting is the
    #: user's name if not specified.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Must conform to the site's password complexity settings. Read `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
    #: If not specified, a random password conforming to the site's password rules will be generated automatically.
    #: example: BgJep@43
    password: Optional[str] = None
    #: Date and time for the start of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before current date
    #: and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Please note that when a meeting is being scheduled, `start` of the meeting will be accurate to minutes,
    #: not seconds or milliseconds. Therefore, if `start` is within the same minute as the current time, `start` will
    #: be adjusted to the upcoming minute; otherwise, `start` will be adjusted with seconds and milliseconds stripped
    #: off. For instance, if the current time is `2022-03-01T10:32:16.657+08:00`, `start` of
    #: `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00` will be adjusted to `2022-03-01T10:33:00+08:00`,
    #: and `start` of `2022-03-01T11:32:28.076+08:00` or `2022-03-01T11:32:41+08:00` will be adjusted to
    #: `2022-03-01T11:32:00+08:00`. The default value for an ad-hoc meeting is 5 minutes after the current time and
    #: the user's input value will be ignored. An ad-hoc meeting can be started immediately even if the `start` is 5
    #: minutes after the current time.
    #: example: 2020-05-15T20:30:00-08:00
    start: Optional[datetime] = None
    #: Date and time for the end of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before current date and
    #: time or before `start`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Please note that when a meeting is being scheduled, `end` of the meeting will be accurate to minutes,
    #: not seconds or milliseconds. Therefore, `end` will be adjusted with seconds and milliseconds stripped off. For
    #: instance, `end` of `2022-03-01T11:52:28.076+08:00` or `2022-03-01T11:52:41+08:00` will be adjusted to
    #: `2022-03-01T11:52:00+08:00`. The default value for an ad-hoc meeting is 20 minutes after the current time and
    #: the user's input value will be ignored.
    #: example: 2020-05-15T21:30:00-08:00
    end: Optional[datetime] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the `IANA time zone database
    #: default value for an ad-hoc meeting is `UTC` and the user's input value will be ignored.
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_), applying only to meeting series. It doesn't apply to
    #: a scheduled meeting or an ended or ongoing meeting instance. This parameter is ignored for an ad-hoc meeting.
    #: Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only the first day or date
    #: specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it
    #: will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=20
    recurrence: Optional[str] = None
    #: Whether or not meeting is recorded automatically.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: the user's preferred site. The default value for an ad-hoc meeting is `true` and the user's input value will be
    #: ignored.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The default value
    #: for an ad-hoc meeting is `true` and the user's input value will be ignored.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect audio in the meeting before the host joins the meeting. This
    #: attribute is only applicable if the `enabledJoinBeforeHost` attribute is set to true. The default value for an
    #: ad-hoc meeting is `true` and the user's input value will be ignored.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. This
    #: attribute is only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default value for an ad-hoc meeting is 0 and the user's input value will be ignored.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation. This parameter is ignored for an
    #: ad-hoc meeting.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar. The default value for an ad-hoc meeting
    #: is `false` and the user's input value will be ignored.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host. This parameter is
    #: ignored for an ad-hoc meeting.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting. The default value for an ad-hoc
    #: meeting is `allowJoinWithLobby` and the user's input value will be ignored.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: When set as an attribute in a POST request body, specifies whether it's a regular meeting, a webinar, or a
    #: meeting scheduled in the user's `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_. If not specified, it's a regular meeting by default. The default
    #: value for an ad-hoc meeting is `meeting` and the user's input value will be ignored.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled. This parameter is ignored for an ad-hoc meeting.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically. This parameter is ignored for an ad-hoc meeting.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts. The default value for an ad-hoc meeting is
    #: `false` and the user's input value will be ignored.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it. The default value for an ad-hoc
    #: meeting is null and the user's input value will be ignored.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: user's preferred site. The default value for an ad-hoc meeting is `false` and the user's input value will be
    #: ignored.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. The default value for an ad-hoc meeting is `true` and the user's input value will be ignored.
    allow_authenticated_devices: Optional[bool] = None
    #: Invitees for meeting. The maximum size of invitees is 1000. If `roomId` is specified and `invitees` is missing,
    #: all the members in the space are invited implicitly. If both `roomId` and `invitees` are specified, only those
    #: in the `invitees` list are invited. `coHost` for each invitee is `true` by default if `roomId` is specified
    #: when creating a meeting, and anyone in the invitee list that is not qualified to be a cohost will be invited as
    #: a non-cohost invitee. The user's input value will be ignored for an ad-hoc meeting and the the members of the
    #: room specified by `roomId` except "me" will be used by default.
    invitees: Optional[list[InviteeObjectForCreateMeeting]] = None
    #: Whether or not to send emails to host and invitees. It is an optional field and default value is true. The
    #: default value for an ad-hoc meeting is `false` and the user's input value will be ignored.
    #: example: True
    send_email: Optional[bool] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin-level scopes. When used, the admin may specify the email of a user in a site they manage to be
    #: the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: URL of the Webex site which the meeting is created on. If not specified, the meeting is created on user's
    #: preferred site. All available Webex sites and preferred site of the user can be retrieved by `Get Site List`
    #: API.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information to join
    #: the meeting. Meeting invitees will receive an email with a registration link for the registration. When the
    #: registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a recurrence field or no password, or the Join Before
    #: Host option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details. This
    #: parameter is ignored for an ad-hoc meeting.
    registration: Optional[CreateMeetingObjectRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc. The integration application queries meetings by a key in its own domain. The
    #: maximum size of `integrationTags` is 3 and each item of `integrationTags` can be a maximum of 64 characters
    #: long. This parameter is ignored for an ad-hoc meeting.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for a meeting.
    simultaneous_interpretation: Optional[CreateMeetingObjectSimultaneousInterpretation] = None
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool] = None
    #: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They allow a subset of
    #: participants to collaborate and share ideas over audio and video. Use breakout sessions for workshops,
    #: classrooms, or for when you need a moment to talk privately with a few participants outside of the main
    #: session. Please note that maximum number of breakout sessions in a meeting or webinar is 100. In webinars, if
    #: hosts preassign attendees to breakout sessions, the role of `attendee` will be changed to `panelist`. Breakout
    #: session is not supported for a meeting with simultaneous interpretation.
    breakout_sessions: Optional[list[BreakoutSessionObject]] = None
    #: Tracking codes information. All available tracking codes and their options for the specified site can be
    #: retrieved by `List Meeting Tracking Codes
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is missing from the `trackingCodes`
    #: array and there's a default option for this tracking code, the default option is assigned automatically. If the
    #: `inputMode` of a tracking code is `select`, its value must be one of the site-level options or the user-level
    #: value. Tracking code is not supported for a personal room meeting or an ad-hoc space meeting.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar. This option works when the value of `scheduledType`
    #: attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set if someone has already registered
    #: for the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only. This option works when the registration option is disabled and the
    #: value of `scheduledType` attribute is `webinar`. Please note that `restrictToInvitees` cannot be set to `true`
    #: if `requireAttendeeLogin` is `false`.
    restrict_to_invitees: Optional[bool] = None


class TemplateObject(ApiModel):
    #: Unique identifier for meeting template.
    #: example: N2Q3ZWE1ZjQyYjkyMWVhY2UwNTM4NmNhMjRhZDczMGU6VS0yMDA5NzItTUMtZW5fVVM
    id: Optional[str] = None
    #: Meeting template name.
    #: example: Meeting template 1
    name: Optional[str] = None
    #: Meeting template locale.
    #: example: en_US
    locale: Optional[str] = None
    #: Site URL for the meeting template.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Meeting template type.
    #: example: meeting
    template_type: Optional[MeetingUsageReportObjectScheduledType] = None
    #: Whether or not the meeting template is a default template.
    is_default: Optional[bool] = None
    #: Whether or not the meeting template is a standard template.
    is_standard: Optional[bool] = None


class DetailedTemplateObject(ApiModel):
    #: Unique identifier for meeting template.
    #: example: N2Q3ZWE1ZjQyYjkyMWVhY2UwNTM4NmNhMjRhZDczMGU6VS0yMDA5NzItTUMtZW5fVVM
    id: Optional[str] = None
    #: Meeting template name.
    #: example: Meeting template 1
    name: Optional[str] = None
    #: Meeting template locale.
    #: example: en_US
    locale: Optional[str] = None
    #: Site URL for the meeting template.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Meeting template type.
    #: example: meeting
    template_type: Optional[MeetingUsageReportObjectScheduledType] = None
    #: Whether or not the meeting template is a default template.
    is_default: Optional[bool] = None
    #: Whether or not the meeting template is a standard template.
    is_standard: Optional[bool] = None
    #: Meeting object which is used to create a meeting by the meeting template. Please note that the meeting object
    #: should be used to create a meeting immediately after retrieval since the `start` and `end` may be invalid
    #: quickly after generation.
    meeting: Optional[CreateMeetingObject] = None


class Control(ApiModel):
    #: Whether the meeting is locked or not.
    locked: Optional[bool] = None
    #: The value can be true or false, it indicates the meeting recording started or not.
    #: example: True
    recording_started: Optional[bool] = None
    #: The value can be true or false, it indicates the meeting recording paused or not.
    #: example: True
    recording_paused: Optional[bool] = None


class Registration(ApiModel):
    #: Whether or not a registrant's first name is required for meeting registration. This option must always be
    #: `true`.
    #: example: True
    require_first_name: Optional[bool] = None
    #: Whether or not a registrant's last name is required for meeting registration. This option must always be `true`.
    #: example: True
    require_last_name: Optional[bool] = None
    #: Whether or not a registrant's email is required for meeting registration. This option must always be `true`.
    #: example: True
    require_email: Optional[bool] = None
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool] = None
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool] = None
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool] = None
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool] = None
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool] = None
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool] = None
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool] = None
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool] = None
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool] = None
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool] = None
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForGetMeeting]] = None
    #: The approval rules for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]] = None


class AnswerForCustomizedQuestion(ApiModel):
    #: Unique identifier for the option.
    #: example: 1.0
    option_id: Optional[int] = None
    #: The content of the answer or the option for this question.
    #: example: green
    answer: Optional[str] = None


class CustomizedRegistrant(ApiModel):
    #: Unique identifier for the customized questions retrieved from the registration form.
    #: example: 330087.0
    question_id: Optional[int] = None
    #: The answers for customized questions. If the question type is checkbox, more than one answer can be set.
    answers: Optional[list[AnswerForCustomizedQuestion]] = None


class RegistrantFormObject(ApiModel):
    #: The registrant's first name.
    #: example: Bob
    first_name: Optional[str] = None
    #: The registrant's last name. (Required)
    #: example: Lee
    last_name: Optional[str] = None
    #: The registrant's email.
    #: example: bob@example.com
    email: Optional[str] = None
    #: If `true` send email to the registrant. Default: `true`.
    #: example: True
    send_email: Optional[bool] = None
    #: The registrant's job title. Registration options define whether or not this is required.
    #: example: manager
    job_title: Optional[str] = None
    #: The registrant's company. Registration options define whether or not this is required.
    #: example: Cisco Systems, Inc.
    company_name: Optional[str] = None
    #: The registrant's first address line. Registration options define whether or not this is required.
    #: example: address1 string
    address1: Optional[str] = None
    #: The registrant's second address line. Registration options define whether or not this is required.
    #: example: address2 string
    address2: Optional[str] = None
    #: The registrant's city name. Registration options define whether or not this is required.
    #: example: New York
    city: Optional[str] = None
    #: The registrant's state. Registration options define whether or not this is required.
    #: example: New York
    state: Optional[str] = None
    #: The registrant's postal code. Registration options define whether or not this is required.
    #: example: 123456.0
    zip_code: Optional[int] = None
    #: The America is not a country or a specific region. Registration options define whether or not this is required.
    #: example: United States
    country_region: Optional[str] = None
    #: The registrant's work phone number. Registration options define whether or not this is required.
    #: example: +1 123456
    work_phone: Optional[str] = None
    #: The registrant's FAX number. Registration options define whether or not this is required.
    #: example: 123456
    fax: Optional[str] = None
    #: The registrant's answers for customized questions. Registration options define whether or not this is required.
    customized_questions: Optional[list[CustomizedRegistrant]] = None


class RegistrantStatus(str, Enum):
    #: Registrant has been approved.
    approved = 'approved'
    #: Registrant is in a pending list waiting for host or cohost approval.
    pending = 'pending'
    #: Registrant has been rejected by the host or cohost.
    rejected = 'rejected'


class Registrant(ApiModel):
    #: New registrant's ID.
    #: example: 123456
    registrant_id: Optional[str] = None
    #: New registrant's status.
    #: example: pending
    status: Optional[RegistrantStatus] = None
    #: Registrant's first name.
    #: example: bob
    first_name: Optional[str] = None
    #: Registrant's last name.
    #: example: Lee
    last_name: Optional[str] = None
    #: Registrant's email.
    #: example: bob@example.com
    email: Optional[str] = None
    #: Registrant's job title.
    #: example: manager
    job_title: Optional[str] = None
    #: Registrant's company.
    #: example: cisco
    company_name: Optional[str] = None
    #: Registrant's first address line.
    #: example: address1 string
    address1: Optional[str] = None
    #: Registrant's second address line.
    #: example: address2 string
    address2: Optional[str] = None
    #: Registrant's city name.
    #: example: New York
    city: Optional[str] = None
    #: Registrant's state.
    #: example: New York
    state: Optional[str] = None
    #: Registrant's postal code.
    #: example: 123456.0
    zip_code: Optional[int] = None
    #: Registrant's country or region.
    #: example: United States
    country_region: Optional[str] = None
    #: Registrant's work phone number.
    #: example: +1 123456
    work_phone: Optional[str] = None
    #: Registrant's FAX number.
    #: example: 123456
    fax: Optional[str] = None
    #: Registrant's registration time.
    #: example: 2021-09-07T09:29:13+08:00
    registration_time: Optional[datetime] = None
    #: Registrant's answers for customized questions, Registration options define whether or not this is required.
    customized_questions: Optional[list[CustomizedRegistrant]] = None
    #: Registrant's source id.The `sourceId` is from `Create Invitation Sources
    #: <https://developer.webex.com/docs/api/v1/meetings/create-invitation-sources>`_ API.
    #: example: cisco
    source_id: Optional[str] = None


class RegistrantCreateResponse(ApiModel):
    #: New registrant's ID.
    #: example: 123456
    id: Optional[str] = None
    #: New registrant's status.
    #: example: pending
    status: Optional[RegistrantStatus] = None
    #: Registrant's first name.
    #: example: bob
    first_name: Optional[str] = None
    #: Registrant's last name.
    #: example: Lee
    last_name: Optional[str] = None
    #: Registrant's email.
    #: example: bob@example.com
    email: Optional[str] = None
    #: Registrant's job title.
    #: example: manager
    job_title: Optional[str] = None
    #: Registrant's company.
    #: example: cisco
    company_name: Optional[str] = None
    #: Registrant's first address line.
    #: example: address1 string
    address1: Optional[str] = None
    #: Registrant's second address line.
    #: example: address2 string
    address2: Optional[str] = None
    #: Registrant's city name.
    #: example: New York
    city: Optional[str] = None
    #: Registrant's state.
    #: example: New York
    state: Optional[str] = None
    #: Registrant's postal code.
    #: example: 123456.0
    zip_code: Optional[int] = None
    #: Registrant's country or region.
    #: example: United States
    country_region: Optional[str] = None
    #: Registrant's work phone number.
    #: example: +1 123456
    work_phone: Optional[str] = None
    #: Registrant's FAX number.
    #: example: 123456
    fax: Optional[str] = None
    #: Registrant's registration time.
    #: example: 2021-09-07T09:29:13+08:00
    registration_time: Optional[datetime] = None
    #: Registrant's answers for customized questions, Registration options define whether or not this is required.
    customized_questions: Optional[list[CustomizedRegistrant]] = None


class QueryRegistrantsOrderType(str, Enum):
    desc = 'DESC'
    asc = 'ASC'


class QueryRegistrantsOrderBy(str, Enum):
    registration_time = 'registrationTime'
    #: Registrant's first name.
    first_name = 'firstName'
    #: Registrant's last name.
    last_name = 'lastName'
    #: Registrant's status.
    status = 'status'
    #: registrant's email.
    email = 'email'


class QueryRegistrants(ApiModel):
    #: Registrant's status.
    #: example: pending
    status: Optional[RegistrantStatus] = None
    #: Sort order for the registrants.
    #: example: DESC
    order_type: Optional[QueryRegistrantsOrderType] = None
    #: Registrant ordering field. Ordered by `registrationTime` by default.
    #: example: registrationTime
    order_by: Optional[QueryRegistrantsOrderBy] = None
    #: List of registrant email addresses.
    #: example: ['bob@example.com']
    emails: Optional[list[str]] = None


class MeetingSessionTypeObjectType(str, Enum):
    #: Meeting session type for a meeting.
    meeting = 'meeting'
    #: Meeting session type for a webinar.
    webinar = 'webinar'
    #: Meeting session type for a private meeting.
    private_meeting = 'privateMeeting'


class MeetingSessionTypeObject(ApiModel):
    #: Unique identifier for the meeting session type.
    #: example: 628
    id: Optional[datetime] = None
    #: Name of the meeting session type.
    #: example: Webex Meetings EC 2.0 meeting
    name: Optional[str] = None
    #: Meeting session type.
    #: example: meeting
    type: Optional[MeetingSessionTypeObjectType] = None
    #: The maximum number of attendees for the meeting session type.
    #: example: 1000.0
    attendees_capacity: Optional[int] = None


class UpdateInterpreterObject(ApiModel):
    #: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous interpretation language
    #: channel. The language codes conform with `ISO 639-1
    #: <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
    #: example: en
    language_code1: Optional[str] = None
    #: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous interpretation language
    #: channel. The language codes conform with `ISO 639-1
    #: <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
    #: example: de
    language_code2: Optional[str] = None
    #: Email address of meeting interpreter. If not specified, it'll be an empty interpreter for the bi-directional
    #: language channel. Please note that multiple interpreters with different emails can be assigned to the same
    #: bi-directional language channel, but the same email cannot be assigned to more than one interpreter.
    #: example: marcus.tuchel@example.com
    email: Optional[str] = None
    #: Display name of meeting interpreter. If the interpreter is already an invitee of the meeting and it has a
    #: different display name, that invitee's display name will be overwritten by this attribute.
    #: example: Tuchel
    display_name: Optional[str] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin on-behalf-of scopes. When used, the admin may specify the email of a user in a site they manage
    #: to be the meeting host.
    #: example: brenda.song@example.com
    host_email: Optional[str] = None
    #: If `true`, send email to the interpreter.
    #: example: True
    send_email: Optional[bool] = None


class UpdateMeetingBreakoutSessionsObject(ApiModel):
    #: Email address for the meeting host. This parameter is only used if the user or application calling the API has
    #: the admin-level scopes. If set, the admin may specify the email of a user in a site they manage and the API
    #: will return details for a meeting that is hosted by that user.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Whether or not to send emails to host and invitees. It is an optional field and default value is true.
    #: example: True
    send_email: Optional[bool] = None
    #: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They allow a subset of
    #: participants to collaborate and share ideas over audio and video. Use breakout sessions for workshops,
    #: classrooms, or for when you need a moment to talk privately with a few participants outside of the main
    #: session. Please note that maximum number of breakout sessions in a meeting or webinar is 100. In webinars, if
    #: hosts preassign attendees to breakout sessions, the role of `attendee` will be changed to `panelist`. Breakout
    #: session is not supported for a meeting with simultaneous interpretation.
    items: Optional[list[BreakoutSessionObject]] = None


class GetBreakoutSessionObject(ApiModel):
    #: Unique identifier for breakout session.
    #: example: 18d2e565770c4eee918784ee333510ec
    id: Optional[str] = None
    #: Name for breakout session.
    #: example: Breakout Session Name
    name: Optional[str] = None
    #: Invitees for a breakout session. Only applies to meeting series and scheduled meetings. Doesn't apply to ongoing
    #: or ended meeting instances.
    invitees: Optional[list[str]] = None


class GetBreakoutSessionsObject(ApiModel):
    #: Breakout Sessions information for meeting.
    items: Optional[list[GetBreakoutSessionObject]] = None


class JoinMeetingObject(ApiModel):
    #: Unique identifier for the meeting. This parameter applies to meeting series and scheduled meetings. It doesn't
    #: apply to ended or in-progress meeting instances. Please note that currently meeting ID of a scheduled
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is also supported for this API.
    #: example: 98d8c2212c9d62b162b9565932735e58_I_231409844992607809
    meeting_id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1e
    web_link: Optional[str] = None
    #: Whether or not to redirect to `joinLink`. It is an optional field and default value is true.
    join_directly: Optional[bool] = None
    #: Email address of meeting participant. If `email` is specified, the link is generated for the user of `email`;
    #: otherwise, it's generated for the user calling the API. `email` is required for a `guest issuer
    #: <https://developer.webex.com/docs/guest-issuer>`_.
    #: example: brenda.song@example.com
    email: Optional[str] = None
    #: Display name of meeting participant. If `email` is specified and `displayName` is empty, the display name is the
    #: same as `email`. The maximum length of `displayName` is 128 characters. `displayName` is required for a
    #: `guest issuer
    #: <https://developer.webex.com/docs/guest-issuer>`_.
    #: example: Brenda Song
    display_name: Optional[str] = None
    #: It's required when the meeting is protected by a password and the current user is not privileged to view it if
    #: they are not a host, cohost or invitee of the meeting.
    #: example: BgJep@43
    password: Optional[str] = None
    #: Expiration duration of `joinLink` in minutes. Must be between 1 and 60.
    #: example: 5.0
    expiration_minutes: Optional[int] = None


class JoinMeetingLinkObject(ApiModel):
    #: The link is used to start a meeting as the meeting host. Only the meeting host or cohost can generate the
    #: `startLink`.
    #: example: https://example.dmz.webex.com/wbxmjs/joinservice/sites/example/meeting/download/b9dd6cac53564877b65589cc17d4233e?siteurl=example&integrationJoinToken=QUhTSwAAAIVboyqJZyO/aObaDYnIe0wkyteQTUFUGkboab2OL/M30apxnba6ZI4G37P0uvRMihtrYnt9wk+Wgj4GMTjeKJ0YuiEsi1PYJ9AfQcft60Mt/N6q6jEC+aldJ5PfmR+ic9dsgRn6Pgz9AmyjMSCr/3Zx7VOJXKPzWHZIc4q0EqOqDyUnWu5aEtJUldB/kZYKtUrbPUj4KUQKbc60e0tGt/St3uuBBVCuf7P45GmmyVk+b3xqlol2aUokcKlYtIig8It/NDIY5sCvCg+GHxtoEWHRGVj3+0lhNXiQfNe1vTRH7w==
    start_link: Optional[str] = None
    #: The link is used to join the meeting.
    #: example: https://example.webex.com/wbxmjs/joinservice/sites/example/meeting/download/cdedf9ae847b4f9993f87e62a8889dad?siteurl=example&integrationJoinToken=QUhTSwAAAIVAFMmwcApsg+NPn9DlUdF1yv2eVVq2HaXr2vu0/4Ttl9P38kCzoA3A5CKTcDnLr79X4FSvZnZUmUPlv/4F/4/iverF7eOgZaYM5rgUayI3L9ye6lNyYGNb7ZYEAL6oo4xFUDRo8oE3+H/iBeu+nzQnkKcmnTQQPjzZVJQcZVM9tQ==&principal=QUhTSwAAAIXf3TeZvJmVBoXnIhYAIpNdFJ5pfxSftfCOhmwAlckVkd1ZuyfEMosdWeWGHDsThiN+5I55up8e5By/SIu5dUkL9QPu6qVPVhH24xIxkBHfhasau2XB0VZgyIG64tCkEcwf4s0/gJO3N/2RhWkmB669
    join_link: Optional[str] = None
    #: Expiration time of `joinLink`.
    #: example: 2022-05-30T09:44:08Z
    expiration: Optional[datetime] = None


class QuestionObjectType(str, Enum):
    #: Text input.
    text = 'text'
    #: Rating.
    rating = 'rating'
    #: Check box which requires `options`.
    checkbox = 'checkbox'
    #: Drop down list box which requires `options`.
    single_dropdown = 'singleDropdown'
    #: Single radio button which requires `options`.
    single_radio = 'singleRadio'


class QuestionObject(ApiModel):
    #: Unique identifier for the question.
    #: example: 3388057.0
    id: Optional[int] = None
    #: Details for the question.
    #: example: Do you like cisco?
    question: Optional[str] = None
    #: Type for the question.
    #: example: text
    type: Optional[QuestionObjectType] = None
    #: The lowest score of the rating question. This attribute will be ingnored, if the value of `type` attribute is
    #: not `rating`.
    #: example: 1.0
    from_score: Optional[int] = None
    #: The lowest score label of the rating question. This attribute will be ingnored, if the value of `type` attribute
    #: is not `rating`.
    #: example: disagree
    from_label: Optional[str] = None
    #: The highest score of the rating question. This attribute will be ingnored, if the value of `type` attribute is
    #: not `rating`.
    #: example: 5.0
    to_score: Optional[int] = None
    #: The highest score label of the rating question. This attribute will be ingnored, if the value of `type`
    #: attribute is not `rating`.
    #: example: agree
    to_label: Optional[str] = None
    #: Options for the question. This attribute will be ingnored, if the value of `type` attribute is `text` or
    #: `rating`.
    options: Optional[list[QuestionOptionObject]] = None


class SurveyObject(ApiModel):
    #: Unique identifier for the survey.
    #: example: 18d2e565770c4eee918784ee333510ec
    id: Optional[str] = None
    #: Name for the survey.
    #: example: Survey name
    survey_name: Optional[str] = None
    #: Unique identifier for the meeting.
    #: example: 560d7b784f5143e3be2fc3064a5c4999
    meeting_id: Optional[str] = None
    #: Description for the survey.
    #: example: Survey name
    description: Optional[str] = None
    #: Whether the survey allows attendees to submit anonymously.
    #: example: True
    allow_anonymous_submit: Optional[bool] = None
    #: Questions for the survey.
    questions: Optional[list[QuestionObject]] = None


class QuestionWithAnswersObject(ApiModel):
    #: Unique identifier for the question.
    #: example: 3388057.0
    id: Optional[int] = None
    #: Details for the question.
    #: example: Do you like cisco?
    question: Optional[str] = None
    #: Type for the question.
    #: example: text
    type: Optional[QuestionObjectType] = None
    #: The user's answers for the question.
    answers: Optional[list[AnswerForCustomizedQuestion]] = None


class SurveyResultObject(ApiModel):
    #: Unique identifier for the survey result.
    #: example: 18d2e565770c4eee918784ee333510ec
    id: Optional[str] = None
    #: Name for the survey.
    #: example: Survey name
    survey_name: Optional[str] = None
    #: Unique identifier for the meeting.
    #: example: 560d7b784f5143e3be2fc3064a5c4999
    meeting_id: Optional[str] = None
    #: Email address of the user who submits the survey.
    #: example: bob@example.com
    email: Optional[str] = None
    #: Name of the user who submits the survey.
    #: example: Bob
    display_name: Optional[str] = None
    #: The time when the user submits the survey.
    #: example: 2022-07-06T14:13:06+08:00
    create_time: Optional[datetime] = None
    #: User's answers for the questions
    questions: Optional[list[QuestionWithAnswersObject]] = None


class RegistrationForUpdate(ApiModel):
    #: - Email address for the meeting host. This parameter is only used if the user or application calling the API has
    #: the admin-level scopes. If set, the admin may specify the email of a user in a site they manage and the API
    #: will return an update for a meeting that is hosted by that user.
    #: example: 'john.andersen@example.com'
    host_email: Optional[str] = None
    #: Whether or not a registrant's first name is required for meeting registration. This option must always be
    #: `true`.
    #: example: True
    require_first_name: Optional[bool] = None
    #: Whether or not a registrant's last name is required for meeting registration. This option must always be `true`.
    #: example: True
    require_last_name: Optional[bool] = None
    #: Whether or not a registrant's email is required for meeting registration. This option must always be `true`.
    #: example: True
    require_email: Optional[bool] = None
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool] = None
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool] = None
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool] = None
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool] = None
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool] = None
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool] = None
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool] = None
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool] = None
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool] = None
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool] = None
    #: Maximum number of meeting registrations. This only applies to meetings. The maximum number of participants for
    #: meetings and webinars, with the limit based on the user capacity and controlled by a toggle at the site level.
    #: The default maximum number of participants for webinars is 10000, but the actual maximum number of participants
    #: is limited by the user capacity.
    #: example: 1000.0
    max_register_num: Optional[int] = None
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForCreateMeeting]] = None
    #: The approval rule for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]] = None


class InvitationSourceCreateObject(ApiModel):
    #: Source ID for the invitation.
    #: example: cisco
    source_id: Optional[str] = None
    #: Email for invitation source.
    #: example: john001@example.com
    source_email: Optional[str] = None


class InvitationSourceObject(ApiModel):
    #: Unique identifier for invitation source.
    #: example: 1
    id: Optional[datetime] = None
    #: Source ID for invitation.
    #: example: cisco
    source_id: Optional[str] = None
    #: Email for invitation source.
    #: example: john001@example.com
    source_email: Optional[str] = None
    #: The link bound to `sourceId` can directly join the meeting.If the meeting requires registration,`joinLink` is
    #: not returned.
    #: example: https://sqdemo56.dmz.webex.com/sqdemo56/j.php?MTID=m6d75f1c875b3e3c5d18c7598036bdd8b
    join_link: Optional[str] = None
    #: The link bound to `sourceId` can directly register the meeting.If the meeting requires
    #: registration,`registerLink` is returned.
    #: example: https://sqdemo56.dmz.webex.com/sqdemo56/j.php?RGID=rb05b31307b5b820e16594da9d1cfc588
    register_link: Optional[str] = None


class MeetingTrackingCodesObject(ApiModel):
    #: Unique identifier for the tracking code.
    #: example: 1
    id: Optional[datetime] = None
    #: Name for the tracking code.
    #: example: Department
    name: Optional[str] = None
    #: Site URL for the tracking code.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Tracking code option list. The options here differ from those in the `site-level tracking codes
    #: <https://developer.webex.com/docs/api/v1/tracking-codes/get-a-tracking-code>`_ and the
    #: `user-level tracking codes
    #: <https://developer.webex.com/docs/api/v1/tracking-codes/get-user-tracking-codes>`_. It is the result of a selective combination of the two. If there's user-level value
    #: for a tracking code, the user-level value becomes the default option for the tracking code, and the site-level
    #: default value becomes non-default.
    options: Optional[list[OptionsForTrackingCodeObject]] = None
    #: The input mode in which the tracking code value can be assigned.
    input_mode: Optional[GetTrackingCodeObjectInputMode] = None
    #: Service for schedule or sign up pages
    service: Optional[ScheduleStartCodeObjectService] = None
    #: Type for meeting scheduler or meeting start pages.
    type: Optional[ScheduleStartCodeObjectType] = None


class ReassignMeetingRequestObject(ApiModel):
    #: Email address of the new meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: List of meeting series IDs to be reassigned the new host. The size is between 1 and 100. All the meetings of
    #: `meetingIds` should belong to the same site, which is the `siteUrl` in the request header, if specified, or the
    #: admin user's preferred site, if not specified. All available Webex sites and the preferred sites of a user can
    #: be retrieved by `Get Site List
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
    meeting_ids: Optional[list[str]] = None


class ReassignMeetingErrorDescriptionObject(ApiModel):
    #: Detailed description for the host reassignment of `meetingId` if it fails.
    #: example: The meeting is not found.
    description: Optional[str] = None


class ReassignMeetingResponseObject(ApiModel):
    #: Unique identifier for the meeting to be reassigned host.
    #: example: 560d7b784f5143e3be2fc3064a5c5888
    meeting_id: Optional[str] = None
    #: HTTP status code for the meeting reassignment result.
    #: example: 404
    http_status: Optional[datetime] = None
    #: General message for the host reassignment of `meetingId` if it fails.
    #: example: The requested resource could not be found.
    message: Optional[str] = None
    #: Detailed descriptions for the host reassignment of `meetingId` if it fails.
    errors: Optional[list[ReassignMeetingErrorDescriptionObject]] = None


class ListMeetingsResponse(ApiModel):
    #: Meetings array.
    items: Optional[list[MeetingSeriesObjectForListMeeting]] = None


class ListMeetingsOfAMeetingSeriesMeetingType(str, Enum):
    scheduled_meeting = 'scheduledMeeting'
    meeting = 'meeting'


class ListMeetingsOfAMeetingSeriesState(str, Enum):
    scheduled = 'scheduled'
    ready = 'ready'
    lobby = 'lobby'
    in_progress = 'inProgress'
    ended = 'ended'
    missed = 'missed'


class ListMeetingsOfAMeetingSeriesResponse(ApiModel):
    #: Meetings array.
    items: Optional[list[ScheduledMeetingObject]] = None


class ListMeetingTemplatesResponse(ApiModel):
    #: Meeting templates array.
    items: Optional[list[TemplateObject]] = None


class ListMeetingSessionTypesResponse(ApiModel):
    #: Meeting session type array
    items: Optional[list[MeetingSessionTypeObject]] = None


class BatchRegisterMeetingRegistrantsResponse(ApiModel):
    items: Optional[list[RegistrantCreateResponse]] = None


class ListMeetingRegistrantsResponse(ApiModel):
    #: Registrants array.
    items: Optional[list[Registrant]] = None


class BatchUpdateMeetingRegistrantsStatusStatusOpType(str, Enum):
    approve = 'approve'
    reject = 'reject'
    cancel = 'cancel'
    bulk_delete = 'bulkDelete'


class ListMeetingInterpretersResponse(ApiModel):
    #: Array of meeting interpreters.
    items: Optional[list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]] = None


class ListMeetingSurveyResultsResponse(ApiModel):
    #: SurveyResult array
    items: Optional[list[SurveyResultObject]] = None


class CreateInvitationSourcesResponse(ApiModel):
    #: Invitation source array.
    items: Optional[list[InvitationSourceObject]] = None


class ReassignMeetingsToANewHostResponse(ApiModel):
    #: Array of meeting reassignment results.
    items: Optional[list[ReassignMeetingResponseObject]] = None


class MeetingSeriesObject1(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: meetingSeries
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: active
    state: Optional[MeetingSeriesObjectState] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ of `start` and `end`, conforming with the `IANA time zone database
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meeting is a meeting series, `start` is the date and
    #: time the first meeting of the series starts. If the meeting is a meeting series and the `current` filter is
    #: true, `start` is the date and time the upcoming or ongoing meeting of the series starts. If the meeting is a
    #: scheduled meeting from a meeting series, `start` is the date and time when that scheduled meeting starts. If
    #: the meeting is a meeting instance that has happened or is happening, `start` is the date and time that the
    #: instance actually starts. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in ISO 8601 compliant format. If the meeting is a meeting series, `end` is the date and
    #: time the first meeting of the series ends. If the meeting is a meeting series and the current filter is true,
    #: `end` is the date and time the upcoming or ongoing meeting of the series ends. If the meeting is a scheduled
    #: meeting from a meeting series, `end` is the date and time when that scheduled meeting ends. If the meeting is a
    #: meeting instance that has happened, `end` is the date and time that instance actually ends. If a meeting
    #: instance is in progress, `end` is not available. Can be modified for a meeting series or a scheduled meeting
    #: using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Can be modified for a meeting series using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only
    #: the first day or date specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12"
    #: is not supported and it will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10". For a
    #: non-recurring meeting which has no `recurrence`, its `meetingType` is also `meetingSeries` which is a meeting
    #: series with only one occurrence in Webex meeting modeling.
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=10
    recurrence: Optional[str] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join a webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingSeriesObjectTelephony] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information in order
    #: to join the meeting. Meeting invitees will receive an email with a registration link for the registration. When
    #: the registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a `recurrence` field or no `password` or when the feature
    #: toggle `DecoupleJBHWithRegistration` is disabled the `Join Before Host` option is enabled for the meeting, See
    #: Register for a Meeting in Cisco Webex Meetings for details.
    registration: Optional[MeetingSeriesObjectRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for a meeting.
    simultaneous_interpretation: Optional[MeetingSeriesObjectSimultaneousInterpretation] = None
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool] = None
    #: `HATEOAS
    #: <https://en.wikipedia.org/wiki/HATEOAS>`_ Breakout Sessions information for meeting.
    links: Optional[list[Link]] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Whether or not audio watermark is enabled.
    enabled_audio_watermark: Optional[bool] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class MeetingSeriesObjectWithAdhoc1(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: meetingSeries
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: active
    state: Optional[MeetingSeriesObjectState] = None
    #: If `true`, the meeting is ad-hoc.
    adhoc: Optional[bool] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ of `start` and `end`, conforming with the `IANA time zone database
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of this meeting is `meetingSeries`, and
    #: `current` is not specified or is `false`, `start` is the scheduled start time of the first occurrence of this
    #: series. If the meetingType of this meeting is `meetingSeries`, and `current` is not specified or is `false`,
    #: `start` is the scheduled start time of the first occurrence of this series. If the meetingType of this meeting
    #: is `meetingSeries`, and `current` is `true`, `start` is the scheduled start time of the ongoing or upcoming
    #: occurrence in this series. If the meetingType of this meeting is `scheduledMeeting`, `start` is the scheduled
    #: start time of this occurrence. If the meetingType of this meeting is `meeting`, `start` is the actual start
    #: time of this meeting instance. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meeting is a meeting series, `end` is the date and
    #: time the first meeting of the series ends. If the meetingType of this meeting is `meetingSeries`, and `current`
    #: is not specified or is `false`, `end` is the scheduled end time of the first occurrence of this series. If the
    #: meetingType of this meeting is `meetingSeries`, and `current` is `true`, `end` is the scheduled end time of the
    #: ongoing or upcoming occurrence in this series. If the meetingType of this meeting is `scheduledMeeting`, `end`
    #: is the scheduled end time of this occurrence. If the meetingType of this meeting is `meeting`, `end` is the
    #: actual end time of this meeting instance. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Can be modified for a meeting series using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only
    #: the first day or date specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12"
    #: is not supported and it will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=10
    recurrence: Optional[str] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join a webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not this meeting instance has chat.
    has_chat: Optional[bool] = None
    #: Whether or not this meeting instance has a recording.
    has_recording: Optional[bool] = None
    #: Whether or not this meeting instance has a transcription.
    has_transcription: Optional[bool] = None
    #: Whether or not this meeting instance has closed captions.
    has_closed_caption: Optional[bool] = None
    #: Whether or not this meeting instance has polls.
    has_polls: Optional[bool] = None
    #: Whether or not this meeting instance has Q&A.
    has_qa: Optional[bool] = Field(alias='hasQA', default=None)
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingPreferenceObjectPersonalMeetingRoomTelephony] = None
    #: Meeting options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information in order
    #: to join the meeting. Meeting invitees will receive an email with a registration link for the registration. When
    #: the registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a `recurrence` field or no password, or the `Join Before
    #: Host` option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details.
    registration: Optional[MeetingSeriesObjectWithAdhocRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for the meeting.
    simultaneous_interpretation: Optional[MeetingSeriesObjectSimultaneousInterpretation] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Whether or not audio watermark is enabled.
    enabled_audio_watermark: Optional[bool] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class MeetingSeriesObjectForListMeeting1(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: meetingSeries
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: active
    state: Optional[MeetingSeriesObjectState] = None
    #: Time zone of `start` and `end`, conforming with the `IANA time zone database
    #: <https://www.iana.org/time-zones>`_.
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `start`
    #: is the scheduled start time of the first occurrence of this series. If the meeting is a meeting series and the
    #: `current` filter is true, `start` is the date and time the upcoming or ongoing meeting of the series starts. If
    #: the meetingType of a meeting is `scheduledMeeting`, `start` is the scheduled start time of this occurrence. If
    #: the meetingType of a meeting is `meeting`, `start` is the actual start time of the meeting instance. Can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `end`
    #: is the scheduled end time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, `end` is the date and time the upcoming or ongoing meeting of the series ends. If the
    #: meetingType of a meeting is `scheduledMeeting`, `end` is the scheduled end time of this occurrence. If the
    #: meetingType of a meeting is `meeting`, `end` is the actual end time of the meeting instance. If a meeting
    #: instance is in progress, `end` is not available. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Can be modified for a meeting series using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_
    #: API. Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only the first day or
    #: date specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported
    #: and it will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=10
    recurrence: Optional[str] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the  `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join a webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not this meeting instance has chat.
    has_chat: Optional[bool] = None
    #: Whether or not this meeting instance has a recording.
    has_recording: Optional[bool] = None
    #: Whether or not this meeting instance has a transcription.
    has_transcription: Optional[bool] = None
    #: Whether or not this meeting instance has closed captions.
    has_closed_caption: Optional[bool] = None
    #: Whether or not this meeting instance has polls.
    has_polls: Optional[bool] = None
    #: Whether or not this meeting instance has Q&A.
    has_qa: Optional[bool] = Field(alias='hasQA', default=None)
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingPreferenceObjectPersonalMeetingRoomTelephony] = None
    #: Meeting options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information in order
    #: to join the meeting. Meeting invitees will receive an email with a registration link for the registration. When
    #: the registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a `recurrence` field or no password, or the `Join Before
    #: Host` option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details.
    registration: Optional[MeetingSeriesObjectWithAdhocRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for the meeting.
    simultaneous_interpretation: Optional[MeetingSeriesObjectSimultaneousInterpretation] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Whether or not audio watermark is enabled.
    enabled_audio_watermark: Optional[bool] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class ScheduledMeetingObject1(ApiModel):
    #: Unique identifier for meeting. For a meeting series, the `id` is used to identify the entire series. For
    #: scheduled meetings from a series, the `id` is used to identify that scheduled meeting. For a meeting instance
    #: that is in progress or has concluded, the `id` is used to identify that instance.
    #: example: dfb45ece33264639a7bc3dd9535d53f7_20200516T230000Z
    id: Optional[str] = None
    #: Unique identifier for meeting series. It only apples to scheduled meeting and meeting instance. If it's a
    #: scheduled meeting from a series or a meeting instance that is happening or has happened, the `meetingSeriesId`
    #: is the `id` of the primary series.
    #: example: dfb45ece33264639a7bc3dd9535d53f7
    meeting_series_id: Optional[str] = None
    #: Unique identifier for scheduled meeting which current meeting is associated with. It only apples to meeting
    #: instance which is happening or has happened. It's the `id` of the scheduled meeting this instance is associated
    #: with.
    #: example: dfb45ece33264639a7bc3dd9535d53f7
    scheduled_meeting_id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Meeting title. Can be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long. This attribute can be modified for a
    #: meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Applies to meeting series, scheduled meetings, and in-progress meeting instances, but not to
    #: meeting instances which have ended. Can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: BgJep@43
    password: Optional[str] = None
    #: 8-digit numeric password used to join a meeting from audio and video devices. This attribute applies to meeting
    #: series, scheduled meetings, and in-progress meeting instances, but not to meeting instances which have ended.
    #: example: 12345678
    phone_and_video_system_password: Optional[str] = None
    #: Meeting type.
    #: example: scheduledMeeting
    meeting_type: Optional[MeetingSeriesObjectMeetingType] = None
    #: Meeting state.
    #: example: scheduled
    state: Optional[MeetingSeriesObjectState] = None
    #: This state only applies to scheduled meeting. Flag identifying whether or not the scheduled meeting has been
    #: modified.
    is_modified: Optional[bool] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ of `start` and `end`, conforming with the `IANA time zone database
    #: example: UTC
    timezone: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `start`
    #: is the scheduled start time of the first occurrence of this series. If the meeting is a meeting series and the
    #: `current` filter is true, `start` is the date and time the upcoming or ongoing meeting of the series starts. If
    #: the meetingType of a meeting is `scheduledMeeting`, `start` is the scheduled start time of this occurrence. If
    #: the meetingType of a meeting is `meeting`, `start` is the actual start time of the meeting instance. Can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If the meetingType of a meeting is `meetingSeries`, `end`
    #: is the scheduled end time of the first occurrence of this series. If the meeting is a meeting series and the
    #: current filter is true, `end` is the date and time the upcoming or ongoing meeting of the series ends. If the
    #: meetingType of a meeting is `scheduledMeeting`, `end` is the scheduled end time of this occurrence. If the
    #: meetingType of a meeting is `meeting`, `end` is the actual end time of the meeting instance. If a meeting
    #: instance is in progress, `end` is not available. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Unique identifier for the meeting host.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS83QkFCQkU5OS1CNDNFLTREM0YtOTE0Ny1BMUU5RDQ2QzlDQTA
    host_user_id: Optional[str] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Key for joining the meeting as host.
    #: example: 123456
    host_key: Optional[str] = None
    #: Site URL for the meeting.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1
    web_link: Optional[str] = None
    #: SIP address for callback from a video system.
    #: example: 123456789@site4-example.webex.com
    sip_address: Optional[str] = None
    #: IP address for callback from a video system.
    #: example: 192.168.100.100
    dial_in_ip_address: Optional[str] = None
    #: Room ID of the associated Webex space. Only applies to ad-hoc meetings and space meetings.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Whether or not meeting is recorded automatically. Can be modified for a meeting series or a scheduled meeting
    #: using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by a `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowAnyUserToBeCoHost` attribute can be modified for a meeting series or a
    #: scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The
    #: `enabledJoinBeforeHost` attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect to audio before the host joins the meeting. Only applicable if
    #: the `enabledJoinBeforeHost` attribute is set to `true`. The `enableConnectAudioBeforeHost` attribute can be
    #: modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. The `joinBeforeHostMinutes` attribute can
    #: be modified for a meeting series or a scheduled meeting using the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default is `0` if not specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Specifies whether the meeting is a regular meeting, a webinar, or a meeting scheduled in the user's
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: 8-digit numeric panelist password to join webinar meeting from audio and video devices.
    #: example: 12345678
    phone_and_video_system_panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by the `siteUrl` parameter when creating the meeting. If not specified,
    #: it's a user's preferred site. The `allowFirstUserToBeCoHost` attribute can be modified for a meeting series or
    #: a scheduled meeting uisng the `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. This attribute can be modified for a meeting series or a scheduled meeting using the
    #: `Update a Meeting
    #: <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ API.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not this meeting instance has chat.
    has_chat: Optional[bool] = None
    #: Whether or not this meeting instance has a recording.
    has_recording: Optional[bool] = None
    #: Whether or not this meeting instance has a transcription.
    has_transcription: Optional[bool] = None
    #: Whether or not this meeting instance has closed captions.
    has_closed_caption: Optional[bool] = None
    #: Whether or not this meeting instance has polls.
    has_polls: Optional[bool] = None
    #: Whether or not this meeting instance has Q&A.
    has_qa: Optional[bool] = Field(alias='hasQA', default=None)
    #: Information for callbacks from a meeting to phone or for joining a teleconference using a phone.
    telephony: Optional[MeetingSeriesObjectTelephony] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information to join
    #: the meeting. Meeting invitees will receive an email with a registration link for the registration. When the
    #: registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a recurrence field or no password, or the Join Before
    #: Host option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details.    +
    #: autoAcceptRequest: `false` (boolean,optional) - Whether or not meeting registration requests are accepted
    #: automatically.
    registration: Optional[MeetingSeriesObjectWithAdhocRegistration] = None
    #: External keys created by an integration application in its domain, for example, Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc.
    integration_tags: Optional[list[str]] = None
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool] = None
    #: `HATEOAS
    #: <https://en.wikipedia.org/wiki/HATEOAS>`_ Breakout Sessions information for meeting.
    links: Optional[list[Link]] = None
    #: Whether or not audio watermark is enabled.
    enabled_audio_watermark: Optional[bool] = None
    #: Tracking codes information.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only.
    restrict_to_invitees: Optional[bool] = None


class UpdateMeetingObject1(ApiModel):
    #: Meeting title. The title can be a maximum of 128 characters long.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Must conform to the site's password complexity settings. Read `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
    #: example: BgJep@43
    password: Optional[str] = None
    #: Date and time for the start of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before current date
    #: and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Refer to the `Webex Meetings
    #: <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on updating date and time for
    #: a meeting. Please note that when a meeting is being updated, `start` of the meeting will be accurate to
    #: minutes, not seconds or milliseconds. Therefore, if `start` is within the same minute as the current time,
    #: `start` will be adjusted to the upcoming minute; otherwise, `start` will be adjusted with seconds and
    #: milliseconds stripped off. For instance, if the current time is `2022-03-01T10:32:16.657+08:00`, `start` of
    #: `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00` will be adjusted to `2022-03-01T10:33:00+08:00`,
    #: and `start` of `2022-03-01T11:32:28.076+08:00` or `2022-03-01T11:32:41+08:00` will be adjusted to
    #: `2022-03-01T11:32:00+08:00`.
    #: example: 2020-05-15T20:30:00-08:00
    start: Optional[datetime] = None
    #: Date and time for the end of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before current date and
    #: time or before `start`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Refer to the `Webex Meetings
    #: <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on updating date and time for
    #: a meeting. Please note that when a meeting is being updated, `end` of the meeting will be accurate to minutes,
    #: not seconds or milliseconds. Therefore, `end` will be adjusted with seconds and milliseconds stripped off. For
    #: instance, `end` of `2022-03-01T11:52:28.076+08:00` or `2022-03-01T11:52:41+08:00` will be adjusted to
    #: `2022-03-01T11:52:00+08:00`.
    #: example: 2020-05-15T21:30:00-08:00
    end: Optional[datetime] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the `IANA time zone database
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring meeting series, not to a
    #: meeting series with only one scheduled meeting. Multiple days or dates for monthly or yearly `recurrence` rule
    #: are not supported, only the first day or date specified is taken. For example,
    #: "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported as
    #: "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=20
    recurrence: Optional[str] = None
    #: Whether or not meeting is recorded automatically.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: user's preferred site.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect audio in the meeting before the host joins the meeting. This
    #: attribute is only applicable if the `enabledJoinBeforeHost` attribute is set to true.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. Only
    #: applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid options for a meeting are `0`, `5`,
    #: `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The default is `0` if not
    #: specified.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host.
    #: example: 30.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required while scheduling webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved by
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: Whether or not webcast view is enabled.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: user's preferred site.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt.
    allow_authenticated_devices: Optional[bool] = None
    #: Whether or not to send emails to host and invitees. It is an optional field and default value is true.
    #: example: True
    send_email: Optional[bool] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin-level scopes. When used, the admin may specify the email of a user in a site they manage to be
    #: the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: URL of the Webex site which the meeting is updated on. If not specified, the meeting is created on user's
    #: preferred site. All available Webex sites and preferred site of the user can be retrieved by `Get Site List`
    #: API.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc. The integration application queries meetings by a key in its own domain. The
    #: maximum size of `integrationTags` is 3 and each item of `integrationTags` can be a maximum of 64 characters
    #: long. Please note that an empty or null `integrationTags` will delete all existing integration tags for the
    #: meeting implicitly. Developer can update integration tags for a `meetingSeries` but he cannot update it for a
    #: `scheduledMeeting` or a `meeting` instance.
    integration_tags: Optional[list[str]] = None
    #: Whether or not breakout sessions are enabled. If the value of `enabledBreakoutSessions` is false, users can not
    #: set breakout sessions. If the value of `enabledBreakoutSessions` is true, users can update breakout sessions
    #: using the `Update Breakout Sessions
    #: <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_ API. Updating breakout sessions are not supported by this API.
    enabled_breakout_sessions: Optional[bool] = None
    #: Tracking codes information. All available tracking codes and their options for the specified site can be
    #: retrieved by `List Meeting Tracking Codes
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is missing from the `trackingCodes`
    #: array and there's a default option for this tracking code, the default option is assigned automatically. If the
    #: `inputMode` of a tracking code is `select`, its value must be one of the site-level options or the user-level
    #: value. Tracking code is not supported for a personal room meeting or an ad-hoc space meeting.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Whether or not audio watermark is enabled.
    enabled_audio_watermark: Optional[bool] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar. This option works when the value of `scheduledType`
    #: attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set if someone has already registered
    #: for the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only. This option works when the registration option is disabled and the
    #: value of `scheduledType` attribute is `webinar`. Please note that `restrictToInvitees` cannot be set to `true`
    #: if `requireAttendeeLogin` is `false`.
    restrict_to_invitees: Optional[bool] = None


class CreateMeetingObject1(ApiModel):
    #: Whether or not to create an ad-hoc meeting for the room specified by `roomId`. When `true`, `roomId` is
    #: required.
    adhoc: Optional[bool] = None
    #: Unique identifier for the Webex space which the meeting is to be associated with. It can be retrieved by
    #: `List Rooms
    #: <https://developer.webex.com/docs/api/v1/rooms/list-rooms>`_. `roomId` is required when `adhoc` is `true`. When `roomId` is specified, the parameter `hostEmail`
    #: will be ignored.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNDMzZjk0ZjAtOTZhNi0xMWViLWJhOTctOTU3OTNjZDhiY2Q2
    room_id: Optional[str] = None
    #: Unique identifier for meeting template. Please note that `start` and `end` are optional when `templateId` is
    #: specified. The list of meeting templates that is available for the authenticated user can be retrieved from
    #: `List Meeting Templates
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_. This parameter is ignored for an ad-hoc meeting.
    #: example: N2Q3ZWE1ZjQyYjkyMWVhY2UwNTM4NmNhMjRhZDczMGU6VS0yMDA5NzItTUMtZW5fVVM
    template_id: Optional[str] = None
    #: Meeting title. The title can be a maximum of 128 characters long. The default value for an ad-hoc meeting is the
    #: user's name if not specified.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Meeting agenda. The agenda can be a maximum of 1300 characters long.
    #: example: John's Agenda
    agenda: Optional[str] = None
    #: Meeting password. Must conform to the site's password complexity settings. Read `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
    #: If not specified, a random password conforming to the site's password rules will be generated automatically.
    #: example: BgJep@43
    password: Optional[str] = None
    #: Date and time for the start of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before current date
    #: and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Please note that when a meeting is being scheduled, `start` of the meeting will be accurate to minutes,
    #: not seconds or milliseconds. Therefore, if `start` is within the same minute as the current time, `start` will
    #: be adjusted to the upcoming minute; otherwise, `start` will be adjusted with seconds and milliseconds stripped
    #: off. For instance, if the current time is `2022-03-01T10:32:16.657+08:00`, `start` of
    #: `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00` will be adjusted to `2022-03-01T10:33:00+08:00`,
    #: and `start` of `2022-03-01T11:32:28.076+08:00` or `2022-03-01T11:32:41+08:00` will be adjusted to
    #: `2022-03-01T11:32:00+08:00`. The default value for an ad-hoc meeting is 5 minutes after the current time and
    #: the user's input value will be ignored. An ad-hoc meeting can be started immediately even if the `start` is 5
    #: minutes after the current time.
    #: example: 2020-05-15T20:30:00-08:00
    start: Optional[datetime] = None
    #: Date and time for the end of meeting in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before current date and
    #: time or before `start`. Duration between `start` and `end` cannot be shorter than 10 minutes or longer than 24
    #: hours. Please note that when a meeting is being scheduled, `end` of the meeting will be accurate to minutes,
    #: not seconds or milliseconds. Therefore, `end` will be adjusted with seconds and milliseconds stripped off. For
    #: instance, `end` of `2022-03-01T11:52:28.076+08:00` or `2022-03-01T11:52:41+08:00` will be adjusted to
    #: `2022-03-01T11:52:00+08:00`. The default value for an ad-hoc meeting is 20 minutes after the current time and
    #: the user's input value will be ignored.
    #: example: 2020-05-15T21:30:00-08:00
    end: Optional[datetime] = None
    #: `Time zone
    #: <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the `IANA time zone database
    #: default value for an ad-hoc meeting is `UTC` and the user's input value will be ignored.
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: Meeting series recurrence rule (conforming with `RFC 2445
    #: <https://www.ietf.org/rfc/rfc2445.txt>`_), applying only to meeting series. It doesn't apply to
    #: a scheduled meeting or an ended or ongoing meeting instance. This parameter is ignored for an ad-hoc meeting.
    #: Multiple days or dates for monthly or yearly `recurrence` rule are not supported, only the first day or date
    #: specified is taken. For example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it
    #: will be partially supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
    #: example: FREQ=DAILY;INTERVAL=1;COUNT=20
    recurrence: Optional[str] = None
    #: Whether or not meeting is recorded automatically.
    enabled_auto_record_meeting: Optional[bool] = None
    #: Whether or not to allow any attendee with a host account on the target site to become a cohost when joining the
    #: meeting. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: the user's preferred site. The default value for an ad-hoc meeting is `true` and the user's input value will be
    #: ignored.
    allow_any_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow any attendee to join the meeting before the host joins the meeting. The default value
    #: for an ad-hoc meeting is `true` and the user's input value will be ignored.
    enabled_join_before_host: Optional[bool] = None
    #: Whether or not to allow any attendee to connect audio in the meeting before the host joins the meeting. This
    #: attribute is only applicable if the `enabledJoinBeforeHost` attribute is set to true. The default value for an
    #: ad-hoc meeting is `true` and the user's input value will be ignored.
    enable_connect_audio_before_host: Optional[bool] = None
    #: Number of minutes an attendee can join the meeting before the meeting start time and the host joins. This
    #: attribute is only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid options for a
    #: meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`, `45`, and `60`. The
    #: default value for an ad-hoc meeting is 0 and the user's input value will be ignored.
    #: example: 15.0
    join_before_host_minutes: Optional[int] = None
    #: Whether or not to exclude the meeting password from the email invitation. This parameter is ignored for an
    #: ad-hoc meeting.
    exclude_password: Optional[bool] = None
    #: Whether or not to allow the meeting to be listed on the public calendar. The default value for an ad-hoc meeting
    #: is `false` and the user's input value will be ignored.
    public_meeting: Optional[bool] = None
    #: The number of minutes before the meeting begins, that an email reminder is sent to the host. This parameter is
    #: ignored for an ad-hoc meeting.
    #: example: 10.0
    reminder_time: Optional[int] = None
    #: Specifies how the people who aren't on the invite can join the unlocked meeting. The default value for an ad-hoc
    #: meeting is `allowJoinWithLobby` and the user's input value will be ignored.
    #: example: allowJoin
    unlocked_meeting_join_security: Optional[MeetingSeriesObjectUnlockedMeetingJoinSecurity] = None
    #: Unique identifier for a meeting session type for the user. This attribute is required when scheduling a webinar
    #: meeting. All available meeting session types enabled for the user can be retrieved using the
    #: `List Meeting Session Types
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
    #: example: 3.0
    session_type_id: Optional[int] = None
    #: When set as an attribute in a POST request body, specifies whether it's a regular meeting, a webinar, or a
    #: meeting scheduled in the user's `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_. If not specified, it's a regular meeting by default. The default
    #: value for an ad-hoc meeting is `meeting` and the user's input value will be ignored.
    #: example: meeting
    scheduled_type: Optional[MeetingSeriesObjectScheduledType] = None
    #: Whether or not webcast view is enabled. This parameter is ignored for an ad-hoc meeting.
    enabled_webcast_view: Optional[bool] = None
    #: Password for panelists of a webinar meeting. Must conform to the site's password complexity settings. Read
    #: `password management
    #: <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password rules
    #: will be generated automatically. This parameter is ignored for an ad-hoc meeting.
    #: example: GwLqa@78
    panelist_password: Optional[str] = None
    #: Whether or not to automatically lock the meeting after it starts. The default value for an ad-hoc meeting is
    #: `false` and the user's input value will be ignored.
    enable_automatic_lock: Optional[bool] = None
    #: The number of minutes after the meeting begins, for automatically locking it. The default value for an ad-hoc
    #: meeting is null and the user's input value will be ignored.
    #: example: 10.0
    automatic_lock_minutes: Optional[int] = None
    #: Whether or not to allow the first attendee of the meeting with a host account on the target site to become a
    #: cohost. The target site is specified by `siteUrl` parameter when creating the meeting; if not specified, it's
    #: user's preferred site. The default value for an ad-hoc meeting is `false` and the user's input value will be
    #: ignored.
    allow_first_user_to_be_co_host: Optional[bool] = None
    #: Whether or not to allow authenticated video devices in the meeting's organization to start or join the meeting
    #: without a prompt. The default value for an ad-hoc meeting is `true` and the user's input value will be ignored.
    allow_authenticated_devices: Optional[bool] = None
    #: Invitees for meeting. The maximum size of invitees is 1000. If `roomId` is specified and `invitees` is missing,
    #: all the members in the space are invited implicitly. If both `roomId` and `invitees` are specified, only those
    #: in the `invitees` list are invited. `coHost` for each invitee is `true` by default if `roomId` is specified
    #: when creating a meeting, and anyone in the invitee list that is not qualified to be a cohost will be invited as
    #: a non-cohost invitee. The user's input value will be ignored for an ad-hoc meeting and the the members of the
    #: room specified by `roomId` except "me" will be used by default.
    invitees: Optional[list[InviteeObjectForCreateMeeting]] = None
    #: Whether or not to send emails to host and invitees. It is an optional field and default value is true. The
    #: default value for an ad-hoc meeting is `false` and the user's input value will be ignored.
    #: example: True
    send_email: Optional[bool] = None
    #: Email address for the meeting host. This attribute should only be set if the user or application calling the API
    #: has the admin-level scopes. When used, the admin may specify the email of a user in a site they manage to be
    #: the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: URL of the Webex site which the meeting is created on. If not specified, the meeting is created on user's
    #: preferred site. All available Webex sites and preferred site of the user can be retrieved by `Get Site List`
    #: API.
    #: example: example.webex.com
    site_url: Optional[str] = None
    #: Meeting Options.
    meeting_options: Optional[MeetingSeriesObjectMeetingOptions] = None
    #: Attendee Privileges. This attribute is not supported for a webinar.
    attendee_privileges: Optional[MeetingSeriesObjectAttendeePrivileges] = None
    #: Meeting registration. When this option is enabled, meeting invitees must register personal information to join
    #: the meeting. Meeting invitees will receive an email with a registration link for the registration. When the
    #: registration form has been submitted and approved, an email with a real meeting link will be received. By
    #: clicking that link the meeting invitee can join the meeting. Please note that meeting registration does not
    #: apply to a meeting when it's a recurring meeting with a recurrence field or no password, or the Join Before
    #: Host option is enabled for the meeting. See `Register for a Meeting in Cisco Webex Meetings
    #: <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details. This
    #: parameter is ignored for an ad-hoc meeting.
    registration: Optional[CreateMeetingObjectRegistration] = None
    #: External keys created by an integration application in its own domain, for example Zendesk ticket IDs, Jira IDs,
    #: Salesforce Opportunity IDs, etc. The integration application queries meetings by a key in its own domain. The
    #: maximum size of `integrationTags` is 3 and each item of `integrationTags` can be a maximum of 64 characters
    #: long. This parameter is ignored for an ad-hoc meeting.
    integration_tags: Optional[list[str]] = None
    #: Simultaneous interpretation information for a meeting.
    simultaneous_interpretation: Optional[CreateMeetingObjectSimultaneousInterpretation] = None
    #: Whether or not breakout sessions are enabled.
    enabled_breakout_sessions: Optional[bool] = None
    #: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They allow a subset of
    #: participants to collaborate and share ideas over audio and video. Use breakout sessions for workshops,
    #: classrooms, or for when you need a moment to talk privately with a few participants outside of the main
    #: session. Please note that maximum number of breakout sessions in a meeting or webinar is 100. In webinars, if
    #: hosts preassign attendees to breakout sessions, the role of `attendee` will be changed to `panelist`. Breakout
    #: session is not supported for a meeting with simultaneous interpretation.
    breakout_sessions: Optional[list[BreakoutSessionObject]] = None
    #: Whether or not audio watermark is enabled.
    enabled_audio_watermark: Optional[bool] = None
    #: Tracking codes information. All available tracking codes and their options for the specified site can be
    #: retrieved by `List Meeting Tracking Codes
    #: <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is missing from the `trackingCodes`
    #: array and there's a default option for this tracking code, the default option is assigned automatically. If the
    #: `inputMode` of a tracking code is `select`, its value must be one of the site-level options or the user-level
    #: value. Tracking code is not supported for a personal room meeting or an ad-hoc space meeting.
    tracking_codes: Optional[list[MeetingUsageReportTrackingCodeObject]] = None
    #: Audio connection options.
    audio_connection_options: Optional[MeetingSeriesObjectAudioConnectionOptions] = None
    #: Require attendees to sign in before joining the webinar. This option works when the value of `scheduledType`
    #: attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set if someone has already registered
    #: for the webinar.
    require_attendee_login: Optional[bool] = None
    #: Restrict webinar to invited attendees only. This option works when the registration option is disabled and the
    #: value of `scheduledType` attribute is `webinar`. Please note that `restrictToInvitees` cannot be set to `true`
    #: if `requireAttendeeLogin` is `false`.
    restrict_to_invitees: Optional[bool] = None


class DetailedTemplateObject1(ApiModel):
    #: Unique identifier for meeting template.
    #: example: N2Q3ZWE1ZjQyYjkyMWVhY2UwNTM4NmNhMjRhZDczMGU6VS0yMDA5NzItTUMtZW5fVVM
    id: Optional[str] = None
    #: Meeting template name.
    #: example: Meeting template 1
    name: Optional[str] = None
    #: Meeting template locale.
    #: example: en_US
    locale: Optional[str] = None
    #: Site URL for the meeting template.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Meeting template type.
    #: example: meeting
    template_type: Optional[MeetingUsageReportObjectScheduledType] = None
    #: Whether or not the meeting template is a default template.
    is_default: Optional[bool] = None
    #: Whether or not the meeting template is a standard template.
    is_standard: Optional[bool] = None
    #: Meeting object which is used to create a meeting by the meeting template. Please note that the meeting object
    #: should be used to create a meeting immediately after retrieval since the `start` and `end` may be invalid
    #: quickly after generation.
    meeting: Optional[CreateMeetingObject1] = None


class Registrant1(ApiModel):
    #: New registrant's ID.
    #: example: 123456
    registrant_id: Optional[str] = None
    #: New registrant's status.
    #: example: pending
    status: Optional[RegistrantStatus] = None
    #: Registrant's first name.
    #: example: bob
    first_name: Optional[str] = None
    #: Registrant's last name.
    #: example: Lee
    last_name: Optional[str] = None
    #: Registrant's email.
    #: example: bob@example.com
    email: Optional[str] = None
    #: Registrant's job title.
    #: example: manager
    job_title: Optional[str] = None
    #: Registrant's company.
    #: example: cisco
    company_name: Optional[str] = None
    #: Registrant's first address line.
    #: example: address1 string
    address1: Optional[str] = None
    #: Registrant's second address line.
    #: example: address2 string
    address2: Optional[str] = None
    #: Registrant's city name.
    #: example: New York
    city: Optional[str] = None
    #: Registrant's state.
    #: example: New York
    state: Optional[str] = None
    #: Registrant's postal code.
    #: example: 123456.0
    zip_code: Optional[int] = None
    #: Registrant's country or region.
    #: example: United States
    country_region: Optional[str] = None
    #: Registrant's work phone number.
    #: example: +1 123456
    work_phone: Optional[str] = None
    #: Registrant's FAX number.
    #: example: 123456
    fax: Optional[str] = None
    #: Registrant's registration time.
    #: example: 2021-09-07T09:29:13+08:00
    registration_time: Optional[datetime] = None
    #: Registrant's answers for customized questions, Registration options define whether or not this is required.
    customized_questions: Optional[list[CustomizedRegistrant]] = None
    #: Registrant's source id.The `sourceId` is from `Create Invitation Sources
    #: <https://developer.webex.com/docs/api/v1/meetings/create-invitation-sources>`_ API.
    #: example: cisco
    source_id: Optional[str] = None
    #: Registrant's registration ID. Registrants have a special number to identify a registrations if it is
    #: webinar-enabled and enabled registration ID.
    #: example: 1111
    registration_id: Optional[datetime] = None


class JoinMeetingObject1(ApiModel):
    #: Unique identifier for the meeting. This parameter applies to meeting series and scheduled meetings. It doesn't
    #: apply to ended or in-progress meeting instances. Please note that currently meeting ID of a scheduled
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is also supported for this API.
    #: example: 98d8c2212c9d62b162b9565932735e58_I_231409844992607809
    meeting_id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1e
    web_link: Optional[str] = None
    #: Whether or not to redirect to `joinLink`. It is an optional field and default value is true.
    join_directly: Optional[bool] = None
    #: Email address of meeting participant. If `email` is specified, the link is generated for the user of `email`;
    #: otherwise, the API returns the link for the user calling the API. `email` is required for a `guest issuer
    #: <https://developer.webex.com/docs/guest-issuer>`_.
    #: example: brenda.song@example.com
    email: Optional[str] = None
    #: Display name of meeting participant. If `displayName` is specified, `email` must be specified as well. If
    #: `email` is specified and `displayName` is not, display name is the same as `email`. If neither `displayName`
    #: nor `email` is specified, the API returns the link for the user calling the API. The maximum length of
    #: `displayName` is 128 characters. `displayName` is required for a `guest issuer
    #: <https://developer.webex.com/docs/guest-issuer>`_.
    #: example: Brenda Song
    display_name: Optional[str] = None
    #: Required when the meeting is protected by a password and the current user is not privileged to view it if they
    #: are not a host, cohost, or invitee.
    #: example: BgJep@43
    password: Optional[str] = None
    #: Expiration duration of `joinLink` in minutes. Must be between 1 and 60.
    #: example: 5.0
    expiration_minutes: Optional[int] = None
    #: Required when the meeting is webinar-enabled and enabled registration ID.
    #: example: 1111
    registration_id: Optional[datetime] = None


class SurveyLinkRequestObject(ApiModel):
    #: Email address for the meeting host. This parameter is only used if the user or application calling the API has
    #: the admin on-behalf-of scopes. An admin can specify the email of the meeting host who is in a site he manages
    #: and the API returns post survey links on behalf of the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Start date and time (inclusive) in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being requested and
    #: conforms with the `timezone` in the request header if specified. `meetingStartTimeFrom` cannot be after
    #: `meetingStartTimeTo`. Only applies when `meetingId` is not an instance ID. The API generates survey links for
    #: the last instance of `meetingId` in the time range specified by `meetingStartTimeFrom` and
    #: `meetingStartTimeTo`. If not specified, `meetingStartTimeFrom` equals `meetingStartTimeTo` minus `1` month; if
    #: `meetingStartTimeTo` is also not specified, the default value for `meetingStartTimeFrom` is `1` month before
    #: the current date and time.
    #: example: 2019-03-18T09:30:00Z
    meeting_start_time_from: Optional[datetime] = None
    #: End date and time (exclusive) in any `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being requested and
    #: conforms with the `timezone` in the request header if specified. `meetingStartTimeTo` cannot be prior to
    #: `meetingStartTimeFrom`. Only applies when `meetingId` is not an instance ID. The API generates survey links for
    #: the last instance of `meetingId` in the time range specified by `meetingStartTimeFrom` and
    #: `meetingStartTimeTo`. If not specified, `meetingStartTimeTo` equals `meetingStartTimeFrom` plus `1` month; if
    #: `meetingStartTimeFrom` is also not specified, the default value for `meetingStartTimeTo` is the current date
    #: and time.
    #: example: 2019-03-25T09:30:00Z
    meeting_start_time_to: Optional[datetime] = None
    #: Participants' email list. The maximum size of `emails` is 100.
    emails: Optional[list[str]] = None


class SurveyLinkObject(ApiModel):
    #: Participant email.
    #: example: kingu1@example.com
    email: Optional[str] = None
    #: Meeting survey Link for the participant.
    #: example: https://example.webex.com/webappng/sites/example/meeting/surveyPage/fa1fc86f70d74c08bc7dc5a3b499ab98?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzaXRlSWQiOjIwNjI4NDIsImJpcnRoVGltZSI6MTY4ODQzODYwODY4NCwiZW1haWwiOiJRVWhUU3dBQUFJVllnWEhTSVJLa2hzN2pIR0lCNzJxVDM3SDc5a1NLWjcwUFNBVG9aekJYeHV3KzhJenZnd3l6ZEJ5ZGFDeGc1TnZLcW9mRHV4RjlqdWpGeWhld3EyRmFsWVpNTU9Sa3drNVRNQWZZR2lTUVFRPT0iLCJtZWV0aW5nSW5zdGFuY2VJZCI6Ijc0Y2YyZTJhMjI0ZDQ3OTViM2QwMjliMDZjMGI4NWFjX0lfMjY0Mzg5MTg4NzU2OTY1MjUxIn0.SDJTSwAAAIVIzXgb0wNfEdKwDeRiGzxLWfhoSG5blNcDoCslAiserg
    survey_link: Optional[str] = None


class ListMeetingsResponse1(ApiModel):
    #: Meetings array.
    items: Optional[list[MeetingSeriesObjectForListMeeting1]] = None


class ListMeetingsOfAMeetingSeriesResponse1(ApiModel):
    #: Meetings array.
    items: Optional[list[ScheduledMeetingObject1]] = None


class ListMeetingRegistrantsResponse1(ApiModel):
    #: Registrants array.
    items: Optional[list[Registrant1]] = None


class GetMeetingSurveyLinksResponse(ApiModel):
    #: Survey link array
    items: Optional[list[SurveyLinkObject]] = None


class Registration2(ApiModel):
    #: Whether or not meeting registration requests are accepted automatically.
    auto_accept_request: Optional[bool] = None
    #: Whether or not a registrant's first name is required for meeting registration. This option must always be
    #: `true`.
    #: example: True
    require_first_name: Optional[bool] = None
    #: Whether or not a registrant's last name is required for meeting registration. This option must always be `true`.
    #: example: True
    require_last_name: Optional[bool] = None
    #: Whether or not a registrant's email is required for meeting registration. This option must always be `true`.
    #: example: True
    require_email: Optional[bool] = None
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool] = None
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool] = None
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool] = None
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool] = None
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool] = None
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool] = None
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool] = None
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool] = None
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool] = None
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool] = None
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForGetMeeting]] = None
    #: The approval rules for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]] = None


class JoinMeetingObject2(ApiModel):
    #: Unique identifier for the meeting. This parameter applies to meeting series and scheduled meetings. It doesn't
    #: apply to ended or in-progress meeting instances. Please note that currently meeting ID of a scheduled
    #: `personal room
    #: <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is also supported for this API.
    #: example: 98d8c2212c9d62b162b9565932735e58_I_231409844992607809
    meeting_id: Optional[str] = None
    #: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but not to meeting
    #: instances which have ended.
    #: example: 123456789
    meeting_number: Optional[str] = None
    #: Link to a meeting information page where the meeting client is launched if the meeting is ready to start or
    #: join.
    #: example: https://site4-example.webex.com/site4/j.php?MTID=md41817da6a55b0925530cb88b3577b1e
    web_link: Optional[str] = None
    #: Whether or not to redirect to `joinLink`. It is an optional field and default value is true.
    join_directly: Optional[bool] = None
    #: Email address of meeting participant. If `email` is specified, the link is generated for the user of `email`;
    #: otherwise, the API returns the link for the user calling the API. `email` is required for a `guest issuer
    #: <https://developer.webex.com/docs/guest-issuer>`_.
    #: example: brenda.song@example.com
    email: Optional[str] = None
    #: Display name of meeting participant. If `displayName` is specified, `email` must be specified as well. If
    #: `email` is specified and `displayName` is not, display name is the same as `email`. If neither `displayName`
    #: nor `email` is specified, the API returns the link for the user calling the API. The maximum length of
    #: `displayName` is 128 characters. `displayName` is required for a `guest issuer
    #: <https://developer.webex.com/docs/guest-issuer>`_.
    #: example: Brenda Song
    display_name: Optional[str] = None
    #: Required when the meeting is protected by a password and the current user is not privileged to view it if they
    #: are not a host, cohost, or invitee.
    #: example: BgJep@43
    password: Optional[str] = None
    #: Expiration duration of `joinLink` in minutes. Must be between 1 and 60.
    #: example: 5.0
    expiration_minutes: Optional[int] = None
    #: Required when the meeting is webinar-enabled and enabled registration ID.
    #: example: 1111
    registration_id: Optional[datetime] = None
    #: Email address for the meeting host. This attribute should be set if the user or application calling the API has
    #: the admin on-behalf-of scopes. This parameter is required for a `Service App
    #: <https://developer.webex.com/docs/service-apps>`_. It only applies to meetings, not
    #: webinars.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None


class RegistrationForUpdate2(ApiModel):
    #: - Email address for the meeting host. This parameter is only used if the user or application calling the API has
    #: the admin-level scopes. If set, the admin may specify the email of a user in a site they manage and the API
    #: will return an update for a meeting that is hosted by that user.
    #: example: 'john.andersen@example.com'
    host_email: Optional[str] = None
    #: Whether or not meeting registration requests are accepted automatically.
    auto_accept_request: Optional[bool] = None
    #: Whether or not a registrant's first name is required for meeting registration. This option must always be
    #: `true`.
    #: example: True
    require_first_name: Optional[bool] = None
    #: Whether or not a registrant's last name is required for meeting registration. This option must always be `true`.
    #: example: True
    require_last_name: Optional[bool] = None
    #: Whether or not a registrant's email is required for meeting registration. This option must always be `true`.
    #: example: True
    require_email: Optional[bool] = None
    #: Whether or not a registrant's job title is shown or required for meeting registration.
    require_job_title: Optional[bool] = None
    #: Whether or not a registrant's company name is shown or required for meeting registration.
    require_company_name: Optional[bool] = None
    #: Whether or not a registrant's first address field is shown or required for meeting registration.
    require_address1: Optional[bool] = None
    #: Whether or not a registrant's second address field is shown or required for meeting registration.
    require_address2: Optional[bool] = None
    #: Whether or not a registrant's city is shown or required for meeting registration.
    require_city: Optional[bool] = None
    #: Whether or not a registrant's state is shown or required for meeting registration.
    require_state: Optional[bool] = None
    #: Whether or not a registrant's postal code is shown or required for meeting registration.
    require_zip_code: Optional[bool] = None
    #: Whether or not a registrant's country or region is shown or required for meeting registration.
    require_country_region: Optional[bool] = None
    #: Whether or not a registrant's work phone number is shown or required for meeting registration.
    require_work_phone: Optional[bool] = None
    #: Whether or not a registrant's fax number is shown or required for meeting registration.
    require_fax: Optional[bool] = None
    #: Maximum number of meeting registrations. This only applies to meetings. The maximum number of participants for
    #: meetings and webinars, with the limit based on the user capacity and controlled by a toggle at the site level.
    #: The default maximum number of participants for webinars is 10000, but the actual maximum number of participants
    #: is limited by the user capacity.
    #: example: 1000.0
    max_register_num: Optional[int] = None
    #: Customized questions for meeting registration.
    customized_questions: Optional[list[CustomizedQuestionForCreateMeeting]] = None
    #: The approval rule for standard questions.
    rules: Optional[list[StandardRegistrationApproveRule]] = None


class Membership(ApiModel):
    #: A unique identifier for the membership.
    #: example: Y2lzY29zcGFyazovL3VzL01FTUJFUlNISVAvMGQwYzkxYjYtY2U2MC00NzI1LWI2ZDAtMzQ1NWQ1ZDExZWYzOmNkZTFkZDQwLTJmMGQtMTFlNS1iYTljLTdiNjU1NmQyMjA3Yg
    id: Optional[str] = None
    #: The room ID.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The person ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the person.
    #: example: john.andersen@example.com
    person_email: Optional[str] = None
    #: The display name of the person.
    #: example: John Andersen
    person_display_name: Optional[str] = None
    #: The organization ID of the person.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    person_org_id: Optional[str] = None
    #: Whether or not the participant is a room moderator.
    #: example: True
    is_moderator: Optional[bool] = None
    #: Whether or not the direct type room is hidden in the Webex clients.
    is_room_hidden: Optional[bool] = None
    #: The type of room the membership is associated with.
    #: example: direct
    room_type: Optional[ECMFolderRoomType] = None
    #: Whether or not the participant is a monitoring bot (deprecated).
    is_monitor: Optional[bool] = None
    #: The date and time when the membership was created.
    #: example: 2015-10-18T14:26:16.203Z
    created: Optional[datetime] = None


class MembershipCollectionResponse(ApiModel):
    items: Optional[list[Membership]] = None


class FileType(str, Enum):
    #: Attachment stored externally.
    external = 'external'
    #: Attachment stored within the Webex platform.
    native = 'native'


class File1(ApiModel):
    #: The `fileId` of the attachment.
    #: example: BFT1BMRS8yNDlmNzRkOS1kYjhhLTQzY2
    file_id: Optional[str] = None
    #: The type of attachment.
    #: example: external
    type: Optional[FileType] = None
    #: The URL for the content.
    #: example: https://testecmwebexteams-my.sharepoint.com/:w:/g/personal/admin_testecmwebexteams_onmicrosoft_com/ESCiJiALU0pBlVm6TVhZ2k0B69XNVB1kWoaa7RIV9GERTg
    content_url: Optional[str] = None


class Attachment(ApiModel):
    #: Enterprise Content Management file.
    content: Optional[File1] = None


class Message(ApiModel):
    #: The unique identifier for the message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    id: Optional[str] = None
    #: The room ID of the message.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The type of room.
    #: example: group
    room_type: Optional[ECMFolderRoomType] = None
    #: The person ID of the recipient when sending a private 1:1 message.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mMDZkNzFhNS0wODMzLTRmYTUtYTcyYS1jYzg5YjI1ZWVlMmX
    to_person_id: Optional[str] = None
    #: The email address of the recipient when sending a private 1:1 message.
    #: example: julie@example.com
    to_person_email: Optional[str] = None
    #: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to provide
    #: alternate text for UI clients that do not support rich text.
    #: example: PROJECT UPDATE - A new project plan has been published on http://example.com/s/lf5vj. The PM for this project is Mike C. and the Engineering Manager is Jane W.
    text: Optional[str] = None
    #: The message, in Markdown format.
    #: example: **PROJECT UPDATE** A new project plan has been published [here](http://example.com/s/lf5vj). The PM for this project is <@personEmail:mike@example.com> and the Engineering Manager is <@personEmail:jane@example.com>.
    markdown: Optional[str] = None
    #: Public URLs for files attached to the message. For the supported media types and the behavior of file uploads,
    #: see `Message Attachments
    #: <https://developer.webex.com/docs/api/basics#message-attachments>`_.
    #: example: ['http://www.example.com/images/media.png']
    files: Optional[list[str]] = None
    #: Content attachments attached to the message.
    attachments: Optional[list[Attachment]] = None
    #: The person ID of the message author.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the message author.
    #: example: matt@example.com
    person_email: Optional[str] = None
    #: People IDs for anyone mentioned in the message.
    #: example: ['Y2lzY29zcGFyazovL3VzL1BFT1BMRS8yNDlmNzRkOS1kYjhhLTQzY2EtODk2Yi04NzllZDI0MGFjNTM', 'Y2lzY29zcGFyazovL3VzL1BFT1BMRS83YWYyZjcyYy0xZDk1LTQxZjAtYTcxNi00MjlmZmNmYmM0ZDg']
    mentioned_people: Optional[list[str]] = None
    #: Group names for the groups mentioned in the message.
    #: example: ['all']
    mentioned_groups: Optional[list[str]] = None
    #: The date and time the message was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None


class DirectMessage(ApiModel):
    #: The unique identifier for the message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    id: Optional[str] = None
    #: The room ID of the message.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vODQxZjY5MjAtNDdlZC00NmE0LWI2YmItZTVjM2M1YTc3Yzgy
    room_id: Optional[str] = None
    #: The type of room. Will always be `direct`.
    #: example: direct
    room_type: Optional[str] = None
    #: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to provide
    #: alternate text for UI clients that do not support rich text.
    #: example: Hey there, what do you think of this project update presentation (http://sharepoint.example.com/presentation.pptx)?
    text: Optional[str] = None
    #: The message, in Markdown format.
    #: example: Hey there, what do you think of [this project update presentation](http://sharepoint.example.com/presentation.pptx)?
    markdown: Optional[str] = None
    #: Public URLs for files attached to the message. For the supported media types and the behavior of file uploads,
    #: see `Message Attachments
    #: <https://developer.webex.com/docs/api/basics#message-attachments>`_.
    #: example: ['http://www.example.com/images/media.png']
    files: Optional[list[str]] = None
    #: The person ID of the message author.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the message author.
    #: example: matt@example.com
    person_email: Optional[str] = None
    #: The date and time the message was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None


class MessageCollectionResponse(ApiModel):
    items: Optional[list[Message]] = None


class DirectMessageCollectionResponse(ApiModel):
    items: Optional[list[DirectMessage]] = None


class AdaptiveCardBody(ApiModel):
    #: example: TextBlock
    type: Optional[str] = None
    #: example: Adaptive Cards
    text: Optional[str] = None
    #: example: large
    size: Optional[str] = None


class AdaptiveCardActions(ApiModel):
    #: example: Action.OpenUrl
    type: Optional[str] = None
    #: example: http://adaptivecards.io
    url: Optional[str] = None
    #: example: Learn More
    title: Optional[str] = None


class AdaptiveCard(ApiModel):
    #: Must be `AdaptiveCard`.
    #: example: AdaptiveCard
    type: Optional[str] = None
    #: Adaptive Card schema version.
    #: example: 1.0
    version: Optional[datetime] = None
    #: The card's elements.
    body: Optional[list[AdaptiveCardBody]] = None
    #: The card's actions.
    actions: Optional[list[AdaptiveCardActions]] = None


class Attachment1(ApiModel):
    #: The content type of the attachment.
    #: example: application/vnd.microsoft.card.adaptive
    content_type: Optional[str] = None
    #: Adaptive Card content.
    content: Optional[AdaptiveCard] = None


class Message1(ApiModel):
    #: The unique identifier for the message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    id: Optional[str] = None
    #: The unique identifier for the parent message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    parent_id: Optional[str] = None
    #: The room ID of the message.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The type of room.
    #: example: group
    room_type: Optional[ECMFolderRoomType] = None
    #: The person ID of the recipient when sending a private 1:1 message.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mMDZkNzFhNS0wODMzLTRmYTUtYTcyYS1jYzg5YjI1ZWVlMmX
    to_person_id: Optional[str] = None
    #: The email address of the recipient when sending a private 1:1 message.
    #: example: julie@example.com
    to_person_email: Optional[str] = None
    #: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to provide
    #: alternate text for UI clients that do not support rich text.
    #: example: PROJECT UPDATE - A new project plan has been published om http://example.com/s/lf5vj. The PM for this project is Mike C. and the Engineering Manager is Jane W.
    text: Optional[str] = None
    #: The message, in Markdown format.
    #: example: **PROJECT UPDATE** A new project plan has been published on <http://box.com/s/lf5vj>. The PM for this project is <@personEmail:mike@example.com> and the Engineering Manager is <@personEmail:jane@example.com>.
    markdown: Optional[str] = None
    #: The text content of the message, in HTML format. This read-only property is used by the Webex clients.
    #: example: <p><strong>PROJECT UPDATE</strong> A new project plan has been published <a href=\"http://example.com/s/lf5vj\" rel=\"nofollow\">here</a>. The PM for this project is mike@example.com and the Engineering Manager is jane@example.com.</p>
    html: Optional[str] = None
    #: Public URLs for files attached to the message. For the supported media types and the behavior of file uploads,
    #: see `Message Attachments
    #: <https://developer.webex.com/docs/basics#message-attachments>`_.
    #: example: ['http://www.example.com/images/media.png']
    files: Optional[list[str]] = None
    #: The person ID of the message author.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the message author.
    #: example: matt@example.com
    person_email: Optional[str] = None
    #: People IDs for anyone mentioned in the message.
    #: example: ['Y2lzY29zcGFyazovL3VzL1BFT1BMRS8yNDlmNzRkOS1kYjhhLTQzY2EtODk2Yi04NzllZDI0MGFjNTM', 'Y2lzY29zcGFyazovL3VzL1BFT1BMRS83YWYyZjcyYy0xZDk1LTQxZjAtYTcxNi00MjlmZmNmYmM0ZDg']
    mentioned_people: Optional[list[str]] = None
    #: Group names for the groups mentioned in the message.
    #: example: ['all']
    mentioned_groups: Optional[list[str]] = None
    #: Message content attachments attached to the message. See the `Cards Guide
    #: <https://developer.webex.com/docs/api/guides/cards>`_ for more information.
    attachments: Optional[list[Attachment1]] = None
    #: The date and time the message was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None
    #: The date and time that the message was last edited by the author. This field is only present when the message
    #: contents have changed.
    #: example: 2015-10-18T14:27:16+00:00
    updated: Optional[datetime] = None
    #: True if the audio file is a voice clip recorded by the client; false if the audio file is a standard audio file
    #: not posted using the voice clip feature.
    is_voice_clip: Optional[bool] = None


class ListMessage(ApiModel):
    #: The unique identifier for the message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    id: Optional[str] = None
    #: The unique identifier for the parent message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    parent_id: Optional[str] = None
    #: The room ID of the message.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The type of room.
    #: example: group
    room_type: Optional[ECMFolderRoomType] = None
    #: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to provide
    #: alternate text for UI clients that do not support rich text.
    #: example: PROJECT UPDATE - A new project plan has been published on http://example.com/s/lf5vj. The PM for this project is Mike C. and the Engineering Manager is Jane W.
    text: Optional[str] = None
    #: The message, in Markdown format.
    #: example: **PROJECT UPDATE** A new project plan has been published on <http://example.com/s/lf5vj>. The PM for this project is <@personEmail:mike@example.com> and the Engineering Manager is <@personEmail:jane@example.com>.
    markdown: Optional[str] = None
    #: The text content of the message, in HTML format. This read-only property is used by the Webex clients.
    #: example: <p><strong>PROJECT UPDATE</strong> A new project plan has been published <a href=\"http://example.com/s/lf5vj\" rel=\"nofollow\">here</a>. The PM for this project is mike@example.com and the Engineering Manager is jane@example.com.</p>
    html: Optional[str] = None
    #: Public URLs for files attached to the message. For the supported media types and the behavior of file uploads,
    #: see `Message Attachments
    #: <https://developer.webex.com/docs/basics#message-attachments>`_.
    #: example: ['http://www.example.com/images/media.png']
    files: Optional[list[str]] = None
    #: The person ID of the message author.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the message author.
    #: example: matt@example.com
    person_email: Optional[str] = None
    #: People IDs for anyone mentioned in the message.
    #: example: ['Y2lzY29zcGFyazovL3VzL1BFT1BMRS8yNDlmNzRkOS1kYjhhLTQzY2EtODk2Yi04NzllZDI0MGFjNTM', 'Y2lzY29zcGFyazovL3VzL1BFT1BMRS83YWYyZjcyYy0xZDk1LTQxZjAtYTcxNi00MjlmZmNmYmM0ZDg']
    mentioned_people: Optional[list[str]] = None
    #: Group names for the groups mentioned in the message.
    #: example: ['all']
    mentioned_groups: Optional[list[str]] = None
    #: Message content attachments attached to the message. See the `Cards Guide
    #: <https://developer.webex.com/docs/api/guides/cards>`_ for more information.
    attachments: Optional[list[Attachment1]] = None
    #: The date and time the message was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None
    #: The date and time that the message was last edited by the author. This field is only present when the message
    #: contents have changed.
    #: example: 2015-10-18T14:27:16+00:00
    updated: Optional[datetime] = None
    #: `true` if the audio file is a voice clip recorded by the client; `false` if the audio file is a standard audio
    #: file not posted using the voice clip feature.
    is_voice_clip: Optional[bool] = None


class DirectMessage1(ApiModel):
    #: The unique identifier for the message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    id: Optional[str] = None
    #: The unique identifier for the parent message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvOTJkYjNiZTAtNDNiZC0xMWU2LThhZTktZGQ1YjNkZmM1NjVk
    parent_id: Optional[str] = None
    #: The room ID of the message.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vODQxZjY5MjAtNDdlZC00NmE0LWI2YmItZTVjM2M1YTc3Yzgy
    room_id: Optional[str] = None
    #: The type of room. Will always be `direct`.
    #: example: direct
    room_type: Optional[str] = None
    #: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to provide
    #: alternate text for UI clients that do not support rich text.
    #: example: Hey there, what do you think of this project update presentation (http://sharepoint.example.com/presentation.pptx)?
    text: Optional[str] = None
    #: The message, in Markdown format.
    #: example: Hey there, what do you think of [this project update presentation](http://sharepoint.example.com/presentation.pptx)?
    markdown: Optional[str] = None
    #: The text content of the message, in HTML format. This read-only property is used by the Webex clients.
    #: example: <p>Hey there, what do you think of <a href=\"http://sharepoint.example.com/presentation.pptx\" rel=\"nofollow\">this project update presentation</a>?</p>
    html: Optional[str] = None
    #: Public URLs for files attached to the message. For the supported media types and the behavior of file uploads,
    #: see `Message Attachments
    #: <https://developer.webex.com/docs/api/basics#message-attachments>`_.
    #: example: ['http://www.example.com/images/media.png']
    files: Optional[list[str]] = None
    #: The person ID of the message author.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the message author.
    #: example: matt@example.com
    person_email: Optional[str] = None
    #: Message content attachments attached to the message. See the `Cards Guide
    #: <https://developer.webex.com/docs/api/guides/cards>`_ for more information.
    attachments: Optional[list[Attachment1]] = None
    #: The date and time the message was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None
    #: The date and time that the message was last edited by the author. This field is only present when the message
    #: contents have changed.
    #: example: 2015-10-18T14:27:16+00:00
    updated: Optional[datetime] = None
    #: True if the audio file is a voice clip recorded by the client; false if the audio file is a standard audio file
    #: not posted using the voice clip feature.
    is_voice_clip: Optional[bool] = None


class MessageCollectionResponse1(ApiModel):
    items: Optional[list[Message1]] = None


class ListMessageCollectionResponse(ApiModel):
    items: Optional[list[ListMessage]] = None


class DirectMessageCollectionResponse1(ApiModel):
    items: Optional[list[DirectMessage1]] = None


class NumberItem(ApiModel):
    #: The source location of the numbers to be moved.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzUyMjNiYmVkLTQyYzktNDU0ZC1hMWYzLTdmYWQ1Y2M3ZTZlMw
    location_id: Optional[str] = None
    #: Indicates the numbers to be moved from one location to another location.
    numbers: Optional[list[str]] = None


class AdminBatchStartJobObject(ApiModel):
    #: Indicates the kind of operation to be carried out.
    #: example: MOVE
    operation: Optional[str] = None
    #: The target location within organization where the unassigned numbers will be moved from the source location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2E4Mjg5NzIyLTFiODAtNDFiNy05Njc4LTBlNzdhZThjMTA5OA
    target_location_id: Optional[str] = None
    #: Indicates the numbers to be moved from source to target locations.
    number_list: Optional[list[NumberItem]] = None


class MoveNumberValidationError(ApiModel):
    #: Unique identifier to track the HTTP requests.
    tracking_id: Optional[str] = None
    error: Optional[Error1] = None


class NumberState(str, Enum):
    #: Phone number is available.
    available = 'AVAILABLE'
    #: Duplicate phone number.
    duplicate = 'DUPLICATE'
    #: Duplicate phone number in the list.
    duplicateinlist = 'DUPLICATEINLIST'
    #: Phone number is invalid.
    invalid = 'INVALID'
    #: Phone number is unavailable and cannot be used.
    unavailable = 'UNAVAILABLE'


class Number(ApiModel):
    #: Phone numbers that need to be validated.
    #: example: +2145557901
    number: Optional[str] = None
    #: Indicates the state of the number.
    state: Optional[NumberState] = None
    #: Indicates whether it's a toll-free number.
    toll_free_number: Optional[bool] = None
    #: Error details if the number is unavailable.
    detail: Optional[list[str]] = None


class NumberObject3(ApiModel):
    #: A unique identifier for the PSTN phone number.
    #: example: +12056350001
    phone_number: Optional[str] = None
    #: Extension for a PSTN phone number.
    #: example: 000
    extension: Optional[str] = None
    #: Phone number's state.
    #: example: ACTIVE
    state: Optional[str] = None
    #: Type of phone number.
    #: example: PRIMARY
    phone_number_type: Optional[str] = None
    #: Indicates if the phone number is used as location clid.
    #: example: True
    main_number: Optional[bool] = None
    #: Indicates if a phone number is a toll free number.
    #: example: True
    toll_free_number: Optional[bool] = None
    location: Optional[Location] = None
    owner: Optional[NumberObjectOwner] = None


class NumberListGetObject2(ApiModel):
    #: Array of phone numbers.
    phone_numbers: Optional[list[NumberObject3]] = None


class State(str, Enum):
    #: Active state.
    _active_ = 'ACTIVE'
    #: Inactive state
    _inactive_ = 'INACTIVE'


class NumbersPost1(ApiModel):
    #: List of phone numbers that need to be added.
    phone_numbers: Optional[list[str]] = None
    #: State of the phone numbers.
    state: Optional[State] = None


class ValidateNumbersResponse(ApiModel):
    #: Indicates the status of the numbers.
    status: Optional[PostValidateExtensionResponseStatus] = None
    #: An array of number objects with number details.
    numbers: Optional[list[Number]] = None


class ContactPrimaryContactMethod(str, Enum):
    sipaddress = 'SIPADDRESS'
    email = 'EMAIL'
    phone = 'PHONE'
    ims = 'IMS'


class ContactSource(str, Enum):
    ch = 'CH'
    webex4_broadworks = 'Webex4Broadworks'


class ContactEmailsType(str, Enum):
    work = 'work'
    home = 'home'
    room = 'room'
    other = 'other'


class ContactEmails(ApiModel):
    #: The email address.
    #: example: user1@example.home.com
    value: Optional[str] = None
    #: The type of the email.
    #: example: home
    type: Optional[ContactEmailsType] = None
    #: A Boolean value indicating the email status.
    primary: Optional[bool] = None


class ContactPhoneNumbersType(str, Enum):
    work = 'work'
    home = 'home'
    mobile = 'mobile'
    work_extension = 'work_extension'
    fax = 'fax'
    pager = 'pager'
    other = 'other'


class ContactPhoneNumbers(ApiModel):
    #: The phone number.
    #: example: 400 123 1234
    value: Optional[str] = None
    #: The types of the phone numbers.
    #: example: work
    type: Optional[ContactPhoneNumbersType] = None
    #: A Boolean value indicating the phone number's primary status.
    #: example: True
    primary: Optional[bool] = None
    #: - A String value on the operation, only `delete` is supported now.
    #: example: delete
    operation: Optional[str] = None


class ContactSipAddressesType(str, Enum):
    enterprise = 'enterprise'
    cloud_calling = 'cloud-calling'
    personal_room = 'personal-room'


class ContactSipAddresses(ApiModel):
    #: The sipAddress value.
    #: example: sipAddress value1
    value: Optional[str] = None
    #: The type of the sipAddress.
    #: example: enterprise
    type: Optional[ContactSipAddressesType] = None
    #: Designate the primary sipAddress.
    #: example: True
    primary: Optional[bool] = None


class ContactImsType(str, Enum):
    aim = 'aim'
    cucm_jid = 'cucm-jid'
    gtalk = 'gtalk'
    icq = 'icq'
    msn = 'msn'
    qq = 'qq'
    skype = 'skype'
    webex_messenger_jid = 'webex-messenger-jid'
    webex_squared_jid = 'webex-squared-jid'
    xmpp = 'xmpp'
    yahoo = 'yahoo'
    microsoft_sip_uri = 'microsoft-sip-uri'
    xmpp_fed_jid = 'xmpp-fed-jid'


class ContactIms(ApiModel):
    #: The IMS account value.
    #: example: aim_account_ID
    value: Optional[str] = None
    #: The type of the IMS.
    #: example: aim
    type: Optional[ContactImsType] = None
    #: A Boolean value indicating the IMS account status.
    #: example: True
    primary: Optional[bool] = None


class Contact(ApiModel):
    #: "urn:cisco:codev:identity:contact:core:1.0".
    #: example: urn:cisco:codev:identity:contact:core:1.0
    schemas: Optional[str] = None
    #: The full name of the contact.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The first name of the contact.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the contact.
    #: example: Andersen
    last_name: Optional[str] = None
    #: The company the contact is working for.
    #: example: Cisco Systems
    company_name: Optional[str] = None
    #: The contact's title.
    #: example: GM
    title: Optional[str] = None
    #: Contact's address.
    #: example: {\"city\" : \"Milpitas\", \"country\" : \"US\", \"street\" : \"1099 Bird Ave.\", \"zipCode\" : \"99212\"}
    address: Optional[str] = None
    #: The URL to the person's avatar in PNG format.
    #: example: https://avatar-prod-us-east-2.webexcontent.com/default_avatar~1600
    avatar_url: Optional[str] = Field(alias='avatarURL', default=None)
    #: The contact's primary contact method.
    #: example: SIPADDRESS
    primary_contact_method: Optional[ContactPrimaryContactMethod] = None
    #: Where the data come from.
    #: example: Webex4Broadworks
    source: Optional[ContactSource] = None
    #: A list of the user's email addresses with an indicator of the user's primary email address.
    emails: Optional[list[ContactEmails]] = None
    #: A list of user's phone numbers with an indicator of primary to specify the user's main number.
    phone_numbers: Optional[list[ContactPhoneNumbers]] = None
    #: The sipAddress values for the user.
    sip_addresses: Optional[list[ContactSipAddresses]] = None
    #: Instant messaging addresses for the user.
    ims: Optional[list[ContactIms]] = None


class BulkCreateContacts(ApiModel):
    #: The full name of the contact.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The first name of the contact.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the contact.
    #: example: Andersen
    last_name: Optional[str] = None
    #: The company the contact is working for.
    #: example: Cisco Systems
    company_name: Optional[str] = None
    #: The contact's title.
    #: example: GM
    title: Optional[str] = None
    #: Contact's address.
    #: example: {\"city\" : \"Milpitas\", \"country\" : \"US\", \"street\" : \"1099 Bird Ave.\", \"zipCode\" : \"99212\"}
    address: Optional[str] = None
    #: The URL to the person's avatar in PNG format.
    #: example: https://avatar-prod-us-east-2.webexcontent.com/default_avatar~1600
    avatar_url: Optional[str] = Field(alias='avatarURL', default=None)
    #: The contact's primary contact method.
    #: example: SIPADDRESS
    primary_contact_method: Optional[ContactPrimaryContactMethod] = None
    #: Where the data come from.
    #: example: Webex4Broadworks
    source: Optional[ContactSource] = None
    #: A list of the user's email addresses with an indicator of the user's primary email address.
    emails: Optional[list[ContactEmails]] = None
    #: A list of user's phone numbers with an indicator of primary to specify the user's main number.
    phone_numbers: Optional[list[ContactPhoneNumbers]] = None
    #: The sipAddress values for the user.
    sip_addresses: Optional[list[ContactSipAddresses]] = None
    #: Instant messaging addresses for the user.
    ims: Optional[list[ContactIms]] = None


class BulkCreate(ApiModel):
    #: "urn:cisco:codev:identity:contact:core:1.0".
    #: example: urn:cisco:codev:identity:contact:core:1.0
    schemas: Optional[str] = None
    #: Contains a list of contacts to be created/updated.
    contacts: Optional[list[BulkCreateContacts]] = None


class BulkDelete(ApiModel):
    #: "urn:cisco:codev:identity:contact:core:1.0".
    #: example: urn:cisco:codev:identity:contact:core:1.0
    schemas: Optional[str] = None
    #: List of UUIDs for the contacts.
    #: example: ['8a5fac49-2c5f-4773-aec7-02db0e3a9d72']
    object_ids: Optional[list[str]] = None


class Meta1(ApiModel):
    #: The date and time the contact was created.
    #: example: 2022-04-29T13:06:26.831Z
    created: Optional[datetime] = None
    #: The date and time the contact was last changed.
    #: example: 2022-05-29T13:06:26.831Z
    last_modified: Optional[datetime] = None


class ContactResponse(ApiModel):
    #: "urn:cisco:codev:identity:contact:core:1.0".
    #: example: urn:cisco:codev:identity:contact:core:1.0
    schemas: Optional[str] = None
    #: Response metadata.
    meta: Optional[Meta1] = None
    #: The full name of the contact.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The first name of the contact.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the contact.
    #: example: Andersen
    last_name: Optional[str] = None
    #: The company the contact is working for.
    #: example: Cisco Systems
    company_name: Optional[str] = None
    #: The contact's title.
    #: example: GM
    title: Optional[str] = None
    #: Contact's address.
    #: example: {\"city\" : \"Milpitas\", \"country\" : \"US\", \"street\" : \"1099 Bird Ave.\", \"zipCode\" : \"99212\"}
    address: Optional[str] = None
    #: The URL to the person's avatar in PNG format.
    #: example: https://avatar-prod-us-east-2.webexcontent.com/default_avatar~1600
    avatar_url: Optional[str] = Field(alias='avatarURL', default=None)
    #: The contact's primary contact method.
    #: example: SIPADDRESS
    primary_contact_method: Optional[ContactPrimaryContactMethod] = None
    #: Where the data come from.
    #: example: Webex4Broadworks
    source: Optional[ContactSource] = None
    #: A list of the user's email addresses with an indicator of the user's primary email address.
    emails: Optional[list[ContactEmails]] = None
    #: A list of user's phone numbers with an indicator of primary to specify the user's main number.
    phone_numbers: Optional[list[ContactPhoneNumbers]] = None
    #: The sipAddress values for the user.
    sip_addresses: Optional[list[ContactSipAddresses]] = None
    #: Instant messaging addresses for the user.
    ims: Optional[list[ContactIms]] = None


class SearchResponse(ApiModel):
    #: An array of contact objects.
    result: Optional[list[ContactResponse]] = None
    #: Start at the zero-based offset in the list of matching contacts.
    start: Optional[int] = None
    #: Limit the number of contacts returned to this maximum count.
    #: example: 1000.0
    limit: Optional[int] = None
    #: Total number of contacts returned in search results.
    #: example: 1.0
    total: Optional[int] = None


class TemplateTemplateType(str, Enum):
    org = 'ORG'
    group = 'GROUP'


class Template(ApiModel):
    #: A unique identifier for a license template.
    #: example: Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: Name of the organization-level template.
    #: example: Default
    template_name: Optional[str] = None
    #: An array of license strings.
    #: example: ['Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh', 'Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi']
    licenses: Optional[list[str]] = None
    #: Specify the template type to be created. Valid values are `ORG` or `GROUP`.
    template_type: Optional[TemplateTemplateType] = None
    #: An array of group IDs associated with the template.
    #: example: ['Y2lzY29zcGFyazovL45zL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh', 'Y2lzY29zcGFyazovL3VzL0xOU0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh']
    groups: Optional[list[str]] = None


class TemplateCollectionResponse(ApiModel):
    items: Optional[list[Template]] = None


class Groups(ApiModel):
    items: Optional[list[Person]] = None


class OrganizationSupportedContentType(str, Enum):
    #: Only Webex content storage.
    native = 'native'
    #: Only ECM storage.
    external = 'external'
    #: Both Webex and ECM storage.
    hybrid = 'hybrid'


class Organization3(ApiModel):
    #: A unique identifier for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    id: Optional[str] = None
    #: Full name of the organization.
    #: example: Acme, Inc.
    display_name: Optional[str] = None
    #: The current Enterprise Content Management setting for the organization.
    #: example: hybrid
    supported_content_type: Optional[OrganizationSupportedContentType] = None
    #: The date and time the organization was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None


class OrganizationCollectionResponse(ApiModel):
    items: Optional[list[Organization3]] = None


class Organization4(ApiModel):
    #: A unique identifier for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    id: Optional[str] = None
    #: Full name of the organization.
    #: example: Acme, Inc.
    display_name: Optional[str] = None
    #: The date and time the organization was created.
    #: example: 2019-10-18T14:26:16+00:00
    created: Optional[datetime] = None
    #: The base path to xsi-actions.
    #: example: https://api-us.bcld.webex.com/com.broadsoft.xsi-actions
    xsi_actions_endpoint: Optional[str] = None
    #: The base path to xsi-events.
    #: example: https://api-us.bcld.webex.com/com.broadsoft.xsi-events
    xsi_events_endpoint: Optional[str] = None
    #: The base path to xsi-events-channel.
    #: example: https://api-us.bcld.webex.com/com.broadsoft.async/com.broadsoft.xsi-events
    xsi_events_channel_endpoint: Optional[str] = None
    #: `api-` prepended to the `bcBaseDomain` value for the organization.
    #: example: api-us.bcld.webex.com
    xsi_domain: Optional[str] = None


class OrganizationCollectionResponse1(ApiModel):
    items: Optional[list[Organization4]] = None


class Organization5(ApiModel):
    #: A unique identifier for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    id: Optional[str] = None
    #: Full name of the organization.
    #: example: Acme, Inc.
    display_name: Optional[str] = None
    #: The date and time the organization was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None


class OrganizationCollectionResponse2(ApiModel):
    items: Optional[list[Organization5]] = None


class IdentityManagedOrg(ApiModel):
    #: The org ID of the managed org.
    #: example: Y2LZY29ZCGFYAZOVL3VZL1BFT1BMRS9MNWIZNJE4NY1JOGRKLTQ3MJCTOGIYZI1MOWM0NDDMMJKWNDY
    org_id: Optional[str] = None
    #: role ID of the user to this org.
    #: example: YXRSYXMTCG9YDGFSLNBHCNRUZXIUC2FSZXNMDWXSYWRTAW4=
    role: Optional[str] = None


class PartnerAdminUser(ApiModel):
    #: The user ID of the partner admin.
    #: example: Y2LZY29ZCGFYAZOVL3VZL1BFT1BMRS9JOTYWOTZIYI1KYTRHLTQ3NZETYTC2ZI1KNDEZODQWZWVM1TQ
    id: Optional[str] = None
    #: The display name of the partner admin.
    #: example: display name
    display_name: Optional[str] = None
    #: The first name of the partner admin.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the partner admin.
    #: example: Doe
    last_name: Optional[str] = None
    #: List of emails for the partner admin.
    #: example: ['johndoe@example.com']
    emails: Optional[list[str]] = None
    #: The role of this partner admin in the given customer org.
    #: example: id_full_admin
    role_in_customer_org: Optional[str] = None


class ManagedOrgsResponse(ApiModel):
    #: An array of managed orgs objects.
    items: Optional[list[IdentityManagedOrg]] = None


class PartneradminsfororgResponse(ApiModel):
    #: An array of partner admin user details.
    items: Optional[list[PartnerAdminUser]] = None


class PersonPhoneNumbersType(str, Enum):
    #: Work phone number of the person.
    work = 'work'
    #: Work extension of the person. For the Webex Calling person, the value will have a routing prefix along with the
    #: extension.
    work_extension = 'work_extension'
    #: Mobile number of the person.
    mobile = 'mobile'
    #: FAX number of the person.
    fax = 'fax'


class PersonPhoneNumbers(ApiModel):
    #: The type of phone number.
    #: example: work
    type: Optional[PersonPhoneNumbersType] = None
    #: The phone number.
    #: example: +1 408 526 7209
    value: Optional[str] = None


class PersonAddresses(ApiModel):
    #: The type of address
    #: example: work
    type: Optional[str] = None
    #: The user's country
    #: example: US
    country: Optional[str] = None
    #: the user's locality, often city
    #: example: Milpitas
    locality: Optional[str] = None
    #: the user's region, often state
    #: example: California
    region: Optional[str] = None
    #: the user's street
    #: example: 1099 Bird Ave.
    street_address: Optional[str] = None
    #: the user's postal or zip code
    #: example: 99212
    postal_code: Optional[str] = None


class PersonStatus(str, Enum):
    #: Active within the last 10 minutes
    active = 'active'
    #: The user is in a call
    call = 'call'
    #: The user has manually set their status to "Do Not Disturb"
    do_not_disturb = 'DoNotDisturb'
    #: Last activity occurred more than 10 minutes ago
    inactive = 'inactive'
    #: The user is in a meeting
    meeting = 'meeting'
    #: The user or a Hybrid Calendar service has indicated that they are "Out of Office"
    out_of_office = 'OutOfOffice'
    #: The user has never logged in; a status cannot be determined
    pending = 'pending'
    #: The user is sharing content
    presenting = 'presenting'
    #: The users status could not be determined
    unknown = 'unknown'


class PersonInvitePending(str, Enum):
    #: The person has been invited to Webex but has not created an account
    true = 'true'
    #: An invite is not pending for this person
    false = 'false'


class PersonType(str, Enum):
    #: Account belongs to a person
    person = 'person'
    #: Account is a bot user
    bot = 'bot'
    #: Account is a `guest user
    #: <https://developer.webex.com/docs/guest-issuer>`_
    appuser = 'appuser'


class Person1(ApiModel):
    #: A unique identifier for the person.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    id: Optional[str] = None
    #: The email addresses of the person.
    #: example: ['john.andersen@example.com']
    emails: Optional[list[str]] = None
    #: Phone numbers for the person.
    phone_numbers: Optional[list[PersonPhoneNumbers]] = None
    #: The Webex Calling extension for the person. Only applies to a person with a Webex Calling license
    #: example: 133
    extension: Optional[datetime] = None
    #: The ID of the location for this person retrieved from BroadCloud.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzYzNzE1
    location_id: Optional[str] = None
    #: The full name of the person.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The nickname of the person if configured. If no nickname is configured for the person, this field will not be
    #: present.
    #: example: John
    nick_name: Optional[str] = None
    #: The first name of the person.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the person.
    #: example: Andersen
    last_name: Optional[str] = None
    #: The URL to the person's avatar in PNG format.
    #: example: https://1efa7a94ed21783e352-c62266528714497a17239ececf39e9e2.ssl.cf1.rackcdn.com/V1~54c844c89e678e5a7b16a306bc2897b9~wx29yGtlTpilEFlYzqPKag==~1600
    avatar: Optional[str] = None
    #: The ID of the organization to which this person belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None
    #: An array of role strings representing the roles to which this admin user belongs.
    #: example: ['Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh', 'Y2lzY29zcGFyazovL3VzL1JPTEUvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi']
    roles: Optional[list[str]] = None
    #: An array of license strings allocated to this person.
    #: example: ['Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh', 'Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvOTZhYmMyYWEtM2RjYy0xMWU1LWIyNjMtMGY0NTkyYWRlZmFi']
    licenses: Optional[list[str]] = None
    #: The business department the user belongs to.
    #: example: Sales
    department: Optional[str] = None
    #: A manager identifier
    #: example: John Duarte
    manager: Optional[str] = None
    #: Person Id of the manager
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80ZGEzYTI0OC05YjBhLTQxMDgtODU0NC1iNTQwMzEyZTU2M2E
    manager_id: Optional[str] = None
    #: the person's title
    #: example: GM
    title: Optional[str] = None
    #: Person's address
    addresses: Optional[list[PersonAddresses]] = None
    #: The date and time the person was created.
    #: example: 2015-10-18T14:26:16.000Z
    created: Optional[datetime] = None
    #: The date and time the person was last changed.
    #: example: 2015-10-18T14:26:16.000Z
    last_modified: Optional[datetime] = None
    #: The time zone of the person if configured. If no timezone is configured on the account, this field will not be
    #: present
    #: example: America/Denver
    timezone: Optional[str] = None
    #: The date and time of the person's last activity within Webex. This will only be returned for people within your
    #: organization or an organization you manage. Presence information will not be shown if the authenticated user
    #: has `disabled status sharing
    #: <https://help.webex.com/nkzs6wl/>`_.
    #: example: 2015-10-18T14:26:16.028Z
    last_activity: Optional[datetime] = None
    #: One or several site names where this user has a role (host or attendee)
    #: example: ['mysite.webex.com#attendee']
    site_urls: Optional[list[str]] = None
    #: The users sip addresses. Read-only.
    #: example: ['{"type": "personal-room","value": "testuser5@mycompany.webex.com","primary": false}']
    sip_addresses: Optional[list[str]] = None
    #: Identifier for intra-domain federation with other XMPP based messenger systems.
    #: example: user@example.com
    xmpp_federation_jid: Optional[str] = None
    #: The current presence status of the person. This will only be returned for people within your organization or an
    #: organization you manage. Presence information will not be shown if the authenticated user has
    #: `disabled status sharing
    #: <https://help.webex.com/nkzs6wl/>`_.
    #: example: active
    status: Optional[PersonStatus] = None
    #: Whether or not an invite is pending for the user to complete account activation. This property is only returned
    #: if the authenticated user is an admin user for the person's organization.
    #: example: false
    invite_pending: Optional[PersonInvitePending] = None
    #: Whether or not the user is allowed to use Webex. This property is only returned if the authenticated user is an
    #: admin user for the person's organization.
    #: example: true
    login_enabled: Optional[PersonInvitePending] = None
    #: The type of person account, such as person or bot.
    #: example: person
    type: Optional[PersonType] = None


class PersonCollectionResponse(ApiModel):
    #: An array of person objects.
    items: Optional[list[Person1]] = None
    #: An array of person IDs that could not be found.
    not_found_ids: Optional[list[str]] = None


class CreateAPersonPhoneNumbersType(str, Enum):
    work = 'work'


class CreateAPersonPhoneNumbers(ApiModel):
    #: The type of phone number.
    #: example: work
    type: Optional[CreateAPersonPhoneNumbersType] = None
    #: The phone number.
    #: example: 408 526 7209
    value: Optional[str] = None


class PolicyType(str, Enum):
    default = 'Default'
    #: Default policy for the org.
    default = 'default'
    #: Customized policy for an App.
    custom = 'custom'


class Policy(ApiModel):
    #: A unique identifier for the policy.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    id: Optional[str] = None
    #: The `appId` of the app to which the policy applies.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    app_id: Optional[str] = None
    #: A user-friendly name for the policy.
    #: example: Allow App 123
    name: Optional[str] = None
    #: The `orgId` of the organization to which the policy applies.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8xZWI2NWZkZi05NjQzLTQxN2YtOTk3NC1hZDcyY2FlMGUxMGY
    org_id: Optional[str] = None
    #: A policy type for the policy.
    #: example: Default
    type: Optional[PolicyType] = None
    #: The `personIds` for the people this policy applies to.
    #: example: ['Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0', 'Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0', 'Y2lzY29zcGFyazovL3VzL0NBTExTLzU0MUFFMzBFLUUyQzUtNERENi04NTM4LTgzOTRDODYzM0I3MQo']
    person_ids: Optional[list[str]] = None
    #: The policy action.
    #: example: allow
    action: Optional[ApplicationUsagePolicyAction] = None
    #: The date and time the policy was created.
    #: example: 2017-05-10T19:39:27.970Z
    created: Optional[datetime] = None


class PolicyCollectionResponse(ApiModel):
    items: Optional[list[Policy]] = None


class ListPoliciesType(str, Enum):
    default = 'default'
    custom = 'custom'


class RecordingReportSummaryObject(ApiModel):
    #: A unique identifier for the recording.
    #: example: 4f914b1dfe3c4d11a61730f18c0f5387
    recording_id: Optional[str] = None
    #: The recording's topic.
    #: example: John's Meeting
    topic: Optional[str] = None
    #: The date and time the recording started in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. the time is the record button was clicked
    #: in the meeting.
    #: example: 2019-01-27T17:40:20Z
    time_recorded: Optional[datetime] = None
    #: Site URL for the recording.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: The number of times the recording was viewed.
    #: example: 7.0
    view_count: Optional[int] = None
    #: The number of times the recording was downloaded.
    #: example: 20.0
    download_count: Optional[int] = None


class RecordingReportObject(ApiModel):
    #: A unique identifier for the recording.
    #: example: 4f914b1dfe3c4d11a61730f18c0f5387
    recording_id: Optional[str] = None
    #: The recording's topic.
    #: example: John's Meeting
    topic: Optional[str] = None
    #: The name of the person who accessed the recording.
    #: example: John Andersen
    name: Optional[str] = None
    #: The email address of the person who accessed the recording.
    #: example: john.andersen@example.com
    email: Optional[str] = None
    #: The date and time the recording was accessed in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2019-01-27T17:40:20Z
    access_time: Optional[datetime] = None
    #: Whether or not the recording was viewed by the person.
    #: example: True
    viewed: Optional[bool] = None
    #: Whether or not the recording was downloaded by the person.
    #: example: True
    downloaded: Optional[bool] = None


class RecordingAchriveSummaryObject(ApiModel):
    #: A unique identifier for the meeting archive summary.
    #: example: 7d7ea5f42b921eace05386ca24ad730e_R_1000634462
    archive_id: Optional[str] = None
    #: Recording achrive summary's service-type.
    #: example: MeetingCenter
    service_type: Optional[MeetingUsageReportObjectServiceType] = None
    #: Meeting title.
    #: example: John's Meeting
    title: Optional[str] = None
    #: The date and time in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format that when the archive was created by the system.
    #: example: 2019-01-27T17:43:24Z
    create_time: Optional[datetime] = None


class MeetingRecordingArchiveParticipant(ApiModel):
    #: An internal ID that is associated with each join.
    #: example: 28208023.0
    correlation_id: Optional[int] = None
    #: Display name for the meeting participant.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The time the participant joined the meeting.
    #: example: 2022-07-20T07:01:31Z
    joined_time: Optional[datetime] = None
    #: The time the participant left the meeting.
    #: example: 2022-07-20T07:01:31Z
    left_time: Optional[datetime] = None
    #: Email address for the meeting participant.
    #: example: john.andersen@example.com
    email: Optional[str] = None


class MeetingRecordingArchiveChat(ApiModel):
    #: Whether the type of the chat is private, public or group. Private chat is for the 1:1 chat. Public chat is for
    #: the message which is sent to all the people in the meeting. Group chat is for the message which is sent to a
    #: small group of people, like a message to the "host and presenter".
    #: example: private
    type: Optional[str] = None
    #: Display name for the sender of the chat snippet.
    #: example: John Andersen
    sender_name: Optional[str] = None
    #: Chat time for the chat snippet in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:22:34Z
    chat_time: Optional[datetime] = None
    #: Information of the receivers of the chat snippet.
    #: example: All Participants
    target: Optional[str] = None
    #: The text of the chat snippet.
    #: example: It's nice to meet you
    text: Optional[str] = None


class MeetingRecordingArchiveUser(ApiModel):
    #: An internal ID that is associated with each join.
    #: example: 28208023.0
    correlation_id: Optional[int] = None
    #: Display name for the meeting participant.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: Email address for the meeting participant.
    #: example: john.andersen@example.com
    email: Optional[str] = None


class MeetingRecordingArchivePollQuestionQuestion(ApiModel):
    #: The number of choices in the questions.
    #: example: 3.0
    choice_count: Optional[int] = None
    #: The type of the question.
    #: example: single
    type: Optional[str] = None
    #: The text of the question.
    #: example: Do you like this API?
    text: Optional[str] = None


class MeetingRecordingArchivePollAnswerSummary(ApiModel):
    #: The total number of people who selected this answer.
    #: example: 10.0
    total_respondents: Optional[int] = None
    #: Whether the answer is correct.
    #: example: True
    is_correct: Optional[bool] = None
    #: The text of the answer.
    #: example: Yes, I do.
    text: Optional[str] = None
    #: The voters among users.
    vote_users: Optional[list[MeetingRecordingArchiveUser]] = None


class MeetingRecordingArchivePollRespondent(ApiModel):
    #: An internal ID that is associated with the respondent's each join.
    #: example: 28208023.0
    correlation_id: Optional[int] = None
    #: Display name for the poll respondent.
    #: example: Alex Green
    display_name: Optional[str] = None
    #: Email address for the poll respondent.
    #: example: alex.green@example.com
    email: Optional[str] = None
    #: An array of answers to the question.
    answers: Optional[list[str]] = None


class MeetingRecordingArchivePollQuestion(ApiModel):
    #: The voters among users.
    vote_users: Optional[list[MeetingRecordingArchiveUser]] = None
    #: The poll's question.
    question: Optional[MeetingRecordingArchivePollQuestionQuestion] = None
    #: The answer summary of the archive poll.
    answer_summary: Optional[list[MeetingRecordingArchivePollAnswerSummary]] = None
    #: The question's respondents.
    respondents: Optional[list[MeetingRecordingArchivePollRespondent]] = None


class MeetingRecordingArchivePollContent(ApiModel):
    #: The total number of questions.
    #: example: 10.0
    question_count: Optional[int] = None
    #: The total number of users.
    #: example: 10.0
    user_count: Optional[int] = None
    #: The number of voters among users.
    #: example: 3.0
    voted_user_count: Optional[int] = None
    #: Poll's questions.
    questions: Optional[list[MeetingRecordingArchivePollQuestion]] = None


class MeetingRecordingArchivePoll(ApiModel):
    #: The type of the question.
    #: example: single
    type: Optional[str] = None
    #: The date and time the poll started in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:25:34Z
    start_time: Optional[datetime] = None
    #: The date and time the poll ended in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:28:34Z
    end_time: Optional[datetime] = None
    #: The content of the meeting archive poll;
    content: Optional[MeetingRecordingArchivePollContent] = None


class MeetingRecordingArchiveQAAnswer(ApiModel):
    #: The answer's response mode.
    #: example: private
    response_mode: Optional[str] = None
    #: The name of the person who answered the question.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: An internal ID that is associated with the answer's each join.
    #: example: 10947662.0
    correlation_id: Optional[int] = None
    #: The email of the person who answered the question.
    #: example: alex.green@example.com
    email: Optional[str] = None
    #: The date and time the question answered in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:52:34Z
    answer_time: Optional[datetime] = None
    #: The text of the answer.
    #: example: Yes, I am.
    text: Optional[str] = None


class MeetingRecordingArchiveQA(ApiModel):
    #: The priority of the Q and A.
    #: example: NA
    priority: Optional[str] = None
    #: Whether the type of the Q and A is private, public, or group. Private Q and A is for the 1:1 chat. Public Q and
    #: A are for the message which is sent to all the people in the meeting. Group Q and A are for the message which
    #: is sent to a small group of people, like a Q and A to "host and presenter".
    #: example: private
    type: Optional[str] = None
    #: The email of the user who asked the question.
    #: example: john.andersen@example.com`
    display_name: Optional[str] = None
    #: The date and time the question was created in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2021-07-06T09:22:34Z
    question_time: Optional[datetime] = None
    #: Information of the user who asked the question.
    #: example: All Participants
    target: Optional[str] = None
    #: The question that was asked.
    #: example: Are you ok?
    question: Optional[str] = None
    #: Question's answers.
    answers: Optional[list[MeetingRecordingArchiveQAAnswer]] = None


class SystemInfoCatalog(ApiModel):
    #: System summary.
    #: example: User Name: John{*}Operating System: Mac OS X 12.6{*}User Home Directory: /Users/John{*}Date and Time: Tue Oct 18 10:38:17 CST 2022{*}
    system_summary: Optional[str] = None
    #: The browser user agent of the person who acted.
    #: example: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
    browser: Optional[str] = None
    #: The type of hardware that the user used to attend the meeting.
    #: example: mac book
    hardware: Optional[str] = None
    #: The software that the user used to attend the meeting.
    #: example: webex
    installed_software: Optional[str] = None
    #: The software the user used that is running.
    #: example: webex
    running_software: Optional[str] = None
    #: Startup Programs.
    #: example: Macintosh HD
    startup_programs: Optional[str] = None
    #: The storage information of the user's device.
    #: example: 16 GB 2667 MHz DDR4
    storage: Optional[str] = None
    #: The video of the user's device.
    #: example: AirPlay
    video: Optional[str] = None
    #: The network of the user's device.
    #: example: Wi-Fi
    network: Optional[str] = None
    #: The operating system of the user's device.
    #: example: Mac OS X 10.0
    operating_system: Optional[str] = None
    #: The environment variables of the user's device.
    #: example: /usr/local/bin:$PATH
    environment_variables: Optional[str] = None
    #: The processes of the user's device.
    #: example: 2.6 GHz 6-Core Intel Core i7
    processes: Optional[str] = None
    #: The logical drives of the user's device.
    #: example: webapp
    logical_drives: Optional[str] = None
    #: The device of the user.
    #: example: device1
    devices: Optional[str] = None
    #: The service of the user's device.
    #: example: Firewall
    services: Optional[str] = None
    #: The system driver of the user's device.
    #: example: 32drivers
    system_drivers: Optional[str] = None
    #: The sign driver system of the user's device.
    #: example: 32drivers
    signed_drivers: Optional[str] = None
    #: The event viewer of the user's device.
    #: example: Screen Sharing
    event_viewer: Optional[str] = None
    #: The basic input and output system.
    #: example: AwardBIOS
    bios: Optional[str] = None


class MeetingRecordingArchiveSystemInfo(ApiModel):
    #: The name of the person who accessed the meeting archive.
    #: example: John Andersen
    display_name: Optional[str] = None
    #: The catalogs of system information.
    catalogs: Optional[list[SystemInfoCatalog]] = None


class RecordingArchiveReportObject(ApiModel):
    #: A unique identifier for the meeting archive summary.
    #: example: 7d7ea5f42b921eace05386ca24ad730e_R_1000634462
    archive_id: Optional[str] = None
    #: Recording achrive report's service-type.
    #: example: MeetingCenter
    service_type: Optional[MeetingUsageReportObjectServiceType] = None
    #: Meeting title.
    #: example: John's Meeting
    title: Optional[str] = None
    #: Start time for meeting in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    #: example: 2019-03-18T11:26:30Z
    start: Optional[datetime] = None
    #: End time for a meeting in ISO 8601 compliant format.
    #: example: 2019-03-18T12:26:30Z
    end: Optional[datetime] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: The participants of the meeting archive.
    participants: Optional[list[MeetingRecordingArchiveParticipant]] = None
    #: The chats of the meeting archive.
    chats: Optional[list[MeetingRecordingArchiveChat]] = None
    #: The polls of the meeting archive.
    polls: Optional[list[MeetingRecordingArchivePoll]] = None
    #: Meeting meeting archive's Q and A.
    qas: Optional[list[MeetingRecordingArchiveQA]] = None
    #: The system Information of the meeting archive, which can be only supported when serviceType is `SupportCenter`.
    system_infos: Optional[list[MeetingRecordingArchiveSystemInfo]] = None


class ListOfRecordingAuditReportSummariesResponse(ApiModel):
    #: An array of recording audit report summaries objects.
    items: Optional[list[RecordingReportSummaryObject]] = None


class GetRecordingAuditReportDetailsResponse(ApiModel):
    #: An array of recording audit report objects.
    items: Optional[list[RecordingReportObject]] = None


class ListMeetingArchiveSummariesResponse(ApiModel):
    #: An array of meeting archive summaries objects.
    items: Optional[list[RecordingAchriveSummaryObject]] = None


class RecordingObjectFormat(str, Enum):
    #: Recording file format is MP4.
    mp4 = 'MP4'
    #: Recording file format is ARF, a proprietary Webex recording format.
    arf = 'ARF'
    #: The recording file is uploaded manually.
    uploaded = 'UPLOADED'


class RecordingObject(ApiModel):
    #: A unique identifier for the recording.
    #: example: 4f914b1dfe3c4d11a61730f18c0f5387
    id: Optional[str] = None
    #: Unique identifier for the recording's ended meeting instance.
    #: example: f91b6edce9864428af084977b7c68291_I_166641849979635652
    meeting_id: Optional[str] = None
    #: Unique identifier for the recording's scheduled meeting instance.
    #: example: f91b6edce9864428af084977b7c68291_I_166641849979635652
    scheduled_meeting_id: Optional[str] = None
    #: Unique identifier for the recording's meeting series.
    #: example: f91b6edce9864428af084977b7c68291
    meeting_series_id: Optional[str] = None
    #: The recording's topic.
    #: example: John's Meeting
    topic: Optional[str] = None
    #: The date and time recording was created in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. Please note that it's not the time the
    #: record button was clicked in meeting but the time the recording file was generated offline.
    #: example: 2019-01-27T17:43:24Z
    create_time: Optional[datetime] = None
    #: The date and time recording started in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. It indicates when the record button was
    #: clicked in the meeting.
    #: example: 2019-01-27T17:40:20Z
    time_recorded: Optional[datetime] = None
    #: Site URL for the recording.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: The download link for recording. This attribute is not available if **Prevent downloading** has been turned on
    #: for the recording being requested. The **Prevent downloading** option can be viewed and set by a site admin on
    #: `Control Hub
    #: <https://help.webex.com/en-us/article/sxdj4ab/Manage-Security-for-a-Cisco-Webex-Site-in-Cisco-Webex-Control-Hub>`_.
    #: example: https://site4-example.webex.com/site4/lsr.php?RCID=60b864cc80aa5b44fc9769c8305b98b7
    download_url: Optional[str] = None
    #: The playback link for recording.
    #: example: https://site4-example.webex.com/site4/ldr.php?RCID=7a8a476b29a32cd1e06dfa6c81970f19
    playback_url: Optional[str] = None
    #: The recording's password.
    #: example: BgJep@43
    password: Optional[str] = None
    #: example: MP4
    format: Optional[RecordingObjectFormat] = None
    #: The service type for the recording.
    #: example: MeetingCenter
    service_type: Optional[MeetingUsageReportObjectServiceType] = None
    #: The duration of the recording, in seconds.
    #: example: 4472.0
    duration_seconds: Optional[int] = None
    #: The size of the recording file, in bytes.
    #: example: 248023188.0
    size_bytes: Optional[int] = None
    #: Whether or not the recording has been shared to the current user.
    share_to_me: Optional[bool] = None
    #: External keys of the parent meeting created by an integration application. They could be Zendesk ticket IDs,
    #: Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries recordings by a key in its own
    #: domain.
    integration_tags: Optional[list[str]] = None
    status: Optional[TranscriptObjectStatus] = None


class RecordingObjectForAdminAndCO(ApiModel):
    #: A unique identifier for the recording.
    #: example: 4f914b1dfe3c4d11a61730f18c0f5387
    id: Optional[str] = None
    #: Unique identifier for the recording's ended meeting instance.
    #: example: f91b6edce9864428af084977b7c68291_I_166641849979635652
    meeting_id: Optional[str] = None
    #: Unique identifier for the recording's scheduled meeting instance.
    #: example: f91b6edce9864428af084977b7c68291_I_166641849979635652
    scheduled_meeting_id: Optional[str] = None
    #: Unique identifier for the recording's meeting series.
    #: example: f91b6edce9864428af084977b7c68291
    meeting_series_id: Optional[str] = None
    #: The recording's topic.
    #: example: John's Meeting
    topic: Optional[str] = None
    #: The date and time recording was created in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. Please note that it's not the time the
    #: record button was clicked in meeting but the time the recording file was generated offline.
    #: example: 2019-01-27T17:43:24Z
    create_time: Optional[datetime] = None
    #: The date and time recording started in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. It indicates when the record button was
    #: clicked in the meeting.
    #: example: 2019-01-27T17:40:20Z
    time_recorded: Optional[datetime] = None
    #: Display name for the meeting host.
    #: example: John Andersen
    host_display_name: Optional[str] = None
    #: Email address for the meeting host.
    #: example: john.andersen@example.com
    host_email: Optional[str] = None
    #: Site URL for the recording.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: The download link for recording. This attribute is not available if **Prevent downloading** has been turned on
    #: for the recording being requested. The **Prevent downloading** option can be viewed and set by a site admin on
    #: `Control Hub
    #: <https://help.webex.com/en-us/article/sxdj4ab/Manage-Security-for-a-Cisco-Webex-Site-in-Cisco-Webex-Control-Hub>`_.
    #: example: https://site4-example.webex.com/site4/lsr.php?RCID=60b864cc80aa5b44fc9769c8305b98b7
    download_url: Optional[str] = None
    #: The playback link for recording.
    #: example: https://site4-example.webex.com/site4/ldr.php?RCID=7a8a476b29a32cd1e06dfa6c81970f19
    playback_url: Optional[str] = None
    #: The recording's password.
    #: example: BgJep@43
    password: Optional[str] = None
    #: example: MP4
    format: Optional[RecordingObjectFormat] = None
    #: The service type for the recording.
    #: example: MeetingCenter
    service_type: Optional[MeetingUsageReportObjectServiceType] = None
    #: The duration of the recording, in seconds.
    #: example: 4472.0
    duration_seconds: Optional[int] = None
    #: The size of the recording file, in bytes.
    #: example: 248023188.0
    size_bytes: Optional[int] = None
    #: Whether or not the recording has been shared to the current user.
    share_to_me: Optional[bool] = None
    #: External keys of the parent meeting created by an integration application. They could be Zendesk ticket IDs,
    #: Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries recordings by a key in its own
    #: domain.
    integration_tags: Optional[list[str]] = None
    status: Optional[TranscriptObjectStatus] = None


class RecordingObjectWithDirectDownloadLinksTemporaryDirectDownloadLinks(ApiModel):
    #: The download link for recording MP4/ARF file without HTML page rendering in browser or HTTP redirect. Expires 3
    #: hours after the API request.
    recording_download_link: Optional[str] = None
    #: The download link for recording audio file without HTML page rendering in browser or HTTP redirect. This
    #: attribute is not available if **Prevent Downloading** has been turned on for the recording being requested.
    #: Expires 3 hours after the API request.
    audio_download_link: Optional[str] = None
    #: The download link for recording transcript file without HTML page rendering in browser or HTTP redirect. This
    #: attribute is not available if **Prevent Downloading** has been turned on for the recording being requested.
    #: Expires 3 hours after the API request.
    transcript_download_link: Optional[str] = None
    #: The date and time when `recordingDownloadLink`, `audioDownloadLink`, and `transcriptDownloadLink` expire in
    #: `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
    expiration: Optional[str] = None


class RecordingObjectWithDirectDownloadLinksStatus(str, Enum):
    #: Recording is available.
    available = 'available'
    #: Recording has been moved to the recycle bin.
    deleted = 'deleted'
    #: Recording has been purged from the recycle bin. Please note that only a compliance officer can access recordings
    #: with a `purged` status.
    purged = 'purged'
    none_ = 'none'


class RecordingObjectWithDirectDownloadLinks(ApiModel):
    #: A unique identifier for recording.
    #: example: 7ee40776779243b4b3da448d941b34dc
    id: Optional[str] = None
    #: Unique identifier for the recording's ended meeting instance.
    #: example: f91b6edce9864428af084977b7c68291_I_166641849979635652
    meeting_id: Optional[str] = None
    #: Unique identifier for the recording's scheduled meeting instance.
    #: example: f91b6edce9864428af084977b7c68291_I_166641849979635652
    scheduled_meeting_id: Optional[str] = None
    #: Unique identifier for the recording's meeting series.
    #: example: f91b6edce9864428af084977b7c68291
    meeting_series_id: Optional[str] = None
    #: The recording's topic.
    #: example: John's Meeting
    topic: Optional[str] = None
    #: The date and time recording was created in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. Please note that it's not the time the
    #: record button was clicked in meeting but the time the recording file was generated offline.
    #: example: 2019-01-27T17:43:24Z
    create_time: Optional[datetime] = None
    #: The date and time recording started in `ISO 8601
    #: <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. It indicates when the record button was
    #: clicked in the meeting.
    #: example: 2019-01-27T17:40:20Z
    time_recorded: Optional[datetime] = None
    #: Site URL for the recording.
    #: example: site4-example.webex.com
    site_url: Optional[str] = None
    #: The download link for the recording. This attribute is not available if `prevent downloading` has been turned on
    #: for the recording being requested. The `prevent downloading` option can be viewed and set on page when editing
    #: a recording.
    #: example: https://site4-example.webex.com/site4/lsr.php?RCID=60b864cc80aa5b44fc9769c8305b98b7
    download_url: Optional[str] = None
    #: The playback link for recording.
    #: example: https://site4-example.webex.com/site4/ldr.php?RCID=7a8a476b29a32cd1e06dfa6c81970f19
    playback_url: Optional[str] = None
    #: The recording's password.
    #: example: BgJep@43
    password: Optional[str] = None
    #: example: MP4
    format: Optional[RecordingObjectFormat] = None
    #: example: MeetingCenter
    service_type: Optional[MeetingUsageReportObjectServiceType] = None
    #: The duration of the recording in seconds.
    #: example: 4472.0
    duration_seconds: Optional[int] = None
    #: The size of the recording file in bytes.
    #: example: 248023188.0
    size_bytes: Optional[int] = None
    #: Whether or not the recording has been shared to the current user.
    share_to_me: Optional[bool] = None
    #: The download links for MP4/ARF, audio, and transcript of the recording without HTML page rendering in browser or
    #: HTTP redirect. This attribute is not available if the user is not a `Compliance Officer
    #: <https://developer.webex.com/docs/compliance#compliance>`_ and **Prevent
    #: Downloading** has been turned on for the recording being requested. The Prevent Downloading option can be
    #: viewed and set on page when editing a recording. Note that there are various products in `Webex Suite
    #: <https://www.cisco.com/c/en/us/products/conferencing/product_comparison.html>`_ such as
    #: "Webex Meetings", "Webex Training" and "Webex Events".
    temporary_direct_download_links: Optional[RecordingObjectWithDirectDownloadLinksTemporaryDirectDownloadLinks] = None
    #: External keys of the parent meeting created by an integration application. The key can be Zendesk ticket IDs,
    #: Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries recordings by a key in its own
    #: domain.
    integration_tags: Optional[list[str]] = None
    status: Optional[RecordingObjectWithDirectDownloadLinksStatus] = None


class BulkSoftDeleteRecordingObject(ApiModel):
    #: Recording IDs for removing recordings into the recycle bin in batch. Please note that all the recording IDs
    #: should belong to the site of `siteUrl` or the user's preferred site if `siteUrl` is not specified.
    recording_ids: Optional[list[str]] = None
    #: URL of the Webex site from which the API deletes recordings. If not specified, the API deletes recordings from
    #: the user's preferred site. All available Webex sites and preferred sites of a user can be retrieved by the
    #: `Get Site List
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
    #: example: example.webex.com
    site_url: Optional[str] = None


class BulkRestoreRecordingObject(ApiModel):
    #: If not specified or `false`, restores the recordings specified by `recordingIds`. If `true`, restores all
    #: recordings from the recycle bin.
    restore_all: Optional[bool] = None
    #: Recording IDs for recovering recordings from the recycle bin in batch. Note that all the recording IDs should
    #: belong to the site of `siteUrl` or the user's preferred site if `siteUrl` is not specified.
    recording_ids: Optional[list[str]] = None
    #: URL of the Webex site from which the API restores recordings. If not specified, the API restores recordings from
    #: a user's preferred site. All available Webex sites and preferred sites of a user can be retrieved by
    #: `Get Site List
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
    #: example: example.webex.com
    site_url: Optional[str] = None


class BulkPurgeRecordingObject(ApiModel):
    #: If not specified or `false`, purges the recordings specified by `recordingIds`. If `true`, purges all recordings
    #: from the recycle bin.
    purge_all: Optional[bool] = None
    #: Recording IDs for purging recordings from the recycle bin in batch. Note that all the recording IDs should
    #: belong to the site of `siteUrl` or the user's preferred site if `siteUrl` is not specified.
    recording_ids: Optional[list[str]] = None
    #: URL of the Webex site from which the API purges recordings. If not specified, the API purges recordings from
    #: user's preferred site. All available Webex sites and preferred sites of the user can be retrieved by
    #: `Get Site List
    #: <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
    #: example: example.webex.com
    site_url: Optional[str] = None


class ListRecordingsFormat(str, Enum):
    mp4 = 'MP4'
    arf = 'ARF'


class ListRecordingsStatus(str, Enum):
    available = 'available'
    deleted = 'deleted'


class ListRecordingsResponse(ApiModel):
    #: An array of recording objects.
    items: Optional[list[RecordingObject]] = None


class ListRecordingsForAnAdminOrComplianceOfficerResponse(ApiModel):
    #: An array of recording objects.
    items: Optional[list[RecordingObjectForAdminAndCO]] = None


class ValidationRules(ApiModel):
    #: Field on which validation rule is applied
    #: example: templateId
    field: Optional[str] = None
    #: Whether the above field is required
    #: example: yes
    required: Optional[str] = None


class ValidationRulesCollection(ApiModel):
    #: An array of validation rules
    validations: Optional[list[ValidationRules]] = None


class Template2(ApiModel):
    #: Unique identifier representing a report.
    #: example: 130
    id: Optional[datetime] = None
    #: Name of the template.
    #: example: Client Version
    title: Optional[str] = None
    #: The service to which the report belongs.
    #: example: Teams
    service: Optional[str] = None
    #: Maximum date range for reports belonging to this template.
    #: example: 31.0
    max_days: Optional[int] = None
    #: Generated reports belong to which field.
    #: example: orgWithoutDate
    identifier: Optional[str] = None
    validations: Optional[ValidationRulesCollection] = None


class CDR(ApiModel):
    #: Whether the call leg was answered after a redirection. Possible values:
    #: 
    #: - Yes
    #: 
    #: - No
    #: 
    #: - Yes-PostRedirection
    #: example: Yes
    answer_indicator: Optional[str] = Field(alias='Answer indicator', default=None)
    #: The time the call was answered. Time is in UTC.
    #: example: 2020-05-14T11:01:17.551Z
    answer_time: Optional[datetime] = Field(alias='Answer time', default=None)
    #: Whether the call leg was answered. For example, in a hunt group case, some legs will be unanswered, and one will
    #: be answered.
    #: example: true
    answered: Optional[str] = Field(alias='Answered', default=None)
    #: The authorization code admin created for a location or site for users to use. Collected by the
    #: Account/Authorization Codes or Enhanced Outgoing Calling Plan services.
    #: example: 107
    authorization_code: Optional[datetime] = Field(alias='Authorization code', default=None)
    #: SIP Call ID used to identify the call. You can share the Call ID with Cisco TAC to help them pinpoint a call if
    #: necessary.
    #: example: SSE1101163211405201218829100@10.177.4.29
    call_id: Optional[str] = Field(alias='Call ID', default=None)
    #: Identifies whether the call was set up or disconnected normally. Possible values:
    #: 
    #: - Success
    #: 
    #: - Failure
    #: 
    #: - Refusal
    #: example: Success
    call_outcome: Optional[str] = Field(alias='Call outcome', default=None)
    #: Additional information about the Call outcome returned.
    #: example: Normal
    call_outcome_reason: Optional[str] = Field(alias='Call outcome reason', default=None)
    #: Indicates the time at which the call transfer service was invoked during the call. The invocation time is shown
    #: using the UTC/GMT time zone format.
    #: example: 2023-06-05T18:21:29.707Z
    call_transfer_time: Optional[datetime] = Field(alias='Call transfer Time', default=None)
    #: Type of call. For example:
    #: 
    #: - SIP_MEETING
    #: 
    #: - SIP_INTERNATIONAL
    #: 
    #: - SIP_SHORTCODE
    #: 
    #: - SIP_INBOUND
    #: 
    #: - UNKNOWN
    #: 
    #: - SIP_EMERGENCY
    #: 
    #: - SIP_PREMIUM
    #: 
    #: - SIP_ENTERPRISE
    #: 
    #: - SIP_TOLLFREE
    #: 
    #: - SIP_NATIONAL
    #: 
    #: - SIP_MOBILE
    #: example: SIP_ENTERPRISE
    call_type: Optional[str] = Field(alias='Call type', default=None)
    #: For incoming calls, the calling line ID of the user. For outgoing calls, it's the calling line ID of the called
    #: party.
    #: example: CALLEDCLIDGOESHERE
    called_line_id: Optional[str] = Field(alias='Called line ID', default=None)
    #: For incoming calls, the telephone number of the user. For outgoing calls, it's the telephone number of the
    #: called party.
    #: example: 2002
    called_number: Optional[datetime] = Field(alias='Called number', default=None)
    #: For incoming calls, the calling line ID of the calling party. For outgoing calls, it's the calling line ID of
    #: the user.
    #: example: YOURCLIDGOESHERE
    calling_line_id: Optional[str] = Field(alias='Calling line ID', default=None)
    #: For incoming calls, the telephone number of the calling party. For outgoing calls, it's the telephone number of
    #: the user.
    #: example: 2001
    calling_number: Optional[datetime] = Field(alias='Calling number', default=None)
    #: The type of client that the user (creating this record) is using to make or receive the call. For example:
    #: 
    #: - SIP
    #: 
    #: - WXC_CLIENT
    #: 
    #: - WXC_THIRD_PARTY
    #: 
    #: - TEAMS_WXC_CLIENT
    #: 
    #: - WXC_DEVICE
    #: 
    #: - WXC_SIP_GW
    #: example: SIP_TOLLFREE
    client_type: Optional[str] = Field(alias='Client type', default=None)
    #: The version of the client that the user (creating this record) is using to make or receive the call.
    #: example: 1.0.2.3
    client_version: Optional[str] = Field(alias='Client version', default=None)
    #: Correlation ID to tie together multiple call legs of the same call session.
    #: example: 8e8e1dc7-4f25-4595-b9c7-26237f824535
    correlation_id: Optional[str] = Field(alias='Correlation ID', default=None)
    #: A unique identifier for the user's department name.
    #: example: 4370c763-81ec-403b-aba3-626a7b1cf264
    department_id: Optional[str] = Field(alias='Department ID', default=None)
    #: The MAC address of the device, if known.
    #: example: 6C710D8ABC10
    device_mac: Optional[str] = Field(alias='Device MAC', default=None)
    #: The keypad digits as dialed by the user, before pre-translations.
    #: This field reports multiple call dial possibilities:
    #: 
    #: - Feature access codes (FAC) used for invoking features such as Last Number Redial or a Call Return.
    #: 
    #: - An extension that got dialed and a mis-dialed keypad digit from a device/app.
    #: 
    #: - When a user must dial an outside access code (for example, 9+) before dialing a number, this access code is
    #: also reported, as well as the digits dialed thereafter.
    #: Note that when pre-translations have no effect, the dialed digits field contains the same data as the called
    #: number field.
    #: This field is only used for originating (outgoing) Calls and is not available for terminating (incoming) Calls.
    #: example: 1246
    dialed_digits: Optional[datetime] = Field(alias='Dialed digits', default=None)
    #: Whether the call was inbound or outbound. The possible values are:
    #: 
    #: - ORIGINATING
    #: 
    #: - TERMINATING
    #: example: ORIGINATING
    direction: Optional[str] = Field(alias='Direction', default=None)
    #: The length of the call in seconds.
    #: example: 36.0
    duration: Optional[int] = Field(alias='Duration', default=None)
    #: Each call consists of four UUIDs known as Local Session ID, Final Local Session ID, Remote Session ID and Final
    #: Remote Session ID.
    #: 
    #: - The Session ID comprises a Universally Unique Identifier (UUID) for each user-agent participating in a call.
    #: 
    #: - It can be used for end-to-end tracking of a SIP session in IP-based multimedia communication systems in
    #: compliance with RFC 7206 and draft-ietf-insipid-session-id-15.
    #: 
    #: - The Local SessionID is generated from the Originating user agent.
    #: 
    #: - The Remote SessionID is generated from the Terminating user agent.
    #: 
    #: - The Final Local Session ID has the value of the Local Session ID at the end of the call.
    #: 
    #: - The Final Remote Session ID has the value of the Remote Session ID at the end of the call.
    #: example: 82bb753300105000a0000242be131609
    final_local_session_id: Optional[str] = Field(alias='Final local SessionID', default=None)
    #: Each call consists of four UUIDs known as Local Session ID, Final Local Session ID, Remote Session ID and Final
    #: Remote Session ID.
    #: 
    #: - The Session ID comprises a Universally Unique Identifier (UUID) for each user-agent participating in a call.
    #: 
    #: - It can be used for end-to-end tracking of a SIP session in IP-based multimedia communication systems in
    #: compliance with RFC 7206 and draft-ietf-insipid-session-id-15.
    #: 
    #: - The Local SessionID is generated from the Originating user agent.
    #: 
    #: - The Remote SessionID is generated from the Terminating user agent.
    #: 
    #: - The Final Local Session ID has the value of the Local Session ID at the end of the call.
    #: 
    #: - The Final Remote Session ID has the value of the Remote Session ID at the end of the call.
    #: example: cfe67b8a00105000a0000242be131609
    final_remote_session_id: Optional[str] = Field(alias='Final remote SessionID', default=None)
    #: Inbound trunk may be presented in Originating and Terminating records.
    #: example: InTrunk
    inbound_trunk: Optional[str] = Field(alias='Inbound trunk', default=None)
    #: The country code of the dialed number. This is only populated for international calls.
    #: example: US
    international_country: Optional[str] = Field(alias='International country', default=None)
    #: A unique identifier that is used to correlate CDRs and call legs with each other. This ID is used in conjunction
    #: with:
    #: 
    #: - Remote call ID: To identify the remote CDR of a call leg.
    #: 
    #: - Transfer related call ID: To identify the call transferred leg.
    #: example: 113104021:0
    local_call_id: Optional[str] = Field(alias='Local call ID', default=None)
    #: Each call consists of four UUIDs known as Local Session ID, Final Local Session ID, Remote Session ID and Final
    #: Remote Session ID.
    #: 
    #: - The Session ID comprises a Universally Unique Identifier (UUID) for each user-agent participating in a call.
    #: 
    #: - It can be used for end-to-end tracking of a SIP session in IP-based multimedia communication systems in
    #: compliance with RFC 7206 and draft-ietf-insipid-session-id-15.
    #: 
    #: - The Local SessionID is generated from the Originating user agent.
    #: 
    #: - The Remote SessionID is generated from the Terminating user agent.
    #: 
    #: - The Final Local Session ID has the value of the Local Session ID at the end of the call.
    #: 
    #: - The Final Remote Session ID has the value of the Remote Session ID at the end of the call.
    #: example: 82bb753300105000a0000242be131609
    local_session_id: Optional[str] = Field(alias='Local SessionID', default=None)
    #: Location of the report.
    #: example: Richardson
    location: Optional[str] = Field(alias='Location', default=None)
    #: The device model type the user is using to make or receive the call.
    #: example: 8851-3PCC
    model: Optional[str] = Field(alias='Model', default=None)
    #: A unique identifier that shows if other CDRs are in the same call leg. Two CDRs belong in the same call leg if
    #: they have the same Network call ID.
    #: example: BW2356451711108231501755806@10.21.0.192
    network_call_id: Optional[str] = Field(alias='Network call ID', default=None)
    #: A unique identifier for the organization that made the call. This is a unique identifier across Cisco.
    #: example: 408806bc-a013-4a4b-9a24-85e374912102
    org_uuid: Optional[str] = Field(alias='Org UUID', default=None)
    #: Call redirection reason for the original called number. For example:
    #: 
    #: - Unconditional: Call Forward Always (CFA) service, Group night forwarding.
    #: 
    #: - NoAnswer: The party was not available to take the call. CF/busy or Voicemail/busy.
    #: 
    #: - Deflection: Indication that a call was redirected. Possible causes could be Blind transfer, Auto attendant
    #: transfer, Transfer out of a Call center etc.
    #: 
    #: - TimeOfDay: Call scheduled period of automated redirection. CF/selective, group night forwarding.
    #: 
    #: - UserBusy: DND enabled or the user willingly declined the call. CF/busy or voicemail/busy.
    #: 
    #: - FollowMe: Automated redirection to a personal redirecting service which could be Simultaneous Ringing,
    #: Sequential Ringing, Office Anywhere, or Remote Office.
    #: 
    #: - CallQueue: A call center call to an agent or a user (a member of the call queue).
    #: 
    #: - HuntGroup: A hunt-group-based call to an agent or a user (denotes a member of the hunt group).
    #: 
    #: - Unavailable: To voicemail, when the user has no app or device.
    #: 
    #: - Unrecognized: Unable to determine the reason.
    #: 
    #: - Unknown: Call forward by phone with no reason.
    #: 
    #: - ExplicitIdxxx: Enterprise voice portal redirection to the users home voice portal. The xxx portion is the
    #: digits collected from the caller, identifying the target mailbox (Extension or DN).
    #: 
    #: - ImplicitId: Indicates an enterprise voice portal redirection to the users home voice portal.
    #: example: UserBusy
    original_reason: Optional[str] = Field(alias='Original reason', default=None)
    #: The operating system that the app was running on, if available.
    #: example: na
    os_type: Optional[str] = Field(alias='OS type', default=None)
    #: Outbound trunk may be presented in Originating and Terminating records.
    #: example: OutTrunk
    outbound_trunk: Optional[str] = Field(alias='Outbound trunk', default=None)
    #: The time the call was finished, in UTC.
    #: example: 2023-10-12 21:22:32.621
    release_time: Optional[datetime] = Field(alias='Release time', default=None)
    #: The length of ringing before the call was answered or timed out, in seconds.
    #: example: 23.0
    ring_duration: Optional[int] = Field(alias='Ring duration', default=None)
    #: Call Redirection Reason for the redirecting number. For example:
    #: 
    #: - Unconditional: Call Forward Always (CFA) service.
    #: 
    #: - NoAnswer: The party was not available to take the call. CF/busy or Voicemail/busy.
    #: 
    #: - Deflection: Indication that a call was redirected. Possible causes could be Blind transfer, Auto attendant
    #: transfer, Transfer out of a Call center etc.
    #: 
    #: - TimeOfDay: Call scheduled period of automated redirection. CF/Selective.
    #: 
    #: - UserBusy: DND enabled or user willingly declined the call. CF/busy or Voicemail/busy.
    #: 
    #: - FollowMe: Automated redirection to a personal redirecting service which could be Simultaneous Ringing,
    #: Sequential Ringing, Office Anywhere, or Remote Office.
    #: 
    #: - CallQueue: A call center call to an agent or a user (denotes a member of the call queue).
    #: 
    #: - HuntGroup: A hunt-group-based call to an agent or a user (denotes a member of the hunt group).
    #: 
    #: - Unavailable: To voicemail, when the user has no app or device.
    #: 
    #: - Unrecognized: Unable to determine the reason.
    #: 
    #: - Unknown: Call forward by phone with no reason.
    #: 
    #: - ExplicitIdxxx: Enterprise voice portal redirection to the users home voice portal. The xxx portion is the
    #: digits collected from the caller, identifying the target mailbox (Extension or DN).
    #: 
    #: - ImplicitId: Indicates an enterprise voice portal redirection to the users home voice portal.
    #: example: Unavailable
    redirect_reason: Optional[str] = Field(alias='Redirect reason', default=None)
    #: When the call has been redirected one or more times, this field reports the last redirecting number. Identifies
    #: who last redirected the call. Only applies to call scenarios such as transfer, call forwarded calls,
    #: simultaneous rings, etc.
    #: example: +13343822691
    redirecting_number: Optional[str] = Field(alias='Redirecting number', default=None)
    #: Call identifier of a different call that was created by this call because of a service activation. The value is
    #: the same as the Local call ID field of the related call. You can use this field to correlate multiple call legs
    #: connected through other services.
    #: example: 760583469:0
    related_call_id: Optional[str] = Field(alias='Related call ID', default=None)
    #: Indicates a trigger that led to a change in the call presence. The trigger could be for this particular call or
    #: redirected via a different call. For example:
    #: 
    #: - ConsultativeTransfer: While on a call, the call was transferred to another user by announcing it first.
    #: meaning the person was given a heads up or asked if they're interested in taking the call and then transferred.
    #: 
    #: - CallForwardSelective: Call Forward as per the defined schedule. Might be based on factors like a specific
    #: time, specific callers or to a VM. It always takes precedence over Call Forwarding.
    #: 
    #: - CallForwardAlways: Calls are unconditionally forwarded to a defined phone number or to VM.
    #: 
    #: - CallForwardNoAnswer: The party was not available to take the call.
    #: 
    #: - CallQueue: A call center call to an agent or a user (denotes a member of the call queue).
    #: 
    #: - HuntGroup: A hunt group based call to an agent or a user (denotes a member of the hunt group).
    #: 
    #: - CallPickup: The user part of a pickup group or pickup attempted by this user against a ringing call for a
    #: different user or extension.
    #: 
    #: - CalllPark: An ongoing call was parked, assigned with a parked number (not the users phone number).
    #: 
    #: - CallParkRetrieve: Call park retrieval attempt by the user, either for a different extension or against the
    #: users own extension.
    #: 
    #: - Deflection: Indication that a call was redirected. Possible causes could be Blind transfer, Auto-attendant
    #: transfer, Transfer out of a Call center, etc.
    #: 
    #: - FaxDeposit: Indicates a FAX was transmitted to the FAX service.
    #: 
    #: - PushNotificationRetrieval: Push notification feature usage indication. Means that a push notification was sent
    #: to wake up the client and get ready to receive a call.
    #: 
    #: - BargeIn: Indicates the user barged-in to someone elses call.
    #: 
    #: - VoiceXMLScriptTermination: Route Point feature usage indication.
    #: 
    #: - AnywhereLocation: Indicates call origination towards the single number reach location.
    #: 
    #: - AnywherePortal: Indicates call origination towards the user identified by the single number reach portal.
    #: 
    #: - Unrecognized: Unable to determine the reason.
    #: 
    #: - CallForwardBusy: The user willingly declined the call, or DND was enabled that then redirected the call to a
    #: defined phone number or voice mail.
    #: 
    #: - CallForwardNotReachable: Hunt group redirection for an agent who is not reachable.
    #: 
    #: - CallRetrieve: The user triggered the call retrieve option to pick up a call that was parked.
    #: 
    #: - CallRecording: The user initiated the call recording service that triggered Start/Pause/Resume/Stop recording
    #: options.
    #: 
    #: - DirectedCallPickup: Indicates this user belonged to a call pickup group who answered the call or answered when
    #: another member of the call pickup group in a location was busy.
    #: 
    #: - Executive: The user has been configured using the Executive/Executive assistant service who is allowed to
    #: handle calls on someone else's behalf. Also known as Boss-admin.
    #: 
    #: - ExecutiveAssistantInitiateCall: The user has been configured as an Executive assistant who placed or initiated
    #: the call on someone elses (Boss admin's) behalf.
    #: 
    #: - ExecutiveAssistantDivert: The user has been configured as an Executive assistant who had call forwarding
    #: enabled to a defined phone number.
    #: 
    #: - ExecutiveForward: The Executive (Boss-admin) had a call forward setting enabled to a defined number. Generally
    #: triggered when an ExecutiveAssistant did not pick a call.
    #: 
    #: - ExecutiveAssistantCallPush: The user has been configured as an Executive assistant who received a call and
    #: pushed that call out (using #63) to the Executives (Boss-admin's) number.
    #: 
    #: - Remote Office: Indicates the call was made to reach the remote location of the user.
    #: 
    #: - RoutePoint: Indicates an incoming and queued call to an agent (for incoming calls to the route point).
    #: 
    #: - SequentialRing: Indicates this user is in the list of phone numbers, which are alerted sequentially upon
    #: receiving an incoming call that matches a set of criteria.
    #: 
    #: - SimultaneousRingPersonal: Indicates this user was in the list of multiple destinations that are to ring
    #: simultaneously when any calls are received on their phone number (the first destination answered is connected).
    #: 
    #: - CCMonitoringBI: The indication that a Call Queue supervisor invoked silent monitoring.
    #: example: CallQueue
    related_reason: Optional[str] = Field(alias='Related reason', default=None)
    #: Indicates which party released the call first. The possible values are:
    #: 
    #: - Local: Used when the local user has released the call first.
    #: 
    #: - Remote: Used when the far-end party releases the call first.
    #: 
    #: - Unknown: Used when the call has partial information or is unable to gather enough information about the party
    #: who released the call. It could be because of situations like force lock or because of a session audit failure.
    #: example: Remote
    releasing_party: Optional[str] = Field(alias='Releasing party', default=None)
    #: A unique identifier that is used to correlate CDRs and call legs with each other. This ID is used in conjunction
    #: with Local call ID to identity the local CDR of a call leg.
    #: example: 113103977:0
    remote_call_id: Optional[str] = Field(alias='Remote call ID', default=None)
    #: Each call consists of four UUIDs known as Local Session ID, Final Local Session ID, Remote Session ID and Final
    #: Remote Session ID.
    #: 
    #: - The Session ID comprises a Universally Unique Identifier (UUID) for each user-agent participating in a call.
    #: 
    #: - It can be used for end-to-end tracking of a SIP session in IP-based multimedia communication systems in
    #: compliance with RFC 7206 and draft-ietf-insipid-session-id-15.
    #: 
    #: - The Local SessionID is generated from the Originating user agent.
    #: 
    #: - The Remote SessionID is generated from the Terminating user agent.
    #: 
    #: - The Final Local Session ID has the value of the Local Session ID at the end of the call.
    #: 
    #: - The Final Remote Session ID has the value of the Remote Session ID at the end of the call.
    #: example: 6bf2f47800105000a0000242be13160a
    remote_session_id: Optional[str] = Field(alias='Remote SessionID', default=None)
    #: A unique ID for this particular record. This can be used when processing records to aid in deduplication.
    #: example: 0a0c2eb7-f1f6-3326-86f9-565d2e11553d
    report_id: Optional[str] = Field(alias='Report ID', default=None)
    #: The time this report was created. Time is in UTC.
    #: example: 2020-05-14T11:01:52.723Z
    report_time: Optional[datetime] = Field(alias='Report time', default=None)
    #: If present, this field's only reported in Originating records. Route group identifies the route group used for
    #: outbound calls routed via a route group to Premises-based PSTN or an on-prem deployment integrated with Webex
    #: Calling (dial plan or unknown extension).
    #: example: RouteGrpAA
    route_group: Optional[str] = Field(alias='Route group', default=None)
    #: The main number for the user's site where the call was made or received.
    #: example: +14692281000
    site_main_number: Optional[str] = Field(alias='Site main number', default=None)
    #: Site timezone is the offset in minutes from UTC time of the user's timezone.
    #: example: -300
    site_timezone: Optional[datetime] = Field(alias='Site timezone', default=None)
    #: A unique identifier for the site associated with the call. Unique across Cisco products.
    #: example: 474d4f70-4ef5-4d52-9e1d-b207086629e0
    site_uuid: Optional[str] = Field(alias='Site UUID', default=None)
    #: This is the start time of the call, the answer time may be slightly after this. Time is in UTC.
    #: example: 2020-05-14T11:01:16.545Z
    start_time: Optional[datetime] = Field(alias='Start time', default=None)
    #: If the call is TO or FROM a mobile phone using Webex Go, the Client type will show SIP, and Sub client type will
    #: show MOBILE_NETWORK.
    #: example: MOBILE_NETWORK
    sub_client_type: Optional[str] = Field(alias='Sub client type', default=None)
    #: Call identifier of a different call that was involved in the transfer. You can share this ID with Cisco TAC to
    #: help them pinpoint parties who were involved in the call transfer.
    #: example: 2340586843:0A
    transfer_related_call_id: Optional[str] = Field(alias='Transfer related call ID', default=None)
    #: The user who made or received the call.
    #: example: John Andersen
    user: Optional[str] = Field(alias='User', default=None)
    #: Represents the E.164 number of the user generating a CDR. If the user has no number assigned to them, then their
    #: extension will be displayed instead.
    #: example: +81546668399
    user_number: Optional[str] = Field(alias='User number', default=None)
    #: The type of user (user or workspace) that made or received the call. For example:
    #: 
    #: - AutomatedAttendantVideo: Automated Attendant Video IVR group service.
    #: 
    #: - Anchor: A Webex Calling user number made or received that is integrated with Webex Contact Center. An "anchor"
    #: is created to facilitate the call routing flow between WxC and WxCC.
    #: 
    #: - BroadworksAnywhere: Single number reach (Office anywhere) service.
    #: 
    #: - VoiceMailRetrieval: Voice Mail group service.
    #: 
    #: - LocalGateway: A local gateway-based user who made or received the call.
    #: 
    #: - HuntGroup: A hunt group based service.
    #: 
    #: - GroupPaging: One way call or group page made for target users.
    #: 
    #: - User: The direct user who made or received the call.
    #: 
    #: - VoiceMailGroup: Shared voicemail or inbound FAX destination for users.
    #: 
    #: - CallCenterStandard: A call queue-based service.
    #: 
    #: - VoiceXML: Call added back to the Route Point queue after script termination.
    #: 
    #: - RoutePoint: Route Point call to an agent (for an incoming call to the routing point).
    #: 
    #: - Place: A workspace-based user who made or received the call.
    #: 
    #: - VirtuaLline: Call made or received by a virtual line user using the Multi-line option in Webex Calling.
    #: example: User
    user_type: Optional[str] = Field(alias='User type', default=None)
    #: A unique identifier for the user associated with the call. This is a unique identifier across Cisco products.
    #: example: 47f0d0c2-f05a-44cc-870d-7a3daf859c6c
    user_uuid: Optional[str] = Field(alias='User UUID', default=None)


class CDRResponse(ApiModel):
    items: Optional[list[CDR]] = None


class Report1(ApiModel):
    #: Unique identifier for the report.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mYzhjMWFhMS00OTM5LTQ2NjEtODAwMy1hYWE0MzFmZWM0ZmE
    id: Optional[str] = None
    #: Name of the template to which this report belongs.
    #: example: Bots Activity
    title: Optional[str] = None
    #: The service to which the report belongs.
    #: example: Teams
    service: Optional[str] = None
    #: The data in this report belongs to dates greater than or equal to this.
    #: example: 2020-02-23
    start_date: Optional[datetime] = None
    #: The data in this report belongs to dates smaller than or equal to this.
    #: example: 2020-03-24
    end_date: Optional[datetime] = None
    #: The site to which this report belongs to. This only exists if the report belongs to service `Webex`.
    #: example: cisco.webex.com
    site_list: Optional[str] = None
    #: Time of creation for this report.
    #: example: 2020-03-24 17:13:39
    created: Optional[datetime] = None
    #: The person who created the report.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mYzhjMWFhMS00OTM5LTQ2NjEtODAwMy1hYWE0MzFmZWM0ZmE
    created_by: Optional[str] = None
    #: Whether this report was scheduled from API or Control Hub.
    #: example: API
    scheduled_from: Optional[str] = None
    #: Completion status of this report.
    #: example: done
    status: Optional[str] = None
    #: The link from which the report can be downloaded.
    #: example: https://downloadservicebts.webex.com/api?reportId=Y2lzY29zcGFyazovL3VzL1JFUE9SVC9hZDBkMjA1NzVkYTA0NWE0OGZhZDQ3ZDk3NGFiNDFmMg
    download_url: Optional[str] = Field(alias='downloadURL', default=None)


class ReportCollectionResponse(ApiModel):
    #: An array of report objects.
    report_attributes: Optional[list[Report1]] = Field(alias='Report Attributes', default=None)


class ResourceGroupMembershipStatus(str, Enum):
    #: activation pending
    pending = 'pending'
    #: activated
    activated = 'activated'
    #: error present
    error = 'error'


class ResourceGroupMembership(ApiModel):
    #: A unique identifier for the resource group membership.
    #: example: Y2lzY29zcGFyazovL3VzL1JFU09VUkNFX0dST1VQX01FTUJFUlNISVAvcGVyc29uSWQ6bGljZW5zZUlk
    id: Optional[str] = None
    #: The resource group ID.
    #: example: Y2lzY29zcGFyazovL3VzL1JFU09VUkNFX0dST1VQL2RlZmF1bHQ
    resource_group_id: Optional[str] = None
    #: The license ID.
    #: example: Y2lzY29zcGFyazovL3VzL0xJQ0VOU0UvMWNjYmJjMTctZDYxNi00ZDc0LTg2NGItYjFmM2IwNzAxZmJhOk1TXzAzMDRjMDkzLTFjM2MtNDRlMC1iYjBhLWU1ZDE2NDM2NmQ1OQ
    license_id: Optional[str] = None
    #: The person ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The organization ID of the person.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    person_org_id: Optional[str] = None
    #: The activation status of the resource group membership.
    #: example: activated
    status: Optional[ResourceGroupMembershipStatus] = None


class ResourceGroupMembershipCollectionResponse(ApiModel):
    items: Optional[list[ResourceGroupMembership]] = None


class ResourceGroup(ApiModel):
    #: A unique identifier for the resource group.
    #: example: Y2lzY29zcGFyazovL3VzL1JFU09VUkNFX0dST1VQL2RlZmF1bHQ
    id: Optional[str] = None
    #: A user-friendly name for the resource group.
    #: example: Resource Group 1
    name: Optional[str] = None
    #: The ID of the organization to which this resource group belongs.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    org_id: Optional[str] = None


class ResourceGroupCollectionResponse(ApiModel):
    items: Optional[list[ResourceGroup]] = None


class RoleCollectionResponse(ApiModel):
    items: Optional[list[Location]] = None


class RoomTab(ApiModel):
    #: A unique identifier for the Room Tab.
    #: example: Y2lzY29zcGFyazovL3VzL01FTUJFUlNISVAvMGQwYzkxYjYtY2U2MC00NzI1LWI2ZDAtMzQ1NWQ1ZDExZWYzOmNkZTFkZDQwLTJmMGQtMTFlNS1iYTljLTdiNjU1NmQyMjA3Yg
    id: Optional[str] = None
    #: A unique identifier for the room containing the room tab.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The room type.
    #: example: group
    room_type: Optional[ECMFolderRoomType] = None
    #: User-friendly name for the room tab.
    #: example: Cisco HomePage
    display_name: Optional[str] = None
    #: Room Tab's content URL.
    #: example: https://www.cisco.com
    content_url: Optional[str] = None
    #: The person ID of the person who created this Room Tab.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    creator_id: Optional[str] = None
    #: The date and time when the Room Tab was created.
    #: example: 2015-10-18T14:26:16.203Z
    created: Optional[datetime] = None


class RoomTabsCollectionResponse(ApiModel):
    items: Optional[list[RoomTab]] = None


class Room(ApiModel):
    #: A unique identifier for the room.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    id: Optional[str] = None
    #: A user-friendly name for the room.
    #: example: Project Unicorn - Sprint 0
    title: Optional[str] = None
    #: The room type.
    #: example: group
    type: Optional[ECMFolderRoomType] = None
    #: Whether the room is moderated (locked) or not.
    #: example: True
    is_locked: Optional[bool] = None
    #: The ID for the team with which this room is associated.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vNjRlNDVhZTAtYzQ2Yi0xMWU1LTlkZjktMGQ0MWUzNDIxOTcz
    team_id: Optional[str] = None
    #: The date and time of the room's last activity.
    #: example: 2016-04-21T19:12:48.920Z
    last_activity: Optional[datetime] = None
    #: The ID of the person who created this room.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    creator_id: Optional[str] = None
    #: The date and time the room was created.
    #: example: 2016-04-21T19:01:55.966Z
    created: Optional[datetime] = None
    #: The ID of the organization which owns this room. See `Webex Data
    #: <https://developer.webex.com/docs/api/guides/compliance#webex-teams-data>`_ in the `Compliance Guide
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    owner_id: Optional[str] = None
    #: Space classification ID represents the space's current classification.  It can be attached during space creation
    #: time, and can be modified at the request of an authorized user.
    #: example: Y2lzY29zcGFyazovL3VzL0NMQVNTSUZJQ0FUSU9OL2YyMDUyZTgyLTU0ZjgtMTFlYS1hMmUzLTJlNzI4Y2U4ODEyNQ
    classification_id: Optional[str] = None
    #: Indicates when a space is in Announcement Mode where only moderators can post messages
    is_announcement_only: Optional[bool] = None
    #: A compliance officer can set a direct room as read-only, which will disallow any new information exchanges in
    #: this space, while maintaing historical data.
    is_read_only: Optional[bool] = None
    #: The room is public and therefore discoverable within the org. Anyone can find and join that room.
    #: example: True
    is_public: Optional[bool] = None
    #: Date and time when the room was made public.
    #: example: 2022-10-10T17:24:19.388Z
    made_public: Optional[datetime] = None
    #: The description of the space.
    #: example: Company Announcements
    description: Optional[str] = None


class RoomCollectionResponse(ApiModel):
    items: Optional[list[Room]] = None


class RoomMeetingDetails(ApiModel):
    #: A unique identifier for the room.
    #: example: Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    room_id: Optional[str] = None
    #: The Webex meeting URL for the room.
    #: example: https://cisco.webex.com/m/37a7d3a8-6563-487f-9577-cd029101c087
    meeting_link: Optional[str] = None
    #: The SIP address for the room.
    #: example: 201632887@cisco.webex.com
    sip_address: Optional[str] = None
    #: The Webex meeting number for the room.
    #: example: 201632887
    meeting_number: Optional[str] = None
    #: The Webex meeting ID for the room.
    #: example: c1c30b52501b4d34aa75a57bdb867853
    meeting_id: Optional[str] = None
    #: The toll-free PSTN number for the room.
    #: example: +1-866-432-9903
    call_in_toll_free_number: Optional[str] = None
    #: The toll (local) PSTN number for the room.
    #: example: +1-408-525-6800
    call_in_toll_number: Optional[str] = None


class ListRoomsSortBy(str, Enum):
    id = 'id'
    lastactivity = 'lastactivity'
    created = 'created'


class BulkUserOperationsMethod(str, Enum):
    post = 'POST'
    patch = 'PATCH'
    delete = 'DELETE'


class BulkUserOperations(ApiModel):
    #: The HTTP method of the current operation.
    #: example: PATCH
    method: Optional[BulkUserOperationsMethod] = None
    #: The resource's relative path. If the method is POST, the value must specify a resource type endpoint, for
    #: example `/Users` or `/Groups`. All other method values must specify the path to a specific resource.
    #: example: /Users/2819c223-7f76-453a-919d-413861904646
    path: Optional[str] = None
    #: The Resource JSON data as it appears for a single POST or PATCH resource operation.
    #: example: JSON text
    data: Optional[str] = None
    #: The transient identifier of a newly created resource, unique within a bulk request and created by the client.
    #: example: ytrewq
    bulk_id: Optional[str] = None


class BulkUser(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:api:messages:2.0:BulkRequest']
    schemas: Optional[list[str]] = None
    #: An integer specifying the maximum number of errors that the service provider will accept before the operation is
    #: terminated and an error response is returned.
    #: example: 99.0
    fail_on_errors: Optional[int] = None
    #: Contains a list of bulk operations for POST/PATCH/DELETE operations.
    operations: Optional[list[BulkUserOperations]] = None


class PatchGroupOperations(ApiModel):
    #: The operation to perform.
    #: example: add
    op: Optional[ModifyDeviceTagsOp] = None
    #: A string containing an attribute path describing the target of the operation.
    #: example: displayName
    path: Optional[str] = None
    #: New value.
    #: example: new attribute value
    value: Optional[str] = None


class PatchGroup1(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:api:messages:2.0:PatchOp']
    schemas: Optional[list[str]] = None
    #: A list of patch operations.
    operations: Optional[list[PatchGroupOperations]] = Field(alias='Operations', default=None)


class ManagedByObject1(ApiModel):
    #: The Organization identifier of the resource.
    #: example: d1349664-9f3d-410b-8bd3-6c31f181f14e
    org_id: Optional[str] = None
    #: The resource type.
    #: example: user
    type: Optional[str] = None
    #: The identifier of the resource.
    #: example: c5349664-9f3d-410b-8bd3-6c31f181f13d
    id: Optional[str] = None
    #: The delegated role.
    #: example: location_full_admin
    role: Optional[str] = None


class PostGroupUrnscimschemasextensionciscowebexidentity20Group(ApiModel):
    #: The identifier of this Group.
    #: example: policy
    usage: Optional[str] = None
    #: The owners of this group.
    owners: Optional[list[CustomizedQuestionForCreateMeetingOptions]] = None
    #: A list of delegates of this group.
    managed_by: Optional[list[ManagedByObject1]] = None


class GroupMemberObject(ApiModel):
    #: The identifier of the member of this Group.
    #: example: c5349664-9f3d-410b-8bd3-6c31f181f13d
    value: Optional[str] = None
    #: A label indicating the type of resource, for example user, machine, or group.
    #: example: user
    type: Optional[str] = None


class PostGroup1(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:schemas:core:2.0:Group', 'urn:scim:schemas:extension:cisco:webexidentity:2.0:Group']
    schemas: Optional[list[str]] = None
    #: A human-readable name for the Group.
    #: example: group1@example.com
    display_name: Optional[str] = None
    #: An identifier for the resource as defined by the provisioning client.
    #: example: test
    external_id: Optional[str] = None
    #: A list of members of this group.
    members: Optional[list[GroupMemberObject]] = None
    #: The Cisco extension of SCIM 2.
    urn_scim_schemas_extension_cisco_webexidentity_2_0_group: Optional[PostGroupUrnscimschemasextensionciscowebexidentity20Group] = Field(alias='urn:scim:schemas:extension:cisco:webexidentity:2.0:Group', default=None)


class GetGroupResponseMembers(ApiModel):
    #: A label indicating the type of resource, for example user, machine, or group.
    #: example: user
    type: Optional[str] = None
    #: The identifier of the member of this Group.
    #: example: c5349664-9f3d-410b-8bd3-6c31f181f13d
    value: Optional[str] = None
    #: A human-readable name for the group member.
    #: example: A user
    display: Optional[str] = None
    #: The URI corresponding to a SCIM resource that is a member of this Group.
    #: example: https://example.com/v2/Users/c5349664-9f3d-410b-8bd3-6c31f181f13d
    _ref: Optional[str] = Field(alias='$ref', default=None)


class GetGroupResponseUrnscimschemasextensionciscowebexidentity20GroupMeta(ApiModel):
    #: The ID of the organization to which this group belongs.
    #: example: e9f9ab27-0459-4cd0-bd72-089bde5a7da6
    organization_id: Optional[str] = Field(alias='organizationID', default=None)


class GetGroupResponseUrnscimschemasextensionciscowebexidentity20Group(ApiModel):
    #: The identifier of this group.
    #: example: location
    usage: Optional[str] = None
    #: The owners of this group.
    owners: Optional[list[CustomizedQuestionForCreateMeetingOptions]] = None
    #: A list of delegates of this group.
    managed_by: Optional[list[ManagedByObject1]] = None
    #: The identifier of the source.
    #: example: AD
    provision_source: Optional[str] = None
    #: Response metadata.
    meta: Optional[GetGroupResponseUrnscimschemasextensionciscowebexidentity20GroupMeta] = None


class MetaObjectResourceType(str, Enum):
    group = 'group'
    user = 'user'


class MetaObject(ApiModel):
    #: example: group
    resource_type: Optional[MetaObjectResourceType] = None
    #: The date and time the group was created.
    #: example: 2011-08-01T21:32:44.882Z
    created: Optional[datetime] = None
    #: The date and time the group was last changed.
    #: example: 2011-08-01T21:32:44.882Z
    last_modified: Optional[datetime] = None
    #: The version of the group.
    #: example: "W\/\"e180ee84f0671b1\""
    version: Optional[str] = None
    #: The resource itself.
    #: example: https://example.com/v2/Groups/e9e30dba-f08f-4109-8486-d5c6a331660a
    location: Optional[str] = None


class GetGroupResponse(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:schemas:core:2.0:Group', 'urn:scim:schemas:extension:cisco:webexidentity:2.0:Group']
    schemas: Optional[list[str]] = None
    #: A human-readable name for the group.
    #: example: group1@example.com
    display_name: Optional[str] = None
    #: A unique identifier for the group.
    #: example: cb8f48e4-5db2-496b-b43d-83d8d5a2a4b3
    id: Optional[str] = None
    #: An identifier for the resource as defined by the provisioning client.
    #: example: test
    external_id: Optional[str] = None
    #: A list of members of this group.
    members: Optional[list[GetGroupResponseMembers]] = None
    #: Response metadata.
    meta: Optional[MetaObject] = None
    #: The Cisco extention of SCIM 2
    urn_scim_schemas_extension_cisco_webexidentity_2_0_group: Optional[GetGroupResponseUrnscimschemasextensionciscowebexidentity20Group] = Field(alias='urn:scim:schemas:extension:cisco:webexidentity:2.0:Group', default=None)


class SearchGroupResponse(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:scim:schemas:extension:cisco:webexidentity:2.0:GroupMembers']
    schemas: Optional[list[str]] = None
    #: Total number of groups in search results.
    #: example: 2.0
    member_size: Optional[int] = None
    #: The total number of items in a paged result.
    #: example: 2.0
    items_per_page: Optional[int] = None
    #: Start at the one-based offset in the list of matching contacts.
    #: example: 1.0
    start_index: Optional[int] = None
    #: An array of group objects.
    resources: Optional[list[GetGroupResponse]] = Field(alias='Resources', default=None)


class GroupMemberResponseMembers(ApiModel):
    #: A label indicating the type of resource, for example user, machine, or group.
    #: example: user
    type: Optional[str] = None
    #: The identifier of the member of this Group.
    #: example: c5349664-9f3d-410b-8bd3-6c31f181f13d
    value: Optional[str] = None
    #: A human-readable name for the group member.
    #: example: A user
    display: Optional[str] = None


class GroupMemberResponse(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:api:messages:2.0:ListResponse']
    schemas: Optional[list[str]] = None
    #: A human-readable name for the group.
    #: example: group1@example.com
    display_name: Optional[str] = None
    #: Total number of groups in search results.
    #: example: 2.0
    total_results: Optional[int] = None
    #: The total number of items in a paged result.
    #: example: 2.0
    items_per_page: Optional[int] = None
    #: Start at the one-based offset in the list of matching groups.
    #: example: 1.0
    start_index: Optional[int] = None
    #: A list of members of this group.
    members: Optional[list[GroupMemberResponseMembers]] = None


class PostUserUrnietfparamsscimschemasextensionenterprise20User(ApiModel):
    #: Identifies the name of a cost center.
    #: example: costCenter 123
    cost_center: Optional[str] = None
    #: Identifies the name of an organization.
    #: example: Cisco webexidentity
    organization: Optional[str] = None
    #: Identifies the name of a division.
    #: example: division 456
    division: Optional[str] = None
    #: Identifies the name of a department.
    #: example: department 789
    department: Optional[str] = None
    #: Numeric or alphanumeric identifier assigned to a person, typically based on order of hire or association with an
    #: organization.
    #: example: 518-8888-888
    employee_number: Optional[str] = None
    #: The user's manager.
    manager: Optional[CustomizedQuestionForCreateMeetingOptions] = None


class SipAddressObjectType(str, Enum):
    enterprise = 'enterprise'


class SipAddressObject(ApiModel):
    #: The sip address value.
    #: example: sipAddress value1
    value: Optional[str] = None
    #: The type of the sipAddress.
    #: example: enterprise
    type: Optional[SipAddressObjectType] = None
    #: A human-readable description, primarily used for display purposes.
    #: example: sipAddress1 description
    display: Optional[str] = None
    #: Designate the primary sipAddress.
    #: example: True
    primary: Optional[bool] = None


class ManagedGroupObject(ApiModel):
    #: Webex Identity assigned organization identifier.
    #: example: 153ced48-d2d1-4369-86fd-9b9fade218ff
    org_id: Optional[str] = None
    #: A unique identifier for the group.
    #: example: 1929effd-b750-43d6-be0d-7dcdaac38e92
    group_id: Optional[str] = None
    #: Role in the target organization for the user.
    #: example: location_full_admin
    role: Optional[str] = None


class ManagedSitesObject(ApiModel):
    #: Managed site name.
    #: example: admintrainSiteName1.webex.com
    site_name: Optional[str] = None
    #: Role in the managed site for the user.
    #: example: full_admin
    role: Optional[str] = None


class PostUserUrnscimschemasextensionciscowebexidentity20User(ApiModel):
    #: Account status of the user.
    #: example: ['element='string' content='active' attributes={'typeAttributes': ApibArray(element='array', content=[ApibString(element='string', content='fixed', attributes=None, meta=None)], attributes=None, meta=None)} meta=None']
    account_status: Optional[list[str]] = None
    #: sipAddress values for the user.
    sip_addresses: Optional[list[SipAddressObject]] = None
    #: Organizations that the user can manage.
    managed_orgs: Optional[list[IdentityManagedOrg]] = None
    #: Groups that the user can manage.
    managed_groups: Optional[list[ManagedGroupObject]] = None
    #: Sites that the user can manage.
    managed_sites: Optional[list[ManagedSitesObject]] = None


class UserTypeObject(str, Enum):
    user = 'user'
    room = 'room'
    external_calling = 'external_calling'
    calling_service = 'calling_service'


class NameObject(ApiModel):
    #: The given name of the user, or first name in most Western languages (e.g., "Sarah" given the full name "Ms.
    #: Sarah J Henderson, III").
    #: example: Sarah
    given_name: Optional[str] = None
    #: The family name of the user, or last name in most Western languages (e.g., "Henderson" given the full name "Ms.
    #: Sarah J Henderson, III").
    #: example: Henderson
    family_name: Optional[str] = None
    #: The middle name(s) of the user (e.g., "Jane" given the full name "Ms. Sarah J Henderson, III").
    #: example: Jane
    middle_name: Optional[str] = None
    #: The honorific prefix(es) of the user, or title in most Western languages (e.g., "Ms." given the full name "Ms.
    #: Sarah J Henderson, III").
    #: example: Mr.
    honorific_prefix: Optional[str] = None
    #: The honorific suffix(es) of the user, or suffix in most Western languages (e.g., "III" given the full name "Ms.
    #: Sarah J Henderson, III").
    #: example: III
    honorific_suffix: Optional[str] = None


class PutUserPhoneNumbers(ApiModel):
    #: phone number.
    #: example: 400 123 1234
    value: Optional[str] = None
    #: We support the following types of phone numbers: 'mobile', 'work', 'fax', 'work_extension', 'alternate1',
    #: 'alternate2'.  Alternate 1 and Alternate 2 are types inherited from Webex meeting sites.
    #: example: work
    type: Optional[ContactPhoneNumbersType] = None
    #: A human-readable name, primarily used for display purposes.
    #: example: work phone number
    display: Optional[str] = None
    #: A Boolean value indicating the phone number premary status.
    #: example: True
    primary: Optional[bool] = None


class PhotoObjectType(str, Enum):
    photo = 'photo'
    thumbnail = 'thumbnail'
    resizable = 'resizable'


class PhotoObject(ApiModel):
    #: photo link.
    #: example: https://photos.example.com/profilephoto/72930000000Ccne/F
    value: Optional[str] = None
    #: The type of the photo
    #: example: photo
    type: Optional[PhotoObjectType] = None
    #: A human-readable description, primarily used for display purposes.
    #: example: photo description
    display: Optional[str] = None
    #: A Boolean value indicating the photo usage status.
    #: example: True
    primary: Optional[bool] = None


class EmailObject(ApiModel):
    #: The email address.
    #: example: user1@example.home.com
    value: Optional[str] = None
    #: The type of the email.
    #: example: home
    type: Optional[ContactEmailsType] = None
    #: A human-readable description, primarily used for display purposes.
    #: example: home email description
    display: Optional[str] = None
    #: A Boolean value indicating the email status. If the type is work and primary is true, the value must equal
    #: "userName".
    primary: Optional[bool] = None


class PostUser(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:schemas:core:2.0:User', 'urn:ietf:params:scim:schemas:extension:enterprise:2.0:User', 'urn:scim:schemas:extension:cisco:webexidentity:2.0:User']
    schemas: Optional[list[str]] = None
    #: A unique identifier for the user and is used to authenticate the user in Webex.  This attribute must be set to
    #: the user's primary email address.  No other user in Webex may have the same userName value and thus this value
    #: is required to be unique within Webex.
    #: example: user1@example.com
    user_name: Optional[str] = None
    #: The type of the user.
    #: example: user
    user_type: Optional[UserTypeObject] = None
    #: The user's business title.  Examples of a title is "Business Manager". "Senior Accountant", "Engineer" etc.
    #: example: Sales manager
    title: Optional[str] = None
    #: A boolean value of "true" or "false" indicating whether the user is active in Webex.
    #: example: True
    active: Optional[bool] = None
    #: Indicates the user's preferred language.  Acceptable values for this field are based on the `ISO-696
    #: <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
    #: with the 2 letter language code followed by an _ and then the 2 letter country code.  Examples are:
    #: 
    #: en_US : for english spoken in the United Statesfr_FR: for french spoken in France.
    #: example: en_US
    preferred_language: Optional[str] = None
    #: The user's locale which is used to represent the user's currency, time format, and numerical representations.
    #: Acceptable values for this field are based on the `ISO-696
    #: <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
    #: followed by an _ and then the 2 letter country code.  Examples are:
    #: 
    #: en_US : for English spoken in the United States or fr_FR: for French spoken in France.
    #: example: en_US
    locale: Optional[str] = None
    #: The user's time zone specified in the `IANA timezone
    #: <https://nodatime.org/timezones>`_ timezone format, for example, "America/Los_Angeles".
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: A fully qualified URL pointing to a page representing the user's online profile.
    #: example: https://jojowiki.com/Jonathan_Joestar
    profile_url: Optional[str] = None
    #: External identity.
    #: example: externalIdValue
    external_id: Optional[str] = None
    #: The value to display or show the user's name in Webex.
    #: example: Mr. Jonathan Jane Joestar, III
    display_name: Optional[str] = None
    #: A casual name of the user.  The value Bob when the user's formal name is Robert.
    #: example: JoJo
    nick_name: Optional[str] = None
    #: The components of the user's real name.
    name: Optional[NameObject] = None
    #: A list of user's phone numbers with an indicator of primary to specify the user's main number.
    phone_numbers: Optional[list[PutUserPhoneNumbers]] = None
    #: A list of photos for the user that represent a thing the user has.
    photos: Optional[list[PhotoObject]] = None
    #: User's physical mailing address.
    addresses: Optional[list[PersonAddresses]] = None
    #: A list of the user's email addresses with an indicator of the user's primary email address.  The primary email
    #: address must be the same value as the user's userName.
    emails: Optional[list[EmailObject]] = None
    #: SCIM2 enterprise extension
    urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: Optional[PostUserUrnietfparamsscimschemasextensionenterprise20User] = Field(alias='urn:ietf:params:scim:schemas:extension:enterprise:2.0:User', default=None)
    #: The Cisco extension of SCIM 2.
    urn_scim_schemas_extension_cisco_webexidentity_2_0_user: Optional[PostUserUrnscimschemasextensionciscowebexidentity20User] = Field(alias='urn:scim:schemas:extension:cisco:webexidentity:2.0:User', default=None)


class PutUser(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:schemas:core:2.0:User', 'urn:ietf:params:scim:schemas:extension:enterprise:2.0:User', 'urn:scim:schemas:extension:cisco:webexidentity:2.0:User']
    schemas: Optional[list[str]] = None
    #: A unique identifier for the user and is used to authenticate the user in Webex.  This attribute must be set to
    #: the user's primary email address.  No other user in Webex may have the same userName value and thus this value
    #: is required to b unique within Webex.
    #: example: user1Changed@example.com
    user_name: Optional[str] = None
    #: The type of the user.
    #: example: user
    user_type: Optional[UserTypeObject] = None
    #: The user's business title.  Examples of a title is "Business Manager". "Senior Accountant", "Engineer" etc.
    #: example: Sales manager
    title: Optional[str] = None
    #: A boolean value of "true" or "false" indicating whether the user is active in Webex.
    #: example: True
    active: Optional[bool] = None
    #: Indicates the user's preferred language.  Acceptable values for this field are based on the `ISO-696
    #: <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
    #: with the 2 letter language code followed by an _ and then the 2 letter country code.  Examples are:
    #: 
    #: en_US : for english spoken in the United States, fr_FR: for french spoken in France.
    #: example: en_US
    preferred_language: Optional[str] = None
    #: The user's locale which is used to represent the user's currency, time format, and numerical representations.
    #: Acceptable values for this field are based on the  `ISO-696
    #: <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
    #: followed by an _ and then the 2 letter country code.  Examples are:
    #: 
    #: en_US : for English spoken in the United States, or fr_FR: for French spoken in France.
    #: example: en_US
    locale: Optional[str] = None
    #: The user's time zone specified in the `IANA timezone
    #: <https://nodatime.org/timezones>`_ timezone format. e.g: "America/Los_Angeles".
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: A fully qualified URL pointing to a page representing the user's online profile.
    #: example: https://jojowiki.com/Jonathan_Joestar
    profile_url: Optional[str] = None
    #: External identity.
    #: example: externalIdNewValue
    external_id: Optional[str] = None
    #: The value to display or show the user's name in Webex.
    #: example: Mr. Jonathan Jane Joestar, III
    display_name: Optional[str] = None
    #: A casual name of the user.  The value Bob when the user's formal name is Robert.
    #: example: JoJo
    nick_name: Optional[str] = None
    #: A list of user's phone numbers with an indicator of primary to specify the users main number.
    phone_numbers: Optional[list[PutUserPhoneNumbers]] = None
    #: A list of photos for the user that represent a thing the user has.
    photos: Optional[list[PhotoObject]] = None
    #: A physical mailing address of user.
    addresses: Optional[list[PersonAddresses]] = None
    #: A list of the user's email addresses with an indicator of the user's primary email address.  The primary email
    #: address must be the same value as the user's userName.
    emails: Optional[list[EmailObject]] = None
    #: SCIM2 enterprise extention
    urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: Optional[PostUserUrnietfparamsscimschemasextensionenterprise20User] = Field(alias='urn:ietf:params:scim:schemas:extension:enterprise:2.0:User', default=None)
    #: cisco extention of SCIM 2
    urn_scim_schemas_extension_cisco_webexidentity_2_0_user: Optional[PostUserUrnscimschemasextensionciscowebexidentity20User] = Field(alias='urn:scim:schemas:extension:cisco:webexidentity:2.0:User', default=None)


class ManagerResponseObject(ApiModel):
    #: Webex Identity assigned user identifier of the user's manager. The manager must be in the same org as the user.
    #: example: b5717a4a-0169-43b2-ac3c-db20ba4e72cd
    value: Optional[str] = None
    #: The value to display or show the manager's name in Webex.
    #: example: Identity Administrator
    display_name: Optional[str] = None
    #: The URI corresponding to a SCIM user that is the manager.
    #: example: http://integration.webexapis.com/identity/scim/0ae87ade-8c8a-4952-af08-318798958d0c/v2/Users/b5717a4a-0169-43b2-ac3c-db20ba4e72cd
    _ref: Optional[str] = Field(alias='$ref', default=None)


class GetUserResponseUrnietfparamsscimschemasextensionenterprise20User(ApiModel):
    #: Identifies the name of a cost center.
    #: example: costCenter 123
    cost_center: Optional[str] = None
    #: Identifies the name of an organization.
    #: example: Cisco webexidentity
    organization: Optional[str] = None
    #: Identifies the name of a division.
    #: example: division 456
    division: Optional[str] = None
    #: Identifies the name of a department.
    #: example: department 789
    department: Optional[str] = None
    #: Numeric or alphanumeric identifier assigned to a person, typically based on order of hire or association with an
    #: organization.
    #: example: 518-8888-888
    employee_number: Optional[str] = None
    #: The user's manager.
    manager: Optional[ManagerResponseObject] = None


class GetUserResponse(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:schemas:core:2.0:User', 'urn:ietf:params:scim:schemas:extension:enterprise:2.0:User', 'urn:scim:schemas:extension:cisco:webexidentity:2.0:User']
    schemas: Optional[list[str]] = None
    #: Webex Identity assigned user identifier.
    #: example: 3426a8e3-d414-4bf0-a493-4f6787632a13
    id: Optional[str] = None
    #: A unique identifier for the user and is used to authenticate the user in Webex.  This attribute must be set to
    #: the user's primary email address.  No other user in Webex may have the same userName value and thus this value
    #: is required to be unique within Webex.
    #: example: user1@example.com
    user_name: Optional[str] = None
    #: A boolean value of "true" or "false" indicating whether the user is active in Webex.
    #: example: True
    active: Optional[bool] = None
    #: The components of the user's real name.
    name: Optional[NameObject] = None
    #: The value to display or show the user's name in Webex.
    #: example: Mr. Jonathan Jane Joestar, III
    display_name: Optional[str] = None
    #: A casual name of the user.  The value Bob when the user's formal name is Robert.
    #: example: JoJo
    nick_name: Optional[str] = None
    #: A list of the user's email addresses with an indicator of the user's primary email address.  The primary email
    #: address must be the same value as the user's userName.
    emails: Optional[list[EmailObject]] = None
    #: The type of the user.
    #: example: user
    user_type: Optional[UserTypeObject] = None
    #: A fully qualified URL pointing to a page representing the user's online profile.
    #: example: https://jojowiki.com/Jonathan_Joestar
    profile_url: Optional[str] = None
    #: The user's business title.  Examples of a title is "Business Manager". "Senior Accountant", "Engineer" etc.
    #: example: Sales manager
    title: Optional[str] = None
    #: Indicates the user's preferred language.  Acceptable values for this field are based on the `ISO-696
    #: <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
    #: with the 2 letter language code followed by an _ and then the 2 letter country code.  Examples are:
    #: 
    #: en_US : for english spoken in the United Statesfr_FR: for french spoken in France.
    #: example: en_US
    preferred_language: Optional[str] = None
    #: The user's locale which is used to represent the user's currency, time format, and numerical representations.
    #: Acceptable values for this field are based on the `ISO-696
    #: <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
    #: followed by an _ and then the 2 letter country code.  Examples are:
    #: 
    #: en_US : for English spoken in the United States or fr_FR: for French spoken in France.
    #: example: en_US
    locale: Optional[str] = None
    #: External identity.
    #: example: externalIdValue
    external_id: Optional[str] = None
    #: The user's time zone specified in the `IANA timezone
    #: <https://nodatime.org/timezones>`_ timezone format, for example, "America/Los_Angeles".
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: A list of user's phone numbers with an indicator of primary to specify the user's main number.
    phone_numbers: Optional[list[PutUserPhoneNumbers]] = None
    #: A list of photos for the user that represent a thing the user has.
    photos: Optional[list[PhotoObject]] = None
    #: User's physical mailing address.
    addresses: Optional[list[PersonAddresses]] = None
    #: SCIM2 enterprise extension
    urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: Optional[GetUserResponseUrnietfparamsscimschemasextensionenterprise20User] = Field(alias='urn:ietf:params:scim:schemas:extension:enterprise:2.0:User', default=None)
    #: The Cisco extension of SCIM 2.
    urn_scim_schemas_extension_cisco_webexidentity_2_0_user: Optional[PostUserUrnscimschemasextensionciscowebexidentity20User] = Field(alias='urn:scim:schemas:extension:cisco:webexidentity:2.0:User', default=None)


class RoleObjectType(str, Enum):
    #: Webex Identity roles: "id_full_admin", "id_user_admin", "id_readonly_admin", "id_device_admin".
    cirole = 'cirole'
    #: service registered role.
    servicerole = 'servicerole'


class RoleObject(ApiModel):
    #: The role value.
    #: example: id_full_admin
    value: Optional[str] = None
    #: The type of the role.
    #: example: cirole
    type: Optional[RoleObjectType] = None
    #: A human-readable description, primarily used for display purposes.
    #: example: role description
    display: Optional[str] = None


class SearchUserResponse(ApiModel):
    #: Input JSON schemas.
    #: example: ['urn:ietf:params:scim:api:messages:2.0:ListResponse']
    schemas: Optional[list[str]] = None
    #: Total number of users in search results.
    #: example: 2.0
    total_results: Optional[int] = None
    #: The total number of items in a paged result.
    #: example: 2.0
    items_per_page: Optional[int] = None
    #: Start at the one-based offset in the list of matching users.
    #: example: 1.0
    start_index: Optional[int] = None
    #: A list of users with details.
    resources: Optional[list[GetUserResponse]] = Field(alias='Resources', default=None)


class SecurityAuditEventData(ApiModel):
    #: The display name of the organization.
    #: example: Acme Inc.
    actor_org_name: Optional[str] = None
    #: A description for the event.
    #: example: An Admin logged in
    event_description: Optional[str] = None
    #: The name of the person who performed the action.
    #: example: Joe Smith
    actor_name: Optional[str] = None
    #: The email of the person who performed the action.
    #: example: joe@example.com
    actor_email: Optional[str] = None
    #: The browser user agent of the person who performed the action.
    #: example: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
    actor_user_agent: Optional[str] = None
    #: A tracking identifier for the event.
    #: example: ATLAS_6f23a878-bcd4-c204-a4db-e701b42b0e5c_0
    tracking_id: Optional[str] = None
    #: The category of resource changed by the event.
    #: example: LOGINS
    event_category: Optional[str] = None
    #: The IP address of the person who performed the action.
    #: example: 128.107.241.191
    actor_ip: Optional[str] = None
    #: A more detailed description of the change made by the person.
    #: example: Joe Smith logged into organization Acme Inc.
    action_text: Optional[str] = None


class SecurityAuditEvent(ApiModel):
    data: Optional[SecurityAuditEventData] = None
    #: The date and time the event took place.
    #: example: 2019-01-02T16:58:36.845Z
    created: Optional[datetime] = None
    #: The `orgId` of the person who made the change.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    actor_org_id: Optional[str] = None
    #: A unique identifier for the event.
    #: example: MjQ0ODhiZTYtY2FiMS00ZGRkLTk0NWQtZDFlYjkzOGQ4NGUy
    id: Optional[str] = None
    #: The `personId` of the person who made the change.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS82ZWVmOGE4ZS1lNzg3LTQzMWUtOWM3ZC1hOGVjZmU1MjM5Nzc
    actor_id: Optional[str] = None


class SecurityAuditEventCollectionResponse(ApiModel):
    #: array of monitoring Audit events
    items: Optional[list[SecurityAuditEvent]] = None


class GetMeetingConfigurationCommonSettingObjectSiteOptions(ApiModel):
    #: Allow hosts to change their Personal Room URLs.
    allow_custom_personal_room_url: Optional[bool] = Field(alias='allowCustomPersonalRoomURL', default=None)


class GetMeetingConfigurationCommonSettingObjectTelephonyConfig(ApiModel):
    #: Whether call-in teleconferencing for sessions was enabled.
    allow_call_in: Optional[bool] = None
    #: Whether call-back teleconferencing for sessions was enabled.
    allow_call_back: Optional[bool] = None
    #: Whether other teleconferencing for sessions was enabled.
    allow_other_teleconf: Optional[bool] = None
    #: Whether toll-free call-in teleconferencing was enabled.
    allow_toll_free_callin: Optional[bool] = None
    #: Whether international call-in teleconferencing was enabled.
    allow_international_callin: Optional[bool] = None
    #: Whether international call-back teleconferencing was enabled.
    allow_international_callback: Optional[bool] = None
    #: Whether Voice Over IP functionality using the attendee computer's speakers and microphones was enabled.
    vo_ip: Optional[bool] = Field(alias='VoIP', default=None)


class GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptionsEntryAndExitTone(str, Enum):
    #: No tone.
    no_tone = 'NoTone'
    #: Beep.
    beep = 'Beep'
    #: Announce name.
    announce_name = 'AnnounceName'


class GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptionsTelephonySupport(str, Enum):
    #: None.
    none_ = 'None'
    #: Webex teleconferencing.
    webex_teleconferencing = 'WebexTeleconferencing'
    #: Other Teleconferencing.
    other = 'Other'


class GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptions(ApiModel):
    #: Determines if a sound is made when someone enters or exits.
    #: example: Beep
    entry_and_exit_tone: Optional[GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptionsEntryAndExitTone] = None
    #: Specifies whether or not joining teleconference without pressing 1 is checked by default.
    join_teleconf_not_press1: Optional[bool] = None
    #: Specifies the type of teleconference support for meetings.
    #: example: WebexTeleconferencing
    telephony_support: Optional[GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptionsTelephonySupport] = None
    #: Specifies whether toll-free call-in is available.
    toll_free: Optional[bool] = None
    #: Denotes if VoIP protocols are being used.
    vo_ip: Optional[bool] = Field(alias='VoIP', default=None)


class GetMeetingConfigurationCommonSettingObjectScheduleMeetingOptions(ApiModel):
    #: Determines if email reminders are to be sent out.
    email_reminders: Optional[bool] = None


class GetMeetingConfigurationCommonSettingObjectSecurityOptionsPasswordCriteria(ApiModel):
    #: Determines if a password requires mixed case.
    mixed_case: Optional[bool] = None
    #: Sets the minimum password length.
    #: example: 8.0
    min_length: Optional[int] = None
    #: Sets the minimum number of numeric characters in the password.
    #: example: 2.0
    min_numeric: Optional[int] = None
    #: Sets the minimum number of alphabetical characters in the password.
    #: example: 4.0
    min_alpha: Optional[int] = None
    #: Sets the minimum number of special characters in the password.
    #: example: 1.0
    min_special: Optional[int] = None
    #: Do not allow dynamic web page text for meeting passwords (like site name, host's name, username, meeting topic).
    disallow_dynamic_web_text: Optional[bool] = None
    #: Specifies if passwords from the `disallowValues` list are to be allowed.
    disallow_list: Optional[bool] = None
    #: Sets password values that are not allowed.
    disallow_values: Optional[list[str]] = None


class GetMeetingConfigurationCommonSettingObjectSecurityOptions(ApiModel):
    #: Allow attendees or panelists to join before the host.
    join_before_host: Optional[bool] = None
    #: Allows attendees or panelists to join the teleconference before the host.
    audio_before_host: Optional[bool] = None
    #: Allows first attendee or panelist as the presenter.
    first_attendee_as_presenter: Optional[bool] = None
    #: Specifies that all meetings must be unlisted.
    unlist_all_meetings: Optional[bool] = None
    #: Determines if a user must login before getting site access.
    require_login_before_access: Optional[bool] = None
    #: Allow screen capture (Android devices only).
    allow_mobile_screen_capture: Optional[bool] = None
    #: Determines if strict passwords are required for meetings.
    require_strong_password: Optional[bool] = None
    #: Criteria of a strong password.
    password_criteria: Optional[GetMeetingConfigurationCommonSettingObjectSecurityOptionsPasswordCriteria] = None


class GetMeetingConfigurationCommonSettingObject(ApiModel):
    #: Site Options on Webex Administration.
    site_options: Optional[GetMeetingConfigurationCommonSettingObjectSiteOptions] = None
    #: Telephony Configuration on WebEx Super Admin (These options are read-only, unable to update by Update Common
    #: Settings API).
    telephony_config: Optional[GetMeetingConfigurationCommonSettingObjectTelephonyConfig] = None
    #: Default Scheduler Options on Webex Administration (These options are applied to the site as defaults, but
    #: individual users can change them).
    default_scheduler_options: Optional[GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptions] = None
    #: Schedule Meeting Options on Webex Administration.
    schedule_meeting_options: Optional[GetMeetingConfigurationCommonSettingObjectScheduleMeetingOptions] = None
    #: Security Options on Webex Administration.
    security_options: Optional[GetMeetingConfigurationCommonSettingObjectSecurityOptions] = None


class UpdateMeetingConfigurationCommonSettingObject(ApiModel):
    #: Site Options on Webex Administration.
    site_options: Optional[GetMeetingConfigurationCommonSettingObjectSiteOptions] = None
    #: Default Scheduler Options on Webex Administration (These options are applied to the site as defaults, but
    #: individual users can change them).
    default_scheduler_options: Optional[GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptions] = None
    #: Schedule Meeting Options on Webex Administration.
    schedule_meeting_options: Optional[GetMeetingConfigurationCommonSettingObjectScheduleMeetingOptions] = None
    #: Security Options on Webex Administration.
    security_options: Optional[GetMeetingConfigurationCommonSettingObjectSecurityOptions] = None


class TagsObj(ApiModel):
    #: Name of the tag.
    #: example: Tag name
    name: Optional[str] = None
    #: Description of the tag
    #: example: Tag description
    description: Optional[str] = None


class TagsRequest(ApiModel):
    #: An array of tags.
    tags: Optional[list[TagsObj]] = None


class CustomerTagsResponse(ApiModel):
    #: Name of the customer organization.
    #: example: Customer Name
    org_name: Optional[str] = None
    #: The unique identifier for the customer organization.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    org_id: Optional[str] = None
    #: An array of tags.
    #: example: ['Tags1', 'Tags2']
    tags: Optional[list[str]] = None


class SubscriptionTagsResponse(ApiModel):
    #: Name of the customer organization.
    #: example: Customer Name
    org_name: Optional[str] = None
    #: The unique identifier for the customer organization.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    org_id: Optional[str] = None
    #: An array of tags.
    #: example: ['Tags1,Tags2']
    tags: Optional[list[str]] = None
    #: The unique identifier for the subscription.
    #: example: Sub119911
    subscription_id: Optional[str] = None
    #: boolean flag for trial or not.
    #: example: false
    trial: Optional[str] = None


class TeamMembership(ApiModel):
    #: A unique identifier for the team membership.
    #: example: Y2lzY29zcGFyazovL3VzL1RFQU1fTUVNQkVSU0hJUC8wZmNmYTJiOC1hZGNjLTQ1ZWEtYTc4Mi1lNDYwNTkyZjgxZWY6MTNlMThmNDAtNDJmYy0xMWU2LWE5ZDgtMjExYTBkYzc5NzY5
    id: Optional[str] = None
    #: The team ID.
    #: example: Y2lzY29zcGFyazovL3VzL1RFQU0vMTNlMThmNDAtNDJmYy0xMWU2LWE5ZDgtMjExYTBkYzc5NzY5
    team_id: Optional[str] = None
    #: The person ID.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the person.
    #: example: john.andersen@example.com
    person_email: Optional[str] = None
    #: The display name of the person.
    #: example: John Andersen
    person_display_name: Optional[str] = None
    #: The organization ID of the person.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    person_org_id: Optional[str] = None
    #: Whether or not the participant is a team moderator.
    #: example: True
    is_moderator: Optional[bool] = None
    #: The date and time when the team membership was created.
    #: example: 2015-10-18T14:26:16.203Z
    created: Optional[datetime] = None


class TeamMembershipCollectionResponse(ApiModel):
    items: Optional[list[TeamMembership]] = None


class Team(ApiModel):
    #: A unique identifier for the team.
    #: example: Y2lzY29zcGFyazovL3VzL1RFQU0vMTNlMThmNDAtNDJmYy0xMWU2LWE5ZDgtMjExYTBkYzc5NzY5
    id: Optional[str] = None
    #: A user-friendly name for the team.
    #: example: Build Squad
    name: Optional[str] = None
    #: The teams description.
    #: example: The A Team
    description: Optional[str] = None
    #: The date and time the team was created.
    #: example: 2015-10-18T14:26:16.000Z
    created: Optional[datetime] = None


class TeamCollectionResponse(ApiModel):
    items: Optional[list[Team]] = None


class ReadTheListOfUcManagerProfilesResponse(ApiModel):
    #: Array of manager profiles.
    calling_profiles: Optional[list[Location]] = None


class CallQueueObject1(ApiModel):
    #: Indicates the Call Queue's unique identifier.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUVVFVUUvMjE3ZDU3YmEtOTMxYi00ZjczLTk1Y2EtOGY3MWFhYzc4MTE5
    id: Optional[str] = None
    #: Indicates the Call Queue's name.
    #: example: SalesQueue
    name: Optional[str] = None
    #: When not null, indicates the Call Queue's phone number.
    #: example: 4255558100
    phone_number: Optional[str] = None
    #: When not null, indicates the Call Queue's extension number.
    #: example: 8100
    extension: Optional[datetime] = None


class AgentAvaliableCallQueueIdList1(ApiModel):
    #: Indicates a list of Call Queues that the agent belongs and are available to be selected as the Caller ID for
    #: outgoing calls. It is empty when the agent's Call Queues have disabled the Call Queue outgoing phone number
    #: setting to be used as Caller ID. In the case where this setting is enabled the array will be populated.
    available_queues: Optional[list[CallQueueObject1]] = None


class AgentCallQueueId1(ApiModel):
    #: When true, indicates that this agent is using the `selectedQueue` for its Caller ID. When false, indicates that
    #: it is using the agent's configured Caller ID.
    #: example: True
    queue_caller_id_enabled: Optional[bool] = None
    #: Indicates agent's choice of using this queue's Caller ID for outgoing calls. It is empty object when
    #: `queueCallerIdEnabled` is false. When `queueCallerIdEnabled` is true this data must be populated.
    selected_queue: Optional[CallQueueObject1] = None


class ApplicationsSetting(ApiModel):
    #: When `true`, indicates to ring devices for outbound Click to Dial calls.
    #: example: True
    ring_devices_for_click_to_dial_calls_enabled: Optional[bool] = None
    #: When `true`, indicates to ring devices for inbound Group Pages.
    #: example: True
    ring_devices_for_group_page_enabled: Optional[bool] = None
    #: When `true`, indicates to ring devices for Call Park recalled.
    #: example: True
    ring_devices_for_call_park_enabled: Optional[bool] = None
    #: Indicates that the browser Webex Calling application is enabled for use.
    #: example: True
    browser_client_enabled: Optional[bool] = None
    #: Device ID of WebRTC client. Returns only if `browserClientEnabled` is true.
    #: example: Y2lzY29zcGFyazovL3VzL0FQUExJQ0FUSU9OLzQyNDM3YzY5LTBlNmYtNGMxZS1iMTJhLTFjNGYxZTk5NDRjMA
    browser_client_id: Optional[str] = None
    #: Indicates that the desktop Webex Calling application is enabled for use.
    #: example: True
    desktop_client_enabled: Optional[bool] = None
    #: Device ID of Desktop client. Returns only if `desktopClientEnabled` is true.
    #: example: Y2lzY29zcGFyazovL3VzL0FQUExJQ0FUSU9OL2IwOWYzMDlhLTY0NDItNDRiYi05OGI2LWEzNTEwYjFhNTJmZg
    desktop_client_id: Optional[str] = None
    #: Indicates that the tablet Webex Calling application is enabled for use.
    #: example: True
    tablet_client_enabled: Optional[bool] = None
    #: Indicates that the mobile Webex Calling application is enabled for use.
    #: example: True
    mobile_client_enabled: Optional[bool] = None
    #: Number of available device licenses for assigning devices/apps.
    #: example: 35.0
    available_line_count: Optional[int] = None


class ApplicationsSettingPut(ApiModel):
    #: When `true`, indicates to ring devices for outbound Click to Dial calls.
    #: example: True
    ring_devices_for_click_to_dial_calls_enabled: Optional[bool] = None
    #: When `true`, indicates to ring devices for inbound Group Pages.
    #: example: True
    ring_devices_for_group_page_enabled: Optional[bool] = None
    #: When `true`, indicates to ring devices for Call Park recalled.
    #: example: True
    ring_devices_for_call_park_enabled: Optional[bool] = None
    #: Indicates that the browser Webex Calling application is enabled for use.
    #: example: True
    browser_client_enabled: Optional[bool] = None
    #: Indicates that the desktop Webex Calling application is enabled for use.
    #: example: True
    desktop_client_enabled: Optional[bool] = None
    #: Indicates that the tablet Webex Calling application is enabled for use.
    #: example: True
    tablet_client_enabled: Optional[bool] = None
    #: Indicates that the mobile Webex Calling application is enabled for use.
    #: example: True
    mobile_client_enabled: Optional[bool] = None


class AvailableSharedLineMemberItem1(ApiModel):
    #: A unique member identifier.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85ODhiYTQyOC0zMjMyLTRmNjItYjUyNS1iZDUzZmI4Nzc0MWE
    id: Optional[str] = None
    #: First name of member.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of member.
    #: example: Doe
    last_name: Optional[str] = None
    #: Phone number of member. Currently, E.164 format is not supported.
    #: example: 1234567890
    phone_number: Optional[str] = None
    #: Phone extension of member.
    #: example: 0000
    extension: Optional[str] = None
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    #: example: SHARED_CALL_APPEARANCE
    line_type: Optional[LineType] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class AvailableSharedLineMemberList1(ApiModel):
    members: Optional[list[AvailableSharedLineMemberItem1]] = None


class BargeInInfo(ApiModel):
    #: Indicates if the Barge In feature is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Indicates that a stutter dial tone will be played when a person is barging in on the active call.
    tone_enabled: Optional[bool] = None


class CallForwardingInfoCallForwardingNoAnswer(ApiModel):
    #: "No Answer" call forwarding is enabled or disabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Destination for "No Answer" call forwarding.
    #: example: 2225551212
    destination: Optional[str] = None
    #: Number of rings before the call will be forwarded if unanswered.
    #: example: 3.0
    number_of_rings: Optional[int] = None
    #: System-wide maximum number of rings allowed for `numberOfRings` setting.
    #: example: 15.0
    system_max_number_of_rings: Optional[int] = None
    #: Indicates the enabled or disabled state of sending incoming calls to destination number's voicemail if the
    #: destination is an internal phone number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool] = None


class CallForwardingInfoCallForwarding(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[CallForwardSettingsGetCallForwardingAlways] = None
    #: Settings for forwarding all incoming calls to the destination you chose while the phone is in use or the person
    #: is busy.
    busy: Optional[GetHuntGroupCallPolicyObjectBusinessContinuity] = None
    #: Settings for forwarding which only occurs when you are away or not answering your phone.
    no_answer: Optional[CallForwardingInfoCallForwardingNoAnswer] = None


class CallForwardingInfo(ApiModel):
    #: Settings related to "Always", "Busy", and "No Answer" call forwarding.
    call_forwarding: Optional[CallForwardingInfoCallForwarding] = None
    #: Settings for sending calls to a destination of your choice if your phone is not connected to the network for any
    #: reason, such as power outage, failed Internet connection, or wiring problem.
    business_continuity: Optional[GetHuntGroupCallPolicyObjectBusinessContinuity] = None


class CallForwardingPutCallForwardingNoAnswer(ApiModel):
    #: "No Answer" call forwarding is enabled or disabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Destination for "No Answer" call forwarding.
    #: example: 2225551212
    destination: Optional[str] = None
    #: Number of rings before the call will be forwarded if unanswered.
    #: example: 3.0
    number_of_rings: Optional[int] = None
    #: Enables and disables sending incoming to destination number's voicemail if the destination is an internal phone
    #: number and that number has the voicemail service enabled.
    destination_voicemail_enabled: Optional[bool] = None


class CallForwardingPutCallForwarding(ApiModel):
    #: Settings for forwarding all incoming calls to the destination you choose.
    always: Optional[CallForwardSettingsGetCallForwardingAlways] = None
    #: Settings for forwarding all incoming calls to the destination you chose while the phone is in use or the person
    #: is busy.
    busy: Optional[GetHuntGroupCallPolicyObjectBusinessContinuity] = None
    #: Settings for forwarding which only occurs when you are away or not answering your phone.
    no_answer: Optional[CallForwardingPutCallForwardingNoAnswer] = None


class CallForwardingPut(ApiModel):
    #: Settings related to "Always", "Busy", and "No Answer" call forwarding.
    call_forwarding: Optional[CallForwardingPutCallForwarding] = None
    #: Settings for sending calls to a destination of your choice if your phone is not connected to the network for any
    #: reason, such as a power outage, failed Internet connection, or wiring problem.
    business_continuity: Optional[GetHuntGroupCallPolicyObjectBusinessContinuity] = None


class CallInterceptInfoIncomingAnnouncements(ApiModel):
    #: `DEFAULT` indicates that a system default message will be placed when incoming calls are intercepted.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Filename of custom greeting; will be an empty string if no custom greeting has been uploaded.
    #: example: incoming.wav
    filename: Optional[str] = None
    #: Information about the new number announcement.
    new_number: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Information about how the call will be handled if zero (0) is pressed.
    zero_transfer: Optional[GetLocationVoicemailGroupObjectNotifications] = None


class CallInterceptInfoIncoming(ApiModel):
    #: `INTERCEPT_ALL` indicated incoming calls are intercepted.
    #: example: INTERCEPT_ALL
    type: Optional[GetLocationInterceptObjectIncomingType] = None
    #: If `true`, the destination will be the person's voicemail.
    voicemail_enabled: Optional[bool] = None
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    announcements: Optional[CallInterceptInfoIncomingAnnouncements] = None


class CallInterceptInfo(ApiModel):
    #: `true` if call intercept is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    incoming: Optional[CallInterceptInfoIncoming] = None
    #: Settings related to how outgoing calls are handled when the intercept feature is enabled.
    outgoing: Optional[GetLocationInterceptObjectOutgoing] = None


class CallInterceptPutIncomingAnnouncements(ApiModel):
    #: `DEFAULT` indicates that a system default message will be placed when incoming calls are intercepted.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Information about the new number announcement.
    new_number: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Information about how call will be handled if zero (0) is pressed.
    zero_transfer: Optional[GetLocationVoicemailGroupObjectNotifications] = None


class CallInterceptPutIncoming(ApiModel):
    #: `INTERCEPT_ALL` indicated incoming calls are intercepted.
    #: example: INTERCEPT_ALL
    type: Optional[GetLocationInterceptObjectIncomingType] = None
    #: If `true`, the destination will be the person's voicemail.
    voicemail_enabled: Optional[bool] = None
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    announcements: Optional[CallInterceptPutIncomingAnnouncements] = None


class CallInterceptPut(ApiModel):
    #: `true` if the intercept feature is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Settings related to how incoming calls are handled when the intercept feature is enabled.
    incoming: Optional[CallInterceptPutIncoming] = None
    #: Settings related to how outgoing calls are handled when the intercept feature is enabled.
    outgoing: Optional[GetLocationInterceptObjectOutgoing] = None


class CallerIdSelectedType(str, Enum):
    #: Outgoing caller ID will show the caller's direct line number and/or extension.
    direct_line = 'DIRECT_LINE'
    #: Outgoing caller ID will show the main number for the location.
    location_number = 'LOCATION_NUMBER'
    #: Outgoing caller ID will show the mobile number for this person.
    mobile_number = 'MOBILE_NUMBER'
    #: Outgoing caller ID will show the value from the `customNumber` field.
    custom = 'CUSTOM'
    none_ = 'none'


class CallerIdInfo(ApiModel):
    #: Allowed types for the `selected` field.
    types: Optional[list[CallerIdSelectedType]] = None
    #: Which type of outgoing Caller ID will be used.
    #: example: DIRECT_LINE
    selected: Optional[CallerIdSelectedType] = None
    #: Direct number which will be shown if `DIRECT_LINE` is selected.
    #: example: 2025551212
    direct_number: Optional[str] = None
    #: Extension number which will be shown if `DIRECT_LINE` is selected.
    #: example: 3456
    extension_number: Optional[datetime] = None
    #: Location number which will be shown if `LOCATION_NUMBER` is selected.
    #: example: 2025551212
    location_number: Optional[str] = None
    #: Mobile number which will be shown if `MOBILE_NUMBER` is selected.
    #: example: 2025552121
    mobile_number: Optional[str] = None
    #: Flag to indicate if the location number is toll-free number.
    toll_free_location_number: Optional[bool] = None
    #: This value must be an assigned number from the person's location.
    #: example: 2025551212
    custom_number: Optional[str] = None
    #: Person's Caller ID first name.  Characters of `%`,  `+`, ``, `"` and Unicode characters are not allowed.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Person's Caller ID last name.  Characters of `%`,  `+`, ``, `"` and Unicode characters are not allowed.
    #: example: Gonzales
    last_name: Optional[str] = None
    #: `true` if the person's identity is blocked when receiving a transferred or forwarded call.
    #: example: True
    block_in_forward_calls_enabled: Optional[bool] = None
    #: Designates which type of External Caller Id Name policy is used. Default is `DIRECT_LINE`.
    #: example: DIRECT_LINE
    external_caller_id_name_policy: Optional[ListVirtualLineObjectExternalCallerIdNamePolicy] = None
    #: Custom External Caller Name, which will be shown if External Caller Id Name is `OTHER`.
    #: example: Hakim custom
    custom_external_caller_id_name: Optional[str] = None
    #: Location's caller ID.
    #: example: Hakim location
    location_external_caller_id_name: Optional[str] = None


class CallerIdPut(ApiModel):
    #: Which type of outgoing Caller ID will be used.
    #: example: DIRECT_LINE
    selected: Optional[CallerIdSelectedType] = None
    #: This value must be an assigned number from the person's location.
    #: example: 2025551212
    custom_number: Optional[str] = None
    #: Person's Caller ID first name.  Characters of `%`,  `+`, ``, `"` and Unicode characters are not allowed.
    #: example: Hakim
    first_name: Optional[str] = None
    #: Person's Caller ID last name.  Characters of `%`,  `+`, ``, `"` and Unicode characters are not allowed.
    #: example: Gonzales
    last_name: Optional[str] = None
    #: `true` if person's identity has to be blocked when receiving a transferred or forwarded call.
    #: example: True
    block_in_forward_calls_enabled: Optional[bool] = None
    #: Designates which type of External Caller Id Name policy is used. Default is `DIRECT_LINE`.
    #: example: DIRECT_LINE
    external_caller_id_name_policy: Optional[ListVirtualLineObjectExternalCallerIdNamePolicy] = None
    #: Person's custom External Caller ID last name.  Characters of `%`,  `+`, ``, `"` and Unicode characters are not
    #: allowed.
    #: example: Hakim Custom
    custom_external_caller_id_name: Optional[str] = None


class DeviceType1(str, Enum):
    #: Indicates the endpoint is a device.
    device = 'DEVICE'
    #: Indicates the endpoint is a application.
    application = 'APPLICATION'


class DoNotDisturbInfo(ApiModel):
    #: `true` if the Do Not Disturb feature is enabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Enables a Ring Reminder to play a brief tone on your desktop phone when you receive incoming calls.
    ring_splash_enabled: Optional[bool] = None


class EndpointIdType(ApiModel):
    #: Persons preferred answer endpoint.
    #: example: Y2lzY29z...
    preferred_answer_endpoint_id: Optional[str] = None


class EventLongDetailsRecurrenceRecurDaily(ApiModel):
    #: Recurring interval in days. The number of days after the start when an event will repeat.  Repetitions cannot
    #: overlap.
    #: example: 1.0
    recur_interval: Optional[int] = None


class EventLongDetailsRecurrenceRecurWeekly(ApiModel):
    #: Specifies the number of weeks between the start of each recurrence.
    #: example: 1.0
    recur_interval: Optional[int] = None
    #: Indicates event occurs weekly on Sunday.
    sunday: Optional[bool] = None
    #: Indicates event occurs weekly on Monday.
    monday: Optional[bool] = None
    #: Indicates event occurs weekly on Tuesday.
    tuesday: Optional[bool] = None
    #: Indicates event occurs weekly on Wednesday.
    #: example: True
    wednesday: Optional[bool] = None
    #: Indicates event occurs weekly on Thursday.
    thursday: Optional[bool] = None
    #: Indicates event occurs weekly on Friday.
    friday: Optional[bool] = None
    #: Indicates event occurs weekly on Saturday.
    saturday: Optional[bool] = None


class EventLongDetailsRecurrence(ApiModel):
    #: True if the event repeats forever. Requires either `recurDaily` or `recurWeekly` to be specified.
    #: example: True
    recur_for_ever: Optional[bool] = None
    #: End date for the recurring event in the format of `YYYY-MM-DD`. Requires either `recurDaily` or `recurWeekly` to
    #: be specified.
    #: example: 2020-03-18
    recur_end_date: Optional[datetime] = None
    #: End recurrence after the event has repeated the specified number of times. Requires either `recurDaily` or
    #: `recurWeekly` to be specified.
    #: example: 1.0
    recur_end_occurrence: Optional[int] = None
    #: Specifies the number of days between the start of each recurrence. Not allowed with `recurWeekly`.
    recur_daily: Optional[EventLongDetailsRecurrenceRecurDaily] = None
    #: Specifies the event recur weekly on the designated days of the week. Not allowed with `recurDaily`.
    recur_weekly: Optional[EventLongDetailsRecurrenceRecurWeekly] = None


class EventLongDetails(ApiModel):
    #: Name for the event.
    #: example: Day_Shift
    name: Optional[str] = None
    #: Start date of the event, or first occurrence if repeating, in the format of `YYYY-MM-DD`.  This field is
    #: required if the `allDayEnabled` field is present.
    #: example: 2020-03-18
    start_date: Optional[datetime] = None
    #: End date of the event, or first occurrence if repeating, in the format of `YYYY-MM-DD`.  This field is required
    #: if the `allDayEnabled` field is present.
    #: example: 2020-03-18
    end_date: Optional[datetime] = None
    #: Start time of the event in the format of `HH:MM` (24 hours format).  This field is required if the
    #: `allDayEnabled` field is false or omitted.
    #: example: 08:00
    start_time: Optional[datetime] = None
    #: End time of the event in the format of `HH:MM` (24 hours format).  This field is required if the `allDayEnabled`
    #: field is false or omitted.
    #: example: 17:00
    end_time: Optional[datetime] = None
    #: True if it is all-day event.
    all_day_enabled: Optional[bool] = None
    #: Recurrance scheme for an event.
    recurrence: Optional[EventLongDetailsRecurrence] = None


class GetSharedLineMemberItem1(ApiModel):
    #: Unique identifier for the member.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85ODhiYTQyOC0zMjMyLTRmNjItYjUyNS1iZDUzZmI4Nzc0MWE
    id: Optional[str] = None
    #: First name of person or workspace.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of person or workspace.
    #: example: Doe
    last_name: Optional[str] = None
    #: Phone number of a person or workspace. Currently, E.164 format is not supported. This will be supported in the
    #: future update.
    #: example: 2056852221
    phone_number: Optional[str] = None
    #: Phone extension of a person or workspace.
    #: example: 1111
    extension: Optional[datetime] = None
    #: Device port number assigned to a person or workspace.
    #: example: 1.0
    port: Optional[int] = None
    #: T.38 Fax Compression setting. Valid only for ATA Devices. Overrides user level compression options.
    #: example: True
    t38_fax_compression_enabled: Optional[bool] = None
    #: If `true` the person or the workspace is the owner of the device. Points to primary line/port of the device.
    #: example: true
    primary_owner: Optional[str] = None
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    #: example: SHARED_CALL_APPEARANCE
    line_type: Optional[LineType] = None
    #: Number of lines that have been configured for the person on the device.
    #: example: 1.0
    line_weight: Optional[int] = None
    #: Registration home IP for the line port.
    #: example: 198.168.0.1
    host_ip: Optional[str] = Field(alias='hostIP', default=None)
    #: Registration remote IP for the line port.
    #: example: 198.168.0.2
    remote_ip: Optional[str] = Field(alias='remoteIP', default=None)
    #: Configure this line to automatically call a predefined number whenever taken off-hook. Once enabled, the line
    #: can only make calls to the predefined number set in hotlineDestination.
    #: example: True
    hotline_enabled: Optional[bool] = None
    #: Preconfigured number for the hotline. Required only if `hotlineEnabled` is set to `true`.
    #: example: 1234
    hotline_destination: Optional[datetime] = None
    #: Set how a device behaves when a call is declined. When set to `true`, a call decline request is extended to all
    #: the endpoints on the device. When set to `false`, a call decline request is only declined at the current
    #: endpoint.
    #: example: True
    allow_call_decline_enabled: Optional[bool] = None
    #: Device line label.
    #: example: share line label
    line_label: Optional[str] = None
    #: Indicates if the member is of type `PEOPLE` or `PLACE`.
    member_type: Optional[MemberType1] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None


class GetSharedLineMemberList1(ApiModel):
    #: Model name of device.
    #: example: Business Communicator - PC
    model: Optional[str] = None
    #: List of members.
    members: Optional[list[GetSharedLineMemberItem1]] = None
    #: Maximum number of device ports.
    #: example: 10.0
    max_line_count: Optional[int] = None


class GetCallingBehaviorObjectBehaviorType(str, Enum):
    #: Calling in Webex or Hybrid Calling.
    native_webex_teams_calling = 'NATIVE_WEBEX_TEAMS_CALLING'
    #: Cisco Jabber app
    call_with_app_registered_for_ciscotel = 'CALL_WITH_APP_REGISTERED_FOR_CISCOTEL'
    #: Third-Party app
    call_with_app_registered_for_tel = 'CALL_WITH_APP_REGISTERED_FOR_TEL'
    #: Webex Calling app
    call_with_app_registered_for_webexcalltel = 'CALL_WITH_APP_REGISTERED_FOR_WEBEXCALLTEL'
    #: Calling in Webex (Unified CM)
    native_sip_call_to_ucm = 'NATIVE_SIP_CALL_TO_UCM'
    #: Using the non-string value of `null` results in the organization-wide default calling behavior being in effect.
    null = 'null'


class GetCallingBehaviorObjectEffectiveBehaviorType(str, Enum):
    #: Calling in Webex or Hybrid Calling.
    native_webex_teams_calling = 'NATIVE_WEBEX_TEAMS_CALLING'
    #: Cisco Jabber app
    call_with_app_registered_for_ciscotel = 'CALL_WITH_APP_REGISTERED_FOR_CISCOTEL'
    #: Third-Party app
    call_with_app_registered_for_tel = 'CALL_WITH_APP_REGISTERED_FOR_TEL'
    #: Webex Calling app
    call_with_app_registered_for_webexcalltel = 'CALL_WITH_APP_REGISTERED_FOR_WEBEXCALLTEL'
    #: Calling in Webex (Unified CM)
    native_sip_call_to_ucm = 'NATIVE_SIP_CALL_TO_UCM'


class GetCallingBehaviorObject(ApiModel):
    #: The current Calling Behavior setting for the person. If `null`, the effective Calling Behavior will be the
    #: Organization's current default.
    #: example: CALL_WITH_APP_REGISTERED_FOR_CISCOTEL
    behavior_type: Optional[GetCallingBehaviorObjectBehaviorType] = None
    #: The effective Calling Behavior setting for the person, will be the organization's default Calling Behavior if
    #: the user's `behaviorType` is set to `null`.
    #: example: NATIVE_WEBEX_TEAMS_CALLING
    effective_behavior_type: Optional[GetCallingBehaviorObjectEffectiveBehaviorType] = None
    #: The UC Manager Profile ID.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExJTkdfUFJPRklMRS9iMzdmMmZiYS0yZTdjLTExZWItYTM2OC1kYmU0Yjc2NzFmZTk
    profile_id: Optional[str] = None


class GetEvent(ApiModel):
    #: Identifier for a event.
    #: example: Y2lzY29zcGFyazovL3VzL1VTRVJfU0NIRURVTEVfRVZFTlQvUkdGNVgxTm9hV1ow
    id: Optional[str] = None
    #: Name for the event.
    #: example: Day_Shift
    name: Optional[str] = None
    #: Start date of the event, or first occurrence if repeating, in the format of `YYYY-MM-DD`.  This field is
    #: required if the `allDayEnabled` field is present.
    #: example: 2020-03-18
    start_date: Optional[datetime] = None
    #: End date of the event, or first occurrence if repeating, in the format of `YYYY-MM-DD`.  This field is required
    #: if the `allDayEnabled` field is present.
    #: example: 2020-03-18
    end_date: Optional[datetime] = None
    #: Start time of the event in the format of `HH:MM` (24 hours format).  This field is required if the
    #: `allDayEnabled` field is false or omitted.
    #: example: 08:00
    start_time: Optional[datetime] = None
    #: End time of the event in the format of `HH:MM `(24 hours format).  This field is required if the `allDayEnabled`
    #: field is false or omitted.
    #: example: 17:00
    end_time: Optional[datetime] = None
    #: True if it is all-day event.
    all_day_enabled: Optional[bool] = None
    #: Recurrance scheme for an event.
    recurrence: Optional[EventLongDetailsRecurrence] = None


class GetMonitoredElementsObjectMember1(ApiModel):
    #: The identifier of the monitored person.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85OWNlZjRmYS03YTM5LTQ1ZDItOTNmNi1jNjA5YTRiMjgzODY
    id: Optional[str] = None
    #: The last name of the monitored person, place or virtual line.
    #: example: Nelson
    last_name: Optional[str] = None
    #: The first name of the monitored person, place or virtual line.
    #: example: John
    first_name: Optional[str] = None
    #: The display name of the monitored person, place or virtual line.
    #: example: John Nelson
    display_name: Optional[str] = None
    #: Indicates whether the type is `PEOPLE`, `PLACE` or `VIRTUAL_LINE`.
    type: Optional[MemberType] = None
    #: The email address of the monitored person, place or virtual line.
    #: example: john.nelson@gmail.com
    email: Optional[str] = None
    #: The list of phone numbers of the monitored person, place or virtual line.
    numbers: Optional[list[GetUserNumberItemObject2]] = None
    #: The location name where the call park extension is.
    #: example: Dallas
    location: Optional[str] = None
    #: The ID for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzZhZjk4ZGViLWVlZGItNGFmYi1hMDAzLTEzNzgyYjdjODAxYw
    location_id: Optional[str] = None


class GetMonitoredElementsObjectCallparkextension1(ApiModel):
    #: The identifier of the call park extension.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExfUEFSS19FWFRFTlNJT04vZTdlZDdiMDEtN2E4Ni00NDEwLWFlODMtOWJmODMzZGEzNzQy
    id: Optional[str] = None
    #: The name used to describe the call park extension.
    #: example: Dallas-Test
    name: Optional[str] = None
    #: The extension number for the call park extension.
    #: example: 4001
    extension: Optional[datetime] = None
    #: The location name where the call park extension is.
    #: example: Dallas
    location: Optional[str] = None
    #: The ID for the location.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzZhZjk4ZGViLWVlZGItNGFmYi1hMDAzLTEzNzgyYjdjODAxYw
    location_id: Optional[str] = None


class GetMonitoredElementsObject1(ApiModel):
    member: Optional[GetMonitoredElementsObjectMember1] = None
    callparkextension: Optional[GetMonitoredElementsObjectCallparkextension1] = None


class GetNumbersPhoneNumbers1(ApiModel):
    #: Flag to indicate if the number is primary or not.
    #: example: True
    primary: Optional[bool] = None
    #: Phone number.
    #: example: 2143456789
    direct_number: Optional[str] = None
    #: Extension.
    #: example: 1234
    extension: Optional[datetime] = None
    #: Optional ring pattern. Applicable only for alternate numbers.
    #: example: NORMAL
    ring_pattern: Optional[RingPatternObject] = None


class GetNumbers1(ApiModel):
    #: Enable/disable a distinctive ring pattern that identifies calls coming from a specific phone number.
    #: example: True
    distinctive_ring_enabled: Optional[bool] = None
    #: Information about the number.
    phone_numbers: Optional[list[GetNumbersPhoneNumbers1]] = None


class IncomingPermissionSettingExternalTransfer(str, Enum):
    #: Allow transfer and forward for all external calls including those which were transferred.
    allow_all_external = 'ALLOW_ALL_EXTERNAL'
    #: Only allow transferred calls to be transferred or forwarded and disallow transfer of other external calls.
    allow_only_transferred_external = 'ALLOW_ONLY_TRANSFERRED_EXTERNAL'
    #: Block all external calls from being transferred or forwarded.
    block_all_external = 'BLOCK_ALL_EXTERNAL'


class IncomingPermissionSetting(ApiModel):
    #: When true, indicates that this person uses the specified calling permissions for receiving inbound calls rather
    #: than the organizational defaults.
    use_custom_enabled: Optional[bool] = None
    #: Specifies the transfer behavior for incoming, external calls.
    #: example: ALLOW_ALL_EXTERNAL
    external_transfer: Optional[IncomingPermissionSettingExternalTransfer] = None
    #: Internal calls are allowed to be received.
    #: example: True
    internal_calls_enabled: Optional[bool] = None
    #: Collect calls are allowed to be received.
    #: example: True
    collect_calls_enabled: Optional[bool] = None


class MonitoringSettings1(ApiModel):
    #: Call park notification is enabled or disabled.
    #: example: True
    call_park_notification_enabled: Optional[bool] = None
    #: Settings of monitored elements which can be person, place, virtual line or call park extension.
    monitored_elements: Optional[list[GetMonitoredElementsObject1]] = None


class MonitoringSettingsPut(ApiModel):
    #: Enable or disable call park notification.
    #: example: True
    enable_call_park_notification: Optional[bool] = None
    #: Identifiers of monitored elements whose monitoring settings will be modified.
    #: example: ['Y2lzY29zcGFyazovL3VzL1BFT1BMRS85OWNlZjRmYS03YTM5LTQ1ZDItOTNmNi1jNjA5YTRiMjgzODY']
    monitored_elements: Optional[list[str]] = None


class OutgoingCallingPermissionsSetting(ApiModel):
    #: When true, indicates that this user uses the specified calling permissions when placing outbound calls.
    #: example: True
    use_custom_enabled: Optional[bool] = None
    #: Specifies the outbound calling permissions settings.
    calling_permissions: Optional[list[CallingPermissionObject]] = None


class PatchCallingBehaviorObject(ApiModel):
    #: The new Calling Behavior setting for the person (case-insensitive). If `null`, the effective Calling Behavior
    #: will be the Organization's current default.
    #: example: NATIVE_WEBEX_TEAMS_CALLING
    behavior_type: Optional[GetCallingBehaviorObjectBehaviorType] = None
    #: The UC Manager Profile ID. Specifying null results in the organizational default being applied.
    #: example: Y2lzY29zcGFyazovL3VzL0NBTExJTkdfUFJPRklMRS9iMzdmMmZiYS0yZTdjLTExZWItYTM2OC1kYmU0Yjc2NzFmZTk
    profile_id: Optional[str] = None


class PhoneNumber(ApiModel):
    #: If `true` marks the phone number as primary.
    #: example: True
    primary: Optional[bool] = None
    #: Either 'ADD' to add phone numbers or 'DELETE' to remove phone numbers.
    action: Optional[Action] = None
    #: Phone numbers that are assigned.
    #: example: +12145553567
    direct_number: Optional[str] = None
    #: Extension that is assigned.
    #: example: 1234
    extension: Optional[datetime] = None
    #: Ring Pattern of this number.
    ring_pattern: Optional[RingPatternObject] = None


class PrivacyGet1(ApiModel):
    #: When `true` auto attendant extension dialing will be enabled.
    #: example: True
    aa_extension_dialing_enabled: Optional[bool] = None
    #: When `true` auto attendant dailing by first or last name will be enabled.
    #: example: True
    aa_naming_dialing_enabled: Optional[bool] = None
    #: When `true` phone status directory privacy will be enabled.
    #: example: True
    enable_phone_status_directory_privacy: Optional[bool] = None
    #: List of people that are being monitored.
    monitoring_agents: Optional[list[GetPersonPlaceVirtualLineCallParksObject1]] = None


class PushToTalkInfo1(ApiModel):
    #: Set to `true` to enable the Push-to-Talk feature.  When enabled, a person receives a Push-to-Talk call and
    #: answers the call automatically.
    #: example: True
    allow_auto_answer: Optional[bool] = None
    #: Specifies the connection type to be used.
    connection_type: Optional[PushToTalkConnectionType] = None
    #: Specifies the access type to be applied when evaluating the member list.
    access_type: Optional[PushToTalkAccessType] = None
    #: List of people that are allowed or disallowed to interact using the Push-to-Talk feature.
    members: Optional[list[GetPersonPlaceVirtualLineCallParksObject1]] = None


class PushToTalkPut(ApiModel):
    #: `true` if Push-to-Talk feature is enabled.
    #: example: True
    allow_auto_answer: Optional[bool] = None
    #: Specifies the connection type to be used.
    connection_type: Optional[PushToTalkConnectionType] = None
    #: Specifies the access type to be applied when evaluating the member list.
    access_type: Optional[PushToTalkAccessType] = None
    #: List of people that are allowed or disallowed to interact using the Push-to-Talk feature.
    #: example: ['Y2lzY29zcGFyazovL3VzL1BFT1BMRS82MWU3MDlkNy1hM2IxLTQ2MDctOTBiOC04NmE5MDgxYWFkNmE']
    members: Optional[list[str]] = None


class PutSharedLineMemberItem(ApiModel):
    #: Unique identifier for the person or workspace.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS85ODhiYTQyOC0zMjMyLTRmNjItYjUyNS1iZDUzZmI4Nzc0MWE
    id: Optional[str] = None
    #: Device port number assigned to person or workspace.
    #: example: 1.0
    port: Optional[int] = None
    #: T.38 Fax Compression setting. Valid only for ATA Devices. Overrides user level compression options.
    #: example: True
    t38_fax_compression_enabled: Optional[bool] = None
    #: If `true` the person or the workspace is the owner of the device. Points to primary line/port of the device.
    #: example: true
    primary_owner: Optional[str] = None
    #: Indicates if the line is acting as a primary line or a shared line for this device.
    #: example: SHARED_CALL_APPEARANCE
    line_type: Optional[LineType] = None
    #: Number of lines that have been configured for the person on the device.
    #: example: 1.0
    line_weight: Optional[int] = None
    #: Configure this line to automatically call a predefined number whenever taken off-hook. Once enabled, the line
    #: can only make calls to the predefined number set in `hotlineDestination`.
    #: example: True
    hotline_enabled: Optional[bool] = None
    #: Preconfigured number for the hotline. Required only if `hotlineEnabled` is set to `true`.
    #: example: 1234
    hotline_destination: Optional[datetime] = None
    #: Set how a device behaves when a call is declined. When set to `true`, a call decline request is extended to all
    #: the endpoints on the device. When set to `false`, a call decline request is only declined at the current
    #: endpoint.
    #: example: True
    allow_call_decline_enabled: Optional[bool] = None
    #: Device line label.
    #: example: share line label
    line_label: Optional[str] = None


class PutSharedLineMemberList(ApiModel):
    members: Optional[list[PutSharedLineMemberItem]] = None


class PutAgentCallQueueId(ApiModel):
    #: When true, indicates that this agent is using the `selectedQueue` for its Caller ID. When false, indicates that
    #: it is using the agent's configured Caller ID.
    #: example: True
    queue_caller_id_enabled: Optional[bool] = None
    #: Use the queue's caller ID for outgoing calls. Optional when queueCallerIdEnabled is false, required when it's
    #: true.
    selected_queue: Optional[Location] = None


class PutEvent(ApiModel):
    #: New name for the event.
    #: example: Central_Zone_Day_Shift
    new_name: Optional[str] = None
    #: Name for the event.
    #: example: Day_Shift
    name: Optional[str] = None
    #: Start date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD.  This field is required
    #: if the `allDayEnabled` field is present.
    #: example: 2020-03-18
    start_date: Optional[datetime] = None
    #: End date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD.  This field is required if
    #: the `allDayEnabled` field is present.
    #: example: 2020-03-18
    end_date: Optional[datetime] = None
    #: Start time of the event in the format of HH:MM (24 hours format).  This field is required if the `allDayEnabled`
    #: field is false or omitted.
    #: example: 08:00
    start_time: Optional[datetime] = None
    #: End time of the event in the format of HH:MM (24 hours format).  This field is required if the `allDayEnabled`
    #: field is false or omitted.
    #: example: 17:00
    end_time: Optional[datetime] = None
    #: True if it is all-day event.
    all_day_enabled: Optional[bool] = None
    #: Recurrance scheme for an event.
    recurrence: Optional[EventLongDetailsRecurrence] = None


class ReceptionInfo1(ApiModel):
    #: Set to `true` to enable the Receptionist Client feature.
    #: example: True
    reception_enabled: Optional[bool] = None
    #: List of people, workspaces or virtual lines to monitor.
    monitored_members: Optional[list[GetPersonPlaceVirtualLineCallParksObject1]] = None


class ReceptionPut(ApiModel):
    #: `true` if the Receptionist Client feature is enabled.
    #: example: True
    reception_enabled: Optional[bool] = None
    #: List of members' unique identifiers to monitor.
    #: example: ['Y2lzY29zcGFyazovL3VzL1BFT1BMRS82MWU3MDlkNy1hM2IxLTQ2MDctOTBiOC04NmE5MDgxYWFkNmE']
    monitored_members: Optional[list[str]] = None


class ScheduleCollectionRequest(ApiModel):
    #: Name for the schedule.
    #: example: Dallas_Office_Hours
    name: Optional[str] = None
    #: Indicates the schedule type whether `businessHours` or `holidays`.
    type: Optional[GetScheduleObjectType] = None
    #: Indicates a list of events.
    events: Optional[list[EventLongDetails]] = None


class ScheduleShortDetails(ApiModel):
    #: Identifier for a schedule.
    #: example: Y2lzY29zcGFyazovL3VzL1VTRVJfU0NIRURVTEUvUkdGc2JHRnpYMDltWm1salpWOUliM1Z5Y3c9PQ
    id: Optional[str] = None
    #: Name for the schedule.
    #: example: Dallas_Office_Hours
    name: Optional[str] = None
    #: Indicates the schedule type whether `businessHours` or `holidays`.
    type: Optional[GetScheduleObjectType] = None


class ScheduleCollectionResponse(ApiModel):
    #: Indicates a list of schedules.
    schedules: Optional[list[ScheduleShortDetails]] = None


class ScheduleLongDetails(ApiModel):
    #: Identifier for a schedule.
    #: example: Y2lzY29zcGFyazovL3VzL1VTRVJfU0NIRURVTEUvUkdGc2JHRnpYMDltWm1salpWOUliM1Z5Y3c9PQ
    id: Optional[str] = None
    #: Name for the schedule.
    #: example: Dallas_Office_Hours
    name: Optional[str] = None
    #: Indicates the schedule type whether `businessHours` or `holidays`.
    type: Optional[GetScheduleObjectType] = None
    #: Indicates a list of events.
    events: Optional[list[EventLongDetails]] = None


class ScheduleUpdateRequest(ApiModel):
    #: New name for the schedule.
    #: example: Richardson_Office_Hours
    new_name: Optional[str] = None
    #: Name for the schedule.
    #: example: Dallas_Office_Hours
    name: Optional[str] = None
    #: Indicates the schedule type whether `businessHours` or `holidays`.
    type: Optional[GetScheduleObjectType] = None
    #: Indicates a list of events.
    events: Optional[list[EventLongDetails]] = None


class UserNumbersPatch(ApiModel):
    #: Enables a distinctive ring pattern for the person.
    #: example: True
    enable_distinctive_ring_pattern: Optional[bool] = None
    #: List of phone numbers that are assigned to a person.
    phone_numbers: Optional[list[PhoneNumber]] = None


class VoiceMailPartyInformation(ApiModel):
    #: The party's name. Only present when the name is available and privacy is not enabled.
    #: example: John Smith
    name: Optional[str] = None
    #: The party's number. Only present when the number is available and privacy is not enabled. The number can be
    #: digits or a URI. Some examples for number include: `1234`, `2223334444`, `+12223334444`, `*73`, and
    #: `user@company.domain`.
    #: example: +12223334444
    number: Optional[str] = None
    #: The party's person ID. Only present when the person ID is available and privacy is not enabled.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9hMTlkODJhMi00ZTY5LTU5YWEtOWYyZi1iY2E2MzEwMTNhNjg=
    person_id: Optional[str] = None
    #: The party's place ID. Only present when the place ID is available and privacy is not enabled.
    #: example: Y2lzY29zcGFyazovL3VzL1BMQUNFL2ExOWQ3MWEyLTRlOTItOTFhYi05ZjJmLWJjYTEzNTAxM2ExNA==
    place_id: Optional[str] = None
    #: Indicates whether privacy is enabled for the name, number and `personId`/`placeId`.
    privacy_enabled: Optional[bool] = None


class VoiceMessageDetails(ApiModel):
    #: The message identifier of the voicemail message.
    #: example: Y2lzY29zcGFyazovL3VzL01FU1NBR0UvNmQ0MTgyMTItZjUwNi00Yzk4LTk5MTItNmI1MmE1ZmU2ODgx
    id: Optional[str] = None
    #: The duration (in seconds) of the voicemail message.  Duration is not present for a FAX message.
    #: example: 38.0
    duration: Optional[int] = None
    #: The calling party's details. For example, if user A calls user B and leaves a voicemail message, then A is the
    #: calling party.
    calling_party: Optional[VoiceMailPartyInformation] = None
    #: `true` if the voicemail message is urgent.
    urgent: Optional[bool] = None
    #: `true` if the voicemail message is confidential.
    confidential: Optional[bool] = None
    #: `true` if the voicemail message has been read.
    #: example: True
    read: Optional[bool] = None
    #: Number of pages for the FAX.  Only set for a FAX.
    #: example: 2.0
    fax_page_count: Optional[int] = None
    #: The date and time the voicemail message was created.
    #: example: 2021-11-14T17:00:00.000Z
    created: Optional[datetime] = None


class VoicemailInfoSendBusyCalls(ApiModel):
    #: Calls will be sent to voicemail when busy.
    #: example: True
    enabled: Optional[bool] = None
    #: `DEFAULT` indicates the default greeting will be played. `CUSTOM` indicates a custom `.wav` file will be played.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Indicates a custom greeting has been uploaded.
    #: example: True
    greeting_uploaded: Optional[bool] = None


class VoicemailInfoSendUnansweredCalls(ApiModel):
    #: Enables and disables sending unanswered calls to voicemail.
    #: example: True
    enabled: Optional[bool] = None
    #: `DEFAULT` indicates the default greeting will be played. `CUSTOM` indicates a custom `.wav` file will be played.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Indicates a custom greeting has been uploaded
    #: example: True
    greeting_uploaded: Optional[bool] = None
    #: Number of rings before unanswered call will be sent to voicemail.
    #: example: 3.0
    number_of_rings: Optional[int] = None
    #: System-wide maximum number of rings allowed for `numberOfRings` setting.
    #: example: 15.0
    system_max_number_of_rings: Optional[int] = None


class VoicemailInfoTransferToNumber(ApiModel):
    #: Indicates enable or disabled state of giving caller option to transfer to destination when pressing zero (0).
    #: example: True
    enabled: Optional[bool] = None
    #: Number voicemail caller will be transferred to when they press zero (0).
    #: example: 6527
    destination: Optional[datetime] = None


class VoicemailInfoMessageStorage(ApiModel):
    #: When `true` desktop phone will indicate there are new voicemails.
    #: example: True
    mwi_enabled: Optional[bool] = None
    #: Designates which type of voicemail message storage is used.
    #: example: INTERNAL
    storage_type: Optional[GetLocationVoicemailGroupObjectMessageStorageStorageType] = None
    #: External email address to which the new voicemail audio will be sent.  A value for this field must be provided
    #: in the request if a `storageType` of `EXTERNAL` is given in the request.
    #: example: dummy@example.com
    external_email: Optional[str] = None


class VoicemailInfoFaxMessage(ApiModel):
    #: When `true` FAX messages for new voicemails will be sent to the designated number.
    #: example: True
    enabled: Optional[bool] = None
    #: Designates phone number for the FAX. A value for this field must be provided in the request if faxMessage
    #: `enabled` field is given as `true` in the request.
    #: example: 2025551212
    phone_number: Optional[str] = None
    #: Designates optional extension for the FAX.
    #: example: 1234
    extension: Optional[datetime] = None


class VoicemailInfo(ApiModel):
    #: Voicemail is enabled or disabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Settings for sending all calls to voicemail.
    send_all_calls: Optional[ModifyCallRecordingSettingsObject] = None
    #: Settings for sending calls to voicemail when the line is busy.
    send_busy_calls: Optional[VoicemailInfoSendBusyCalls] = None
    send_unanswered_calls: Optional[VoicemailInfoSendUnansweredCalls] = None
    #: Settings for notifications when there are any new voicemails.
    notifications: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Settings for voicemail caller to transfer to a different number by pressing zero (0).
    transfer_to_number: Optional[VoicemailInfoTransferToNumber] = None
    #: Settings for sending a copy of new voicemail message audio via email.
    email_copy_of_message: Optional[GetLocationVoicemailGroupObjectEmailCopyOfMessage] = None
    message_storage: Optional[VoicemailInfoMessageStorage] = None
    fax_message: Optional[VoicemailInfoFaxMessage] = None


class VoicemailPutSendBusyCalls(ApiModel):
    #: Calls will be sent to voicemail when busy.
    #: example: True
    enabled: Optional[bool] = None
    #: `DEFAULT` indicates the default greeting will be played. `CUSTOM` indicates a custom `.wav` file will be played.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None


class VoicemailPutSendUnansweredCalls(ApiModel):
    #: Unanswered call sending to voicemail is enabled or disabled.
    #: example: True
    enabled: Optional[bool] = None
    #: `DEFAULT` indicates the default greeting will be played. `CUSTOM` indicates a custom `.wav` file will be played.
    #: example: DEFAULT
    greeting: Optional[HoursMenuObjectGreeting] = None
    #: Number of rings before an unanswered call will be sent to voicemail.
    #: example: 3.0
    number_of_rings: Optional[int] = None


class VoicemailPut(ApiModel):
    #: Voicemail is enabled or disabled.
    #: example: True
    enabled: Optional[bool] = None
    #: Settings for sending all calls to voicemail.
    send_all_calls: Optional[ModifyCallRecordingSettingsObject] = None
    #: Settings for sending calls to voicemail when the line is busy.
    send_busy_calls: Optional[VoicemailPutSendBusyCalls] = None
    send_unanswered_calls: Optional[VoicemailPutSendUnansweredCalls] = None
    #: Settings for notifications when there are any new voicemails.
    notifications: Optional[GetLocationVoicemailGroupObjectNotifications] = None
    #: Settings for voicemail caller to transfer to a different number by pressing zero (0).
    transfer_to_number: Optional[VoicemailInfoTransferToNumber] = None
    #: Settings for sending a copy of new voicemail message audio via email.
    email_copy_of_message: Optional[GetLocationVoicemailGroupObjectEmailCopyOfMessage] = None
    message_storage: Optional[VoicemailInfoMessageStorage] = None
    fax_message: Optional[VoicemailInfoFaxMessage] = None


class Endpoints(ApiModel):
    #: Unique identifier for the endpoint.
    #: example: Y2lzY29z...
    id: Optional[str] = None
    #: Enumeration that indicates if the endpoint is of type `DEVICE` or `APPLICATION`.
    type: Optional[DeviceType1] = None
    #: The `name` filed in the response is calculated using device tag. Admins have the ability to set tags for
    #: devices. If a `name=<value>` tag is set, for example name=home phone, then the `<value>` is included in the
    #: `name` field of the API response. In this example home phone.
    #: example: Cisco 8865 (Phone in reception area)
    name: Optional[str] = None


class EndpointInformation(ApiModel):
    #: Persons preferred answer endpoint.
    #: example: Y2lzY29z...
    preferred_answer_endpoint_id: Optional[str] = None
    #: Array of endpoints available to the person.
    endpoints: Optional[list[Endpoints]] = None


class CountObject2(ApiModel):
    #: Indicates the total number of user moves requested.
    total_moves: Optional[int] = None
    #: Indicates the total number of user moves completed.
    moved: Optional[int] = None
    #: Indicates the total number of user moves that failed.
    failed: Optional[int] = None


class ErrorOrImpactItem(ApiModel):
    #: Error or Impact code.
    code: Optional[int] = None
    #: Message string with more error or impact information.
    message: Optional[int] = None


class JobExecutionStatusObject3(ApiModel):
    #: Unique identifier that identifies each instance of the job.
    id: Optional[int] = None
    #: The date and time with seconds, the job has started in UTC format.
    start_time: Optional[str] = None
    #: The date and time with seconds, the job has ended in UTC format.
    end_time: Optional[str] = None
    #: The date and time with seconds, the job has last updated in UTC format post one of the step execution
    #: completion.
    last_updated: Optional[str] = None
    #: Displays status for overall steps that are part of the job.
    status_message: Optional[str] = None
    #: Exit Code for a job.
    exit_code: Optional[str] = None
    #: The date and time with seconds, the job has created in UTC format.
    created_time: Optional[str] = None
    #: Time lapsed in seconds since the job execution started.
    time_elapsed: Optional[str] = None
    #: Status of each step within a job.
    step_execution_statuses: Optional[list[StepExecutionStatuses]] = None


class JobDetailsResponse(ApiModel):
    #: Unique identifier of the job.
    id: Optional[str] = None
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str] = None
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str] = None
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str] = None
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str] = None
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int] = None
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatusObject3]] = None
    #: Indicates the most recent status (`STARTING`,`STARTED`,`COMPLETED`,`FAILED`) of the job at the time of
    #: invocation.
    latest_execution_status: Optional[str] = None
    #: Job statistics.
    counts: Optional[CountObject2] = None
    #: Reference ID for the file that holds the errors and impacts.
    csv_file: Optional[str] = None
    #: The date and time with seconds, the file expires in UTC format.
    csv_file_expiry_time: Optional[str] = None
    #: 'text/csv',  Format of the file generated.
    file_format: Optional[str] = None


class JobDetailsResponseById(ApiModel):
    #: Job name.
    name: Optional[str] = None
    #: Unique identifier of the job.
    id: Optional[str] = None
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str] = None
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str] = None
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str] = None
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str] = None
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int] = None
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[JobExecutionStatusObject3]] = None
    #: Indicates the most recent status (`STARTING`,`STARTED`,`COMPLETED`,`FAILED`) of the job at the time of
    #: invocation.
    latest_execution_status: Optional[str] = None
    #: Job statistics.
    counts: Optional[CountObject2] = None
    #: Reference ID for the file that holds the errors and impacts.
    csv_file: Optional[str] = None
    #: The date and time with seconds, the file expires in UTC format.
    csv_file_expiry_time: Optional[str] = None
    #: 'text/csv',  Format of the file generated.
    file_format: Optional[str] = None
    #: URL to the CSV file containing errors and impacts.
    csv_file_download_url: Optional[str] = None


class JobListResponse2(ApiModel):
    #: Lists all jobs for the customer in order of most recent one to oldest one irrespective of its status.
    items: Optional[list[JobDetailsResponse]] = None


class MoveUsersErrorResponse(ApiModel):
    #: List of error items.
    error: Optional[list[ErrorOrImpactItem]] = None


class UserItem(ApiModel):
    #: User ID to be moved.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzUyMjNiYmVkLTQyYzktNDU0ZC1hMWYzLTdmYWQ1Y2M3ZTZlMw
    user_id: Optional[str] = None
    #: Extension to be moved.
    #: example: 28544
    extension: Optional[str] = None


class UsersListItem(ApiModel):
    #: The target location for the user move.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OL2E4Mjg5NzIyLTFiODAtNDFiNy05Njc4LTBlNzdhZThjMTA5OA
    location_id: Optional[str] = None
    #: When `true`, validate the user move. When `false`, perform the user move.
    validate: Optional[bool] = None
    #: A list of users to be moved.
    users: Optional[list[UserItem]] = None


class MoveUsersStartJobObject(ApiModel):
    #: The user to be moved from the source location.
    users_list: Optional[list[UsersListItem]] = None


class StartJobExecutionStatusObject(ApiModel):
    #: Unique identifier that identifies each instance of the job.
    id: Optional[int] = None
    #: The date and time with seconds, the job has started in UTC format.
    start_time: Optional[str] = None
    #: The date and time with seconds, the job has last updated in UTC format post one of the step execution
    #: completion.
    last_updated: Optional[str] = None
    #: Displays status for overall steps that are part of the job.
    status_message: Optional[str] = None
    #: Exit Code for a job.
    exit_code: Optional[str] = None
    #: The date and time with seconds, the job has been created in UTC format.
    created_time: Optional[str] = None
    #: Time lapsed in seconds since the job execution started.
    time_elapsed: Optional[str] = None


class StartJobResponseObject(ApiModel):
    #: Job name.
    name: Optional[str] = None
    #: Unique identifier of the job.
    id: Optional[str] = None
    #: Unique identifier to track the flow of HTTP requests.
    tracking_id: Optional[str] = None
    #: Unique identifier to identify which user has run the job.
    source_user_id: Optional[str] = None
    #: Unique identifier to identify the customer who has run the job.
    source_customer_id: Optional[str] = None
    #: Unique identifier to identify the customer for which the job was run.
    target_customer_id: Optional[str] = None
    #: Unique identifier to identify the instance of the job.
    instance_id: Optional[int] = None
    #: Displays the most recent step's execution status. Contains execution statuses of all the steps involved in the
    #: execution of the job.
    job_execution_status: Optional[list[StartJobExecutionStatusObject]] = None
    #: Indicates the most recent status (`STARTING`,`STARTED`,`COMPLETED`,`FAILED`) of the job at the time of
    #: invocation.
    latest_execution_status: Optional[str] = None
    #: Job statistics.
    counts: Optional[CountObject2] = None


class MoveUsersStartJobResponse(ApiModel):
    #: Response for the user move.
    response: Optional[StartJobResponseObject] = None


class UserListItem(ApiModel):
    #: Associated user ID for the validation response.
    user_id: Optional[str] = None
    #: List of impacts for the user move.
    impacts: Optional[list[ErrorOrImpactItem]] = None
    #: List of errors for the user move.
    errors: Optional[list[ErrorOrImpactItem]] = None


class MoveUsersValidationResponse(ApiModel):
    #: Response for the user move validation.
    response: Optional[list[UserListItem]] = None


class UserHotelingRequestPatch(ApiModel):
    #: Modify person Device Hoteling Setting.
    hoteling: Optional[Hoteling] = None


class RetrieveExecutiveAssistantSettingsForAPersonResponseType(str, Enum):
    #: Indicates the feature is not enabled.
    unassigned = 'UNASSIGNED'
    #: Indicates the feature is enabled and the person is an Executive.
    executive = 'EXECUTIVE'
    #: Indicates the feature is enabled and the person is an Executive Assistant.
    executive_assistant = 'EXECUTIVE_ASSISTANT'


class RetrieveExecutiveAssistantSettingsForAPersonResponse(ApiModel):
    #: Indicates the Executive Assistant type.
    #: example: EXECUTIVE
    type: Optional[RetrieveExecutiveAssistantSettingsForAPersonResponseType] = None


class GetMessageSummaryResponse(ApiModel):
    #: The number of new (unread) voicemail messages.
    #: example: 2.0
    new_messages: Optional[int] = None
    #: The number of old (read) voicemail messages.
    #: example: 5.0
    old_messages: Optional[int] = None
    #: The number of new (unread) urgent voicemail messages.
    new_urgent_messages: Optional[int] = None
    #: The number of old (read) urgent voicemail messages.
    #: example: 1.0
    old_urgent_messages: Optional[int] = None


class ListMessagesResponse(ApiModel):
    items: Optional[list[VoiceMessageDetails]] = None


class ClusterClientTypeDistributionDetailsBlr1a(ApiModel):
    #: The type of device.
    #: example: sipEndpoint
    device_type: Optional[str] = None
    #: The description of the device type.
    #: example: SIP Devices
    description: Optional[str] = None
    #: The count of the device type.
    #: example: 10.0
    count: Optional[int] = None


class ClusterClientTypeDistributionBlr1(ApiModel):
    #: ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzM2ZDg5NGY3LTJiNTctNDNjMS1hY2VlLWQ0N2U2Nzc2MTQxNDo1ODJhMWFlYy03YTMwLTQ2MDItYTI2NS02YTE5NDcwOWZkOTg
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: Bangalore
    cluster_name: Optional[str] = None
    #: Client Type Distribution Details.
    client_type_distribution_details: Optional[list[ClusterClientTypeDistributionDetailsBlr1a]] = None


class ClientTypeDistributionTrend1(ApiModel):
    #: Timestamp.
    #: example: 2022-03-23T10:30:00Z
    timestamp: Optional[datetime] = None
    clusters: Optional[list[ClusterClientTypeDistributionBlr1]] = None


class ClienttypedistributionCollectionforOrg(ApiModel):
    #: The unique ID for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ
    org_id: Optional[str] = None
    #: Start date and time (inclusive) for the Client Type Distribution details.
    #: example: 2022-03-23T10:22:03Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the Client Type Distribution details.
    #: example: 2022-03-24T10:22:03Z
    to_: Optional[datetime] = None
    #: The aggregation period of the trend data.
    #: example: 10m
    aggregation_interval: Optional[datetime] = None
    #: Client Type Distribution details for the organization.
    items: Optional[list[ClientTypeDistributionTrend1]] = None


class ClienttypedistributionforOrg(ApiModel):
    items: Optional[list[ClienttypedistributionCollectionforOrg]] = None


class ClusterAvailableTimeline(ApiModel):
    #: Start date and time of the segment of availability data.
    #: example: 2021-09-15T15:53:00Z
    segment_start_time: Optional[datetime] = None
    #: End date and time of the segment of availability data.
    #: example: 2021-09-15T16:53:00Z
    segment_end_time: Optional[datetime] = None
    #: Availability information of the Video Mesh cluster.
    #: example: Available
    availability: Optional[str] = None
    #: Number of nodes that are online.
    #: example: 1.0
    no_of_online_nodes: Optional[int] = None
    #: Number of nodes that are offline.
    #: example: 1.0
    no_of_offline_nodes: Optional[int] = None
    #: Total number of nodes in the Video Mesh cluster.
    #: example: 2.0
    total_nodes: Optional[int] = None


class ClusterAvailability(ApiModel):
    #: ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzFlYjY1ZmRmLTk2NDMtNDE3Zi05OTc0LWFkNzJjYWUwZTEwZjpiMzdmNTgzYy1kZGRjLTQyOGItODJlNS1jYmU2ODFkYjQ5NjI=
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: San Jose
    cluster_name: Optional[str] = None
    availability_segments: Optional[list[ClusterAvailableTimeline]] = None


class ClusterAvailabilityCollection(ApiModel):
    #: The unique ID for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ=
    org_id: Optional[str] = None
    #: Availability details of the Video Mesh cluster.
    items: Optional[list[ClusterAvailability]] = None
    #: Start date and time (inclusive) of the availability data.
    #: example: 2021-09-15T15:53:00Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the availability data.
    #: example: 2021-09-15T17:53:00Z
    to_: Optional[datetime] = None


class ClustersAvailability(ApiModel):
    items: Optional[list[ClusterAvailabilityCollection]] = None


class NodeAvailableTimeline(ApiModel):
    #: Number of nodes that are online.
    #: example: 1.0
    no_of_online_nodes: Optional[int] = None
    #: Number of nodes that are offline.
    no_of_offline_nodes: Optional[int] = None
    #: Start date and time of the segment of availability data.
    #: example: 2021-09-15T15:53:00Z
    segment_start_time: Optional[datetime] = None
    #: End date and time of the segment of availability data.
    #: example: 2021-09-15T16:53:00Z
    segment_end_time: Optional[datetime] = None
    #: Availability information of the Video Mesh node.
    #: example: Available
    availability: Optional[str] = None
    #: Reason for the Video Mesh node being unavailable (if any).
    #: example: NA
    un_availability_reason: Optional[str] = None
    #: Total number of nodes in the Video Mesh cluster.
    #: example: 1.0
    total_nodes: Optional[int] = None


class NodeAvailability(ApiModel):
    #: ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzFlYjY1ZmRmLTk2NDMtNDE3Zi05OTc0LWFkNzJjYWUwZTEwZjpiMzdmNTgzYy1kZGRjLTQyOGItODJlNS1jYmU2ODFkYjQ5NjI=
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: San Jose
    cluster_name: Optional[str] = None
    #: Host Name or the IP of the Video Mesh node.
    #: example: xyz.abc.com
    host_name_or_ip: Optional[str] = None
    #: ID of the Video Mesh node.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMWViNjVmZGYtOTY0My00MTdmLTk5NzQtYWQ3MmNhZTBlMTBmOmMyNTk0YmY2NDFmZTRkNTFiZDg3YThiMjYxYzg3NWY1
    node_id: Optional[str] = None
    availability_segments: Optional[list[NodeAvailableTimeline]] = None


class NodeAvailabilityCollection(ApiModel):
    #: Unique ID for a Video Mesh organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ=
    org_id: Optional[str] = None
    #: Availability details of the Video Mesh cluster.
    items: Optional[list[NodeAvailability]] = None
    #: Start date and time (inclusive) of the availability data.
    #: example: 2021-09-15T15:53:00Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the availability data.
    #: example: 2021-09-15T17:53:00Z
    to_: Optional[datetime] = None


class NodesAvailability(ApiModel):
    items: Optional[list[NodeAvailabilityCollection]] = None


class SingleNodeAvailableTimeline(ApiModel):
    #: Start date and time of the segment of availability data.
    #: example: 2021-09-15T15:53:00Z
    segment_start_time: Optional[datetime] = None
    #: End date and time of the segment of availability data.
    #: example: 2021-09-15T16:53:00Z
    segment_end_time: Optional[datetime] = None
    #: Availability information of the Video Mesh node.
    #: example: Available
    availability: Optional[str] = None
    #: Reason for the Video Mesh node being unavailable (if any).
    #: example: NA
    un_availability_reason: Optional[str] = None


class SingleNodeAvailability1(ApiModel):
    #: ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzFlYjY1ZmRmLTk2NDMtNDE3Zi05OTc0LWFkNzJjYWUwZTEwZjpiMzdmNTgzYy1kZGRjLTQyOGItODJlNS1jYmU2ODFkYjQ5NjI=
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: San Jose
    cluster_name: Optional[str] = None
    #: Host Name or the IP of the Video Mesh node.
    #: example: xyz.abc.com
    host_name_or_ip: Optional[str] = None
    #: ID of the Video Mesh node.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMWViNjVmZGYtOTY0My00MTdmLTk5NzQtYWQ3MmNhZTBlMTBmOmMyNTk0YmY2NDFmZTRkNTFiZDg3YThiMjYxYzg3NWY1
    node_id: Optional[str] = None
    availability_segments: Optional[list[SingleNodeAvailableTimeline]] = None


class SingleNodeAvailabilityCollection(ApiModel):
    #: Unique ID for a Video Mesh organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ=
    org_id: Optional[str] = None
    #: Availability details of the Video Mesh cluster.
    items: Optional[list[SingleNodeAvailability1]] = None
    #: Start date and time (inclusive) of the availability data.
    #: example: 2021-09-15T15:53:00Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the availability data.
    #: example: 2021-09-15T17:53:00Z
    to_: Optional[datetime] = None


class SingleNodeAvailability(ApiModel):
    items: Optional[list[SingleNodeAvailabilityCollection]] = None


class MediaSignallingtestResultFailure(ApiModel):
    #: The name of the test.
    #: example: Media Signalling
    test_name: Optional[str] = None
    #: Test results(Success/Failed).
    #: example: Failed
    test_result: Optional[str] = None
    #: Reason for test failure.
    #: example: An internal error occurred in monitoring tool [Error Code:1003]. If the issue persists, please contact Cisco Support.
    failure_reason: Optional[str] = None


class MediaHealthMonitoringTestResultsFailure(ApiModel):
    #: The timestamp of the test run.
    #: example: 2022-03-15T15:53:00Z
    timestamp: Optional[datetime] = None
    #: Unique ID of the test.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT01NQU5EX0lELzJjM2M5ZjllLTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhYzo2NTJmNmMxMC01NjgxLTExZWQtOTkyZS1kNTY5YzlkMDlhNzU
    id: Optional[str] = None
    #: Test results of Media Signalling, SIP Signalling, Media Cascade runs.
    test_results: Optional[list[MediaSignallingtestResultFailure]] = None


class MediaHealthMonitoringsecondnode(ApiModel):
    #: Unique ID of the Video Mesh node.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOTUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFkOjE1NmRmNzg5Yzg1NTRkNTVhMjc1ZGY5OTc4Zjk5MDJk
    node_id: Optional[str] = None
    #: Host name or the IP of the Video Mesh node.
    #: example: abc.company.com
    host_name_or_ip: Optional[str] = Field(alias='hostNameOrIP', default=None)
    #: The Media Health Monitoring Tool test results for a single Video Mesh node.
    mhm_test_results: Optional[list[MediaHealthMonitoringTestResultsFailure]] = None


class MediaHealthMonitoringforfirstcluster(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzJjM2M5Zjk1LTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhZDpmMWJmMGI1MC0yMDUyLTQ3ZmUtYjg3ZC01MTFjMmZlNzQ3MWI=
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: banglore
    cluster_name: Optional[str] = None
    #: The Video Mesh nodes in the cluster.
    nodes: Optional[list[MediaHealthMonitoringsecondnode]] = None


class MediaHealthMonitoringclusters(ApiModel):
    #: The list of Video Mesh clusters.
    clusters: Optional[list[MediaHealthMonitoringforfirstcluster]] = None


class MediaHealthMonitoringResultsCollectionfororganization(ApiModel):
    #: Unique ID of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8yYzNjOWY5NS03M2Q5LTQ0NjAtYTY2OC0wNDcxNjJmZjFiYWQ=
    org_id: Optional[str] = None
    #: Start date and time (inclusive) of the Media Health Monitoring Tool data.
    #: example: 2023-01-15T15:53:00Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the Media Health Monitoring Tool data.
    #: example: 2023-01-20T15:53:00Z
    to_: Optional[datetime] = None
    #: Media Health Monitoring Tool test results.
    items: Optional[list[MediaHealthMonitoringclusters]] = None


class MediaHealthMonitoringResultsforOrganization(ApiModel):
    items: Optional[list[MediaHealthMonitoringResultsCollectionfororganization]] = None


class MediaSignallingtestResultSuccess(ApiModel):
    #: The name of the test.
    #: example: Media Signalling
    test_name: Optional[str] = None
    #: The result, either `Success` or `Failed`.
    #: example: Success
    test_result: Optional[str] = None


class MediaHealthMonitoringTestResultsSuccess(ApiModel):
    #: The timestamp of the test run.
    #: example: 2022-03-15T15:53:00Z
    timestamp: Optional[datetime] = None
    #: Unique ID of the test.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT01NQU5EX0lELzJjM2M5ZjllLTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhYzo2NTJmNmMxMC01NjgxLTExZWQtOTkyZS1kNTY5YzlkMDlhNzU
    id: Optional[str] = None
    #: Test results of Media Signalling, SIP Signalling, Media Cascade runs.
    test_results: Optional[list[MediaSignallingtestResultSuccess]] = None


class OverflowDetails1(ApiModel):
    #: The reason for this overflow.
    #: example: Capacity exceeded
    overflow_reason: Optional[str] = None
    #: Number of overflows.
    #: example: 25.0
    overflow_count: Optional[int] = None
    #: Any possible remediations for this overflow.
    #: example: Video Mesh exceeded its capacity. If this happens frequently, consider adding more nodes to your clusters.
    possible_remediation: Optional[str] = None


class CloudOverflowTrend1(ApiModel):
    #: Timestamp.
    #: example: 2022-03-23T10:30:00Z
    timestamp: Optional[datetime] = None
    #: Overflow Details.
    overflow_details: Optional[list[OverflowDetails1]] = None


class OverflowtoCloudCollection(ApiModel):
    #: The unique ID for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ
    org_id: Optional[str] = None
    #: Start date and time (inclusive) for the Overflow to Cloud data.
    #: example: 2022-03-23T10:22:03Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) for the Overflow to Cloud data.
    #: example: 2022-03-24T04:22:03Z
    to_: Optional[datetime] = None
    #: The aggregation period of the trend data.
    #: example: 10m
    aggregation_interval: Optional[datetime] = None
    #: Overflow data for the organization.
    items: Optional[list[CloudOverflowTrend1]] = None


class OverflowtoCloud(ApiModel):
    items: Optional[list[OverflowtoCloudCollection]] = None


class ClusterRedirectDetailsBlr1a(ApiModel):
    #: The reason for the redirect.
    #: example: Capacity exceeded
    redirect_reason: Optional[str] = None
    #: Number of Call Redirects.
    #: example: 10.0
    redirect_count: Optional[int] = None
    #: Any possible remediations for this overflow.
    #: example: Video Mesh exceeded its capacity. If this happens frequently, consider adding more nodes to your clusters.
    possible_remediation: Optional[str] = None


class ClusterRedirectBlr1(ApiModel):
    #: ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzM2ZDg5NGY3LTJiNTctNDNjMS1hY2VlLWQ0N2U2Nzc2MTQxNDo1ODJhMWFlYy03YTMwLTQ2MDItYTI2NS02YTE5NDcwOWZkOTg
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: bangalore
    cluster_name: Optional[str] = None
    #: Call Redirect Details.
    redirect_details: Optional[list[ClusterRedirectDetailsBlr1a]] = None


class RedirectTrend1(ApiModel):
    #: Timestamp.
    #: example: 2022-03-23T10:30:00Z
    timestamp: Optional[datetime] = None
    clusters: Optional[list[ClusterRedirectBlr1]] = None


class RedirectCollectionForOrg(ApiModel):
    #: The unique ID for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ
    org_id: Optional[str] = None
    #: Start date and time (inclusive) for the Call Redirect details.
    #: example: 2022-03-23T10:22:03Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the Call Redirect details.
    #: example: 2022-03-24T10:22:03Z
    to_: Optional[datetime] = None
    #: The aggregation period of the trend data.
    #: example: 10m
    aggregation_interval: Optional[datetime] = None
    #: Redirect details for the organization.
    items: Optional[list[RedirectTrend1]] = None


class RedirectforOrg(ApiModel):
    items: Optional[list[RedirectCollectionForOrg]] = None


class UtilizationMetricsT1SJ(ApiModel):
    #: Peak CPU usage during the time interval.
    #: example: 54.54
    peak_cpu: Optional[int] = None
    #: Average CPU usage during the time interval.
    #: example: 4.27
    avg_cpu: Optional[int] = None
    #: Maximum active calls at a point in the time interval.
    #: example: 5.0
    active_calls: Optional[int] = None
    #: Maximum active private calls at a point in the time interval.
    #: example: 1.0
    active_private_calls: Optional[int] = None


class ClusterUtilizationT1SJ(ApiModel):
    #: ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzM2ZDg5NGY3LTJiNTctNDNjMS1hY2VlLWQ0N2U2Nzc2MTQxNDo1ODJhMWFlYy03YTMwLTQ2MDItYTI2NS02YTE5NDcwOTEyMzQ=
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: sanjose
    cluster_name: Optional[str] = None
    #: Utilization details for the cluster in the time interval.
    utilization_metrics: Optional[UtilizationMetricsT1SJ] = None


class ClusterUtilizationTrend1(ApiModel):
    #: Timestamp.
    #: example: 2022-03-23T10:30:00Z
    timestamp: Optional[datetime] = None
    clusters: Optional[list[ClusterUtilizationT1SJ]] = None


class ClusterUtilizationCollection(ApiModel):
    #: The unique ID for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ=
    org_id: Optional[str] = None
    #: The aggregation period of the trend data.
    #: example: 10m
    aggregation_interval: Optional[datetime] = None
    #: Start date and time (inclusive) of the utilization data.
    #: example: 2022-03-23T10:22:03Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the utilization data.
    #: example: 2022-03-24T10:22:03Z
    to_: Optional[datetime] = None
    #: Utilization details of the Video Mesh cluster
    items: Optional[list[ClusterUtilizationTrend1]] = None


class ClustersUtilization(ApiModel):
    items: Optional[list[ClusterUtilizationCollection]] = None


class ReachabilityTestresultsSuccess(ApiModel):
    #: Destination IP address.
    #: example: 1.1.1.1
    ip_address: Optional[str] = None
    #: Port number.
    #: example: 5004.0
    port: Optional[int] = None
    #: Port reachability information.
    #: example: True
    reachable: Optional[bool] = None


class ReachabilityTestresultsStunresults1(ApiModel):
    #: The timestamp of the test run.
    #: example: 2022-03-15T15:53:00Z
    timestamp: Optional[datetime] = None
    #: The type of the test being executed. Can be either `OnDemand` or `Periodic`.
    #: example: OnDemand
    trigger_type: Optional[str] = None
    #: Unique ID of the test.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT01NQU5EX0lELzJjM2M5ZjllLTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhYzo2NTJmNmMxMC01NjgxLTExZWQtOTkyZS1kNTY5YzlkMDlhNzU
    id: Optional[str] = None
    #: List of UDP ports being checked in Reachability test.
    udp: Optional[list[ReachabilityTestresultsSuccess]] = None
    #: List of TCP ports being checked in Reachability test.
    tcp: Optional[list[ReachabilityTestresultsSuccess]] = None


class ReachabilityTestresultsdestinationcluster(ApiModel):
    #: Cloud Webex cluster against which Reachability test is being executed.
    #: example: Amsterdam Cluster
    destination_cluster: Optional[str] = None
    #: STUN test results for a Video Mesh cluster.
    stun_results: Optional[list[ReachabilityTestresultsStunresults1]] = None


class ReachabilityTestresultsfirstnode(ApiModel):
    #: Unique ID of the Video Mesh node.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOTUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFkOjE1NmRmNzg5Yzg1NTRkNTVhMjc1ZGY5OTc4Zjk5MDJk
    node_id: Optional[str] = None
    #: Host name or the IP of the Video Mesh node.
    #: example: xyz.company.com
    host_name_or_ip: Optional[str] = Field(alias='hostNameOrIP', default=None)
    #: Reachability test results for a single Video Mesh node.
    test_results: Optional[list[ReachabilityTestresultsdestinationcluster]] = None


class ReachabilityTestResultsforfirstcluster(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzJjM2M5Zjk1LTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhZDpmMWJmMGI1MC0yMDUyLTQ3ZmUtYjg3ZC01MTFjMmZlNzQ3MWI=
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: banglore
    cluster_name: Optional[str] = None
    #: The Video Mesh nodes in the cluster.
    nodes: Optional[list[ReachabilityTestresultsfirstnode]] = None


class ReachabilityTestResultsforcluster(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[ReachabilityTestResultsforfirstcluster]] = None


class ReachabilityTestresultsfororganization(ApiModel):
    #: Unique ID of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8yYzNjOWY5NS03M2Q5LTQ0NjAtYTY2OC0wNDcxNjJmZjFiYWQ=
    org_id: Optional[str] = None
    #: Start date and time (inclusive) of the Reachability test results data.
    #: example: 2023-01-15T15:53:00Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the Reachability test results data.
    #: example: 2023-01-20T15:53:00Z
    to_: Optional[datetime] = None
    #: Reachability test results data.
    items: Optional[list[ReachabilityTestResultsforcluster]] = None


class ReachabilityTestResults(ApiModel):
    items: Optional[list[ReachabilityTestresultsfororganization]] = None


class BlrNodeLocation(ApiModel):
    #: Country code of the Location where the Video Mesh node is deployed.
    #: example: IN
    country_code: Optional[str] = None
    #: City where Video Mesh node is deployed.
    #: example: Bangalore
    city: Optional[str] = None
    #: Time zone in which the Video Mesh node is deployed.
    #: example: Asia/Kolkata
    time_zone: Optional[str] = None


class BlrNode1(ApiModel):
    #: ID of the Video Mesh node.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzM2ZDg5NGY3LTJiNTctNDNjMS1hY2VlLWQ0N2U2Nzc2MTQxNDo0NjdiNGIxZC1jZWI2LTQwN2EtYWZmOC1mMjIxZmFiNzhjNzI
    node_id: Optional[str] = None
    #: Host Name or the IP of the Video Mesh node.
    #: example: xyz.abc.com
    host_name_or_ip: Optional[str] = None
    #: Deployment Type of the Video Mesh node.
    #: example: Video Mesh Node Lite
    deployment_type: Optional[str] = None
    #: Location details of the Video Mesh node.
    location: Optional[BlrNodeLocation] = None


class ClusterUpgradeScheduleBlr(ApiModel):
    #: Days of the week when scheduled upgrades will occur for the Video Mesh cluster.
    #: example: ['sunday', 'monday', 'tuesday']
    schedule_days: Optional[list[str]] = None
    #: Time when scheduled upgrade will occur for the Video Mesh cluster.
    #: example: 02:00
    schedule_time: Optional[datetime] = None
    #: Timezone of the scheduled upgrade of Video Mesh cluster.
    #: example: Asia/Kolkata
    schedule_time_zone: Optional[str] = None
    #: Upgrade Pending information.
    #: example: True
    upgrade_pending: Optional[bool] = None
    #: Time when the next upgrade is scheduled for the Video Mesh cluster.
    #: example: 2020-03-25T20:30:00Z
    next_upgrade_time: Optional[datetime] = None


class BlrClusterDetails(ApiModel):
    #: ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzFlYjY1ZmRmLTk2NDMtNDE3Zi05OTc0LWFkNzJjYWUwZTEwZjpiMzdmNTgzYy1kZGRjLTQyOGItODJlNS1jYmU2ODFkYjQ5NjI
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: Bangalore
    cluster_name: Optional[str] = None
    #: The Video Mesh nodes in the cluster.
    nodes: Optional[list[BlrNode1]] = None
    #: Release Channel of the Video Mesh cluster.
    #: example: alpha
    release_channel: Optional[str] = None
    #: Upgrade Schedule details of the Video Mesh cluster.
    upgrade_schedule: Optional[ClusterUpgradeScheduleBlr] = None


class ClusterDetailsCollection(ApiModel):
    #: The unique ID for the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8zNmQ4OTRmNy0yYjU3LTQzYzEtYWNlZS1kNDdlNjc3NjE0MTQ
    org_id: Optional[str] = None
    #: Details of all the clusters of the organization.
    items: Optional[list[BlrClusterDetails]] = None


class ClusterDetails(ApiModel):
    items: Optional[list[ClusterDetailsCollection]] = None


class TriggeredTestResult(ApiModel):
    #: Test type of the command ID.
    #: example: MediaHealthMonitorTest
    type: Optional[str] = None
    #: The unique ID for the test being executed.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT01NQU5EX0lELzJjM2M5ZjllLTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhYzo2NTJmNmMxMC01NjgxLTExZWQtOTkyZS1kNTY5YzlkMDlhNzU
    command_id: Optional[str] = None
    #: Unique ID of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8yYzNjOWY5NS03M2Q5LTQ0NjAtYTY2OC0wNDcxNjJmZjFiYWQ=
    org_id: Optional[str] = None
    results: Optional[list[MediaHealthMonitoringclusters]] = None


class NodeStatusList1Status(str, Enum):
    dispatched = 'Dispatched'
    completed = 'Completed'
    errored = 'Errored'


class NodeStatusList1(ApiModel):
    #: Unique ID of the Video Mesh node.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOTUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFkOjE1NmRmNzg5Yzg1NTRkNTVhMjc1ZGY5OTc4Zjk5MDJk
    node_id: Optional[str] = None
    #: Status of the test triggered.
    #: example: Dispatched
    status: Optional[NodeStatusList1Status] = None


class TriggeredTestStatus1(ApiModel):
    #: Unique ID of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8yYzNjOWY5NS03M2Q5LTQ0NjAtYTY2OC0wNDcxNjJmZjFiYWQ=
    org_id: Optional[str] = None
    #: The unique ID of the test being executed.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT01NQU5EX0lELzJjM2M5ZjllLTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhYzo2NTJmNmMxMC01NjgxLTExZWQtOTkyZS1kNTY5YzlkMDlhNzU
    command_id: Optional[str] = None
    #: Unique ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzJjM2M5Zjk1LTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhZDpmMWJmMGI1MC0yMDUyLTQ3ZmUtYjg3ZC01MTFjMmZlNzQ3MWI=
    cluster_id: Optional[str] = None
    nodes: Optional[list[NodeStatusList1]] = None


class TriggerOnDemandBodyType(str, Enum):
    #: Used to test whether the media ports within the Video Mesh node are open, and whether the Video Mesh node is
    #: able to reach the cloud clusters pertaining to the media containers via those ports.
    reachability_test = 'ReachabilityTest'
    #: Used to test the network environment of the Video Mesh node by running various connectivity, bandwidth, and DNS
    #: resolution tests against Webex Cloud and ThirdParty Cloud (Docker) services.
    network_test = 'NetworkTest'
    #: Used to test the meetings and call health of Video Mesh nodes using signalling and cascading methods.
    media_health_monitor_test = 'MediaHealthMonitorTest'


class TriggerOnDemandBody(ApiModel):
    #: Test type to trigger on node.
    #: example: ReachabilityTest
    type: Optional[TriggerOnDemandBodyType] = None


class TriggerOnDemandBodyCluster(ApiModel):
    #: Test type to trigger on node.
    #: example: ReachabilityTest
    type: Optional[TriggerOnDemandBodyType] = None
    #: List of nodes to test.
    #: example: ['Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOWUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFjOjE1NmRmNzg5Yzg1NTRkNTVhMjc1ZGU5OTc4Zjk5MDJk', 'Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOWUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFjOjE1NmRmNzg5Yzg1NTRhYmNhZGVmZ2U5OTc4Zjk5MDJk']
    nodes: Optional[list[str]] = None


class FailureDetails3(ApiModel):
    #: Possible reasons for failure for the test.
    #: example: ['Degraded Network Bandwidth speed detected in the Video Mesh Node connectivity to the Webex Cloud [Error Code: 1402,1405].']
    possible_failure_reason: Optional[list[str]] = None
    #: Possible fixes for the failures mentioned above.
    #: example: ['Please refer to Video Mesh deployment guide to ensure the network settings are configured correctly, and the minimum internet speed requirements are met. If the issue persists, please contact Cisco Support.']
    possible_remediation: Optional[list[str]] = None


class ServiceTypeResult4(ApiModel):
    #: Service for which the test was executed.
    #: example: WebexCloud
    service_type: Optional[str] = None
    #: Result of the test executed.
    #: example: Failed
    test_result: Optional[str] = None
    failure_details: Optional[FailureDetails3] = None


class BandwidthTest(ApiModel):
    #: The type of test result.
    #: example: BandwidthTest
    type: Optional[str] = None
    #: Test Results from different services.
    results: Optional[list[ServiceTypeResult4]] = None


class ConnectivityTestResultsForNode(ApiModel):
    #: The timestamp of the test run.
    #: example: 2022-03-15T15:53:00Z
    timestamp: Optional[datetime] = None
    #: The type of the test being executed. Can be either `OnDemand` or `Periodic`.
    #: example: OnDemand
    trigger_type: Optional[str] = None
    #: Unique ID of the test.
    #: example: Y2lzY29zcGFyazovL3VzL0NPTU1BTkRJRC8xZWI2NWZkZi05NjQzLTQxN2YtOTk3NC1hZDcyY2FlMGUxMGY6YWRlODhhNjAtMzk5Mi0xMWVkLTlhYmQtYzUyMjRiZjNjMzQ4
    id: Optional[str] = None
    result: Optional[list[BandwidthTest]] = None


class PerNodeConnectivityResult1(ApiModel):
    #: Unique ID of the Video Mesh node.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DT05ORUNUT1IvMmMzYzlmOTUtNzNkOS00NDYwLWE2NjgtMDQ3MTYyZmYxYmFkOjE1NmRmNzg5Yzg1NTRkNTVhMjc1ZGY5OTc4Zjk5MDJk
    node_id: Optional[str] = None
    #: Host name or IP Address of the Video Mesh node.
    #: example: abc.company.com
    host_name_or_ip: Optional[str] = Field(alias='hostNameOrIP', default=None)
    test_results: Optional[list[ConnectivityTestResultsForNode]] = None


class PerClusterConnectivityResult1(ApiModel):
    #: Unique ID of the Video Mesh cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzJjM2M5Zjk1LTczZDktNDQ2MC1hNjY4LTA0NzE2MmZmMWJhZDpmMWJmMGI1MC0yMDUyLTQ3ZmUtYjg3ZC01MTFjMmZlNzQ3MWI=
    cluster_id: Optional[str] = None
    #: Name of the Video Mesh cluster.
    #: example: sanjose
    cluster_name: Optional[str] = None
    nodes: Optional[list[PerNodeConnectivityResult1]] = None


class ConnectivityTestResultsClustersObject1(ApiModel):
    #: List of Video Mesh clusters.
    clusters: Optional[list[PerClusterConnectivityResult1]] = None


class ConnectivityTestResultsObject(ApiModel):
    #: Unique ID of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8yYzNjOWY5NS03M2Q5LTQ0NjAtYTY2OC0wNDcxNjJmZjFiYWQ=
    org_id: Optional[str] = None
    #: Start date and time (inclusive) of the Network Test data.
    #: example: 2023-01-15T15:53:00Z
    from_: Optional[datetime] = None
    #: End date and time (inclusive) of the Network Test data.
    #: example: 2023-01-20T15:53:00Z
    to_: Optional[datetime] = None
    #: Network test results.
    items: Optional[list[ConnectivityTestResultsClustersObject1]] = None


class ServiceTypeResult2(ApiModel):
    #: Service for which the test was executed.
    #: example: ThirdPartyCloud
    service_type: Optional[str] = None
    #: Result of the test executed.
    #: example: Success
    test_result: Optional[str] = None


class WebSocketConnectivityTest(ApiModel):
    #: The type of test result.
    #: example: WebSocketConnectivityTest
    type: Optional[str] = None
    #: Test Results from different services.
    results: Optional[list[ServiceTypeResult2]] = None


class UpdateEventThresholdConfig1(ApiModel):
    #: Threshold value (in percentage) to trigger an event.
    #: example: 40.0
    min_threshold: Optional[int] = None
    #: Deafault Threshold value (in percentage) to trigger an event.
    #: example: 10.0
    default_min_threshold: Optional[int] = None


class GetEntityThresholdConfig1(ApiModel):
    #: Name of the event.
    #: example: clusterCallsRedirected
    event_name: Optional[str] = None
    #: Unique ID of the event threshold configuration.
    #: example: Y2lzY29zcGFyazovL3VzL0VWRU5ULzQyN2U5ZTk2LTczYTctNDYwYS04MGZhLTcyNWU4MWE2MDg3Zjo2YzJhZGRmMS0wYjAzLTRiZWEtYjIxYy0xYzFjYzdiY2UwOWQ
    event_threshold_id: Optional[str] = None
    #: The `eventScope` is scope of event.
    #: example: CLUSTER
    event_scope: Optional[str] = None
    #: The `entityId` is the unique ID of the Organization or the unique ID of the Video Mesh Cluster.
    #: example: Y2lzY29zcGFyazovL3VzL0hZQlJJRF9DTFVTVEVSLzRiNTk5NzkwLWVlMzctMTFlZC1hMDViLTAyNDJhYzEyMDAwMzo2NjMxOTMyNC1lZTM3LTExZWQtYTA1Yi0wMjQyYWMxMjAwMDM
    entity_id: Optional[str] = None
    #: Threshold configuration of an `entityId`.
    threshold_config: Optional[UpdateEventThresholdConfig1] = None


class GetEventThresholdResponse(ApiModel):
    #: Unique ID of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8yYzNjOWY5NS03M2Q5LTQ0NjAtYTY2OC0wNDcxNjJmZjFiYWQ
    org_id: Optional[str] = None
    event_thresholds: Optional[list[GetEntityThresholdConfig1]] = None


class BulkUpdateEventThresholdResponse(ApiModel):
    #: Unique ID of the organization.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8yYzNjOWY5NS03M2Q5LTQ0NjAtYTY2OC0wNDcxNjJmZjFiYWQ
    org_id: Optional[str] = None
    #: List of successful updated response
    event_thresholds: Optional[list[GetEntityThresholdConfig1]] = None
    #: List of failed or invalid event threshold IDs.
    #: example: ['Y2lzY29zcGFyazovL3VzL0VWRU5ULzQyN2U5ZTk2LTczYTctNDYwYS04MGZhLTcyNWU4MWE2MDg3ZjowM2ZkYjkzZC1jNTllLTQzMjQtODIwNS1lNDIyYzA3NGQ5Mzg']
    failed_event_threshold_ids: Optional[list[str]] = None


class EventThresholdBodyEventName(str, Enum):
    #: Event name for cluster call redirects.
    cluster_calls_redirected = 'clusterCallsRedirected'
    #: Event name for organization call overflows.
    org_calls_overflowed = 'orgCallsOverflowed'
    none_ = 'none'


class EventThresholdBody(ApiModel):
    #: The name of the event corresponding to the `entitiyId`.
    event_name: Optional[EventThresholdBodyEventName] = None


class ListMediaHealthMonitoringToolTestResultsV2TriggerType(str, Enum):
    on_demand = 'OnDemand'
    periodic = 'Periodic'
    all = 'All'


class ListEventThresholdConfigurationEventName(str, Enum):
    cluster_calls_redirected = 'clusterCallsRedirected'
    org_calls_overflowed = 'orgCallsOverflowed'


class ListEventThresholdConfigurationEventScope(str, Enum):
    cluster = 'CLUSTER'
    org = 'ORG'


class UpdateEventThresholdConfigurationEventThresholdsThresholdConfig(ApiModel):
    min_threshold: Optional[int] = None


class UpdateEventThresholdConfigurationEventThresholds(ApiModel):
    event_threshold_id: Optional[str] = None
    threshold_config: Optional[UpdateEventThresholdConfigurationEventThresholdsThresholdConfig] = None


class ListVirtualLineObject1(ApiModel):
    #: A unique identifier for the virtual line.
    #: example: Y2lzY29zcGFyazovL3VzL1ZJUlRVQUxfTElORS9iMTJhNTBiMi01N2NiLTQ0MzktYjc1MS1jZDQ4M2I4MjhmNmU=
    id: Optional[str] = None
    #: Last name for virtual line.
    #: example: Shen
    last_name: Optional[str] = None
    #: First name for virtual line.
    #: example: Tom
    first_name: Optional[str] = None
    #: `callerIdLastName` for virtual line.
    #: example: Shen
    caller_id_last_name: Optional[str] = None
    #: `callerIdFirstName` for virtual line.
    #: example: Tom
    caller_id_first_name: Optional[str] = None
    #: `callerIdNumber` for virtual line.
    #: example: +15558675313
    caller_id_number: Optional[str] = None
    #: `externalCallerIdNamePolicy` for the virtual line.
    #: example: DIRECT_LINE
    external_caller_id_name_policy: Optional[ListVirtualLineObjectExternalCallerIdNamePolicy] = None
    #: `customExternalCallerIdName` for virtual line.
    #: example: Tom
    custom_external_caller_id_name: Optional[str] = None
    #: Calling details of virtual line.
    number: Optional[GetUserNumberItemObject2] = None
    #: Location details of virtual line.
    location: Optional[Location] = None
    #: Number of devices assigned to a virtual line.
    #: example: 1.0
    number_of_devices_assigned: Optional[int] = None
    #: Type of billing plan.
    #: example: BCOCP1
    billing_plan: Optional[str] = None


class ReadTheListOfVirtualLinesResponse1(ApiModel):
    #: Array of virtual lines.
    virtual_lines: Optional[list[ListVirtualLineObject1]] = None


class SkillCreateRequestLanguages(str, Enum):
    en = 'en'
    es = 'es'
    fr = 'fr'


class SkillCreateRequest(ApiModel):
    languages: Optional[list[SkillCreateRequestLanguages]] = None
    url: Optional[str] = None
    name: Optional[str] = None
    contact_email: Optional[str] = Field(alias='contact_email', default=None)
    secret: Optional[str] = None
    public_key: Optional[str] = Field(alias='public_key', default=None)
    #: example: ['[]']
    suggested_invocation_names: Optional[list[str]] = Field(alias='suggested_invocation_names', default=None)


class SkillCreateResponse(ApiModel):
    skill_id: Optional[str] = Field(alias='skill_id', default=None)
    developer_id: Optional[str] = Field(alias='developer_id', default=None)
    url: Optional[str] = None
    name: Optional[str] = None
    contact_email: Optional[str] = Field(alias='contact_email', default=None)
    public: Optional[bool] = None
    deleted: Optional[bool] = None
    created_at: Optional[str] = Field(alias='created_at', default=None)
    deleted_at: Optional[str] = Field(alias='deleted_at', default=None)
    modified_at: Optional[str] = Field(alias='modified_at', default=None)
    #: example: ['[]']
    suggested_invocation_names: Optional[list[str]] = Field(alias='suggested_invocation_names', default=None)
    languages: Optional[list[str]] = None


class DeveloperRegistrationGetResponse(ApiModel):
    registration_id: Optional[str] = Field(alias='registration_id', default=None)
    skill_id: Optional[str] = Field(alias='skill_id', default=None)
    enabled: Optional[bool] = None
    languages: Optional[list[str]] = None
    invocation_names: Optional[list[str]] = Field(alias='invocation_names', default=None)
    created_at: Optional[str] = Field(alias='created_at', default=None)
    modified_at: Optional[str] = Field(alias='modified_at', default=None)
    developer_id: Optional[str] = Field(alias='developer_id', default=None)


class DeveloperRegistrationUpdateRequest(ApiModel):
    invocation_names: Optional[list[str]] = Field(alias='invocation_names', default=None)


class WebhookResource(str, Enum):
    #: The `Attachment Actions
    #: <https://developer.webex.com/docs/api/v1/attachment-actions>`_ resource.
    attachment_actions = 'attachmentActions'
    #: The `Memberships
    #: <https://developer.webex.com/docs/api/v1/memberships>`_ resource.
    memberships = 'memberships'
    #: The `Messages
    #: <https://developer.webex.com/docs/api/v1/messages>`_ resource.
    messages = 'messages'
    #: The `Rooms
    #: <https://developer.webex.com/docs/api/v1/rooms>`_ resource.
    rooms = 'rooms'
    #: The `Meetings
    #: <https://developer.webex.com/docs/api/v1/meetings>`_ resource.
    meetings = 'meetings'
    #: The `Recordings
    #: <https://developer.webex.com/docs/api/v1/recordings>`_ resource.
    recordings = 'recordings'
    #: The `Meeting Participants
    #: <https://developer.webex.com/docs/api/v1/meeting-participants>`_ resource.
    meeting_participants = 'meetingParticipants'
    #: The `Meeting Transcripts
    #: <https://developer.webex.com/docs/api/v1/meeting-transcripts>`_ resource.
    meeting_transcripts = 'meetingTranscripts'


class WebhookEvent(str, Enum):
    #: An object was created.
    created = 'created'
    #: An object was updated.
    updated = 'updated'
    #: An object was deleted.
    deleted = 'deleted'
    #: A meeting was started.
    started = 'started'
    #: A meeting was ended.
    ended = 'ended'
    #: A participant joined.
    joined = 'joined'
    #: A participant left.
    left = 'left'
    #: A room was migrated to a different geography. The roomId has changed.
    migrated = 'migrated'


class WebhookStatus(str, Enum):
    #: The webhook is active.
    active = 'active'
    #: The webhook is inactive.
    inactive = 'inactive'


class Webhook(ApiModel):
    #: A unique identifier for the webhook.
    #: example: Y2lzY29zcGFyazovL3VzL1dFQkhPT0svOTZhYmMyYWEtM2RjYy0xMWU1LWExNTItZmUzNDgxOWNkYzlh
    id: Optional[str] = None
    #: A user-friendly name for the webhook.
    #: example: My Awesome Webhook
    name: Optional[str] = None
    #: The URL that receives POST requests for each event.
    #: example: https://example.com/mywebhook
    target_url: Optional[str] = None
    #: The resource type for the webhook. Creating a webhook requires 'read' scope on the resource the webhook is for.
    #: example: messages
    resource: Optional[WebhookResource] = None
    #: The event type for the webhook.
    #: example: created
    event: Optional[WebhookEvent] = None
    #: The filter that defines the webhook scope.
    #: example: roomId=Y2lzY29zcGFyazovL3VzL1JPT00vYmJjZWIxYWQtNDNmMS0zYjU4LTkxNDctZjE0YmIwYzRkMTU0
    filter: Optional[str] = None
    #: The secret used to generate payload signature.
    #: example: 86dacc007724d8ea666f88fc77d918dad9537a15
    secret: Optional[str] = None
    #: The status of the webhook. Use `active` to reactivate a disabled webhook.
    #: example: active
    status: Optional[WebhookStatus] = None
    #: The date and time the webhook was created.
    #: example: 2015-10-18T14:26:16+00:00
    created: Optional[datetime] = None
    #: Specify `org` when creating an org/admin level webhook. Supported for `meetings`, `recordings`,
    #: `meetingParticipants`, `meetingTranscripts`, `videoMeshAlerts`, `controlHubAlerts`, `rooms`, and `messaging`
    #: (for Compliance Officers and messages with file attachments only - see `inline file DLP
    #: <https://developer.webex.com/docs/api/guides/webex-real-time-file-dlp-basics>`_) resources.
    #: example: org
    owned_by: Optional[str] = None


class WebhookCollectionResponse(ApiModel):
    items: Optional[list[Webhook]] = None


class ListReportType(str, Enum):
    user = 'USER'
    customer = 'CUSTOMER'
    partner = 'PARTNER'


class ListReport1(ApiModel):
    #: A unique report id that corresponds to a billing report.
    #: example: 'Y2lzY29zcGFyazovL3VzL0JJTExJTkdfUkVQT1JULzViOGQ1MThhLThmMDAtNDUxYi1hNDA2LWVhZjQ5YjRhN2ZhOA'
    id: Optional[str] = None
    #: Billing report startDate.
    #: example: 2021-05-21
    billing_start_date: Optional[datetime] = None
    #: Billing report endDate.
    #: example: 2021-05-30
    billing_end_date: Optional[datetime] = None
    #: The status of the billing report
    #: example: COMPLETED
    status: Optional[ReportStatus] = None
    #: Billing Report Type.
    #: example: PARTNER
    type: Optional[ListReportType] = None


class Report2(ApiModel):
    #: A unique report ID that corresponds to a billing report.
    #: example: 'Y2lzY29zcGFyazovL3VzL0JJTExJTkdfUkVQT1JULzViOGQ1MThhLThmMDAtNDUxYi1hNDA2LWVhZjQ5YjRhN2ZhOA'
    id: Optional[str] = None
    #: Billing report `startDate`.
    #: example: 2021-05-21
    billing_start_date: Optional[datetime] = None
    #: Billing report `endDate`.
    #: example: 2021-05-30
    billing_end_date: Optional[datetime] = None
    #: Billing Report Type
    #: example: PARTNER
    type: Optional[ListReportType] = None
    #: The date and time the report was generated.
    #: example: 2021-06-16T12:40:33.109Z
    created: Optional[datetime] = None
    #: The person ID of the partner administrator who created the report.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS8wYWNkMzg3NS00ZTEyLTRkNzctYjk4MS1lMzg5ZmQ4ODQ2YzA
    created_by: Optional[str] = None
    #: The status of the billing report.
    #: example: COMPLETED
    status: Optional[ReportStatus] = None
    #: The URL for partners to download the billing report.
    #: example: https://billing-reports-int-us-east-1.webexcontent.com/a366de9b-3204-4140-8181-25808d360e36/WHOLESALE/340177d1-7f25-41e1-a39f-ad63ec1103a5.csv?Expires=1624978489&Signature=Syp3vrVeMx4P6MeMtm8e1bQaeAdHFe-c7NeHERWh5-qJGLZ1T8Dvl2ee-M8OsFf~z6Yepz94e2Hh1HDVailD0Uryl8SgiM~jl0cBh7L0PmSe~i9oFA0eJ0MulkqGSMVf7ZHhxY55xYMgIBZIERkWm3CqQNDg5BS4EaXapKfOnmFegf36OokCM63m5uOK8-csk08IkZhwo2Z0l1JMtuWYEaLh4dgMHoe~xgH3YmDSSCWInFYaEifUAfgi2YAYS6nP9Zq4BTliBq62XBaehOE1gBrhy4RdwD-3WSs2oD-BdpoRpuGzo3FZzDLVEvd0S2D6gTcHljOHodQKxe-u0BXPWQ__&Key-Pair-Id=APKAJADAKLCI2FW2U32Q
    temp_download_url: Optional[str] = Field(alias='tempDownloadURL', default=None)
    #: List of errors that occurred during report generation.
    #: 
    #: **Note:**
    #: 
    #: * This list captures errors that occurred during asynchronous or background report generation, after the request
    #: has been accepted and a `202 OK` response is returned.
    errors: Optional[list[ReportError]] = None


class ReportId1(ApiModel):
    #: A unique report ID that corresponds to a billing report.
    #: example: 'Y2lzY29zcGFyazovL3VzL0JJTExJTkdfUkVQT1JULzViOGQ1MThhLThmMDAtNDUxYi1hNDA2LWVhZjQ5YjRhN2ZhOA'
    id: Optional[str] = None
    #: Billing report startDate.
    #: example: 2021-05-21
    billing_start_date: Optional[datetime] = None
    #: Billing report endDate.
    #: example: 2021-05-30
    billing_end_date: Optional[datetime] = None
    #: Billing Report Type
    #: example: PARTNER
    type: Optional[ListReportType] = None


class WholesaleBillingReportsListResponse(ApiModel):
    #: An array of report objects.
    items: Optional[list[ListReport1]] = None


class ListWholesaleBillingReportsSortBy(str, Enum):
    id = 'id'
    billing_start_date = 'billingStartDate'
    billing_end_date = 'billingEndDate'
    status = 'status'


class Address(ApiModel):
    #: Address Line 1.
    #: example: 771 Alder Drive
    address_line1: Optional[str] = None
    #: Address Line 2.
    #: example: Cisco Site 5
    address_line2: Optional[str] = None
    #: City of the customer.
    #: example: Milpitas
    city: Optional[str] = None
    #: State or Province of the customer.
    #: example: CA
    state_or_province: Optional[str] = None
    #: Postal/Zip code of the customer.
    #: example: 95035
    zip_or_postal_code: Optional[str] = None
    #: ISO2 country code of the customer size = 2.
    #: example: `US`:
    country: Optional[str] = None


class CustomerStatus(str, Enum):
    #: Customer is fully provisioned on Cisco Webex.
    provisioned = 'provisioned'
    #: Customer is provisioned with errors.
    provisioned_with_errors = 'provisioned_with_errors'
    #: Customer is provisioning.
    provisioning = 'provisioning'
    #: Customer is updating.
    updating = 'updating'
    #: Customer is being deleted.
    deleting = 'deleting'
    #: An error occurred provisioning the customer on Cisco Webex.
    error = 'error'
    #: The customer is pending a Denied Party List compliance check.
    pending_rpl_review = 'pending_rpl_review'


class PackageName(str, Enum):
    #: Webex Common Area Calling Package.
    common_area_calling = 'common_area_calling'
    #: Webex Calling Package.
    webex_calling = 'webex_calling'
    #: Webex Meetings Package.
    webex_meetings = 'webex_meetings'
    #: Webex Suite Package.
    webex_suite = 'webex_suite'
    #: Webex Voice Package.
    webex_voice = 'webex_voice'


class PackageStatus(str, Enum):
    #: Customer is fully provisioned on Cisco Webex.
    provisioned = 'provisioned'
    #: Customer is provisioning.
    provisioning = 'provisioning'
    #: Customer is being deleted.
    deleting = 'deleting'
    #: An error occurred provisioning the customer on Cisco Webex.
    error = 'error'


class Package(ApiModel):
    #: The Webex Wholesale Packages assigned to the customer.
    #: example: common_area_calling
    name: Optional[PackageName] = None
    #: The provisioning status of the a particular package.
    #: example: provisioned
    status: Optional[PackageStatus] = None
    #: List of warnings that occurred during that last attempt to provision/update this customer.
    #: 
    #: *Note:*
    #: 
    #: + This list captures errors that occurred during *asynchronous or background* provisioning of the customer,
    #: *after* the API has been accepted and 202 response returned.
    #: 
    #: + Any errors that occur during initial API request validation will be captured directly in error response with
    #: appropriate HTTP status code.
    warnings: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None
    #: List of errors that occurred during that last attempt to provision/update this customer.
    #: 
    #: *Note:*
    #: 
    #: + This list captures errors that occurred during *asynchronous or background* provisioning of the customer,
    #: *after* the API has been accepted and 202 response returned.
    #: 
    #: + Any errors that occur during initial API request validation will be captured directly in error response with
    #: appropriate HTTP status code.
    errors: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None


class ResourceDetails(ApiModel):
    packages: Optional[list[Package]] = None


class Customer2(ApiModel):
    #: A unique Cisco identifier for the customer. This value should be used for the `customerId` parameter in the
    #: Wholesale Customers and Wholesale Subscribers API.
    #: example: 'Y2lzY29zcGFyazovL3VzL0VOVEVSUFJJU0UvNTJjZjU3NmQtNjBhOC00MDdhLWIyMmMtNDY3YzUxNTkxOTA4'
    id: Optional[str] = None
    #: The Organization ID of the enterprise on Cisco Webex, to be used when referencing this customer on other Cisco
    #: Webex APIs. Only presented when status is `provisioned`.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    org_id: Optional[str] = None
    #: External ID of the Customer.
    #: example: c1677a16-557a-4fb4-b48f-24adde57ec99
    external_id: Optional[str] = None
    address: Optional[Address] = None
    #: The provisioning status of the customer.
    #: example: provisioned
    status: Optional[CustomerStatus] = None
    #: List of package names provisioned
    #: example: ['common_area_calling', 'webex_calling', 'webex_meetings', 'webex_suite', 'webex_voice']
    packages: Optional[list[str]] = None
    resource_details: Optional[ResourceDetails] = None
    #: List of errors that occurred during that last attempt to provision/update this customer.
    #: 
    #: *Note:*
    #: 
    #: + This list captures errors that occurred during *asynchronous or background* provisioning of the customer,
    #: *after* the API has been accepted and 202 response returned.
    #: 
    #: + Any errors that occur during initial API request validation will be captured directly in error response with
    #: appropriate HTTP status code.
    errors: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None


class CustomerListResponse(ApiModel):
    #: An array of Customer objects.
    items: Optional[list[Customer2]] = None


class ResourceURL(ApiModel):
    #: A URL which points to the `Get a Wholesale Customer
    #: <https://developer.webex.com/docs/api/v1/wholesale-provisioning/get-a-wholesale-customer>`_ endpoint for the provisioned customer.
    #: example: "https://webexapis.com/v1/wholesale/customers/Y2lzY29zcGFyazovL3VzL0VOVEVSUFJJU0UvNTJjZjU3NmQtNjBhOC00MDdhLWIyMmMtNDY3YzUxNTkxOTA4"
    url: Optional[str] = None


class SubPartnerProvisioningState(str, Enum):
    _active_ = 'active'
    #: Sub-partner can provision new customers and subscribers or update, delete existing ones.
    active = 'active'
    #: Sub-partner cannot provision, update customers and subscribers but can delete existing ones.
    suspended = 'suspended'


class SubPartner(ApiModel):
    #: The Organization ID for the sub-partner.
    #: example: 'Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE'
    org_id: Optional[str] = None
    #: The Wholesale Subscription ID of the partner.
    #: example: 'Sub23452345'
    subscription_id: Optional[str] = None
    #: The provisioning status of the sub-partner.
    #: example: 'active'
    provisioning_state: Optional[SubPartnerProvisioningState] = None
    #: 02-16T14:10:18.855Z' (string) - The date and time the sub-partner was created.
    #: example: '2023
    created: Optional[datetime] = None
    #: 02-22T13:43:41.117Z' (string) - The date and time from which new billing for the sub-partner started.
    #: example: '2023
    billing_start_date: Optional[datetime] = None


class SubPartnersListResponse(ApiModel):
    #: An array of `SubPartner` objects.
    items: Optional[list[SubPartner]] = None


class SubscriberPackage2(str, Enum):
    #: Calling Basic Package.
    webex_calling = 'webex_calling'
    #: Meetings Package.
    webex_meetings = 'webex_meetings'
    #: Suite Package.
    webex_suite = 'webex_suite'
    #: Voice Package.
    webex_voice = 'webex_voice'


class SubscriberStatus2(str, Enum):
    #: The subscriber is fully provisioned on Cisco Webex.
    provisioned = 'provisioned'
    #: The subscriber user migration is pending.
    pending_user_migration = 'pending_user_migration'


class Subscriber2(ApiModel):
    #: A unique Cisco identifier for the subscriber.
    #: example: 'Y2lzY29zcGFyazovL3VzL1NVQlNDUklCRVIvNjk3MGU2YmItNzQzOS00ZmZiLWFkMzQtZDNmZjAxNjdkZGFk'
    id: Optional[str] = None
    #: The person id of the subscriber used in the /people API. Only presented when status is `provisioned`.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    person_id: Optional[str] = None
    #: The email address of the subscriber.
    #: example: john.anderson@acme.com
    email: Optional[str] = None
    #: A unique identifier for the customer.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS9mNWIzNjE4Ny1jOGRkLTQ3MjctOGIyZi1mOWM0NDdmMjkwNDY
    customer_id: Optional[str] = None
    #: External ID of the Wholesale customer.
    #: example: c1677a16-557a-4fb4-b48f-24adde57ec99
    external_customer_id: Optional[str] = None
    #: The Webex Wholesale Package assigned to the subscriber.
    #: example: webex_calling
    package: Optional[SubscriberPackage2] = None
    #: The provisioning status of the user.
    #: example: provisioned
    status: Optional[SubscriberStatus2] = None
    #: List of errors that occurred during that last attempt to provision/update this subscriber.
    #: 
    #: *Note:*
    #: 
    #: + This list captures errors that occurred during provisioning of the subscriber.
    #: 
    #: + Any errors that occur during initial API request validation will be captured directly in error response with
    #: appropriate HTTP status code.
    errors: Optional[list[EnterpriseBroadworksDirectorySyncDirectorySyncStatusErrors]] = None
    #: The date and time the subscriber was provisioned.
    #: example: 2019-10-18T14:26:16.000Z
    created: Optional[datetime] = None
    #: The date and time the provisioning status of the subscriber last changed.
    #: example: 2020-03-18T16:05:34.000Z
    last_status_change: Optional[datetime] = None


class SubscriberListResponse2(ApiModel):
    #: An array of Subscriber objects.
    items: Optional[list[Subscriber2]] = None


class ProvisionAWholesaleCustomerCustomerInfo(ApiModel):
    #: The name of the Wholesale customer.
    #: example: John's Pizza
    name: Optional[str] = None
    #: The primary email address of the customer.
    #: example: john.anderson@acme.com
    primary_email: Optional[str] = None
    #: The {ISO-639-1}_{ISO-3166} or {ISO-639-1} locale or language code used as preferred language for organization
    #: and Webex Meeting Sites. Refer to the `help page
    #: <https://www.cisco.com/c/en/us/td/docs/voice_ip_comm/cloudCollaboration/wholesale_rtm/wbxbw_b_wholesale-rtm-solution-guide/wbxbw_m_overview-of-webex-wholesale.html#Cisco_Reference.dita_deb994cb-9c48-4488-b352-54495c54ba1e>`_ for more information.
    #: example: 'en'
    language: Optional[str] = None


class ProvisionAWholesaleCustomerProvisioningParametersCallingLocation(ApiModel):
    #: Name of the wholesale customer office.
    #: example: Head Office
    name: Optional[str] = None
    #: Address of the wholesale customer.
    address: Optional[Address] = None
    #: Customer timezone for calling package.
    #: example: America/Los_Angeles
    timezone: Optional[str] = None
    #: Determine language for all generated emails and voice announcements.
    #: example: en_us
    language: Optional[str] = None
    #: SIP Header for any emergency calls from this location.
    #: example: 95547321
    emergency_location_identifier: Optional[str] = None
    #: List of numbers to be assigned to the location.
    #: example: ['+17205557878', '+17205557879', '+17205557880', '+17205557881']
    numbers: Optional[list[str]] = None
    #: Main number of the Wholesale customer.
    #: example: +17205557878
    main_number: Optional[str] = None


class ProvisionAWholesaleCustomerProvisioningParametersCalling(ApiModel):
    location: Optional[ProvisionAWholesaleCustomerProvisioningParametersCallingLocation] = None


class ProvisionAWholesaleCustomerProvisioningParametersMeetings(ApiModel):
    #: Customer timezone for meetings package.
    #: example: America/Los_Angeles
    timezone: Optional[str] = None


class ProvisionAWholesaleCustomerProvisioningParameters(ApiModel):
    calling: Optional[ProvisionAWholesaleCustomerProvisioningParametersCalling] = None
    meetings: Optional[ProvisionAWholesaleCustomerProvisioningParametersMeetings] = None


class PrecheckAWholesaleCustomerProvisioningCustomerInfo(ApiModel):
    #: The name of the Wholesale customer.
    #: example: John's Pizza
    name: Optional[str] = None
    #: The primary email address of the Wholesale customer.
    #: example: "john.anderson@acme.com"
    primary_email: Optional[str] = None


class ProvisionAWholesaleSubscriberProvisioningParameters(ApiModel):
    #: The first name of the subscriber.
    #: example: John
    first_name: Optional[str] = None
    #: The last name of the subscriber.
    #: example: Andersen
    last_name: Optional[str] = None
    #: The primary phone number configured for the subscriber. A primary phone number, extension, or both must be
    #: supplied when assigning a calling-enabled package, unless the subscriber is an existing Webex Calling entitled
    #: user.
    #: example: +12405551212
    primary_phone_number: Optional[str] = None
    #: The extension configured for the subscriber. An extension, primary phone number or both must be supplied when
    #: assigning a calling-enabled package, unless the subscriber is an existing Webex Calling entitled user.
    #: example: 51212
    extension: Optional[str] = None
    #: A unique identifier for the location. This ID should be retrieved via the `List Locations
    #: <https://developer.webex.com/docs/api/v1/locations/list-locations>`_ API.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzAxMjM0NTY3LTg5YWItY2RlZi0wMTIzLTQ1Njc4OWFiY2RlZg==
    location_id: Optional[str] = None


class UpdateAWholesaleSubscriberProvisioningParameters(ApiModel):
    #: The primary phone number configured for the subscriber. A primary phone number, extension, or both must be
    #: supplied when changing from the webex_meetings package to any calling-enabled package.
    #: example: +1-240-555-1212
    primary_phone_number: Optional[str] = None
    #: The extension configured for the subscriber. An extension, primary phone number or both must be supplied when
    #: changing from the webex_meetings package to any calling-enabled package.
    #: example: 5221
    extension: Optional[datetime] = None
    #: A unique identifier for the location. This id should be retrieved via the `List Locations
    #: <https://developer.webex.com/docs/api/v1/locations/list-locations>`_ API.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzAxMjM0NTY3LTg5YWItY2RlZi0wMTIzLTQ1Njc4OWFiY2RlZg==
    location_id: Optional[str] = None


class CLIDPolicySelection(str, Enum):
    #: Outgoing caller ID will show the caller's direct line number and/or extension.
    direct_line = 'DIRECT_LINE'
    #: Outgoing caller ID will show the main number for the location.
    location_number = 'LOCATION_NUMBER'
    #: Outgoing caller ID will show the value from the `customNumber` field.
    custom = 'CUSTOM'


class ModifyPlaceCallerIdGet(ApiModel):
    #: Which type of outgoing Caller ID will be used.
    #: example: DIRECT_LINE
    selected: Optional[CLIDPolicySelection] = None
    #: This value must be an assigned number from the workspace's location.
    #: example: +12815550003
    custom_number: Optional[str] = None
    #: Workspace's caller ID display name.
    #: example: Clockmaker's shop 7.1
    display_name: Optional[str] = None
    #: Workspace's caller ID display details.
    #: example: .
    display_detail: Optional[str] = None
    #: Flag to block call forwarding.
    #: example: True
    block_in_forward_calls_enabled: Optional[bool] = None
    #: Designates which type of External Caller ID Name policy is used. Default is `DIRECT_LINE`.
    #: example: DIRECT_LINE
    external_caller_id_name_policy: Optional[ListVirtualLineObjectExternalCallerIdNamePolicy] = None
    #: Custom External Caller Name, which will be shown if External Caller ID Name is `OTHER`.
    #: example: Custom external caller name
    custom_external_caller_id_name: Optional[str] = None
    #: External Caller Name, which will be shown if External Caller ID Name is `OTHER`.
    #: example: Anna
    location_external_caller_id_name: Optional[str] = None


class UserNumberItem1(ApiModel):
    #: Phone number of person or workspace. Either `phoneNumber` or `extension` is mandatory.
    #: example: +19075552859
    external: Optional[str] = None
    #: Extension of person or workspace. Either `phoneNumber` or `extension` is mandatory.
    #: example: 8080
    extension: Optional[datetime] = None
    #: Flag to indicate primary phone.
    #: example: True
    primary: Optional[bool] = None
    #: Flag to indicate toll free number.
    #: example: True
    toll_free_number: Optional[bool] = None


class MonitoredElementUser1(ApiModel):
    #: ID of person or workspace.
    #: example: Y2lzY29zcGFyazovL3VzL1BFT1BMRS80NDVkMzMzMC1mNjE3LTExZWItOWQyZS01NzViODE3ZGE2NmE
    id: Optional[str] = None
    #: First name of person or workspace.
    #: example: John
    first_name: Optional[str] = None
    #: Last name of person or workspace.
    #: example: Brown
    last_name: Optional[str] = None
    #: Display name of person or workspace.
    #: example: John Brown
    display_name: Optional[str] = None
    #: Type of the person or workspace.
    #: example: PEOPLE
    type: Optional[MemberType1] = None
    #: Email of the person or workspace.
    #: example: john.brown@gmail.com
    email: Optional[str] = None
    #: List of phone numbers of the person or workspace.
    numbers: Optional[list[UserNumberItem1]] = None
    #: Name of location for call park.
    #: example: Alaska
    location: Optional[str] = None
    #: ID of the location for call park.
    #: example: Y2lzY29zcGFyazovL3VzL0xPQ0FUSU9OLzEyMzQ1
    location_id: Optional[str] = None


class MonitoredElementItem1(ApiModel):
    #: Monitored Call Park extension.
    callparkextension: Optional[GetMonitoredElementsObjectCallparkextension1] = None
    #: Monitored member for this workspace.
    member: Optional[MonitoredElementUser1] = None


class PlaceCallerIdGet(ApiModel):
    #: Allowed types for the `selected` field.
    types: Optional[list[CLIDPolicySelection]] = None
    #: Which type of outgoing Caller ID will be used.
    #: example: DIRECT_LINE
    selected: Optional[CLIDPolicySelection] = None
    #: Direct number which will be shown if `DIRECT_LINE` is selected.
    #: example: +12815550003
    direct_number: Optional[str] = None
    #: Location number which will be shown if `LOCATION_NUMBER` is selected
    #: example: +12815550002
    location_number: Optional[str] = None
    #: Flag for specifying a toll-free number.
    toll_free_location_number: Optional[bool] = None
    #: This value must be an assigned number from the person's location.
    #: example: +12815550003
    custom_number: Optional[str] = None
    #: Workspace's caller ID display name.
    #: example: Clockmaker's shop 7.1
    display_name: Optional[str] = None
    #: Workspace's caller ID display details. Default is `.`.
    #: example: .
    display_detail: Optional[str] = None
    #: Flag to block call forwarding.
    #: example: True
    block_in_forward_calls_enabled: Optional[bool] = None
    #: Designates which type of External Caller ID Name policy is used. Default is `DIRECT_LINE`.
    #: example: DIRECT_LINE
    external_caller_id_name_policy: Optional[ListVirtualLineObjectExternalCallerIdNamePolicy] = None
    #: Custom External Caller Name, which will be shown if External Caller ID Name is `OTHER`.
    #: example: Custom external caller name
    custom_external_caller_id_name: Optional[str] = None
    #: External Caller Name, which will be shown if External Caller ID Name is `OTHER`.
    #: example: Anna
    location_external_caller_id_name: Optional[str] = None


class UserMonitoringGet1(ApiModel):
    #: Call park notification enabled or disabled.
    #: example: True
    call_park_notification_enabled: Optional[bool] = None
    #: Monitored element items.
    monitored_elements: Optional[MonitoredElementItem1] = None


class UserPlaceAuthorizationCodeListGet(ApiModel):
    #: Indicates the set of activation codes and description.
    access_codes: Optional[list[AuthorizationCode]] = None


class ListNumbersAssociatedWithASpecificWorkspaceResponse1(ApiModel):
    #: Array of numbers primary followed by alternate numbers.
    phone_numbers: Optional[list[GetUserNumberItemObject2]] = None
    #: Workspace object having a unique identifier for the Workspace.
    workspace: Optional[DepartmentResponseWithId] = None
    #: Location object having a unique identifier for the location and its name.
    location: Optional[Location] = None
    #: Organization object having a unique identifier for the organization and its name.
    organization: Optional[Location] = None


class Location10(ApiModel):
    #: Unique identifier for the location.
    #: example: Y2lzY29zcGFyazovL3VybjpURUFNOnVzLWVhc3QtMV9pbnQxMy9XT1JLU1BBQ0VfTE9DQVRJT04vM2E2ZmYzNzMtNjhhNy00NGU0LTkxZDYtYTI3NDYwZTBhYzVjIzUxOWY2N2E1LTlkOTktNGM2My04YTA5LWI5MTcxY2M2NmJkMQ==
    id: Optional[str] = None
    #: A friendly name for the location.
    #: example: Cisco Barcelona
    display_name: Optional[str] = None
    #: The location address.
    #: example: Carrer de Pere IV, Barcelona, Spain
    address: Optional[str] = None
    #: The location country code (ISO 3166-1).
    #: example: ES
    country_code: Optional[str] = None
    #: The location city name.
    #: example: Barcelona
    city_name: Optional[str] = None
    #: The location latitude.
    #: example: 41.4066147
    latitude: Optional[int] = None
    #: The location longitude.
    #: example: 2.2007173
    longitude: Optional[int] = None
    #: Notes associated with the location.
    #: example: A note about the location
    notes: Optional[str] = None


class WorkspaceLocationsCreationRequest(ApiModel):
    #: A friendly name for the location.
    #: example: Cisco Barcelona
    display_name: Optional[str] = None
    #: The location address.
    #: example: Carrer de Pere IV, Barcelona, Spain
    address: Optional[str] = None
    #: The location country code (ISO 3166-1).
    #: example: ES
    country_code: Optional[str] = None
    #: The location city name.
    #: example: Barcelona
    city_name: Optional[str] = None
    #: The location latitude.
    #: example: 41.4066147
    latitude: Optional[int] = None
    #: The location longitude.
    #: example: 2.2007173
    longitude: Optional[int] = None
    #: Notes associated with the location.
    #: example: A note about the location
    notes: Optional[str] = None


class WorkspaceLocationsCollectionResponse(ApiModel):
    #: An array of location objects.
    items: Optional[list[Location10]] = None


class AggregatedMetric(ApiModel):
    #: Timestamp indicating the start of the aggregation bucket (ISO 8601).
    #: example: 2021-10-21T12:00:00
    start: Optional[datetime] = None
    #: Timestamp indicating the end of the aggregation bucket (ISO 8601).
    #: example: 2021-10-21T13:00:00
    end: Optional[datetime] = None
    #: The mean measurement value in the bucket.
    #: example: 12.3
    mean: Optional[int] = None
    #: The lowest measurement value in the bucket.
    #: example: 5.1
    min: Optional[int] = None
    #: The highest measurement value in the bucket.
    #: example: 8.8
    max_: Optional[int] = None


class RawMetric(ApiModel):
    #: ID of the device reporting the metric.
    #: example: Y2lzY29zcGFyazovM4dz09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    device_id: Optional[str] = None
    #: Timestamp of the measurement (ISO 8601).
    #: example: 2021-10-21T13:00:00
    timestamp: Optional[datetime] = None
    #: The measurement value.
    #: example: 5.1
    value: Optional[int] = None


class WorkspaceMetricsResponseMetricName(str, Enum):
    sound_level = 'soundLevel'
    ambient_noise = 'ambientNoise'
    temperature = 'temperature'
    humidity = 'humidity'
    tvoc = 'tvoc'
    people_count = 'peopleCount'


class WorkspaceMetricsResponseAggregation(str, Enum):
    none_ = 'none'
    hourly = 'hourly'
    daily = 'daily'


class WorkspaceMetricsResponseUnit(str, Enum):
    celsius = 'celsius'
    fahrenheit = 'fahrenheit'


class WorkspaceMetricsResponseSortBy(str, Enum):
    newest_first = 'newestFirst'
    oldest_first = 'oldestFirst'


class WorkspaceMetricsResponse(ApiModel):
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    workspace_id: Optional[str] = None
    #: example: temperature
    metric_name: Optional[WorkspaceMetricsResponseMetricName] = None
    #: example: hourly
    aggregation: Optional[WorkspaceMetricsResponseAggregation] = None
    #: example: 2020-10-21T13:33:37.789Z
    from_: Optional[datetime] = None
    #: example: 2020-10-31T16:00:00.532Z
    to_: Optional[datetime] = None
    #: Output data unit (only present if `metricName` is `temperature`).
    #: example: celsius
    unit: Optional[WorkspaceMetricsResponseUnit] = None
    #: example: newestFirst
    sort_by: Optional[WorkspaceMetricsResponseSortBy] = None
    items: Optional[list[RawMetric]] = None


class DurationMetric(ApiModel):
    #: Timestamp indicating the start of the aggregation bucket (ISO 8601).
    #: example: 2021-10-21T12:00:00Z
    start: Optional[datetime] = None
    #: Timestamp indicating the end of the aggregation bucket (ISO 8601).
    #: example: 2021-10-21T13:00:00Z
    end: Optional[datetime] = None
    #: The time duration (in a given state) in the bucket.
    #: example: 13.0
    duration: Optional[int] = None


class WorkspaceDurationMetricsResponseAggregation(str, Enum):
    hourly = 'hourly'
    daily = 'daily'


class WorkspaceDurationMetricsResponseMeasurement(str, Enum):
    time_used = 'timeUsed'
    time_booked = 'timeBooked'


class WorkspaceDurationMetricsResponse(ApiModel):
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi85NmFiYzJhYS0zZGNjLTExZTUtYTE1Mi1mZTM0ODE5Y2RjOWE
    workspace_id: Optional[str] = None
    #: example: hourly
    aggregation: Optional[WorkspaceDurationMetricsResponseAggregation] = None
    #: example: timeBooked
    measurement: Optional[WorkspaceDurationMetricsResponseMeasurement] = None
    #: example: 2020-10-21T13:33:37.789Z
    from_: Optional[datetime] = None
    #: example: 2020-10-31T16:00:00.532Z
    to_: Optional[datetime] = None
    #: The time unit.
    #: example: minutes
    unit: Optional[str] = None
    items: Optional[list[DurationMetric]] = None


class WorkspacePersonalizationRequest(ApiModel):
    #: The user that the device will become personalised for.
    #: example: julie@example.com
    email: Optional[str] = None


class WorkspacePersonalizationTaskResponse(ApiModel):
    #: Describes if the personalization was successful.
    success: Optional[bool] = None
    #: A description of the error will be provided if the personalization was not successful.
    #: example: Device is offline
    error_description: Optional[str] = None


class WorkspaceType(str, Enum):
    #: High concentration.
    focus = 'focus'
    #: Brainstorm/collaboration.
    huddle = 'huddle'
    #: Dedicated meeting space.
    meeting_room = 'meetingRoom'
    #: Unstructured agile.
    open = 'open'
    #: Individual.
    desk = 'desk'
    #: Unspecified.
    other = 'other'


class WorkspaceType1(str, Enum):
    #: No workspace type set.
    not_set = 'notSet'
    #: High concentration.
    focus = 'focus'
    #: Brainstorm/collaboration.
    huddle = 'huddle'
    #: Dedicated meeting space.
    meeting_room = 'meetingRoom'
    #: Unstructured agile.
    open = 'open'
    #: Individual.
    desk = 'desk'
    #: Unspecified.
    other = 'other'
    none_ = 'none'


class WorkspaceCallingType(str, Enum):
    #: Free Calling.
    free_calling = 'freeCalling'
    #: Hybrid Calling.
    hybrid_calling = 'hybridCalling'
    #: Webex Calling.
    webex_calling = 'webexCalling'
    #: Webex Edge For Devices.
    webex_edge_for_devices = 'webexEdgeForDevices'
    #: Third-party SIP URI.
    third_party_sip_calling = 'thirdPartySipCalling'
    #: No Calling.
    none_ = 'none'


class WorkspaceCallingHybridCalling(ApiModel):
    #: End user email address in Cisco Unified CM.
    #: example: workspace@example.com
    email_address: Optional[str] = None


class WorkspaceCalling(ApiModel):
    #: Calling.
    #: example: hybridCalling
    type: Optional[WorkspaceCallingType] = None
    #: The `hybridCalling` object only applies when calling type is `hybridCalling`.
    hybrid_calling: Optional[WorkspaceCallingHybridCalling] = None


class WorkspaceHotdeskingStatus(str, Enum):
    #: Workspace supports hotdesking.
    on = 'on'
    #: Workspace does not support hotdesking.
    off = 'off'
    none_ = 'none'


class WorkspaceSupportedDevices(str, Enum):
    #: Workspace supports collaboration devices.
    collaboration_devices = 'collaborationDevices'
    #: Workspace supports MPP phones.
    phones = 'phones'


class WorkspaceCalendarType(str, Enum):
    #: No calendar.
    none_ = 'none'
    #: Google Calendar.
    google = 'google'
    #: Microsoft Exchange or Office 365.
    microsoft = 'microsoft'


class WorkspaceCalendar(ApiModel):
    #: example: microsoft
    type: Optional[WorkspaceCalendarType] = None
    #: Workspace email address. Will not be set when the calendar type is `none`.
    #: example: workspace@example.com
    email_address: Optional[str] = None


class WorkspaceDeviceHostedMeetings(ApiModel):
    #: `true` if enabled or `false` otherwise.
    #: example: True
    enabled: Optional[bool] = None
    #: The Webex site for the device hosting meetings.
    #: example: 'example.webex.com'
    site_url: Optional[str] = None


class Workspace4(ApiModel):
    #: Unique identifier for the Workspace.
    #: example: Y2lzY29zcGFyazovL3VzL1BMQUNFUy81MTAxQjA3Qi00RjhGLTRFRjctQjU2NS1EQjE5QzdCNzIzRjc
    id: Optional[str] = None
    #: `OrgId` associate with the workspace.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8xZWI2NWZkZi05NjQzLTQxN2YtOTk3NC1hZDcyY2FlMGUxMGY
    org_id: Optional[str] = None
    #: Location associated with the workspace.
    #: example: YL34GrT...
    workspace_location_id: Optional[str] = None
    #: Floor associated with the workspace.
    #: example: Y2lzY29z...
    floor_id: Optional[str] = None
    #: A friendly name for the workspace.
    #: example: SFO-12 Capanina
    display_name: Optional[str] = None
    #: How many people the workspace is suitable for.
    #: example: 5.0
    capacity: Optional[int] = None
    #: The workspace type.
    type: Optional[WorkspaceType1] = None
    #: `SipUrl` to call all the devices associated with the workspace.
    #: example: test_workspace_1@trialorg.room.ciscospark.com
    sip_address: Optional[str] = None
    #: The date and time that the workspace was registered, in ISO8601 format.
    #: example: 2016-04-21T17:00:00.000Z
    created: Optional[datetime] = None
    #: Calling type.
    calling: Optional[WorkspaceCalling] = None
    #: Notes associated to the workspace.
    #: example: this is a note
    notes: Optional[str] = None
    #: Hot desking status of the workspace.
    hotdesking_status: Optional[WorkspaceHotdeskingStatus] = None
    #: The supported devices for the workspace. Default is `collaborationDevices`.
    #: example: collaborationDevices
    supported_devices: Optional[WorkspaceSupportedDevices] = None
    #: Calendar type. Calendar of type `none` does not include an `emailAddress` field.
    calendar: Optional[WorkspaceCalendar] = None
    #: Device hosted meetings configuration.
    device_hosted_meetings: Optional[WorkspaceDeviceHostedMeetings] = None


class WorkspaceCreationRequestCallingWebexCalling(ApiModel):
    #: End user phone number.
    #: example: +12145654032
    phone_number: Optional[str] = None
    #: End user extension.
    #: example: 28278
    extension: Optional[str] = None
    #: Calling location ID.
    #: example: Y2lzY29g4...
    location_id: Optional[str] = None


class WorkspaceCreationRequestCalling(ApiModel):
    #: Calling.
    #: example: webexCalling
    type: Optional[str] = None
    #: The `webexCalling` object only applies when calling type is `webexCalling`.
    webex_calling: Optional[WorkspaceCreationRequestCallingWebexCalling] = None


class WorkspaceCreationRequestCalendar(ApiModel):
    #: example: microsoft
    type: Optional[str] = None
    #: Workspace email address. Will not be set when the calendar type is `none`.
    #: example: workspace@example.com
    email_address: Optional[str] = None


class WorkspaceCreationRequest(ApiModel):
    #: A friendly name for the workspace.
    #: example: SFO-12 Capanina
    display_name: Optional[str] = None
    #: `OrgId` associated with the workspace. Only admin users of another organization (such as partners) may use this
    #: parameter.
    #: example: Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8xZWI2NWZkZi05NjQzLTQxN2YtOTk3NC1hZDcyY2FlMGUxMGY
    org_id: Optional[str] = None
    #: Location associated with the workspace. Must be provided when the `floorId` is set.
    #: example: YL34GrT...
    workspace_location_id: Optional[str] = None
    #: Floor associated with the workspace.
    #: example: Y2lzY29z...
    floor_id: Optional[str] = None
    #: How many people the workspace is suitable for. If set, must be 0 or higher.
    #: example: 5.0
    capacity: Optional[int] = None
    #: The type that best describes the workspace.
    type: Optional[WorkspaceType1] = None
    #: The `sipAddress` field can only be provided when calling type is `thirdPartySipCalling`
    sip_address: Optional[str] = None
    #: Calling types supported on create are `freeCalling`, `webexEdgeForDevices`, `thirdPartySipCalling`,
    #: `webexCalling` and `none`. Default is `freeCalling`.
    calling: Optional[WorkspaceCreationRequestCalling] = None
    #: Workspace calendar configuration. Provide a type (`microsoft`, `google` or `none`) and an `emailAddress`.
    #: Default is `none`.
    calendar: Optional[WorkspaceCreationRequestCalendar] = None
    #: Notes associated to the workspace.
    #: example: this is a note
    notes: Optional[str] = None
    #: Hot desking status of the workspace.
    #: example: on
    hotdesking_status: Optional[CallMembershipAudio] = None
    #: To enable device hosted meetings, set a Webex `siteUrl` and the `enabled` flag to `true`.
    device_hosted_meetings: Optional[WorkspaceDeviceHostedMeetings] = None
    #: The supported devices for the workspace. Default is `collaborationDevices`.
    #: example: collaborationDevices
    supported_devices: Optional[WorkspaceSupportedDevices] = None


class WorkspaceUpdateRequestType(str, Enum):
    #: No workspace type set.
    not_set = 'notSet'
    #: High concentration.
    focus = 'focus'
    #: Brainstorm/collaboration.
    huddle = 'huddle'
    #: Dedicated meeting space.
    meeting_room = 'meetingRoom'
    #: Unstructured agile.
    open = 'open'
    #: Individual.
    desk = 'desk'
    #: Unspecified.
    other = 'other'


class WorkspaceUpdateRequest(ApiModel):
    #: A friendly name for the workspace.
    #: example: SFO-12 Capanina
    display_name: Optional[str] = None
    #: Location associated with the workspace. Must be provided when the `floorId` is set.
    #: example: YL34GrT...
    workspace_location_id: Optional[str] = None
    #: Floor associated with the workspace.
    #: example: Y2lzY29z...
    floor_id: Optional[str] = None
    #: How many people the workspace is suitable for. If set, must be 0 or higher.
    #: example: 5.0
    capacity: Optional[int] = None
    #: The type that best describes the workspace.
    #: example: focus
    type: Optional[WorkspaceUpdateRequestType] = None
    #: An empty/null calendar field will not cause any changes. Provide a type (`microsoft`, `google` or `none`) and an
    #: `emailAddress`. Removing calendar is done by setting the `none` type, and setting `none` type does not require
    #: an `emailAddress`.
    calendar: Optional[WorkspaceCreationRequestCalendar] = None
    #: The `sipAddress` field can only be provided when calling type is `thirdPartySipCalling`
    sip_address: Optional[str] = None
    #: Calling types supported on update are `freeCalling`, `thirdPartySipCalling`, `webexCalling` and `none`.
    calling: Optional[WorkspaceCreationRequestCalling] = None
    #: Notes associated to the workspace.
    #: example: this is a note
    notes: Optional[str] = None
    #: Hot desking status of the workspace.
    #: example: on
    hotdesking_status: Optional[CallMembershipAudio] = None
    #: To enable device hosted meetings, set a Webex `siteUrl` and the `enabled` flag to `true`.
    device_hosted_meetings: Optional[WorkspaceDeviceHostedMeetings] = None


class WorkspaceCollectionResponse(ApiModel):
    #: An array of workspace objects.
    items: Optional[list[Workspace4]] = None


class SupportAndConfiguredInfo(ApiModel):
    #: Is the workspace capability supported or not.
    #: example: True
    supported: Optional[bool] = None
    #: Is the workspace capability configured or not.
    #: example: True
    configured: Optional[bool] = None


class CapabilityMap(ApiModel):
    #: Occupancy detection.
    occupancy_detection: Optional[SupportAndConfiguredInfo] = None
    #: Presence detection.
    presence_detection: Optional[SupportAndConfiguredInfo] = None
    #: Ambient noise.
    ambient_noise: Optional[SupportAndConfiguredInfo] = None
    #: Sound level.
    sound_level: Optional[SupportAndConfiguredInfo] = None
    #: Temperature.
    temperature: Optional[SupportAndConfiguredInfo] = None
    #: Air quality.
    air_quality: Optional[SupportAndConfiguredInfo] = None
    #: Relative humidity.
    relative_humidity: Optional[SupportAndConfiguredInfo] = None


class CapabilityResponse(ApiModel):
    #: The map of workspace capabilities.
    capabilities: Optional[CapabilityMap] = None


class QueryStatusResponseResultAudio(ApiModel):
    #: example: 75.0
    volume: Optional[int] = Field(alias='Volume', default=None)


class QueryStatusResponseResult(ApiModel):
    audio: Optional[QueryStatusResponseResultAudio] = Field(alias='Audio', default=None)


class QueryStatusResponse(ApiModel):
    #: The unique identifier for the Webex RoomOS Device.
    #: example: Y2lzY29zcGFyazovL3VzL0RFVklDRS8wNTVkYThiNy02NWI2LTQ5NjgtOTg1ZC02ZmFjODcwOWMyMDM
    device_id: Optional[str] = None
    #: xAPI status result
    result: Optional[QueryStatusResponseResult] = None


class ExecuteCommandArguments(ApiModel):
    #: example: 50.0
    level: Optional[int] = Field(alias='Level', default=None)


class ExecuteCommandBodyBookingTime(ApiModel):
    #: example: 2020-07-01T13:00:00Z
    start_time: Optional[datetime] = Field(alias='StartTime', default=None)
    #: example: 60.0
    duration: Optional[int] = Field(alias='Duration', default=None)


class ExecuteCommandBodyBookingOrganizer(ApiModel):
    #: example: John Doe
    name: Optional[str] = Field(alias='Name', default=None)


class ExecuteCommandBodyBooking(ApiModel):
    #: example: foo
    id: Optional[str] = Field(alias='Id', default=None)
    #: example: Booking Title
    title: Optional[str] = Field(alias='Title', default=None)
    #: example: SIP
    protocol: Optional[str] = Field(alias='Protocol', default=None)
    time: Optional[ExecuteCommandBodyBookingTime] = Field(alias='Time', default=None)
    organizer: Optional[ExecuteCommandBodyBookingOrganizer] = Field(alias='Organizer', default=None)
    #: example: number@example.com
    number: Optional[str] = Field(alias='Number', default=None)


class ExecuteCommandBody(ApiModel):
    booking: Optional[ExecuteCommandBodyBooking] = Field(alias='Booking', default=None)


class ExecuteCommandResponse(ApiModel):
    #: The unique identifier for the Webex RoomOS Device.
    #: example: Y2lzY29zcGFyazovL3VzL0RFVklDRS8wNTVkYThiNy02NWI2LTQ5NjgtOTg1ZC02ZmFjODcwOWMyMDM
    device_id: Optional[str] = None
    #: xAPI command arguments
    arguments: Optional[ExecuteCommandArguments] = None
    #: xAPI command results
    result: Optional[ExecuteCommandBody] = None


class AdminAuditEventsWithScalingApi(ApiChild, base='adminAudit'):
    """
    Admin Audit Events with Scaling
    
    Admin Audit Events are available to full administrators for `certain events
    <https://help.webex.com/n3b0w6x/>`_ performed in Webex Control Hub.
    
    Administrators with accounts created before 2019 who have never logged into `Webex Control Hub
    <https://admin.webex.com>`_ will need to log into
    Webex Control Hub at least once to enable access to this API.
    
    An administrator account with the `audit:events_read` scope is required to use this API.
    """

    def list_admin_audit_events(self, org_id: str, from_: Union[str, datetime], to_: Union[str, datetime],
                                actor_id: str = None, event_categories: list[str] = None,
                                **params) -> Generator[AuditEvent, None, None]:
        """
        List Admin Audit Events

        List admin audit events in your organization. Several query parameters are available to filter the response.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        **NOTE**: A maximum of one year of audit events can be returned per request.

        :param org_id: List events in this organization, by ID.
        :type org_id: str
        :param from_: List events which occurred after a specific date and time.
        :type from_: Union[str, datetime]
        :param to_: List events which occurred before a specific date and time.
        :type to_: Union[str, datetime]
        :param actor_id: List events performed by this person, by ID.
        :type actor_id: str
        :param event_categories: List events, by event categories.
        :type event_categories: list[str]
        :return: Generator yielding :class:`AuditEvent` instances
        """
        params['orgId'] = org_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        if actor_id is not None:
            params['actorId'] = actor_id
        if event_categories is not None:
            params['eventCategories'] = ','.join(event_categories)
        url = self.ep('events')
        return self.session.follow_pagination(url=url, model=AuditEvent, item_key='items', params=params)

    def list_admin_audit_event_categories(self) -> list[str]:
        """
        List Admin Audit Event Categories

        Get the list of all admin event categories.

        :rtype: list[str]
        """
        url = self.ep('eventCategories')
        data = super().get(url)
        r = data['eventCategories']
        return r


class AdminAuditEventsApi(ApiChild, base='adminAudit'):
    """
    Admin Audit Events
    
    Admin Audit Events are available to full administrators for `certain events
    <https://help.webex.com/n3b0w6x/>`_ performed in Webex Control Hub.
    
    Administrators with accounts created before 2019 who have never logged into `Webex Control Hub
    <https://admin.webex.com>`_ will need to log into
    Webex Control Hub at least once to enable access to this API.
    
    An administrator account with the `audit:events_read` scope is required to use this API.
    """

    def list_admin_audit_events(self, org_id: str, from_: Union[str, datetime], to_: Union[str, datetime],
                                actor_id: str = None, event_categories: list[str] = None,
                                **params) -> Generator[AuditEvent1, None, None]:
        """
        List Admin Audit Events

        List admin audit events in your organization. Several query parameters are available to filter the response.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        **NOTE**: A maximum of one year of audit events can be returned per request.

        :param org_id: List events in this organization, by ID.
        :type org_id: str
        :param from_: List events which occurred after a specific date and time.
        :type from_: Union[str, datetime]
        :param to_: List events which occurred before a specific date and time.
        :type to_: Union[str, datetime]
        :param actor_id: List events performed by this person, by ID.
        :type actor_id: str
        :param event_categories: List events, by event categories.
        :type event_categories: list[str]
        :return: Generator yielding :class:`AuditEvent1` instances
        """
        params['orgId'] = org_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        if actor_id is not None:
            params['actorId'] = actor_id
        if event_categories is not None:
            params['eventCategories'] = ','.join(event_categories)
        url = self.ep('events')
        return self.session.follow_pagination(url=url, model=AuditEvent1, item_key='items', params=params)

    def list_admin_audit_event_categories(self) -> list[str]:
        """
        List Admin Audit Event Categories

        Get the list of all admin event categories.

        :rtype: list[str]
        """
        url = self.ep('eventCategories')
        data = super().get(url)
        r = data['eventCategories']
        return r


class ApplicationUsageApi(ApiChild, base='application/usage'):
    """
    Application Usage
    
    """

    def list_application_usage(self, org_id: str = None, app_name: str = None, app_id: str = None,
                               order_by: ListApplicationUsageOrderBy = None, cursor: str = None,
                               **params) -> Generator[ApplicationUsage, None, None]:
        """
        List Application Usage

        Lists all applications, optionally filtered by organization ID, application name, or application ID.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param org_id: List application usage for applications owned by this organization, by ID.
        :type org_id: str
        :param app_name: List application usage information for applications with this name.
        :type app_name: str
        :param app_id: List application usage for an application, by ID.
        :type app_id: str
        :param order_by: Sort results.
        :type order_by: ListApplicationUsageOrderBy
        :param cursor: The current cursor when `paging
            <https://developer.webex.com/docs/basics#pagination>`_ through long result sets.
        :type cursor: str
        :return: Generator yielding :class:`ApplicationUsage` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if app_name is not None:
            params['appName'] = app_name
        if app_id is not None:
            params['appId'] = app_id
        if order_by is not None:
            params['orderBy'] = order_by
        if cursor is not None:
            params['cursor'] = cursor
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ApplicationUsage, item_key='items', params=params)


class ApplicationsApi(ApiChild, base='applications'):
    """
    Applications
    
    """

    def list_applications(self, type: ListApplicationsType = None, org_id: str = None, created_by: str = None,
                          submission_status: ApplicationSubmissionStatus = None,
                          org_submission_status: ApplicationSubmissionStatus = None,
                          order_by: ListApplicationUsageOrderBy = None, category: str = None, tag: str = None,
                          bot_email: str = None, is_featured: bool = None, is_native: bool = None, cursor: str = None,
                          wait_for_ci: bool = None, **params) -> Generator[Application, None, None]:
        """
        List Applications

        Lists all applications.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param type: List applications of this type.
        :type type: ListApplicationsType
        :param org_id: List applications owned by this organization, by ID.
        :type org_id: str
        :param created_by: List applications created by this person, by ID. Use `me` as a shorthand for the current API
            user when used with an authentication token.
        :type created_by: str
        :param submission_status: List applications with this Webex App Hub submission status.
        :type submission_status: ApplicationSubmissionStatus
        :type org_submission_status: ApplicationSubmissionStatus
        :param order_by: Sort results.
        :type order_by: ListApplicationUsageOrderBy
        :param category: List applications which belong to this Webex App Hub category.
        :type category: str
        :type tag: str
        :param bot_email: List applications with this bot email.
        :type bot_email: str
        :param is_featured: Limit to applications featured in the Webex App Hub.
        :type is_featured: bool
        :param is_native: Internal use only.
        :type is_native: bool
        :param cursor: The current cursor when `paging
            <https://developer.webex.com/docs/basics#pagination>`_ through long result sets.
        :type cursor: str
        :param wait_for_ci: Internal use only.
        :type wait_for_ci: bool
        :return: Generator yielding :class:`Application` instances
        """
        if type is not None:
            params['type'] = type
        if org_id is not None:
            params['orgId'] = org_id
        if created_by is not None:
            params['createdBy'] = created_by
        if submission_status is not None:
            params['submissionStatus'] = submission_status
        if org_submission_status is not None:
            params['orgSubmissionStatus'] = org_submission_status
        if order_by is not None:
            params['orderBy'] = order_by
        if category is not None:
            params['category'] = category
        if tag is not None:
            params['tag'] = tag
        if bot_email is not None:
            params['botEmail'] = bot_email
        if is_featured is not None:
            params['isFeatured'] = str(is_featured).lower()
        if is_native is not None:
            params['isNative'] = str(is_native).lower()
        if cursor is not None:
            params['cursor'] = cursor
        if wait_for_ci is not None:
            params['waitForCI'] = str(wait_for_ci).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Application, item_key='items', params=params)


class AttachmentActionsApi(ApiChild, base='attachment/actions'):
    """
    Attachment Actions
    
    Users create attachment actions by interacting with message attachments such as clicking on a submit button in a
    `card
    <https://developer.webex.com/docs/api/guides/cards>`_.
    """

    def create_an_attachment_action(self, type: AttachmentActivityType, message_id: str,
                                    inputs: SubmitCardActionInputs) -> AttachmentActivity:
        """
        Create an Attachment Action

        Create a new attachment action.

        :param type: The type of action to perform.
        :type type: AttachmentActivityType
        :param message_id: The ID of the message which contains the attachment.
        :type message_id: str
        :param inputs: The attachment action's inputs.
        :type inputs: SubmitCardActionInputs
        :rtype: :class:`AttachmentActivity`
        """
        body = dict()
        body['type'] = enum_str(type)
        body['messageId'] = message_id
        body['inputs'] = loads(inputs.model_dump_json())
        url = self.ep()
        data = super().post(url, json=body)
        r = AttachmentActivity.model_validate(data)
        return r

    def get_attachment_action_details(self, id: str) -> AttachmentActivity:
        """
        Get Attachment Action Details

        Shows details for a attachment action, by ID.

        Specify the attachment action ID in the `id` URI parameter.

        :param id: A unique identifier for the attachment action.
        :type id: str
        :rtype: :class:`AttachmentActivity`
        """
        url = self.ep(f'{id}')
        data = super().get(url)
        r = AttachmentActivity.model_validate(data)
        return r


class AuthorizationsApi(ApiChild, base='authorizations'):
    """
    Authorizations
    
    Admin API. You need full or user level admin privileges to call this API.
    
    
    
    Authorizations are user grants to applications to act on the user's behalf. Authorizations are how `Integrations
    <https://developer.webex.com/docs/integrations>`_ get
    authorized with specific `access scopes
    <https://developer.webex.com/docs/integrations#scopes>`_ in the oAuth client life-cycle. Integrations and some of the Webex service
    portals, like `developer.webex.com
    <https://developer.webex.com/>`_, are all oAuth clients, each with their unique `clientId`.
    
    Your application receives an API `access token
    <https://developer.webex.com/docs/integrations#getting-an-access-token>`_ and a `refresh token
    used to call Webex APIs for which the user authorized the scopes. Access tokens expire fairly frequently, while
    refresh tokens (when being regularly used) will be refreshed to last forever (see `Using the Refresh Token
    <https://developer.webex.com/docs/integrations#using-the-refresh-token>`_ for
    details).
    
    In this API an authorization is synonymous with an `API access token
    <https://developer.webex.com/docs/integrations#getting-an-access-token>`_.
    
    To provide admins with fine-grained token management control, you use the `/authorizations
    <https://developer.webex.com/docs/api/v1/authorizations>`_ API with
    the `DELETE` HTTP method to revoke access and refresh tokens.
    
    Deleting a refresh token will revoke all associated access tokens as well. Deleting an access token will revoke the
    developers ability to call the APIs with it.
    Webex subsystems may cache the validity of the token for a short while longer after the authorization was deleted.
    
    Admins can revoke user authorizations for users in their organization. When an admin deletes their own token, the
    `clientId` used to auhtorize the request must match the `clientId` used to generate the token.
    
    To use the authorizations API in an Integration the scopes must include:
    `identity:tokens_write`,`identity:tokens_read`.
    """

    def list_authorizations_for_a_user(self, person_id: str, person_email: str) -> list[Authorization]:
        """
        List authorizations for a user

        Lists all authorizations for a user. Either `personId` or `personEmail` must be provided. This API does not
        support pagination.

        :param person_id: List authorizations for this user id.
        :type person_id: str
        :param person_email: List authorizations for this user email.
        :type person_email: str
        :rtype: list[Authorization]
        """
        params = {}
        params['personId'] = person_id
        params['personEmail'] = person_email
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[Authorization]).validate_python(data['items'])
        return r

    def delete_authorization(self, authorization_id: str):
        """
        Delete authorization

        Deletes an authorization, by authorization ID.

        Specify the authorization Id in the `authorizationId` parameter in the URI which was listed in the list
        resource.

        :param authorization_id: The unique identifier for the message.
        :type authorization_id: str
        :rtype: None
        """
        url = self.ep(f'{authorization_id}')
        super().delete(url)

    def delete_authorization_of_org_and_client_id(self, client_id: str, org_id: str = None):
        """
        Delete authorization of org and client ID

        Deletes an authorization, by org ID and client ID.

        :param client_id: The unique oAuth client id.
        :type client_id: str
        :param org_id: The ID of the organization to which this person belongs.  If no orgId is specified, use orgId
            from the OAuth token.
        :type org_id: str
        :rtype: None
        """
        params = {}
        params['clientId'] = client_id
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        super().delete(url, params=params)


class BetaBroadWorksEnterprisesWithDeleteOrgImprovementsApi(ApiChild, base='broadworks/enterprises'):
    """
    Beta BroadWorks Enterprises With Delete Org Improvements
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks enterprise information requires an administrator auth token with
    `spark-admin:broadworks_enterprises_read` scope.
    Updating directory sync configuration or trigger directory sync for a Webex for BroadWorks enterprise require an
    administrator auth token with `spark-admin:broadworks_enterprises_write` scope.
    """

    def list_broad_works_enterprises(self, sp_enterprise_id: str = None, starts_with: str = None,
                                     **params) -> Generator[Enterprise, None, None]:
        """
        List BroadWorks Enterprises

        List the provisioned enterprises for a Service Provider. This API also allows a Service Provider to search for
        their provisioned enterprises on Webex. A search on enterprises can be performed using either a full or
        partial enterprise identifier.

        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param starts_with: The starting string of the enterprise identifiers to match against.
        :type starts_with: str
        :return: Generator yielding :class:`Enterprise` instances
        """
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if starts_with is not None:
            params['startsWith'] = starts_with
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Enterprise, item_key='items', params=params)

    def update_directory_sync_for_a_broad_works_enterprise(self, id: str,
                                                           enable_dir_sync: str) -> TriggerDirectorySyncResponse:
        """
        Update Directory Sync for a BroadWorks Enterprise

        This API allows a Partner Admin to update enableDirSync for the customer's Broadworks enterprise on Webex.

        <div>
        <Callout type='info'>When `enableDirSync` is set to false, an asynchronous cleanup process will be scheduled
        after configured minutes to perform a graceful clean up, in case the partner admin invokes the
        `Organization Deletion
        <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#organization-deletion>`_ immediately. [Get Directory Sync Status for an Enterprise
        ](https://developer.webex.com/docs/api/v1/broadworks-enterprises/get-directory-sync-status-for-an-enterprise)
        can be used to get the status of the cleanup progress.
        </Callout>
        </div>

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param enable_dir_sync: The toggle to enable/disable directory sync.
        :type enable_dir_sync: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['enableDirSync'] = enable_dir_sync
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().put(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def trigger_directory_sync_for_an_enterprise(self, id: str, sync_status: str) -> TriggerDirectorySyncResponse:
        """
        Trigger Directory Sync for an Enterprise

        This API will allow a Partner Admin to trigger a directory sync for the customer's Broadworks enterprise on
        Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param sync_status: At this time, the only option allowed for this attribute is `SYNC_NOW` which will trigger
            the directory sync for the BroadWorks enterprise.
        :type sync_status: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['syncStatus'] = sync_status
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().post(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def get_directory_sync_status_for_an_enterprise(self, id: str) -> EnterpriseBroadworksDirectorySync:
        """
        Get Directory Sync Status for an Enterprise

        This API will allow a Partner Admin to  get the most recent directory sync status for a customer's Broadworks
        enterprise on Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :rtype: :class:`EnterpriseBroadworksDirectorySync`
        """
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().get(url)
        r = EnterpriseBroadworksDirectorySync.model_validate(data)
        return r

    def trigger_directory_sync_for_a_user(self, id: str, user_id: str = None) -> TriggerUserDirectorySyncResponse:
        """
        Trigger Directory Sync for a User

        This API allows a Partner Admin to trigger a directory sync for an external user (real or virtual user) on
        Broadworks enterprise with Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param user_id: The user ID of the Broadworks user to be synced (A non-webex user).
        :type user_id: str
        :rtype: :class:`TriggerUserDirectorySyncResponse`
        """
        body = dict()
        body['userId'] = user_id
        url = self.ep(f'{id}/broadworksDirectorySync/externalUser')
        data = super().post(url, json=body)
        r = TriggerUserDirectorySyncResponse.model_validate(data)
        return r


class BetaBroadWorksEnterprisesWithEnterpriseGroupContactSupportApi(ApiChild, base='broadworks/enterprises'):
    """
    Beta BroadWorks Enterprises With Enterprise Group Contact Support
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks enterprise information requires an administrator auth token with
    `spark-admin:broadworks_enterprises_read` scope.
    Updating directory sync configuration or trigger directory sync for a Webex for BroadWorks enterprise require an
    administrator auth token with `spark-admin:broadworks_enterprises_write` scope.
    """

    def list_broad_works_enterprises(self, sp_enterprise_id: str = None, starts_with: str = None,
                                     **params) -> Generator[Enterprise1, None, None]:
        """
        List BroadWorks Enterprises

        List the provisioned enterprises for a Service Provider. This API also allows a Service Provider to search for
        their provisioned enterprises on Webex. A search on enterprises can be performed using either a full or
        partial enterprise identifier.

        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param starts_with: The starting string of the enterprise identifiers to match against.
        :type starts_with: str
        :return: Generator yielding :class:`Enterprise1` instances
        """
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if starts_with is not None:
            params['startsWith'] = starts_with
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Enterprise1, item_key='items', params=params)

    def update_directory_sync_for_a_broad_works_enterprise(self, id: str,
                                                           enable_dir_sync: str) -> TriggerDirectorySyncResponse:
        """
        Update Directory Sync for a BroadWorks Enterprise

        This API allows a Partner Admin to update enableDirSync for the customer's Broadworks enterprise on Webex.

        <div>
        <Callout type='info'>When `enableDirSync` is set to false, an asynchronous cleanup process will be scheduled
        after configured minutes to perform a graceful clean up, in case the partner admin invokes the
        `Organization Deletion
        <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#organization-deletion>`_ immediately. [Get Directory Sync Status for an Enterprise
        ](https://developer.webex.com/docs/api/v1/broadworks-enterprises/get-directory-sync-status-for-an-enterprise)
        can be used to get the status of the cleanup progress.
        </Callout>
        </div>

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param enable_dir_sync: The toggle to enable/disable directory sync.
        :type enable_dir_sync: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['enableDirSync'] = enable_dir_sync
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().put(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def trigger_directory_sync_for_an_enterprise(self, id: str, sync_status: str) -> TriggerDirectorySyncResponse:
        """
        Trigger Directory Sync for an Enterprise

        This API will allow a Partner Admin to trigger a directory sync for the customer's Broadworks enterprise on
        Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param sync_status: At this time, the only option allowed for this attribute is `SYNC_NOW` which will trigger
            the directory sync for the BroadWorks enterprise.
        :type sync_status: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['syncStatus'] = sync_status
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().post(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def get_directory_sync_status_for_an_enterprise(self, id: str) -> EnterpriseBroadworksDirectorySync1:
        """
        Get Directory Sync Status for an Enterprise

        This API will allow a Partner Admin to  get the most recent directory sync status for a customer's Broadworks
        enterprise on Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :rtype: :class:`EnterpriseBroadworksDirectorySync1`
        """
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().get(url)
        r = EnterpriseBroadworksDirectorySync1.model_validate(data)
        return r

    def trigger_directory_sync_for_a_user(self, id: str, user_id: str = None) -> TriggerUserDirectorySyncResponse:
        """
        Trigger Directory Sync for a User

        This API allows a Partner Admin to trigger a directory sync for an external user (real or virtual user) on
        Broadworks enterprise with Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param user_id: The user ID of the Broadworks user to be synced (A non-webex user).
        :type user_id: str
        :rtype: :class:`TriggerUserDirectorySyncResponse`
        """
        body = dict()
        body['userId'] = user_id
        url = self.ep(f'{id}/broadworksDirectorySync/externalUser')
        data = super().post(url, json=body)
        r = TriggerUserDirectorySyncResponse.model_validate(data)
        return r


class BetaBroadWorksEnterprisesWithListEnterprisesEnhancementsApi(ApiChild, base='broadworks/enterprises'):
    """
    Beta BroadWorks Enterprises with List Enterprises Enhancements
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks enterprise information requires an administrator auth token with
    `spark-admin:broadworks_enterprises_read` scope.
    Updating directory sync configuration or trigger directory sync for a Webex for BroadWorks enterprise require an
    administrator auth token with `spark-admin:broadworks_enterprises_write` scope.
    """

    def list_broad_works_enterprises(self, sp_enterprise_id: str = None, starts_with: str = None,
                                     last_sync_end_time: str = None, sync_status: str = None, after: str = None,
                                     **params) -> Generator[Enterprise, None, None]:
        """
        List BroadWorks Enterprises

        List the provisioned enterprises for a Service Provider.

        This API also allows a Service Provider to search for their provisioned enterprises on Cisco Webex. There are a
        number of filter options which can be combined in a single request.

        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param starts_with: The starting string of the enterprise identifiers to match against.
        :type starts_with: str
        :param last_sync_end_time: Only include enterprises last synced after this date and time. Epoch time (in
            milliseconds) preferred, but ISO 8601 date format also accepted.
        :type last_sync_end_time: str
        :param sync_status: The directory sync status of the enterprise. This parameter supports multiple comma
            separated values. For example: status=failed,in_progress,not_synced.
        :type sync_status: str
        :param after: Only include enterprises created after this date and time. Epoch time (in milliseconds)
            preferred, but ISO 8601 date format also accepted.
        :type after: str
        :return: Generator yielding :class:`Enterprise` instances
        """
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if starts_with is not None:
            params['startsWith'] = starts_with
        if last_sync_end_time is not None:
            params['lastSyncEndTime'] = last_sync_end_time
        if sync_status is not None:
            params['syncStatus'] = sync_status
        if after is not None:
            params['after'] = after
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Enterprise, item_key='items', params=params)

    def update_directory_sync_for_a_broad_works_enterprise(self, id: str,
                                                           enable_dir_sync: str) -> TriggerDirectorySyncResponse:
        """
        Update Directory Sync for a BroadWorks Enterprise

        This API allows a Partner Admin to Update enableDirSync for the customer's Broadworks enterprise on Cisco
        Webex.

        :param id: Unique identifier for the enterprise.
        :type id: str
        :param enable_dir_sync: The toggle to enable/disable directory sync.
        :type enable_dir_sync: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['enableDirSync'] = enable_dir_sync
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().put(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def trigger_directory_sync_for_an_enterprise(self, id: str, sync_status: str) -> TriggerDirectorySyncResponse:
        """
        Trigger Directory Sync for an Enterprise

        This API allows a Partner Admin to Trigger a directory sync for the customer's Broadworks enterprise on Cisco
        Webex.

        :param id: Unique identifier for the enterprise.
        :type id: str
        :param sync_status: The only option allowed for this attribute is SYNC_NOW which triggers the directory sync
            for the Broadworks enterprise.
        :type sync_status: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['syncStatus'] = sync_status
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().post(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def get_directory_sync_status_for_an_enterprise(self, id: str) -> EnterpriseBroadworksDirectorySync:
        """
        Get Directory Sync Status for an Enterprise

        This API allows a Partner Admin to Get the most recent directory sync status for a customer's Broadworks
        enterprise on Cisco Webex.

        :param id: Unique identifier for the enterprise.
        :type id: str
        :rtype: :class:`EnterpriseBroadworksDirectorySync`
        """
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().get(url)
        r = EnterpriseBroadworksDirectorySync.model_validate(data)
        return r

    def trigger_directory_sync_for_a_user(self, id: str, user_id: str = None) -> TriggerUserDirectorySyncResponse:
        """
        Trigger Directory Sync for a User

        This API allows a Partner Admin to Trigger a directory sync for an external user (real or virtual) for a
        customer's Broadworks enterprise on Cisco Webex.

        :param id: Unique identifier for the enterprise.
        :type id: str
        :param user_id: The user ID of the non-Webex Broadworks user to be synced.
        :type user_id: str
        :rtype: :class:`TriggerUserDirectorySyncResponse`
        """
        body = dict()
        body['userId'] = user_id
        url = self.ep(f'{id}/broadworksDirectorySync/externalUser')
        data = super().post(url, json=body)
        r = TriggerUserDirectorySyncResponse.model_validate(data)
        return r


class BetaBroadWorksEnterprisesWithOrgCreationTimestampApi(ApiChild, base='broadworks/enterprises'):
    """
    Beta BroadWorks Enterprises with Org Creation Timestamp
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks enterprise information requires an administrator auth token with
    `spark-admin:broadworks_enterprises_read` scope.
    Updating directory sync configuration or trigger directory sync for a Webex for BroadWorks enterprise require an
    administrator auth token with `spark-admin:broadworks_enterprises_write` scope.
    """

    def list_broad_works_enterprises(self, sp_enterprise_id: str = None, starts_with: str = None,
                                     **params) -> Generator[Enterprise3, None, None]:
        """
        List BroadWorks Enterprises

        List the provisioned enterprises for a Service Provider. This API will also allow a Service Provider to search
        for their provisioned enterprises on Cisco Webex. A search on enterprises can be performed by either a full or
        partial enterprise identifier.

        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param starts_with: The starting string of the enterprise identifiers to match against.
        :type starts_with: str
        :return: Generator yielding :class:`Enterprise3` instances
        """
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if starts_with is not None:
            params['startsWith'] = starts_with
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Enterprise3, item_key='items', params=params)

    def update_directory_sync_for_a_broad_works_enterprise(self, id: str,
                                                           enable_dir_sync: str) -> TriggerDirectorySyncResponse:
        """
        Update Directory Sync for a BroadWorks Enterprise

        Update `enableDirSync` for a customer's Broadworks enterprise on Cisco Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param enable_dir_sync: The toggle to enable/disable directory sync.
        :type enable_dir_sync: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['enableDirSync'] = enable_dir_sync
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().put(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def trigger_directory_sync_for_an_enterprise(self, id: str, sync_status: str) -> TriggerDirectorySyncResponse:
        """
        Trigger Directory Sync for an Enterprise

        This API allows a Partner Admin to trigger a directory sync for the customer's Broadworks enterprise on Cisco
        Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param sync_status: At this time, the only option allowed for this attribute is `SYNC_NOW` which triggers the
            directory sync for the BroadWorks enterprise.
        :type sync_status: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['syncStatus'] = sync_status
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().post(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def get_directory_sync_status_for_an_enterprise(self, id: str) -> EnterpriseBroadworksDirectorySync:
        """
        Get Directory Sync Status for an Enterprise

        Get the most recent directory sync status for a customer's Broadworks enterprise on Cisco Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :rtype: :class:`EnterpriseBroadworksDirectorySync`
        """
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().get(url)
        r = EnterpriseBroadworksDirectorySync.model_validate(data)
        return r

    def trigger_directory_sync_for_a_user(self, id: str, user_id: str = None) -> TriggerUserDirectorySyncResponse:
        """
        Trigger Directory Sync for a User

        Trigger a directory sync for an external user (real or virtual) for a customer's Broadworks enterprise on Cisco
        Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param user_id: The user ID of the Broadworks user to be synced (A non-webex user).
        :type user_id: str
        :rtype: :class:`TriggerUserDirectorySyncResponse`
        """
        body = dict()
        body['userId'] = user_id
        url = self.ep(f'{id}/broadworksDirectorySync/externalUser')
        data = super().post(url, json=body)
        r = TriggerUserDirectorySyncResponse.model_validate(data)
        return r


class BetaBroadWorksSubscribersWithEnterpriseGroupContactSupportApi(ApiChild, base='broadworks/subscribers'):
    """
    Beta BroadWorks Subscribers With Enterprise Group Contact Support
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks subscriber information requires an administrator auth token with
    `spark-admin:broadworks_subscribers_read` scope. Provisioning, updating, and removing subscribers requires an
    administrator auth token with the `spark-admin:broadworks_subscribers_write` scope.
    
    <div>
    <Callout type="info">Additional Infocodes are given for all success cases. To learn more about the Infocodes used
    in Broadworks Subscriber Provisioning Precheck APIs, see the `Provisioning Precheck API Info Codes
    <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#whats-possible-with-webex-for-broadworks-provisioning-precheck-apis>`_
    guides.</Callout>
    </div>
    """

    def list_broad_works_subscribers(self, user_id: str = None, person_id: str = None, email: str = None,
                                     provisioning_id: str = None, sp_enterprise_id: str = None,
                                     last_status_change: str = None, status: SubscriberStatus = None,
                                     after: str = None, self_activated: bool = None,
                                     **params) -> Generator[Subscriber, None, None]:
        """
        List BroadWorks Subscribers

        This API lets a Service Provider search for their associated subscribers. There are a number of filter options
        that can be combined in a single request.

        :param user_id: The user ID of the subscriber on BroadWorks.
        :type user_id: str
        :param person_id: The Person ID of the Webex subscriber.
        :type person_id: str
        :param email: The email address of the subscriber.
        :type email: str
        :param provisioning_id: The Provisioning ID associated with this subscriber.
        :type provisioning_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param last_status_change: Only include subscribers with a provisioning status change after this date and time.
            Epoch time (in milliseconds) preferred, but ISO 8601 date format also accepted.
        :type last_status_change: str
        :param status: The provisioning status of the subscriber. This Parameter supports multiple comma separated
            values. For example : status=error,provisioned,provisioning.
        :type status: SubscriberStatus
        :param after: Only include subscribers created after this date and time. Epoch time (in milliseconds)
            preferred, but ISO 8601 date format also accepted.
        :type after: str
        :param self_activated: Indicates if the subscriber was self activated, rather than provisioned via these APIs.
        :type self_activated: bool
        :return: Generator yielding :class:`Subscriber` instances
        """
        if user_id is not None:
            params['userId'] = user_id
        if person_id is not None:
            params['personId'] = person_id
        if email is not None:
            params['email'] = email
        if provisioning_id is not None:
            params['provisioningId'] = provisioning_id
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if last_status_change is not None:
            params['lastStatusChange'] = last_status_change
        if status is not None:
            params['status'] = status
        if after is not None:
            params['after'] = after
        if self_activated is not None:
            params['selfActivated'] = str(self_activated).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Subscriber, item_key='items', params=params)

    def provision_a_broad_works_subscriber(self, provisioning_id: str, user_id: str, sp_enterprise_id: str,
                                           first_name: str, last_name: str, package: SubscriberPackage,
                                           sp_enterprise_group_id: str = None, primary_phone_number: str = None,
                                           mobile_phone_number: str = None, email: str = None, language: str = None,
                                           timezone: str = None) -> Subscriber:
        """
        Provision a BroadWorks Subscriber

        Provision a new BroadWorks subscriber for Webex services.

        This API lets a Service Provider map a BroadWorks subscriber to a new or existing Webex user and assign the
        required licenses and entitlements for Webex and Meetings.

        :param provisioning_id: This Provisioning ID defines how this subscriber is to be provisioned for Webex
            Services.

        Each Customer Template will have their own unique Provisioning ID. This ID will be displayed under the chosen
        Customer Template
        on Webex Control Hub.
        :type provisioning_id: str
        :param user_id: The user ID of the subscriber on BroadWorks.
        :type user_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param package: The Webex for BroadWorks package to be assigned to the subscriber.
        :type package: SubscriberPackage
        :param sp_enterprise_group_id: The group name under the enterprise in Broadworks. Only applicable to Enterprise
            mode.
        :type sp_enterprise_group_id: str
        :param primary_phone_number: The primary phone number configured against the subscriber on BroadWorks.
        :type primary_phone_number: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks. Any empty
            value on update will remove the already configured mobile phone number.
        :type mobile_phone_number: str
        :param email: The email address of the subscriber (mandatory for the trusted email provisioning flow).
        :type email: str
        :param language: The ISO 639-1 language code associated with the subscriber. Reserved for future use - any
            value currently specified will be ignored during subscriber provisioning.
        :type language: str
        :param timezone: The time zone associated with the subscriber. Refer to the `Webex Meetings Site Timezone
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_
            section of the `Webex for BroadWorks
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide>`_ guide for more information.
        :type timezone: str
        :rtype: :class:`Subscriber`
        """
        body = dict()
        body['provisioningId'] = provisioning_id
        body['userId'] = user_id
        body['spEnterpriseId'] = sp_enterprise_id
        body['spEnterpriseGroupId'] = sp_enterprise_group_id
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['package'] = enum_str(package)
        body['primaryPhoneNumber'] = primary_phone_number
        body['mobilePhoneNumber'] = mobile_phone_number
        body['email'] = email
        body['language'] = language
        body['timezone'] = timezone
        url = self.ep()
        data = super().post(url, json=body)
        r = Subscriber.model_validate(data)
        return r

    def get_a_broad_works_subscriber(self, subscriber_id: str) -> Subscriber:
        """
        Get a BroadWorks Subscriber

        This API lets a Service Provider retrieve details of a provisioned BroadWorks subscriber on Webex.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :rtype: :class:`Subscriber`
        """
        url = self.ep(f'{subscriber_id}')
        data = super().get(url)
        r = Subscriber.model_validate(data)
        return r

    def update_a_broad_works_subscriber(self, subscriber_id: str, user_id: str = None, first_name: str = None,
                                        last_name: str = None, sp_enterprise_group_id: str = None,
                                        primary_phone_number: str = None, mobile_phone_number: str = None,
                                        language: str = None, timezone: str = None,
                                        package: str = None) -> Subscriber:
        """
        Update a BroadWorks Subscriber

        This API lets a Service Provider update certain details of a provisioned BroadWorks subscriber
        on Webex.

        <div>
        <Callout type='info'>The updated items will not be immediately reflected in the response body, but can be
        subsequently obtained via the `Get a BroadWorks Subscriber
        <https://developer.webex.com/docs/api/v1/broadworks-subscribers/get-a-broadworks-subscriber>`_ API once the status has transitioned from the
        updating state to the provisioned state.</Callout>
        </div>

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :param user_id: The user ID of the subscriber on BroadWorks.
        :type user_id: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param sp_enterprise_group_id: The group name under the enterprise in Broadworks. Only applicable to Enterprise
            mode.
        :type sp_enterprise_group_id: str
        :param primary_phone_number: The primary phone number configured against the subscriber on BroadWorks.
        :type primary_phone_number: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks. Any empty
            value on update will remove the already configured mobile phone number.
        :type mobile_phone_number: str
        :param language: The ISO 639-1 language code associated with the subscriber. Reserved for future use - any
            value currently specified will be ignored during subscriber provisioning.
        :type language: str
        :param timezone: The time zone associated with the subscriber. Refer to the `Webex Meetings Site Timezone
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_
            section of the `Webex for BroadWorks
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide>`_ guide for more information.
        :type timezone: str
        :param package: The Webex for BroadWorks Package to be assigned to the subscriber.
        :type package: str
        :rtype: :class:`Subscriber`
        """
        body = dict()
        body['userId'] = user_id
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['spEnterpriseGroupId'] = sp_enterprise_group_id
        body['primaryPhoneNumber'] = primary_phone_number
        body['mobilePhoneNumber'] = mobile_phone_number
        body['language'] = language
        body['timezone'] = timezone
        body['package'] = package
        url = self.ep(f'{subscriber_id}')
        data = super().put(url, json=body)
        r = Subscriber.model_validate(data)
        return r

    def remove_a_broad_works_subscriber(self, subscriber_id: str):
        """
        Remove a BroadWorks Subscriber

        This API will allow a Service Provider to remove the mapping between a BroadWorks Subscriber and Webex user.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :rtype: None
        """
        url = self.ep(f'{subscriber_id}')
        super().delete(url)


class BetaCallControlsWithMuteAndUnmuteFeatureApi(ApiChild, base='telephony/calls'):
    """
    Beta Call Controls with Mute and Unmute Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Call Control APIs in support of Webex Calling.
    
    All `GET` commands require the `spark:calls_read` scope while all other commands require the `spark:calls_write`
    scope.
    
    **NOTE**: These APIs support 3rd Party Call Control only.
    """

    def dial(self, destination: str, endpoint_id: str = None) -> DialResponse:
        """
        Dial

        Initiate an outbound call to a specified destination. This is also commonly referred to as Click to Call or
        Click to Dial. Alerts occur on all the devices belonging to a user unless an optional `endpointId` is
        specified in which case only the device or application identified by the `endpointId` is alerted. When a user
        answers an alerting device, an outbound call is placed from that device to the destination.

        :param destination: The destination to be dialed. The destination can be digits or a URI. Some examples for
            destination include: `1234`, `2223334444`, `+12223334444`, `*73`, `tel:+12223334444`,
            `user@company.domain`, and `sip:user@company.domain`.
        :type destination: str
        :param endpoint_id: The ID of the device or application to use for the call. The `endpointId` must be one of
            the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['destination'] = destination
        body['endpointId'] = endpoint_id
        url = self.ep('dial')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def answer(self, call_id: str, endpoint_id: str = None):
        """
        Answer

        Answer an incoming call. When no `endpointId` is specified, the call is answered on the user's primary device.
        When an `endpointId` is specified, the call is answered on the device or application identified by the
        `endpointId`. The answer API is rejected if the device is not alerting for the call or the device does not
        support answer via API.

        :param call_id: The call identifier of the call to be answered.
        :type call_id: str
        :param endpoint_id: The ID of the device or application to answer the call on. The `endpointId` must be one of
            the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['endpointId'] = endpoint_id
        url = self.ep('answer')
        super().post(url, json=body)

    def reject(self, call_id: str, action: RejectActionEnum = None):
        """
        Reject

        Reject an unanswered incoming call.

        :param call_id: The call identifier of the call to be rejected.
        :type call_id: str
        :param action: The rejection action to apply to the call. The busy action is applied if no specific action is
            provided.
        :type action: RejectActionEnum
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['action'] = enum_str(action)
        url = self.ep('reject')
        super().post(url, json=body)

    def hangup(self, call_id: str):
        """
        Hangup

        Hangup a call. If used on an unanswered incoming call, the call is rejected and sent to busy.

        :param call_id: The call identifier of the call to hangup.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('hangup')
        super().post(url, json=body)

    def hold(self, call_id: str):
        """
        Hold

        Hold a connected call.

        :param call_id: The call identifier of the call to hold.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('hold')
        super().post(url, json=body)

    def resume(self, call_id: str):
        """
        Resume

        Resume a held call.

        :param call_id: The call identifier of the call to resume.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('resume')
        super().post(url, json=body)

    def divert(self, call_id: str, destination: str = None, to_voicemail: str = None):
        """
        Divert

        Divert a call to a destination or a user's voicemail. This is also commonly referred to as a Blind Transfer.

        :param call_id: The call identifier of the call to divert.
        :type call_id: str
        :param destination: The destination to divert the call to. If toVoicemail is false, destination is required.
            The destination can be digits or a URI. Some examples for destination include: `1234`, `2223334444`,
            `+12223334444`, `*73`, `tel:+12223334444`, `user@company.domain`, `sip:user@company.domain`
        :type destination: str
        :param to_voicemail: If set to true, the call is diverted to voicemail. If no destination is specified, the
            call is diverted to the user's own voicemail. If a destination is specified, the call is diverted to the
            specified user's voicemail.
        :type to_voicemail: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['destination'] = destination
        body['toVoicemail'] = to_voicemail
        url = self.ep('divert')
        super().post(url, json=body)

    def transfer(self, call_id1: str = None, call_id2: str = None, destination: str = None):
        """
        Transfer

        Transfer two calls together.

        Unanswered incoming calls cannot be transferred but can be diverted using the divert API.

        If the user has only two calls and wants to transfer them together, the `callId1` and `callId2` parameters are
        optional and when not provided the calls are automatically selected and transferred.

        If the user has more than two calls and wants to transfer two of them together, the `callId1` and `callId2`
        parameters are mandatory to specify which calls are being transferred. Those are also commonly referred to as
        Attended Transfer, Consultative Transfer, or Supervised Transfer and will return a `204` response.

        If the user wants to transfer one call to a new destination but only when the destination responds, the
        `callId1` and destination parameters are mandatory to specify the call being transferred and the destination.

        This is referred to as a Mute Transfer and is similar to the divert API with the difference of waiting for the
        destination to respond prior to transferring the call. If the destination does not respond, the call is not
        transferred. This will return a `201` response.

        :param call_id1: The call identifier of the first call to transfer. This parameter is mandatory if either
            `callId2` or `destination` is provided.
        :type call_id1: str
        :param call_id2: The call identifier of the second call to transfer. This parameter is mandatory if `callId1`
            is provided and `destination` is not provided.
        :type call_id2: str
        :param destination: The destination to be transferred to. The destination can be digits or a URI. Some examples
            for destination include: `1234`, `2223334444`, `+12223334444`, `tel:+12223334444`, `user@company.domain`,
            `sip:user@company.domain`. This parameter is mandatory if `callId1` is provided and `callId2` is not
            provided.
        :type destination: str
        :rtype: None
        """
        body = dict()
        body['callId1'] = call_id1
        body['callId2'] = call_id2
        body['destination'] = destination
        url = self.ep('transfer')
        super().post(url, json=body)

    def park(self, call_id: str, destination: Union[str, datetime] = None,
             is_group_park: str = None) -> PartyInformation:
        """
        Park

        Park a connected call. The number field in the response can be used as the destination for the retrieve command
        to retrieve the parked call.

        :param call_id: The call identifier of the call to park.
        :type call_id: str
        :param destination: Identifes where the call is to be parked. If not provided, the call is parked against the
            parking user. The destination can be digits or a URI. Some examples for destination include: `1234`,
            `2223334444`, `+12223334444`, `*73`, `tel:+12223334444`, `user@company.domain`, `sip:user@company.domain`
        :type destination: Union[str, datetime]
        :param is_group_park: If set to`true`, the call is parked against an automatically selected member of the
            user's call park group and the destination parameter is ignored.
        :type is_group_park: str
        :rtype: PartyInformation
        """
        body = dict()
        body['callId'] = call_id
        body['destination'] = destination
        body['isGroupPark'] = is_group_park
        url = self.ep('park')
        data = super().post(url, json=body)
        r = PartyInformation.model_validate(data['parkedAgainst'])
        return r

    def retrieve(self, destination: Union[str, datetime] = None, endpoint_id: str = None) -> DialResponse:
        """
        Retrieve

        Retrieve a parked call. A new call is initiated to perform the retrieval in a similar manner to the dial
        command. The number field from the park command response can be used as the destination for the retrieve
        command.

        :param destination: Identifies where the call is parked. The number field from the park command response can be
            used as the destination for the retrieve command. If not provided, the call parked against the retrieving
            user is retrieved. The destination can be digits or a URI. Some examples for destination include: `1234`,
            `2223334444`, `+12223334444`, `*73`, `tel:+12223334444`, `user@company.domain`, `sip:user@company.domain`
        :type destination: Union[str, datetime]
        :param endpoint_id: The ID of the device or application to use for the retrieval. The `endpointId` must be one
            of the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['destination'] = destination
        body['endpointId'] = endpoint_id
        url = self.ep('retrieve')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def start_recording(self, call_id: str = None):
        """
        Start Recording

        Start recording a call. Use of this API is only valid when the user's call recording mode is set to "On
        Demand".

        :param call_id: The call identifier of the call to start recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('startRecording')
        super().post(url, json=body)

    def stop_recording(self, call_id: str = None):
        """
        Stop Recording

        Stop recording a call. Use of this API is only valid when a call is being recorded and the user's call
        recording mode is set to "On Demand".

        :param call_id: The call identifier of the call to stop recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('stopRecording')
        super().post(url, json=body)

    def pause_recording(self, call_id: str = None):
        """
        Pause Recording

        Pause recording on a call. Use of this API is only valid when a call is being recorded and the user's call
        recording mode is set to "On Demand" or "Always with Pause/Resume".

        :param call_id: The call identifier of the call to pause recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('pauseRecording')
        super().post(url, json=body)

    def resume_recording(self, call_id: str = None):
        """
        Resume Recording

        Resume recording a call. Use of this API is only valid when a call's recording is paused and the user's call
        recording mode is set to "On Demand" or "Always with Pause/Resume".

        :param call_id: The call identifier of the call to resume recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('resumeRecording')
        super().post(url, json=body)

    def transmit_dtmf(self, call_id: str = None, dtmf: Union[str, datetime] = None):
        """
        Transmit DTMF

        Transmit DTMF digits to a call.

        :param call_id: The call identifier of the call to transmit DTMF digits for.
        :type call_id: str
        :param dtmf: The DTMF digits to transmit. Each digit must be part of the following set: `[0, 1, 2, 3, 4, 5, 6,
            7, 8, 9, *, #, A, B, C, D]`. A comma "," may be included to indicate a pause between digits. For the value
            1,234, the DTMF 1 digit is initially sent. After a pause, the DTMF 2, 3, and 4 digits are sent
            successively.
        :type dtmf: Union[str, datetime]
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['dtmf'] = dtmf
        url = self.ep('transmitDtmf')
        super().post(url, json=body)

    def barge_in(self, target: Union[str, datetime], endpoint_id: str = None) -> DialResponse:
        """
        Barge In

        Barge-in on another user's answered call. A new call is initiated to perform the barge-in in a similar manner
        to the dial command.

        :param target: Identifies the user to barge-in on. The target can be digits or a URI. Some examples for target
            include: `1234`, `2223334444`, `+12223334444`, `tel:+12223334444`, `user@company.domain`,
            `sip:user@company.domain`
        :type target: Union[str, datetime]
        :param endpoint_id: The ID of the device or application to use for the barge-in. The `endpointId` must be one
            of the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['target'] = target
        body['endpointId'] = endpoint_id
        url = self.ep('bargeIn')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def list_calls(self) -> list[Call]:
        """
        List Calls

        Get the list of details for all active calls associated with the user.

        :rtype: list[Call]
        """
        url = self.ep()
        data = super().get(url)
        r = TypeAdapter(list[Call]).validate_python(data['items'])
        return r

    def get_call_details(self, call_id: str) -> Call:
        """
        Get Call Details

        Get the details of the specified active call for the user.

        :param call_id: The call identifier of the call.
        :type call_id: str
        :rtype: :class:`Call`
        """
        url = self.ep(f'{call_id}')
        data = super().get(url)
        r = Call.model_validate(data)
        return r

    def list_call_history(self, type: CallHistoryRecordTypeEnum = None) -> list[CallHistoryRecord]:
        """
        List Call History

        Get the list of call history records for the user. A maximum of 20 call history records per type (`placed`,
        `missed`, `received`) are returned.

        :param type: The type of call history records to retrieve. If not specified, then all call history records are
            retrieved.
        :type type: CallHistoryRecordTypeEnum
        :rtype: list[CallHistoryRecord]
        """
        params = {}
        if type is not None:
            params['type'] = type
        url = self.ep('history')
        data = super().get(url, params=params)
        r = TypeAdapter(list[CallHistoryRecord]).validate_python(data['items'])
        return r

    def pickup(self, target: Union[str, datetime] = None, endpoint_id: str = None) -> DialResponse:
        """
        Pickup

        Picks up an incoming call to another user. A new call is initiated to perform the pickup in a similar manner to
        the dial command. When target is not present, the API pickups up a call from the user's call pickup group.
        When target is present, the API pickups an incoming call from the specified target user.

        :param target: Identifies the user to pickup an incoming call from. If not provided, an incoming call to the
            user's call pickup group is picked up. The target can be digits or a URI. Some examples for target
            include: `1234`, `2223334444`, `+12223334444`, `tel:+12223334444`, `user@company.domain`,
            `sip:user@company.domain`
        :type target: Union[str, datetime]
        :param endpoint_id: The ID of the device or application to use for the pickup. The `endpointId` must be one of
            the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['target'] = target
        body['endpointId'] = endpoint_id
        url = self.ep('pickup')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def push(self, call_id: str = None):
        """
        Push

        Pushes a call from the assistant to the executive the call is associated with. Use of this API is only valid
        when the assistant's call is associated with an executive.

        :param call_id: The call identifier of the call to push.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('push')
        super().post(url, json=body)

    def mute(self, call_id: str):
        """
        Mute

        Mute a call.

        :param call_id: The call identifier of the call to mute.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('mute')
        super().post(url, json=body)

    def unmute(self, call_id: str):
        """
        Unmute

        Unmute a call.

        :param call_id: The call identifier of the call to unmute.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('unmute')
        super().post(url, json=body)


class BetaCallRoutingWithRoutingPrefixUpdateApi(ApiChild, base='telephony/config/jobs/updateRoutingPrefix'):
    """
    Beta Call Routing with Routing Prefix Update
    
    """

    def get_a_list_of_update_routing_prefix_jobs(self, org_id: str = None) -> list[BatchResponse]:
        """
        Get a List of Update Routing Prefix jobs

        Get the list of all update routing prefix jobs in an organization.

        The routing prefix is associated with a location and is used to route calls belonging to that location.
        This API allows users to retrieve all the update routing prefix jobs in an organization.

        Retrieving the list of update routing prefix jobs in an organization requires a full, user, or read-only
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param org_id: Retrieve list of update routing prefix jobs in this organization.
        :type org_id: str
        :rtype: list[BatchResponse]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[BatchResponse]).validate_python(data)
        return r

    def get_the_job_status_of_update_routing_prefix_job(self, job_id: str, org_id: str = None) -> BatchResponse:
        """
        Get the job status of Update Routing Prefix job

        Get the status of the update routing prefix job by its job ID.

        The routing prefix is associated with a location and is used to route calls belonging to that location.
        This API allows users to check the status of update routing prefix job by job ID in an organization.

        Checking the status of the update routing prefix job in an organization requires a full, user, or read-only
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job status for this `jobId`.
        :type job_id: str
        :param org_id: Check update routing prefix job status in this organization.
        :type org_id: str
        :rtype: :class:`BatchResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{job_id}')
        data = super().get(url, params=params)
        r = BatchResponse.model_validate(data)
        return r

    def get_job_errors_for_update_routing_prefix_job(self, job_id: str, org_id: str = None) -> BatchJobError:
        """
        Get job errors for update routing prefix job

        GET job errors for the update routing prefix job in an organization.

        The routing prefix is associated with a location and is used to route calls belonging to that location.
        This API allows users to retrieve all the errors of the update routing prefix job by job ID in an organization.

        Retrieving all the errors of the update routing prefix job in an organization requires a full, user, or
        read-only administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job errors for this `jobId`.
        :type job_id: str
        :param org_id: Retrieve list of errors for update routing prefix job in this organization.
        :type org_id: str
        :rtype: :class:`BatchJobError`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{job_id}/errors')
        data = super().get(url, params=params)
        r = BatchJobError.model_validate(data)
        return r


class BetaDECTDevicesSettingsApi(ApiChild, base='telephony/config'):
    """
    Beta DECT Devices Settings
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    DECT APIs allow the admin to create a DECT network, and add base stations and handsets to the DECT network. People,
    places and virtual lines member types are supported on handset lines in the DECT network. Currently, APIs support
    Cisco DECT device models only.
    
    Viewing and searching  DECT settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Adding and modifying these DECT settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    """

    def create_a_dect_network(self, location_id: str, name: str, display_name: str, model: CreateDECTNetworkModel,
                              default_access_code_enabled: bool, default_access_code: Union[str, datetime],
                              org_id: str = None) -> str:
        """
        Create a DECT Network

        Create a multi-cell DECT network for a given location.

        Creating a DECT network requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create a DECT network in this location.
        :type location_id: str
        :param name: Name of the DECT network. Min and max length supported for the DECT network name are 1 and 40
            respectively.
        :type name: str
        :param display_name: Add a default name (11 characters max) to display for all handsets. If left blank, the
            default name will be an indexed number followed by the DECT network name.
        :type display_name: str
        :param model: Select a device model type depending on the number of base stations and handset lines needed in
            the DECT network.
        :type model: CreateDECTNetworkModel
        :param default_access_code_enabled: If set to true, need to provide a default access code that will be shared
            for all users in this network to pair their lines to the next available handset. Otherwise, each user will
            get a unique 4-digit access code that will be auto-generated.
        :type default_access_code_enabled: bool
        :param default_access_code: If `defaultAccessCodeEnabled` is set to true, then provide a default access code
            that needs to be a 4-numeric digit. The access code should be unique to the DECT network for the location.
        :type default_access_code: Union[str, datetime]
        :param org_id: Create a DECT network in this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['displayName'] = display_name
        body['model'] = enum_str(model)
        body['defaultAccessCodeEnabled'] = default_access_code_enabled
        body['defaultAccessCode'] = default_access_code
        url = self.ep(f'locations/{location_id}/dectNetworks')
        data = super().post(url, params=params, json=body)
        r = data['dectNetworkId']
        return r

    def create_multiple_base_stations(self, location_id: str, dect_id: str, base_station_macs: list[str],
                                      org_id: str = None) -> list[BaseStationResponse]:
        """
        Create Multiple Base Stations

        This API is used to create multiple base stations in a DECT network in an organization.

        Creating base stations in a DECT network requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create a base station in this location.
        :type location_id: str
        :param dect_id: Create a base station for the DECT network.
        :type dect_id: str
        :param base_station_macs: Array of base stations.
        :type base_station_macs: list[str]
        :param org_id: Create a base station for a DECT network in this organization.
        :type org_id: str
        :rtype: list[BaseStationResponse]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['baseStationMacs'] = base_station_macs
        url = self.ep(f'locations/{location_id}/dectNetworks/{dect_id}/basestations')
        data = super().post(url, params=params, json=body)
        r = TypeAdapter(list[BaseStationResponse]).validate_python(data['baseStationMacs'])
        return r

    def add_a_handset_to_a_dect_network(self, location_id: str, dect_network_id: str, line1_member_id: str,
                                        line2_member_id: str, custom_display_name: str, org_id: str = None):
        """
        Add a Handset to a DECT Network

        Add a handset to a DECT network in a location in an organization.

        Adding a handset to a DECT network requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`

        :param location_id: Add handset in this location.
        :type location_id: str
        :param dect_network_id: A unique identifier for the DECT network.
        :type dect_network_id: str
        :param line1_member_id: ID of the member on line1 of the handset. Members can be PEOPLE or PLACE.
        :type line1_member_id: str
        :param line2_member_id: ID of the member on line2 of the handset. Members can be PEOPLE, PLACE, or
            VIRTUAL_LINE.
        :type line2_member_id: str
        :param custom_display_name: Custom display name on the handset. Min and max length supported for the custom
            display name is 1 and 16 respectively
        :type custom_display_name: str
        :param org_id: Add handset in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['line1MemberId'] = line1_member_id
        body['line2MemberId'] = line2_member_id
        body['customDisplayName'] = custom_display_name
        url = self.ep(f'locations/{location_id}/dectNetworks/{dect_network_id}/handsets')
        super().post(url, params=params, json=body)

    def search_available_members(self, org_id: str = None, start: int = None, member_name: str = None,
                                 phone_number: str = None, order: str = None, exclude_virtual_profile: bool = None,
                                 device_location_id: str = None, **params) -> Generator[AvailableMember, None, None]:
        """
        Search Available Members

        List the members that are available to be assigned to DECT handset lines.

        This requires a full or read-only administrator auth token with a scope of `spark-admin:telephony_config_read`

        :param org_id: Search members in this organization.
        :type org_id: str
        :param start: Specifies the offset from the first result that you want to fetch.
        :type start: int
        :param member_name: Search (Contains) numbers based on member name.
        :type member_name: str
        :param phone_number: Search (Contains) based on number.
        :type phone_number: str
        :param order: Sort the list of available members on the device in ascending order by name, using either last
            name `lname` or first name `fname`. Default sort is the last name in ascending order.
        :type order: str
        :param exclude_virtual_profile: If true, search results will exclude virtual lines in the member list. NOTE:
            Virtual lines cannot be assigned as the primary line.
        :type exclude_virtual_profile: bool
        :param device_location_id: Location ID of DECT network.
        :type device_location_id: str
        :return: Generator yielding :class:`AvailableMember` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if member_name is not None:
            params['memberName'] = member_name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if order is not None:
            params['order'] = order
        if exclude_virtual_profile is not None:
            params['excludeVirtualProfile'] = str(exclude_virtual_profile).lower()
        if device_location_id is not None:
            params['deviceLocationId'] = device_location_id
        url = self.ep('devices/availableMembers')
        return self.session.follow_pagination(url=url, model=AvailableMember, item_key='members', params=params)


class BetaDepartmentsWithDepartmentFeaturesApi(ApiChild, base='telephony/config/departments'):
    """
    Beta Departments with Department Features
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Webex Calling Organization Settings support reading and writing of Webex Calling settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `OrgId`
    query parameter.
    
    Only organization settings with department-related fields are listed.  For department membership, please refer to
    `Get Group Members API
    <https://developer.webex.com/docs/api/v1/groups/get-group-members>`_ to retrieve members of a department group.
    
    The use of the `/groups` API for departments is supported in a read-only
    manner only. Modification of a department via the `/groups` API is
    unsupported.
    
    """

    def get_a_list_of_departments(self, org_id: str = None, start: int = None, name: str = None, id: str = None,
                                  **params) -> Generator[DepartmentResponse, None, None]:
        """
        Get a List of Departments

        Retrieve a list of departments.

        Admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Retrieve list of departments for this organization.
        :type org_id: str
        :param start: Specifies the offset from the first result that you want to fetch.
        :type start: int
        :param name: Specifies the case insensitive substring to be matched against the department names.
        :type name: str
        :param id: Specifies the department ID you want to fetch.
        :type id: str
        :return: Generator yielding :class:`DepartmentResponse` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if id is not None:
            params['id'] = id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=DepartmentResponse, item_key='departments', params=params)

    def create_a_department(self, name: str, org_id: str = None) -> str:
        """
        Create a Department

        This API is used to create a department in an organization.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param name: Name of the department.
        :type name: str
        :param org_id: Create a department for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        url = self.ep()
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_department(self, department_id: str, org_id: str = None):
        """
        Delete a Department

        This API is used to delete a department by its department id.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        <br/>

        <strong> NOTE </strong>: Before deleting a department, please be sure to unassign the resources (such as call
        queues, paging groups, etc.) that are associated with it.
        Unassigning resources from a department happens asynchronously and can take upto 20 seconds to take effect.

        :param department_id: Unique identifier for the department.
        :type department_id: str
        :param org_id: Delete a department from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{department_id}')
        super().delete(url, params=params)

    def get_details_of_a_department(self, department_id: str, org_id: str = None) -> DepartmentResponseDepartment:
        """
        Get Details of a Department

        Retrieve details of a department.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param department_id: Unique identifier for the department.
        :type department_id: str
        :param org_id: Retrieve details for a department in this organization.
        :type org_id: str
        :rtype: DepartmentResponseDepartment
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{department_id}')
        data = super().get(url, params=params)
        r = DepartmentResponseDepartment.model_validate(data['department'])
        return r

    def modify_a_department(self, department_id: str, name: str, org_id: str = None):
        """
        Modify a Department

        This API is used to modify a department in an organization.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param department_id: Unique identifier for the department.
        :type department_id: str
        :param name: Name of the department.
        :type name: str
        :param org_id: Modify a department for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        url = self.ep(f'{department_id}')
        super().put(url, params=params, json=body)


class BetaDeviceCallSettingsWithESNFeatureApi(ApiChild, base='telephony/config/devices/{deviceId}'):
    """
    Beta Device Call Settings with ESN Feature
    
    These APIs manages Webex Calling settings for devices with are of the Webex Calling type.
    
    Viewing these read-only device settings requires a full, device, or
    read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these device settings requires a full or device
    administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    """

    def get_device_members(self, device_id: str, org_id: str = None) -> GetMemberResponse:
        """
        Get Device Members

        Get the list of all the members of the device including primary and secondary users.

        A device member can be either a person or a workspace. An admin can access the list of member details, modify
        member details and
        search for available members on a device.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: Retrieves the list of all members of the device in this organization.
        :type org_id: str
        :rtype: :class:`GetMemberResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'members')
        data = super().get(url, params=params)
        r = GetMemberResponse.model_validate(data)
        return r

    def search_members(self, device_id: str, location_id: str, org_id: str = None, start: int = None,
                       member_name: str = None, phone_number: str = None, extension: Union[str, datetime] = None,
                       **params) -> Generator[SearchMemberObject, None, None]:
        """
        Search Members

        Search members that can be assigned to the device.

        A device member can be either a person or a workspace. A admin can access the list of member details, modify
        member details and
        search for available members on a device.

        This requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param location_id: Unique identifier for the location.
        :type location_id: str
        :param org_id: Retrieves the list of available members on the device in this organization.
        :type org_id: str
        :param start: Specifies the offset from the first result that you want to fetch.
        :type start: int
        :param member_name: Search (Contains) numbers based on member name.
        :type member_name: str
        :param phone_number: Search (Contains) based on number.
        :type phone_number: str
        :param extension: Search (Contains) based on extension.
        :type extension: Union[str, datetime]
        :return: Generator yielding :class:`SearchMemberObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if member_name is not None:
            params['memberName'] = member_name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if extension is not None:
            if isinstance(extension, str):
                extension = isoparse(extension)
            extension = dt_iso_str(extension)
            params['extension'] = extension
        url = self.ep(f'availableMembers')
        return self.session.follow_pagination(url=url, model=SearchMemberObject, item_key='members', params=params)


class BetaFeaturesAnnouncementRepositoryWithLocationAdminSupportApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Announcement Repository with Location Admin Support
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Announcement Repository support reading and writing of Webex Calling Announcement Repository settings for
    a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator or location administrator
    auth token with a scope of `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def fetch_list_of_announcement_greetings_on_location_and_organization_level(self, org_id: str = None,
                                                                                location_id: FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelLocationId = None,
                                                                                start: int = None, order: str = None,
                                                                                file_name: str = None,
                                                                                file_type: str = None,
                                                                                media_file_type: str = None,
                                                                                name: str = None,
                                                                                **params) -> Generator[AnnouncementsListResponse, None, None]:
        """
        Fetch list of announcement greetings on location and organization level

        Fetch a list of binary announcement greetings at an organization as well as location level.

        An admin can upload a file at an organization level. This file will be uploaded to the announcement repository.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Get announcements in this organization.
        :type org_id: str
        :param location_id: Return the list of enterprise or Location announcement files. Without this parameter, the
            Enterprise level announcements are returned.
        :type location_id: FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelLocationId
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Sort the list according to fileName or fileSize. The default sort will be in Ascending order.
        :type order: str
        :param file_name: Return the list of announcements with the given fileName.
        :type file_name: str
        :param file_type: Return the list of announcement files for this fileType.
        :type file_type: str
        :param media_file_type: Return the list of announcement files for this mediaFileType.
        :type media_file_type: str
        :param name: Return the list of announcement files for this announcement label.
        :type name: str
        :return: Generator yielding :class:`AnnouncementsListResponse` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if file_name is not None:
            params['fileName'] = file_name
        if file_type is not None:
            params['fileType'] = file_type
        if media_file_type is not None:
            params['mediaFileType'] = media_file_type
        if name is not None:
            params['name'] = name
        url = self.ep('announcements')
        return self.session.follow_pagination(url=url, model=AnnouncementsListResponse, item_key='announcements', params=params)

    def upload_a_binary_announcement_greeting_at_the_location_level(self, location_id: str, org_id: str = None) -> str:
        """
        Upload a binary announcement greeting at the location level

        Upload a binary file to the announcement repository at a location level.

        An admin can upload a file at a location level. This file will be uploaded to the announcement repository.

        Your request will need to be a `multipart/form-data` request rather than JSON, using the `audio/wav`
        Content-Type.

        This API requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write` .

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param org_id: Create an announcement for location in this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements')
        data = super().post(url, params=params)
        r = data['id']
        return r

    def fetch_repository_usage_for_announcements_in_a_location(self, location_id: str,
                                                               org_id: str = None) -> AnnouncementUsageResponse:
        """
        Fetch repository usage for announcements in a location

        Retrieves repository usage for announcements in a location.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param org_id: Get announcement usage for location in this organization.
        :type org_id: str
        :rtype: :class:`AnnouncementUsageResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/usage')
        data = super().get(url, params=params)
        r = AnnouncementUsageResponse.model_validate(data)
        return r

    def delete_an_announcement_greeting_in_a_location(self, location_id: str, org_id: str = None):
        """
        Delete an announcement greeting in a location

        Delete an announcement greeting in a location.

        This API requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Unique identifier of a location where announcement is being created.
        :type location_id: str
        :param org_id: Delete an announcement for location in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/{announcementsId}')
        super().delete(url, params=params)

    def fetch_details_of_a_binary_announcement_greeting_at_location_level(self, location_id: str, announcement_id: str,
                                                                          org_id: str = None) -> AnnouncementResponse:
        """
        Fetch details of a binary announcement greeting at location level

        Fetch details of a binary announcement greeting by its ID at a location level.

        An admin can upload a file at a location level. This file will be uploaded to the announcement repository.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param announcement_id: Unique identifier of an announcement.
        :type announcement_id: str
        :param org_id: Fetch an announcement for location in this organization.
        :type org_id: str
        :rtype: :class:`AnnouncementResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/{announcement_id}')
        data = super().get(url, params=params)
        r = AnnouncementResponse.model_validate(data)
        return r

    def modify_a_binary_announcement_greeting(self, location_id: str, announcement_id: str, org_id: str = None):
        """
        Modify a binary announcement greeting

        Modify an existing announcement greeting at a location level.

        This API requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param announcement_id: Unique identifier of an announcement.
        :type announcement_id: str
        :param org_id: Modify an announcement for location in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/{announcement_id}')
        super().put(url, params=params)


class BetaFeaturesAutoAttendantWithDepartmentFeaturesApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Auto Attendant with Department Features
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Auto Attendant support reading and writing of Webex Calling Auto Attendant settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_auto_attendants(self, org_id: str = None, location_id: str = None, start: int = None,
                                         name: str = None, phone_number: str = None, department_id: str = None,
                                         department_name: str = None,
                                         **params) -> Generator[ListAutoAttendantObject, None, None]:
        """
        Read the List of Auto Attendants

        List all Auto Attendants for the organization.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List auto attendants for this organization.
        :type org_id: str
        :param location_id: Return the list of auto attendants for this location.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return auto attendants with the matching name.
        :type name: str
        :param phone_number: Only return auto attendants with the matching phone number.
        :type phone_number: str
        :param department_id: Return only auto attendants with the matching departmentId.
        :type department_id: str
        :param department_name: Return only auto attendants with the matching departmentName.
        :type department_name: str
        :return: Generator yielding :class:`ListAutoAttendantObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if department_id is not None:
            params['departmentId'] = department_id
        if department_name is not None:
            params['departmentName'] = department_name
        url = self.ep('autoAttendants')
        return self.session.follow_pagination(url=url, model=ListAutoAttendantObject, item_key='autoAttendants', params=params)

    def get_details_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                          org_id: str = None) -> GetAutoAttendantObject:
        """
        Get Details for an Auto Attendant

        Retrieve an Auto Attendant's details.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Retrieving an auto attendant details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve an auto attendant details in this location.
        :type location_id: str
        :param auto_attendant_id: Retrieve the auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param org_id: Retrieve auto attendant details from this organization.
        :type org_id: str
        :rtype: :class:`GetAutoAttendantObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        data = super().get(url, params=params)
        r = GetAutoAttendantObject.model_validate(data)
        return r

    def update_an_auto_attendant(self, location_id: str, auto_attendant_id: str, name: str, phone_number: str,
                                 extension: Union[str, datetime], first_name: str, last_name: str,
                                 alternate_numbers: list[AlternateNumbersObject], language_code: str,
                                 business_schedule: str, holiday_schedule: str,
                                 extension_dialing: GetAutoAttendantObjectExtensionDialing,
                                 name_dialing: GetAutoAttendantObjectExtensionDialing, time_zone: str,
                                 business_hours_menu: HoursMenuObject, after_hours_menu: HoursMenuObject,
                                 department: DepartmentResponseWithId, org_id: str = None):
        """
        Update an Auto Attendant

        Update the designated Auto Attendant.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Updating an auto attendant requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Update an auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param name: Unique name for the auto attendant.
        :type name: str
        :param phone_number: Auto attendant phone number. Either phone number or extension should be present as
            mandatory.
        :type phone_number: str
        :param extension: Auto attendant extension. Either phone number or extension should be present as mandatory.
        :type extension: Union[str, datetime]
        :param first_name: First name defined for an auto attendant.
        :type first_name: str
        :param last_name: Last name defined for an auto attendant.
        :type last_name: str
        :param alternate_numbers: Alternate numbers defined for the auto attendant.
        :type alternate_numbers: list[AlternateNumbersObject]
        :param language_code: Language code for the auto attendant.
        :type language_code: str
        :param business_schedule: Business hours for the auto attendant.
        :type business_schedule: str
        :param holiday_schedule: Holiday schedule for the auto attendant.
        :type holiday_schedule: str
        :param extension_dialing: Extension dialing setting. If the values are not set default will be set as
            ENTERPRISE.
        :type extension_dialing: GetAutoAttendantObjectExtensionDialing
        :param name_dialing: Name dialing setting. If the values are not set default will be set as ENTERPRISE.
        :type name_dialing: GetAutoAttendantObjectExtensionDialing
        :param time_zone: Time zone defined for the auto attendant.
        :type time_zone: str
        :param business_hours_menu: Business hours menu defined for the auto attendant.
        :type business_hours_menu: HoursMenuObject
        :param after_hours_menu: After hours menu defined for the auto attendant.
        :type after_hours_menu: HoursMenuObject
        :param department: Specifies the department information.
        :type department: DepartmentResponseWithId
        :param org_id: Update an auto attendant from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['alternateNumbers'] = loads(TypeAdapter(list[AlternateNumbersObject]).dump_json(alternate_numbers))
        body['languageCode'] = language_code
        body['businessSchedule'] = business_schedule
        body['holidaySchedule'] = holiday_schedule
        body['extensionDialing'] = enum_str(extension_dialing)
        body['nameDialing'] = enum_str(name_dialing)
        body['timeZone'] = time_zone
        body['businessHoursMenu'] = loads(business_hours_menu.model_dump_json())
        body['afterHoursMenu'] = loads(after_hours_menu.model_dump_json())
        body['department'] = loads(department.model_dump_json())
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        super().put(url, params=params, json=body)


class BetaFeaturesAutoAttendantWithESNFeatureApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Auto Attendant with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Auto Attendant support reading and writing of Webex Calling Auto Attendant settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_auto_attendants(self, org_id: str = None, location_id: str = None, start: int = None,
                                         name: str = None, phone_number: str = None,
                                         **params) -> Generator[ListAutoAttendantObject1, None, None]:
        """
        Read the List of Auto Attendants

        List all Auto Attendants for the organization.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List auto attendants for this organization.
        :type org_id: str
        :param location_id: Return the list of auto attendants for this location.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return auto attendants with the matching name.
        :type name: str
        :param phone_number: Only return auto attendants with the matching phone number.
        :type phone_number: str
        :return: Generator yielding :class:`ListAutoAttendantObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('autoAttendants')
        return self.session.follow_pagination(url=url, model=ListAutoAttendantObject1, item_key='autoAttendants', params=params)

    def get_details_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                          org_id: str = None) -> GetAutoAttendantObject1:
        """
        Get Details for an Auto Attendant

        Retrieve an Auto Attendant details.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Retrieving an auto attendant details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve an auto attendant details in this location.
        :type location_id: str
        :param auto_attendant_id: Retrieve the auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param org_id: Retrieve auto attendant details from this organization.
        :type org_id: str
        :rtype: :class:`GetAutoAttendantObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        data = super().get(url, params=params)
        r = GetAutoAttendantObject1.model_validate(data)
        return r


class BetaFeaturesCallParkWithESNFeatureApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Call Park with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Park supports reading and writing of Webex Calling Call Park settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_details_for_a_call_park(self, location_id: str, call_park_id: str,
                                    org_id: str = None) -> GetCallParkObject:
        """
        Get Details for a Call Park

        Retrieve Call Park details.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Retrieving call park details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        **NOTE**: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Retrieve settings for a call park in this location.
        :type location_id: str
        :param call_park_id: Retrieve settings for a call park with the matching ID.
        :type call_park_id: str
        :param org_id: Retrieve call park settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallParkObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParks/{call_park_id}')
        data = super().get(url, params=params)
        r = GetCallParkObject.model_validate(data)
        return r

    def get_available_agents_from_call_parks(self, location_id: str, org_id: str = None, call_park_name: str = None,
                                             start: int = None, name: str = None, phone_number: str = None,
                                             order: str = None,
                                             **params) -> Generator[GetPersonPlaceVirtualLineCallParksObject, None, None]:
        """
        Get available agents from Call Parks

        Retrieve available agents from call parks for a given location.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Retrieving available agents from call parks requires a full or read-only administrator auth token with a scope
        of `spark-admin:telephony_config_read`.

        :param location_id: Return the available agents for this location.
        :type location_id: str
        :param org_id: Return the available agents for this organization.
        :type org_id: str
        :param call_park_name: Only return available agents from call parks with the matching name.
        :type call_park_name: str
        :param start: Start at the zero-based offset in the list of matching available agents.
        :type start: int
        :param name: Only return available agents with the matching name.
        :type name: str
        :param phone_number: Only return available agents with the matching primary number.
        :type phone_number: str
        :param order: Order the available agents according to the designated fields. Up to three vertical bar (|)
            separated sort order fields may be specified. Available sort fields: fname, lname, number and extension.
            The maximum supported sort order value is 3.
        :type order: str
        :return: Generator yielding :class:`GetPersonPlaceVirtualLineCallParksObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if call_park_name is not None:
            params['callParkName'] = call_park_name
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if order is not None:
            params['order'] = order
        url = self.ep(f'locations/{location_id}/callParks/availableUsers')
        return self.session.follow_pagination(url=url, model=GetPersonPlaceVirtualLineCallParksObject, item_key='agents', params=params)

    def read_the_list_of_call_park_extensions(self, org_id: str = None, start: int = None, extension: Union[str,
                                              datetime] = None, name: str = None, location_id: str = None,
                                              location_name: str = None, order: str = None,
                                              **params) -> Generator[ListCallParkExtensionObject, None, None]:
        """
        Read the List of Call Park Extensions

        List all Call Park Extensions for the organization.

        The Call Park service, enabled for all users by default, allows a user to park a call against an available
        user's extension or to a Call Park Extension. Call Park Extensions are extensions defined within the Call Park
        service for holding parked calls.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List call park extensions for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param extension: Only return call park extensions with the matching extension.
        :type extension: Union[str, datetime]
        :param name: Only return call park extensions with the matching name.
        :type name: str
        :param location_id: Only return call park extensions with matching location ID.
        :type location_id: str
        :param location_name: Only return call park extensions with the matching extension.
        :type location_name: str
        :param order: Order the available agents according to the designated fields.  Available sort fields:
            `groupName`, `callParkExtension`, `callParkExtensionName`, `callParkExtensionExternalId`.
        :type order: str
        :return: Generator yielding :class:`ListCallParkExtensionObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if extension is not None:
            if isinstance(extension, str):
                extension = isoparse(extension)
            extension = dt_iso_str(extension)
            params['extension'] = extension
        if name is not None:
            params['name'] = name
        if location_id is not None:
            params['locationId'] = location_id
        if location_name is not None:
            params['locationName'] = location_name
        if order is not None:
            params['order'] = order
        url = self.ep('callParkExtensions')
        return self.session.follow_pagination(url=url, model=ListCallParkExtensionObject, item_key='callParkExtensions', params=params)

    def get_details_for_a_call_park_extension(self, location_id: str, call_park_extension_id: str,
                                              org_id: str = None) -> GetCallParkExtensionObject:
        """
        Get Details for a Call Park Extension

        Retrieve Call Park Extension details.

        The Call Park service, enabled for all users by default, allows a user to park a call against an available
        user's extension or to a Call Park Extension. Call Park Extensions are extensions defined within the Call Park
        service for holding parked calls.

        Retrieving call park extension details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve details for a call park extension in this location.
        :type location_id: str
        :param call_park_extension_id: Retrieve details for a call park extension with the matching ID.
        :type call_park_extension_id: str
        :param org_id: Retrieve call park extension details from this organization.
        :type org_id: str
        :rtype: :class:`GetCallParkExtensionObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParkExtensions/{call_park_extension_id}')
        data = super().get(url, params=params)
        r = GetCallParkExtensionObject.model_validate(data)
        return r


class BetaFeaturesCallPickupWithESNFeatureApi(ApiChild, base='telephony/config/locations/{locationId}/callPickups'):
    """
    Beta Features:  Call Pickup with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Pickup supports reading and writing of Webex Calling Call Pickup settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_details_for_a_call_pickup(self, location_id: str, call_pickup_id: str,
                                      org_id: str = None) -> GetCallPickupObject:
        """
        Get Details for a Call Pickup

        Retrieve Call Pickup details.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Retrieving call pickup details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Retrieve settings for a call pickup in this location.
        :type location_id: str
        :param call_pickup_id: Retrieve settings for a call pickup with the matching ID.
        :type call_pickup_id: str
        :param org_id: Retrieve call pickup settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallPickupObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{call_pickup_id}')
        data = super().get(url, params=params)
        r = GetCallPickupObject.model_validate(data)
        return r

    def get_available_agents_from_call_pickups(self, location_id: str, org_id: str = None,
                                               call_pickup_name: str = None, start: int = None, name: str = None,
                                               phone_number: str = None, order: str = None,
                                               **params) -> Generator[GetPersonPlaceVirtualLineCallPickupObject, None, None]:
        """
        Get available agents from Call Pickups

        Retrieve available agents from call pickups for a given location.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Retrieving available agents from call pickups requires a full or read-only administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param location_id: Return the available agents for this location.
        :type location_id: str
        :param org_id: Return the available agents for this organization.
        :type org_id: str
        :param call_pickup_name: Only return available agents from call pickups with the matching name.
        :type call_pickup_name: str
        :param start: Start at the zero-based offset in the list of matching available agents.
        :type start: int
        :param name: Only return available agents with the matching name.
        :type name: str
        :param phone_number: Only return available agents with the matching primary number.
        :type phone_number: str
        :param order: Order the available agents according to the designated fields. Up to three vertical bar (|)
            separated sort order fields may be specified. Available sort fields: `fname`, `lname`, `extension`,
            `number`.
        :type order: str
        :return: Generator yielding :class:`GetPersonPlaceVirtualLineCallPickupObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if call_pickup_name is not None:
            params['callPickupName'] = call_pickup_name
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if order is not None:
            params['order'] = order
        url = self.ep(f'availableUsers')
        return self.session.follow_pagination(url=url, model=GetPersonPlaceVirtualLineCallPickupObject, item_key='agents', params=params)


class BetaFeaturesCallQueueWithDepartmentFeaturesApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Call Queue with Department Features
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Queue supports reading and writing of Webex Calling Call Queue settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_call_queues(self, org_id: str = None, location_id: str = None, start: int = None,
                                     name: str = None, phone_number: str = None, department_id: str = None,
                                     department_name: str = None,
                                     **params) -> Generator[ListCallQueueObject, None, None]:
        """
        Read the List of Call Queues

        List all Call Queues for the organization.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List call queues for this organization.
        :type org_id: str
        :param location_id: Only return call queues with matching location ID.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return call queues with the matching name.
        :type name: str
        :param phone_number: Only return call queues with matching primary phone number or extension.
        :type phone_number: str
        :param department_id: Return only call queues with the matching departmentId.
        :type department_id: str
        :param department_name: Return only call queues with the matching departmentName.
        :type department_name: str
        :return: Generator yielding :class:`ListCallQueueObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if department_id is not None:
            params['departmentId'] = department_id
        if department_name is not None:
            params['departmentName'] = department_name
        url = self.ep('queues')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject, item_key='queues', params=params)

    def get_details_for_a_call_queue(self, location_id: str, queue_id: str, org_id: str = None) -> GetCallQueueObject:
        """
        Get Details for a Call Queue

        Retrieve Call Queue details.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned anvinternal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Retrieving call queue details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallQueueObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        data = super().get(url, params=params)
        r = GetCallQueueObject.model_validate(data)
        return r

    def update_a_call_queue(self, location_id: str, queue_id: str, enabled: bool, name: str, language_code: str,
                            first_name: str, last_name: str, time_zone: str, phone_number: str, extension: Union[str,
                            datetime], alternate_number_settings: GetCallQueueObjectAlternateNumberSettings,
                            call_policies: GetCallQueueCallPolicyObject, queue_settings: CallQueueQueueSettingsObject,
                            allow_call_waiting_for_agents_enabled: bool, agents: list[PostPersonPlaceObject],
                            department: DepartmentResponseWithId, org_id: str = None):
        """
        Update a Call Queue

        Update the designated Call Queue.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Updating a call queue requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param enabled: Whether or not the call queue is enabled.
        :type enabled: bool
        :param name: Unique name for the call queue.
        :type name: str
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this call queue. Defaults to ".".
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this call queue. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param phone_number: Primary phone number of the call queue.
        :type phone_number: str
        :param extension: Extension of the call queue.
        :type extension: Union[str, datetime]
        :param alternate_number_settings: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a call queue. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the call queue.
        :type alternate_number_settings: GetCallQueueObjectAlternateNumberSettings
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: GetCallQueueCallPolicyObject
        :param queue_settings: Overall call queue settings.
        :type queue_settings: CallQueueQueueSettingsObject
        :param allow_call_waiting_for_agents_enabled: Flag to indicate whether call waiting is enabled for agents.
        :type allow_call_waiting_for_agents_enabled: bool
        :param agents: People, including workspaces, that are eligible to receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param department: Specifies the department information.
        :type department: DepartmentResponseWithId
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['name'] = name
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['alternateNumberSettings'] = loads(alternate_number_settings.model_dump_json())
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['queueSettings'] = loads(queue_settings.model_dump_json())
        body['allowCallWaitingForAgentsEnabled'] = allow_call_waiting_for_agents_enabled
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['department'] = loads(department.model_dump_json())
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        super().put(url, params=params, json=body)


class BetaFeaturesCallQueueWithESNFeatureApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Call Queue with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Queue supports reading and writing of Webex Calling Call Queue settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_call_queues(self, org_id: str = None, location_id: str = None, start: int = None,
                                     name: str = None, phone_number: str = None,
                                     **params) -> Generator[ListCallQueueObject1, None, None]:
        """
        Read the List of Call Queues

        List all Call Queues for the organization.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List call queues for this organization.
        :type org_id: str
        :param location_id: Only return call queues with matching location ID.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return call queues with the matching name.
        :type name: str
        :param phone_number: Only return call queues with matching primary phone number or extension.
        :type phone_number: str
        :return: Generator yielding :class:`ListCallQueueObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('queues')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject1, item_key='queues', params=params)

    def get_details_for_a_call_queue(self, location_id: str, queue_id: str, org_id: str = None) -> GetCallQueueObject1:
        """
        Get Details for a Call Queue

        Retrieve Call Queue details.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Retrieving call queue details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallQueueObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        data = super().get(url, params=params)
        r = GetCallQueueObject1.model_validate(data)
        return r


class BetaFeaturesCallRecordingWithComplianceAnnouncementFeaturePhase3Api(ApiChild, base='telephony/config'):
    """
    Beta Features:  Call Recording with Compliance Announcement Feature Phase 3
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Recording supports reading and writing of Webex Calling Call Recording settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_details_for_the_organization_compliance_announcement_setting(self,
                                                                         org_id: str = None) -> GetOrgComplianceAnnouncementObject:
        """
        Get Details for the organization compliance announcement setting

        Retrieve the organization compliance announcement settings.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Retrieving organization compliance announcement setting requires a full or read-only administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param org_id: Retrieve compliance announcement setting from this organization.
        :type org_id: str
        :rtype: :class:`GetOrgComplianceAnnouncementObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('callRecording/complianceAnnouncement')
        data = super().get(url, params=params)
        r = GetOrgComplianceAnnouncementObject.model_validate(data)
        return r

    def update_the_organization_compliance_announcement(self, inbound_pstncalls_enabled: bool,
                                                        outbound_pstncalls_enabled: bool,
                                                        outbound_pstncalls_delay_enabled: bool, delay_in_seconds: int,
                                                        org_id: str = None):
        """
        Update the organization compliance announcement

        Update the organization compliance announcement.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Updating the organization compliance announcement requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param inbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is played
            to an inbound caller.
        :type inbound_pstncalls_enabled: bool
        :param outbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is
            played to an outbound caller.
        :type outbound_pstncalls_enabled: bool
        :param outbound_pstncalls_delay_enabled: Flag to indicate whether compliance announcement is played after a
            specified delay in seconds.
        :type outbound_pstncalls_delay_enabled: bool
        :param delay_in_seconds: Number of seconds to wait before playing the compliance announcement.
        :type delay_in_seconds: int
        :param org_id: Update the compliance announcement setting from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['inboundPSTNCallsEnabled'] = inbound_pstncalls_enabled
        body['outboundPSTNCallsEnabled'] = outbound_pstncalls_enabled
        body['outboundPSTNCallsDelayEnabled'] = outbound_pstncalls_delay_enabled
        body['delayInSeconds'] = delay_in_seconds
        url = self.ep('callRecording/complianceAnnouncement')
        super().put(url, params=params, json=body)

    def get_details_for_the_location_compliance_announcement_setting(self, location_id: str,
                                                                     org_id: str = None) -> GetComplianceAnnouncementObject:
        """
        Get Details for the location compliance announcement setting

        Retrieve the location compliance announcement settings.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Retrieving location compliance announcement setting requires a full or read-only administrator auth token with
        a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve compliance announcement settings for this location.
        :type location_id: str
        :param org_id: Retrieve compliance announcement setting from this organization.
        :type org_id: str
        :rtype: :class:`GetComplianceAnnouncementObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callRecording/complianceAnnouncement')
        data = super().get(url, params=params)
        r = GetComplianceAnnouncementObject.model_validate(data)
        return r

    def update_the_location_compliance_announcement(self, location_id: str, inbound_pstncalls_enabled: bool,
                                                    use_org_settings_enabled: bool, outbound_pstncalls_enabled: bool,
                                                    outbound_pstncalls_delay_enabled: bool, delay_in_seconds: int,
                                                    org_id: str = None):
        """
        Update the location compliance announcement

        Update the location compliance announcement.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Updating the location compliance announcement requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update the compliance announcement settings for this location.
        :type location_id: str
        :param inbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is played
            to an inbound caller.
        :type inbound_pstncalls_enabled: bool
        :param use_org_settings_enabled: Flag to indicate whether to use the customer level compliance announcement
            default settings.
        :type use_org_settings_enabled: bool
        :param outbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is
            played to an outbound caller.
        :type outbound_pstncalls_enabled: bool
        :param outbound_pstncalls_delay_enabled: Flag to indicate whether compliance announcement is played after a
            specified delay in seconds.
        :type outbound_pstncalls_delay_enabled: bool
        :param delay_in_seconds: Number of seconds to wait before playing the compliance announcement.
        :type delay_in_seconds: int
        :param org_id: Update the compliance announcement setting from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['inboundPSTNCallsEnabled'] = inbound_pstncalls_enabled
        body['useOrgSettingsEnabled'] = use_org_settings_enabled
        body['outboundPSTNCallsEnabled'] = outbound_pstncalls_enabled
        body['outboundPSTNCallsDelayEnabled'] = outbound_pstncalls_delay_enabled
        body['delayInSeconds'] = delay_in_seconds
        url = self.ep(f'locations/{location_id}/callRecording/complianceAnnouncement')
        super().put(url, params=params, json=body)


class BetaFeaturesCallRecordingWithComplianceAnnouncementFeatureApi(ApiChild, base='telephony/config/locations/{locationId}/callRecording/complianceAnnouncement'):
    """
    Beta Features:  Call Recording with Compliance Announcement Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Recording supports reading and writing of Webex Calling Call Recording settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_details_for_the_location_compliance_announcement_setting(self, location_id: str,
                                                                     org_id: str = None) -> bool:
        """
        Get Details for the location compliance announcement setting

        Retrieve the location compliance announcement settings.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Retrieving location compliance announcement setting requires a full or read-only administrator auth token with
        a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve compliance announcement settings for this location.
        :type location_id: str
        :param org_id: Retrieve compliance announcement setting from this organization.
        :type org_id: str
        :rtype: bool
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = data['inboundPSTNCallsEnabled']
        return r

    def update_the_location_compliance_announcement(self, location_id: str, inbound_pstncalls_enabled: bool,
                                                    org_id: str = None):
        """
        Update the location compliance announcement

        Update the location compliance announcement.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Updating the location compliance announcement requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update the compliance announcement settings for this location.
        :type location_id: str
        :param inbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is played
            to an internal caller.
        :type inbound_pstncalls_enabled: bool
        :param org_id: Update the compliance announcement setting from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['inboundPSTNCallsEnabled'] = inbound_pstncalls_enabled
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BetaFeaturesHuntGroupWithConfigureOnpremPhoneNumbersApi(ApiChild, base='telephony/config/locations/{locationId}/huntGroups'):
    """
    Beta Features:  Hunt Group with Configure On-prem Phone Numbers
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Hunt Group supports reading and writing of Webex Calling Hunt Group settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def create_a_hunt_group(self, location_id: str, name: str, phone_number: str, extension: Union[str, datetime],
                            language_code: str, first_name: str, last_name: str, time_zone: str,
                            call_policies: PostHuntGroupCallPolicyObject, use_hosted_agent_enabled: bool,
                            use_policy_server_enabled: bool, agents: list[PostPersonPlaceObject],
                            address_agents: list[AddressAgentHuntGroupObject], enabled: bool,
                            org_id: str = None) -> str:
        """
        Create a Hunt Group

        Create new Hunt Groups for the given location.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Creating a hunt group requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the hunt group for the given location.
        :type location_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group. Either phone number or extension are required.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group. Either phone number or extension are required.
        :type extension: Union[str, datetime]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param use_hosted_agent_enabled: Determines whether hosted or numeric Hunt Group agents are used for this Hunt
            Group
        :type use_hosted_agent_enabled: bool
        :param use_policy_server_enabled: Determines wether to use the Policy Server for this Hunt Group
        :type use_policy_server_enabled: bool
        :param agents: People, workspaces and virtual lines that are eligible to  receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param address_agents: People, workspaces and virtual lines that are eligible to  receive calls, on-prem.
        :type address_agents: list[AddressAgentHuntGroupObject]
        :param enabled: Whether or not the hunt group is enabled.
        :type enabled: bool
        :param org_id: Create the hunt group for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['useHostedAgentEnabled'] = use_hosted_agent_enabled
        body['usePolicyServerEnabled'] = use_policy_server_enabled
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['addressAgents'] = loads(TypeAdapter(list[AddressAgentHuntGroupObject]).dump_json(address_agents))
        body['enabled'] = enabled
        url = self.ep(f'')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_details_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                     org_id: str = None) -> GetHuntGroupObject:
        """
        Get Details for a Hunt Group

        Retrieve Hunt Group details.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Retrieving hunt group details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a hunt group in this location.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for the hunt group with this identifier.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetHuntGroupObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{hunt_group_id}')
        data = super().get(url, params=params)
        r = GetHuntGroupObject.model_validate(data)
        return r

    def update_a_hunt_group(self, location_id: str, hunt_group_id: str, name: str, phone_number: str,
                            extension: Union[str, datetime], distinctive_ring: bool,
                            alternate_numbers: list[AlternateNumbersWithPattern], language_code: str, first_name: str,
                            last_name: str, time_zone: str, call_policies: PostHuntGroupCallPolicyObject,
                            use_policy_server_enabled: bool, agents: list[PostPersonPlaceObject],
                            address_agents: list[AddressAgentHuntGroupObject], enabled: bool, org_id: str = None):
        """
        Update a Hunt Group

        Update the designated Hunt Group.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Updating a hunt group requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update the hunt group for this location.
        :type location_id: str
        :param hunt_group_id: Update settings for the hunt group with the matching ID.
        :type hunt_group_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group.
        :type extension: Union[str, datetime]
        :param distinctive_ring: Whether or not the hunt group has the distinctive ring option enabled.
        :type distinctive_ring: bool
        :param alternate_numbers: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a hunt group. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the hunt group.
        :type alternate_numbers: list[AlternateNumbersWithPattern]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param use_policy_server_enabled: Determines wether to use the Policy Server for this Hunt Group
        :type use_policy_server_enabled: bool
        :param agents: People, workspaces and virtual lines that are eligible to  receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param address_agents: People, workspaces and virtual lines that are eligible to  receive calls, on-prem.
        :type address_agents: list[AddressAgentHuntGroupObject]
        :param enabled: Whether or not the hunt group is enabled.
        :type enabled: bool
        :param org_id: Update hunt group settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['distinctiveRing'] = distinctive_ring
        body['alternateNumbers'] = loads(TypeAdapter(list[AlternateNumbersWithPattern]).dump_json(alternate_numbers))
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['usePolicyServerEnabled'] = use_policy_server_enabled
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['addressAgents'] = loads(TypeAdapter(list[AddressAgentHuntGroupObject]).dump_json(address_agents))
        body['enabled'] = enabled
        url = self.ep(f'{hunt_group_id}')
        super().put(url, params=params, json=body)


class BetaFeaturesHuntGroupWithDepartmentFeaturesApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Hunt Group with Department Features
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Hunt Group supports reading and writing of Webex Calling Hunt Group settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_hunt_groups(self, org_id: str = None, location_id: str = None, start: int = None,
                                     name: str = None, phone_number: str = None, department_id: str = None,
                                     department_name: str = None,
                                     **params) -> Generator[ListCallQueueObject, None, None]:
        """
        Read the List of Hunt Groups

        List all calling Hunt Groups for the organization.

        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List hunt groups for this organization.
        :type org_id: str
        :param location_id: Only return hunt groups with matching location ID.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return hunt groups with the matching name.
        :type name: str
        :param phone_number: Only return hunt groups with the matching primary phone number or extension.
        :type phone_number: str
        :param department_id: Return only hunt groups with the matching departmentId.
        :type department_id: str
        :param department_name: Return only hunt groups with the matching departmentName.
        :type department_name: str
        :return: Generator yielding :class:`ListCallQueueObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if department_id is not None:
            params['departmentId'] = department_id
        if department_name is not None:
            params['departmentName'] = department_name
        url = self.ep('huntGroups')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject, item_key='huntGroups', params=params)

    def get_details_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                     org_id: str = None) -> GetHuntGroupObject1:
        """
        Get Details for a Hunt Group

        Retrieve Hunt Group details.

        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.

        Retrieving hunt group details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a hunt group in this location.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for the hunt group with this identifier.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetHuntGroupObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        data = super().get(url, params=params)
        r = GetHuntGroupObject1.model_validate(data)
        return r

    def update_a_hunt_group(self, location_id: str, hunt_group_id: str, name: str, phone_number: str,
                            extension: Union[str, datetime], distinctive_ring: bool,
                            alternate_numbers: list[AlternateNumbersWithPattern], language_code: str, first_name: str,
                            last_name: str, time_zone: str, call_policies: PostHuntGroupCallPolicyObject,
                            agents: list[PostPersonPlaceObject], enabled: bool, department: DepartmentResponseWithId,
                            org_id: str = None):
        """
        Update a Hunt Group

        Update the designated Hunt Group.

        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.

        Updating a hunt group requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update the hunt group for this location.
        :type location_id: str
        :param hunt_group_id: Update setting for the hunt group with the matching ID.
        :type hunt_group_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group.
        :type extension: Union[str, datetime]
        :param distinctive_ring: Whether or not the hunt group has the distinctive ring option enabled.
        :type distinctive_ring: bool
        :param alternate_numbers: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a hunt group. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the hunt group.
        :type alternate_numbers: list[AlternateNumbersWithPattern]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to ".".
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param agents: People, including workspaces, that are eligible to  receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param enabled: Whether or not the hunt group is enabled.
        :type enabled: bool
        :param department: Department the huntgroup is assigned to.
        :type department: DepartmentResponseWithId
        :param org_id: Update hunt group settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['distinctiveRing'] = distinctive_ring
        body['alternateNumbers'] = loads(TypeAdapter(list[AlternateNumbersWithPattern]).dump_json(alternate_numbers))
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['enabled'] = enabled
        body['department'] = loads(department.model_dump_json())
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        super().put(url, params=params, json=body)


class BetaFeaturesHuntGroupWithESNFeatureApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Hunt Group with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Hunt Group supports reading and writing of Webex Calling Hunt Group settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_hunt_groups(self, org_id: str = None, location_id: str = None, start: int = None,
                                     name: str = None, phone_number: str = None,
                                     **params) -> Generator[ListCallQueueObject1, None, None]:
        """
        Read the List of Hunt Groups

        List all calling Hunt Groups for the organization.

        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List hunt groups for this organization.
        :type org_id: str
        :param location_id: Only return hunt groups with matching location ID.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return hunt groups with the matching name.
        :type name: str
        :param phone_number: Only return hunt groups with the matching primary phone number or extension.
        :type phone_number: str
        :return: Generator yielding :class:`ListCallQueueObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('huntGroups')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject1, item_key='huntGroups', params=params)

    def get_details_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                     org_id: str = None) -> GetHuntGroupObject2:
        """
        Get Details for a Hunt Group

        Retrieve Hunt Group details.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Retrieving hunt group details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a hunt group in this location.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for the hunt group with this identifier.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetHuntGroupObject2`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        data = super().get(url, params=params)
        r = GetHuntGroupObject2.model_validate(data)
        return r


class BetaFeaturesHuntGroupWithSelectCallerIDFeatureApi(ApiChild, base='telephony/config/locations/{locationId}/huntGroups'):
    """
    Beta Features:  Hunt Group with Select Caller ID Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Hunt Group supports reading and writing of Webex Calling Hunt Group settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def create_a_hunt_group(self, location_id: str, name: str, phone_number: str, extension: Union[str, datetime],
                            language_code: str, first_name: str, last_name: str, time_zone: str,
                            call_policies: PostHuntGroupCallPolicyObject, agents: list[PostPersonPlaceObject],
                            enabled: bool, hunt_group_caller_id_for_outgoing_calls_enabled: bool,
                            org_id: str = None) -> str:
        """
        Create a Hunt Group

        Create new Hunt Groups for the given location.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Creating a hunt group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the hunt group for the given location.
        :type location_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group. Either phone number or extension are required.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group. Either phone number or extension are required.
        :type extension: Union[str, datetime]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param agents: People, workspaces and virtual lines that are eligible to  receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param enabled: Whether or not the hunt group is enabled.
        :type enabled: bool
        :param hunt_group_caller_id_for_outgoing_calls_enabled: Enable the hunt group to be used as the caller ID when
            the agent places outgoing calls. When set to true the hunt group's caller ID will be used.
        :type hunt_group_caller_id_for_outgoing_calls_enabled: bool
        :param org_id: Create the hunt group for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['enabled'] = enabled
        body['huntGroupCallerIdForOutgoingCallsEnabled'] = hunt_group_caller_id_for_outgoing_calls_enabled
        url = self.ep(f'')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_details_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                     org_id: str = None) -> GetHuntGroupObject3:
        """
        Get Details for a Hunt Group

        Retrieve Hunt Group details.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Retrieving hunt group details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a hunt group in this location.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for the hunt group with this identifier.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetHuntGroupObject3`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{hunt_group_id}')
        data = super().get(url, params=params)
        r = GetHuntGroupObject3.model_validate(data)
        return r

    def update_a_hunt_group(self, location_id: str, hunt_group_id: str, name: str, phone_number: str,
                            extension: Union[str, datetime], distinctive_ring: bool,
                            alternate_numbers: list[AlternateNumbersWithPattern], language_code: str, first_name: str,
                            last_name: str, time_zone: str, call_policies: PostHuntGroupCallPolicyObject,
                            agents: list[PostPersonPlaceObject], enabled: bool,
                            hunt_group_caller_id_for_outgoing_calls_enabled: bool, org_id: str = None):
        """
        Update a Hunt Group

        Update the designated Hunt Group.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Updating a hunt group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update the hunt group for this location.
        :type location_id: str
        :param hunt_group_id: Update settings for the hunt group with the matching ID.
        :type hunt_group_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group.
        :type extension: Union[str, datetime]
        :param distinctive_ring: Whether or not the hunt group has the distinctive ring option enabled.
        :type distinctive_ring: bool
        :param alternate_numbers: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a hunt group. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the hunt group.
        :type alternate_numbers: list[AlternateNumbersWithPattern]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param agents: People, workspaces and virtual lines that are eligible to  receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param enabled: Whether or not the hunt group is enabled.
        :type enabled: bool
        :param hunt_group_caller_id_for_outgoing_calls_enabled: Enable the hunt group to be used as the caller ID when
            the agent places outgoing calls. When set to true the hunt group's caller ID will be used.
        :type hunt_group_caller_id_for_outgoing_calls_enabled: bool
        :param org_id: Update hunt group settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['distinctiveRing'] = distinctive_ring
        body['alternateNumbers'] = loads(TypeAdapter(list[AlternateNumbersWithPattern]).dump_json(alternate_numbers))
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['enabled'] = enabled
        body['huntGroupCallerIdForOutgoingCallsEnabled'] = hunt_group_caller_id_for_outgoing_calls_enabled
        url = self.ep(f'{hunt_group_id}')
        super().put(url, params=params, json=body)


class BetaFeaturesPagingGroupWithDepartmentFeaturesApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Paging Group with Department Features
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Paging Group supports reading and writing of Webex Calling Paging Group settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_paging_groups(self, org_id: str = None, start: int = None, location_id: str = None,
                                       name: str = None, phone_number: str = None, department_id: str = None,
                                       department_name: str = None,
                                       **params) -> Generator[ListPagingGroupObject, None, None]:
        """
        Read the List of Paging Groups

        List all Paging Groups for the organization.

        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List paging groups for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects. Default is 0
        :type start: int
        :param location_id: Return only paging groups with matching location ID. Default is all locations
        :type location_id: str
        :param name: Return only paging groups with the matching name.
        :type name: str
        :param phone_number: Return only paging groups with matching primary phone number or extension.
        :type phone_number: str
        :param department_id: Return only paging groups with the matching departmentId.
        :type department_id: str
        :param department_name: Return only paging groups with the matching departmentName.
        :type department_name: str
        :return: Generator yielding :class:`ListPagingGroupObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if location_id is not None:
            params['locationId'] = location_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if department_id is not None:
            params['departmentId'] = department_id
        if department_name is not None:
            params['departmentName'] = department_name
        url = self.ep('paging')
        return self.session.follow_pagination(url=url, model=ListPagingGroupObject, item_key='locationPaging', params=params)

    def get_details_for_a_paging_group(self, location_id: str, paging_id: str,
                                       org_id: str = None) -> GetPagingGroupObject:
        """
        Get Details for a Paging Group

        Retrieve Paging Group details.

        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Retrieving paging group details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a paging group in this location.
        :type location_id: str
        :param paging_id: Retrieve settings for the paging group with this identifier.
        :type paging_id: str
        :param org_id: Retrieve paging group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetPagingGroupObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        data = super().get(url, params=params)
        r = GetPagingGroupObject.model_validate(data)
        return r

    def update_a_paging_group(self, location_id: str, paging_id: str, enabled: bool, name: str, phone_number: str,
                              extension: Union[str, datetime], language_code: str, first_name: str, last_name: str,
                              originator_caller_id_enabled: bool, originators: list[str], targets: list[str],
                              department: DepartmentResponseWithId, org_id: str = None):
        """
        Update a Paging Group

        Update the designated Paging Group.

        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Updating a paging group requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update settings for a paging group in this location.
        :type location_id: str
        :param paging_id: Update settings for the paging group with this identifier.
        :type paging_id: str
        :param enabled: Whether or not the paging group is enabled.
        :type enabled: bool
        :param name: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
        :type name: str
        :param phone_number: Paging group phone number. Minimum length is 1. Maximum length is 23. Either phoneNumber
            or extension is mandatory.
        :type phone_number: str
        :param extension: Paging group extension. Minimum length is 2. Maximum length is 6. Either phoneNumber or
            extension is mandatory.
        :type extension: Union[str, datetime]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this paging group. Defaults to ".".
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this paging group. Defaults to the
            phone number if set, otherwise defaults to call group name.
        :type last_name: str
        :param originator_caller_id_enabled: Determines what is shown on target users caller ID when a group page is
            performed. If true shows page originator ID.
        :type originator_caller_id_enabled: bool
        :param originators: An array of people and/or workspaces, who may originate pages to this paging group.
        :type originators: list[str]
        :param targets: People, including workspaces, that are added to paging group as paging call targets.
        :type targets: list[str]
        :param department: Specifies the department information.
        :type department: DepartmentResponseWithId
        :param org_id: Update paging group settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['originatorCallerIdEnabled'] = originator_caller_id_enabled
        body['originators'] = originators
        body['targets'] = targets
        body['department'] = loads(department.model_dump_json())
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        super().put(url, params=params, json=body)


class BetaFeaturesPagingGroupWithESNFeatureApi(ApiChild, base='telephony/config'):
    """
    Beta Features:  Paging Group with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Paging Group supports reading and writing of Webex Calling Paging Group settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_paging_groups(self, org_id: str = None, start: int = None, location_id: str = None,
                                       name: str = None, phone_number: str = None,
                                       **params) -> Generator[ListPagingGroupObject1, None, None]:
        """
        Read the List of Paging Groups

        List all Paging Groups for the organization.

        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List paging groups for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects. Default is 0
        :type start: int
        :param location_id: Return only paging groups with matching location ID. Default is all locations
        :type location_id: str
        :param name: Return only paging groups with the matching name.
        :type name: str
        :param phone_number: Return only paging groups with matching primary phone number or extension.
        :type phone_number: str
        :return: Generator yielding :class:`ListPagingGroupObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if location_id is not None:
            params['locationId'] = location_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('paging')
        return self.session.follow_pagination(url=url, model=ListPagingGroupObject1, item_key='locationPaging', params=params)

    def get_details_for_a_paging_group(self, location_id: str, paging_id: str,
                                       org_id: str = None) -> GetPagingGroupObject1:
        """
        Get Details for a Paging Group

        Retrieve Paging Group details.

        Group Paging allows a person, place or virtual line a one-way call or group page to up to 75 people and/or
        workspaces and/or virtual line by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Retrieving paging group details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a paging group in this location.
        :type location_id: str
        :param paging_id: Retrieve settings for the paging group with this identifier.
        :type paging_id: str
        :param org_id: Retrieve paging group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetPagingGroupObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        data = super().get(url, params=params)
        r = GetPagingGroupObject1.model_validate(data)
        return r


class FeaturesReceptionistClientApi(ApiChild, base='telephony/config/locations/{locationId}/receptionistContacts/directories'):
    """
    Features:  Receptionist Client
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Receptionist Client supports reading and writing of Webex Calling Receptionist Client settings for a
    specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def create_a_receptionist_contact_directory(self, location_id: str, name: str, contacts: list[PersonId],
                                                org_id: str = None) -> str:
        """
        Create a Receptionist Contact Directory

        Creates a new Receptionist Contact Directory for a location.

        Receptionist Contact Directories can be used to create named directories of users and/or location features
        (Auto Attendant, Call Queue, Hunt Group, Single Number Reach, and Paging Group).

        Adding a directory requires a full or write-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Add a Receptionist Contact Directory to this location.
        :type location_id: str
        :param name: Receptionist Contact Directory name.
        :type name: str
        :param contacts: Array of users assigned to this Receptionist Contact Directory.
        :type contacts: list[PersonId]
        :param org_id: Add a Receptionist Contact Directory to this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['contacts'] = loads(TypeAdapter(list[PersonId]).dump_json(contacts))
        url = self.ep(f'')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def read_list_of_receptionist_contact_directories(self, location_id: str, org_id: str = None) -> list[Location]:
        """
        Read list of Receptionist Contact Directories

        List all Receptionist Contact Directories for a location.

        Receptionist Contact Directories can be used to create named directories of users.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: List Receptionist Contact Directories for this location.
        :type location_id: str
        :param org_id: List Receptionist Contact Directories for this organization.
        :type org_id: str
        :rtype: list[Location]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = TypeAdapter(list[Location]).validate_python(data['directories'])
        return r

    def get_details_for_a_receptionist_contact_directory(self, location_id: str, directory_id: str, org_id: str = None,
                                                         search_criteria_mode_or: bool = None, first_name: str = None,
                                                         last_name: str = None, phone_number: str = None,
                                                         extension: Union[str, datetime] = None,
                                                         person_id: str = None) -> list[ContactDetails]:
        """
        Get details for a Receptionist Contact Directory

        Get details for a specific Receptionist Contact Directory from a location.

        Receptionist Contact Directories are uniquely named per location and contain directories of Persons, Auto
        Attendants, Call Queues, Hunt Groups, Single Number Reaches, and Paging Groups.

        This API is currently supported for Webex calling organizations with fewer than 2000 users or location-based
        calling features. For organizations with more than 2000 users or location features, the API will throw and
        error 25395.

        Retrieving details requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Get a Receptionist Contact Directory from this location.
        :type location_id: str
        :param directory_id: Get details for the Receptionist Contact Directory with this identifier.
        :type directory_id: str
        :param org_id: Get a Receptionist Contact Directory from this organization.
        :type org_id: str
        :param search_criteria_mode_or: When `true`, results matching any one of the search criteria are included. The
            value can only be `true` or not included in the request. Specifying `searchCriteriaModeOr` without any
            search criteria, or setting it to `false` results in an `ErrorResponse`. If no search criteria is
            specified, all results are returned.
        :type search_criteria_mode_or: bool
        :param first_name: Search for directories that contain people with the indicated first name.
        :type first_name: str
        :param last_name: Search for directories that contain people with the indicated last name.
        :type last_name: str
        :param phone_number: Search for directories that contain people with the indicated phone number.
        :type phone_number: str
        :param extension: Search for directories that contain people with the indicated extension.
        :type extension: Union[str, datetime]
        :param person_id: Search for directories that contain people with the indicated person ID.
        :type person_id: str
        :rtype: list[ContactDetails]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if search_criteria_mode_or is not None:
            params['searchCriteriaModeOr'] = str(search_criteria_mode_or).lower()
        if first_name is not None:
            params['firstName'] = first_name
        if last_name is not None:
            params['lastName'] = last_name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if extension is not None:
            if isinstance(extension, str):
                extension = isoparse(extension)
            extension = dt_iso_str(extension)
            params['extension'] = extension
        if person_id is not None:
            params['personId'] = person_id
        url = self.ep(f'{directory_id}')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ContactDetails]).validate_python(data['contacts'])
        return r

    def delete_a_receptionist_contact_directory(self, location_id: str, directory_id: str, org_id: str = None):
        """
        Delete a Receptionist Contact Directory

        Delete a Receptionist Contact Directory from a location.

        Receptionist Contact Directories can be used to create named directories of users.

        Deleting a directory requires a full or write-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Delete a Receptionist Contact Directory from this location.
        :type location_id: str
        :param directory_id: Add a Receptionist Contact Directory ID.
        :type directory_id: str
        :param org_id: Delete a Receptionist Contact Directory from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{directory_id}')
        super().delete(url, params=params)

    def modify_a_receptionist_contact_directory(self, location_id: str, directory_id: str, name: str,
                                                contacts: list[str], org_id: str = None) -> str:
        """
        Modify a Receptionist Contact Directory

        Modify Receptionist Contact Directories attached to a location. This modification will replace the existing
        list of contacts with the new incoming contacts list from the request body. The API does not support
        incremental updates.

        Receptionist Contact Directories can be used to create named groups of Persons, Auto Attendants, Call Queues,
        Hunt Groups, Single Number Reaches, and Paging Groups.

        Modifying a directory requires a full or write-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Modify list of Receptionist Contact Directories for this location.
        :type location_id: str
        :param directory_id: Get details for the Receptionist Contact Directory with this identifier.
        :type directory_id: str
        :param name: Receptionist Contact Directory name.
        :type name: str
        :param contacts: Array of users or location features assigned to this Receptionist Contact Directory.
        :type contacts: list[str]
        :param org_id: Modify list of Receptionist Contact Directories for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['contacts'] = contacts
        url = self.ep(f'{directory_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r


class BetaFeatureCallPickupsWithCallPickupNotificationApi(ApiChild, base='telephony/config/locations/{locationId}/callPickups'):
    """
    Beta Feature: Call Pickups with Call Pickup Notification
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Users who are added to a call pickup can answer calls when another member of the call pickup is busy.
    Features: Call Pickup supports reading and writing of Webex Calling Call Pickup settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def create_a_call_pickup(self, location_id: str, name: str, notification_type: GetCallPickupObjectNotificationType,
                             notification_delay_timer_seconds: int, agents: list[str], org_id: str = None) -> str:
        """
        Create a Call Pickup

        Create new Call Pickups for the given location.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Creating a call pickup requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Create the call pickup for this location.
        :type location_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param notification_type: Type of the notification when an incoming call is unanswered, the call pickup group
            notifies all of its members. Default: NONE.
        :type notification_type: GetCallPickupObjectNotificationType
        :param notification_delay_timer_seconds: After the number of seconds given by the notificationDelayTimerSeconds
            has elapsed, notify every member of the call pickup group when an incoming call goes unanswered. The
            notificationType field specifies the notification method.Default: 6.
        :type notification_delay_timer_seconds: int
        :param agents: An Array of ID strings of people, workspaces and virtual lines that are added to call pickup.
        :type agents: list[str]
        :param org_id: Create the call pickup for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['notificationType'] = enum_str(notification_type)
        body['notificationDelayTimerSeconds'] = notification_delay_timer_seconds
        body['agents'] = agents
        url = self.ep(f'')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_details_for_a_call_pickup(self, location_id: str, call_pickup_id: str,
                                      org_id: str = None) -> GetCallPickupObject1:
        """
        Get Details for a Call Pickup

        Retrieve the designated Call Pickup details.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Retrieving call pickup details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Retrieve settings for a call pickup in this location.
        :type location_id: str
        :param call_pickup_id: Retrieve settings for a call pickup with the matching ID.
        :type call_pickup_id: str
        :param org_id: Retrieve call pickup settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallPickupObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{call_pickup_id}')
        data = super().get(url, params=params)
        r = GetCallPickupObject1.model_validate(data)
        return r

    def update_a_call_pickup(self, location_id: str, call_pickup_id: str, name: str,
                             notification_type: GetCallPickupObjectNotificationType,
                             notification_delay_timer_seconds: int, agents: list[str], org_id: str = None) -> str:
        """
        Update a Call Pickup

        Update the designated Call Pickup.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Updating a call pickup requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Location in which this call pickup exists.
        :type location_id: str
        :param call_pickup_id: Update settings for a call pickup with the matching ID.
        :type call_pickup_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param notification_type: Type of the notification when an incoming call is unanswered, the call pickup group
            notifies all of its members. Default: NONE.
        :type notification_type: GetCallPickupObjectNotificationType
        :param notification_delay_timer_seconds: After the number of seconds given by the notificationDelayTimerSeconds
            has elapsed, notify every member of the call pickup group when an incoming call goes unanswered. The
            notificationType field specifies the notification method.Default: 6.
        :type notification_delay_timer_seconds: int
        :param agents: An array of people, workspace, and virtual lines IDs, that are added to call pickup.
        :type agents: list[str]
        :param org_id: Update call pickup settings from this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['notificationType'] = enum_str(notification_type)
        body['notificationDelayTimerSeconds'] = notification_delay_timer_seconds
        body['agents'] = agents
        url = self.ep(f'{call_pickup_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r


class BetaLocationCallSettingsVoicemailWithESNFeatureApi(ApiChild, base='telephony/config'):
    """
    Beta Location Call Settings:  Voicemail with ESN Feature
    
    Location Call Settings: Voicemail supports reading and writing of Webex
    Calling Location Voicemail settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def list_voicemail_group(self, location_id: str = None, org_id: str = None, start: int = None, name: str = None,
                             phone_number: str = None, **params) -> Generator[GetVoicemailGroupObject, None, None]:
        """
        List VoicemailGroup

        List the voicemail group information for the organization.

        You can create a shared voicemail box and inbound FAX box to
        assign to users or call routing features like an auto attendant, call queue, or hunt group.

        Retrieving a voicemail group for the organization requires a full read-only administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param location_id: Location to which the voicemail group belongs.
        :type location_id: str
        :param org_id: Organization to which the voicemail group belongs.
        :type org_id: str
        :param start: Offset from the first result that you want to fetch.
        :type start: int
        :param name: Search (Contains) based on voicemail group name
        :type name: str
        :param phone_number: Search (Contains) based on number or extension
        :type phone_number: str
        :return: Generator yielding :class:`GetVoicemailGroupObject` instances
        """
        if location_id is not None:
            params['locationId'] = location_id
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('voicemailGroups')
        return self.session.follow_pagination(url=url, model=GetVoicemailGroupObject, item_key='voicemailGroups', params=params)

    def get_location_voicemail_group(self, location_id: str, voicemail_group_id: str,
                                     org_id: str = None) -> GetLocationVoicemailGroupObject:
        """
        Get Location Voicemail Group

        Retrieve voicemail group details for a location.

        Manage your voicemail group settings for a specific location, like when you want your voicemail to be active,
        message storage settings, and how you would like to be notified of new voicemail messages.

        Retrieving voicemail group details requires a full, user or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Retrieve voicemail group details for this location.
        :type location_id: str
        :param voicemail_group_id: Retrieve voicemail group details for this voicemail group ID.
        :type voicemail_group_id: str
        :param org_id: Retrieve voicemail group details for a customer location.
        :type org_id: str
        :rtype: :class:`GetLocationVoicemailGroupObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicemailGroups/{voicemail_group_id}')
        data = super().get(url, params=params)
        r = GetLocationVoicemailGroupObject.model_validate(data)
        return r


class BetaLocationCallSettingsWithRoutingPrefixUpdateApi(ApiChild, base='telephony/config'):
    """
    Beta Location Call Settings with Routing Prefix Update
    
    Location Call Settings supports reading and writing of Webex Calling Location settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def list_locations_webex_calling_details(self, org_id: str = None, start: int = None, name: str = None,
                                             order: str = None,
                                             **params) -> Generator[ListLocationObject, None, None]:
        """
        List Locations Webex Calling Details

        Lists Webex Calling locations for an organization with Webex Calling details.

        Searching and viewing locations with Webex Calling details in your organization require an administrator auth
        token with the `spark-admin:telephony_config_read` scope.

        :param org_id: List locations for this organization.
        :type org_id: str
        :param start: Specify the offset from the first result that you want to fetch.
        :type start: int
        :param name: List locations whose name contains this string.
        :type name: str
        :param order: Sort the list of locations based on `name`, either asc or desc.
        :type order: str
        :return: Generator yielding :class:`ListLocationObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if order is not None:
            params['order'] = order
        url = self.ep('locations')
        return self.session.follow_pagination(url=url, model=ListLocationObject, item_key='locations', params=params)

    def enable_a_location_for_webex_calling(self, id: str, name: str, time_zone: str, preferred_language: str,
                                            announcement_language: str, address: PostLocationCallingRequestAddress,
                                            org_id: str = None) -> str:
        """
        Enable a Location for Webex Calling

        Enable a location by adding it to Webex Calling. This add Webex Calling support to a location created using the
        POST /v1/locations API.

        Locations are used to support calling features which can be defined at the location level.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param id: A unique identifier for the location.
        :type id: str
        :param name: The name of the location.
        :type name: str
        :param time_zone: Time zone associated with this location.
        :type time_zone: str
        :param preferred_language: Default email language.
        :type preferred_language: str
        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param address: The address of the location.
        :type address: PostLocationCallingRequestAddress
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['id'] = id
        body['name'] = name
        body['timeZone'] = time_zone
        body['preferredLanguage'] = preferred_language
        body['announcementLanguage'] = announcement_language
        body['address'] = loads(address.model_dump_json())
        url = self.ep('locations')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_location_webex_calling_details(self, location_id: str, org_id: str = None) -> GetTelephonyLocationObject:
        """
        Get Location Webex Calling Details

        Shows Webex Calling details for a location, by ID.

        Specifies the location ID in the `locationId` parameter in the URI.

        Searching and viewing locations in your organization requires an administrator auth token with the
        `spark-admin:telephony_config_read` scope.

        :param location_id: Retrieve Webex Calling location attributes for this location.
        :type location_id: str
        :param org_id: Retrieve Webex Calling location attributes for this organization.
        :type org_id: str
        :rtype: :class:`GetTelephonyLocationObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}')
        data = super().get(url, params=params)
        r = GetTelephonyLocationObject.model_validate(data)
        return r

    def update_location_webex_calling_details(self, location_id: str, announcement_language: str,
                                              calling_line_id: GetTelephonyLocationObjectCallingLineId,
                                              connection: GetTelephonyLocationObjectConnection,
                                              external_caller_id_name: str, p_access_network_info: str,
                                              outside_dial_digit: Union[str, datetime], routing_prefix: int,
                                              charge_number: str, org_id: str = None) -> AttachmentAction:
        """
        Update Location Webex Calling Details

        Update Webex Calling details for a location, by ID.

        Specifies the location ID in the `locationId` parameter in the URI.

        Modifying the `connection` via API is only supported for the local PSTN types of `TRUNK` and `ROUTE_GROUP`.

        Updating a location in your organization requires an administrator auth token with the
        `spark-admin:telephony_config_write` scope.

        :param location_id: Updating Webex Calling location attributes for this location.
        :type location_id: str
        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param calling_line_id: Location calling line information.
        :type calling_line_id: GetTelephonyLocationObjectCallingLineId
        :param connection: Connection details can only be modified to and from local PSTN types of `TRUNK` and
            `ROUTE_GROUP`.
        :type connection: GetTelephonyLocationObjectConnection
        :param external_caller_id_name: Denve' (string) - External Caller ID Name value. Unicode characters.
        :type external_caller_id_name: str
        :param p_access_network_info: Location Identifier.
        :type p_access_network_info: str
        :param outside_dial_digit: Must dial to reach an outside line. Default is None.
        :type outside_dial_digit: Union[str, datetime]
        :param routing_prefix: Must dial a prefix when calling between locations having same extension within same
            location; should be numeric.
        :type routing_prefix: int
        :param charge_number: Chargeable number for the line placing the call. When this is set, all calls placed from
            this location will include a P-Charge-Info header with the selected number in the SIP INVITE.
        :type charge_number: str
        :param org_id: Updating Webex Calling location attributes for this organization.
        :type org_id: str
        :rtype: :class:`AttachmentAction`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['announcementLanguage'] = announcement_language
        body['callingLineId'] = loads(calling_line_id.model_dump_json())
        body['connection'] = loads(connection.model_dump_json())
        body['externalCallerIdName'] = external_caller_id_name
        body['pAccessNetworkInfo'] = p_access_network_info
        body['outsideDialDigit'] = outside_dial_digit
        body['routingPrefix'] = routing_prefix
        body['chargeNumber'] = charge_number
        url = self.ep(f'locations/{location_id}')
        data = super().put(url, params=params, json=body)
        r = AttachmentAction.model_validate(data)
        return r

    def change_announcement_language(self, location_id: str, agent_enabled: bool, service_enabled: bool,
                                     announcement_language_code: str, org_id: str = None):
        """
        Change Announcement Language

        Change announcement language for the given location.

        Change announcement language for current people/workspaces and/or existing feature configurations. This does
        not change the default announcement language which is applied to new users/workspaces and new feature
        configurations.

        Changing the announcement language for the given location requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Change announcement language for this location.
        :type location_id: str
        :param agent_enabled: Set to `true` to change announcement language for existing people and workspaces.
        :type agent_enabled: bool
        :param service_enabled: Set to `true` to change announcement language for existing feature configurations.
        :type service_enabled: bool
        :param announcement_language_code: Language code.
        :type announcement_language_code: str
        :param org_id: Change announcement language for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['agentEnabled'] = agent_enabled
        body['serviceEnabled'] = service_enabled
        body['announcementLanguageCode'] = announcement_language_code
        url = self.ep(f'locations/{location_id}/actions/modifyAnnouncementLanguage/invoke')
        super().post(url, params=params, json=body)

    def read_the_list_of_dial_patterns(self, dial_plan_id: str, org_id: str = None, dial_pattern: str = None,
                                       start: int = None, order: str = None, **params) -> Generator[str, None, None]:
        """
        Read the List of Dial Patterns

        List all Dial Patterns for the organization.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param dial_plan_id: ID of the dial plan.
        :type dial_plan_id: str
        :param org_id: ID of the organization to which the dial patterns belong.
        :type org_id: str
        :param dial_pattern: An enterprise dial pattern is represented by a sequence of digits (1-9), followed by
            optional wildcard characters.
        Valid wildcard characters are `!` (matches any sequence of digits) and `X` (matches a single digit, 0-9).
        The `!` wildcard can only occur once at the end and only in an E.164 pattern
        :type dial_pattern: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the dial patterns according to the designated fields.  Available sort fields:
            `dialPattern`.
        :type order: str
        :return: Array of dial patterns. An enterprise dial pattern is represented by a sequence of digits (1-9),
            followed by optional wildcard characters.
        """
        if org_id is not None:
            params['orgId'] = org_id
        if dial_pattern is not None:
            params['dialPattern'] = dial_pattern
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}/dialPatterns')
        return self.session.follow_pagination(url=url, model=None, item_key='dialPatterns', params=params)

    def get_a_location_emergency_callback_number(self, location_id: str,
                                                 location_info: GetLocationCallBackNumberObjectLocationInfo,
                                                 location_member_info: GetLocationCallBackNumberObjectLocationMemberInfo,
                                                 selected: CallBackSelected, org_id: str = None):
        """
        Get a Location Emergency callback number

        Get location emergency callback number.

        * To retrieve location callback number requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Update location attributes for this location.
        :type location_id: str
        :param location_info: Data relevant to this location.
        :type location_info: GetLocationCallBackNumberObjectLocationInfo
        :param location_member_info: Data relevant to the user/place (member) selected for ECBN.
        :type location_member_info: GetLocationCallBackNumberObjectLocationMemberInfo
        :param selected: Selected number type to configure emergency call back.
        :type selected: CallBackSelected
        :param org_id: Update location attributes for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['locationInfo'] = loads(location_info.model_dump_json())
        body['locationMemberInfo'] = loads(location_member_info.model_dump_json())
        body['selected'] = enum_str(selected)
        url = self.ep(f'locations/{location_id}/features/emergencyCallbackNumber')
        super().get(url, params=params, json=body)

    def update_a_location_emergency_callback_number(self, location_id: str, selected: CallBackSelected,
                                                    location_member_id: str, org_id: str = None):
        """
        Update a Location Emergency callback number

        Update details for a location emergency callback number.

        * Updating a location callback number requires a full administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_write`.

        :param location_id: Update location attributes for this location.
        :type location_id: str
        :param selected: Selected number type to configure emergency call back.
        :type selected: CallBackSelected
        :param location_member_id: Member ID of user/place within the location. Required if `LOCATION_MEMBER_NUMBER` is
            selected.
        :type location_member_id: str
        :param org_id: Update location attributes for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['selected'] = enum_str(selected)
        body['locationMemberId'] = location_member_id
        url = self.ep(f'locations/{location_id}/features/emergencyCallbackNumber')
        super().put(url, params=params, json=body)

    def validate_the_list_of_extensions(self, extensions: list[str],
                                        org_id: str = None) -> PostValidateExtensionResponse:
        """
        Validate the List of Extensions

        Validate the List of Extensions.
        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param extensions: String array of extensions.
        :type extensions: list[str]
        :param org_id: Validate extensions for this organization.
        :type org_id: str
        :rtype: :class:`PostValidateExtensionResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['extensions'] = extensions
        url = self.ep('actions/validateExtensions/invoke')
        data = super().post(url, params=params, json=body)
        r = PostValidateExtensionResponse.model_validate(data)
        return r

    def validate_extensions(self, location_id: str, extensions: list[str],
                            org_id: str = None) -> StatusOfExtensionsObject:
        """
        Validate Extensions

        Validate extensions for a specific location.

        Validating extensions requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Validate extensions for this location.
        :type location_id: str
        :param extensions: Array of extensions that will be validated.
        :type extensions: list[str]
        :param org_id: Validate extensions for this organization.
        :type org_id: str
        :rtype: :class:`StatusOfExtensionsObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['extensions'] = extensions
        url = self.ep(f'locations/{location_id}/actions/validateExtensions/invoke')
        data = super().post(url, params=params, json=body)
        r = StatusOfExtensionsObject.model_validate(data)
        return r

    def update_music_on_hold(self, location_id: str, call_hold_enabled: bool, call_park_enabled: bool,
                             greeting: GetMusicOnHoldObjectGreeting, audio_file: AudioAnnouncementFileGetObject,
                             org_id: str = None):
        """
        Update Music On Hold

        Update the location's music on hold settings.

        Location music on hold settings allows you to play music when a call is placed on hold or parked.

        Updating a location's music on hold settings requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Update music on hold settings for this location.
        :type location_id: str
        :param call_hold_enabled: If enabled, music will be played when call is placed on hold.
        :type call_hold_enabled: bool
        :param call_park_enabled: If enabled, music will be played when call is parked.
        :type call_park_enabled: bool
        :param greeting: Greeting type for the location.
        :type greeting: GetMusicOnHoldObjectGreeting
        :param audio_file: Announcement Audio File details when greeting is selected to be `CUSTOM`.
        :type audio_file: AudioAnnouncementFileGetObject
        :param org_id: Update music on hold settings for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callHoldEnabled'] = call_hold_enabled
        body['callParkEnabled'] = call_park_enabled
        body['greeting'] = enum_str(greeting)
        body['audioFile'] = loads(audio_file.model_dump_json())
        url = self.ep(f'locations/{location_id}/musicOnHold')
        super().put(url, params=params, json=body)

    def get_music_on_hold(self, location_id: str, org_id: str = None) -> GetMusicOnHoldObject:
        """
        Get Music On Hold

        Retrieve the location's music on hold settings.

        Location music on hold settings allows you to play music when a call is placed on hold or parked.

        Retrieving a location's music on hold settings requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve music on hold settings for this location.
        :type location_id: str
        :param org_id: Retrieve music on hold settings for this organization.
        :type org_id: str
        :rtype: :class:`GetMusicOnHoldObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/musicOnHold')
        data = super().get(url, params=params)
        r = GetMusicOnHoldObject.model_validate(data)
        return r

    def get_private_network_connect(self, location_id: str,
                                    org_id: str = None) -> GetPrivateNetworkConnectObjectNetworkConnectionType:
        """
        Get Private Network Connect

        Retrieve the location's network connection type.

        Network Connection Type determines if the location's network connection is public or private.

        Retrieving a location's network connection type requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve the network connection type for this location.
        :type location_id: str
        :param org_id: Retrieve the network connection type for this organization.
        :type org_id: str
        :rtype: GetPrivateNetworkConnectObjectNetworkConnectionType
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/privateNetworkConnect')
        data = super().get(url, params=params)
        r = GetPrivateNetworkConnectObjectNetworkConnectionType.model_validate(data['networkConnectionType'])
        return r

    def update_private_network_connect(self, location_id: str,
                                       network_connection_type: GetPrivateNetworkConnectObjectNetworkConnectionType,
                                       org_id: str = None):
        """
        Update Private Network Connect

        Update the location's network connection type.

        Network Connection Type determines if the location's network connection is public or private.

        Updating a location's network connection type requires a full administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Update the network connection type for this location.
        :type location_id: str
        :param network_connection_type: Network Connection Type for the location.
        :type network_connection_type: GetPrivateNetworkConnectObjectNetworkConnectionType
        :param org_id: Update network connection type for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['networkConnectionType'] = enum_str(network_connection_type)
        url = self.ep(f'locations/{location_id}/privateNetworkConnect')
        super().put(url, params=params, json=body)

    def read_the_list_of_routing_choices(self, org_id: str = None, route_group_name: str = None,
                                         trunk_name: str = None, start: int = None, order: str = None,
                                         **params) -> Generator[RouteIdentity, None, None]:
        """
        Read the List of Routing Choices

        List all Routes for the organization.

        Trunk and Route Group qualify as Route. Trunks and Route Groups provide you the ability to configure Webex
        Calling to manage calls between Webex Calling hosted users and premises PBX users. This solution lets you
        configure users to use Cloud PSTN (CCP or Cisco PSTN) or Premises-based PSTN.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List route identities for this organization.
        :type org_id: str
        :param route_group_name: Return the list of route identities matching the Route group name.
        :type route_group_name: str
        :param trunk_name: Return the list of route identities matching the Trunk name.
        :type trunk_name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the route identities according to the designated fields.  Available sort fields:
            `routeName`, `routeType`.
        :type order: str
        :return: Generator yielding :class:`RouteIdentity` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if route_group_name is not None:
            params['routeGroupName'] = route_group_name
        if trunk_name is not None:
            params['trunkName'] = trunk_name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep('routeChoices')
        return self.session.follow_pagination(url=url, model=RouteIdentity, item_key='routeIdentities', params=params)


class BetaNumbersWithESNFeatureApi(ApiChild, base='telephony/config/numbers'):
    """
    Beta Numbers with ESN Feature
    
    Numbers supports reading and writing of Webex Calling phone numbers for a
    specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_phone_numbers_for_an_organization_with_given_criterias(self, org_id: str = None, location_id: str = None,
                                                                   start: int = None, phone_number: str = None,
                                                                   available: bool = None, order: str = None,
                                                                   owner_name: str = None, owner_id: str = None,
                                                                   owner_type: GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType = None,
                                                                   extension: str = None, number_type: str = None,
                                                                   phone_number_type: str = None, state: str = None,
                                                                   details: bool = None,
                                                                   toll_free_numbers: bool = None,
                                                                   restricted_non_geo_numbers: bool = None,
                                                                   **params) -> Generator[NumberObject, None, None]:
        """
        Get Phone Numbers for an Organization with Given Criterias

        List all the phone numbers for the given organization along with the status and owner (if any).

        PSTN phone numbers are associated with a specific location and can be active/inactive and assigned/unassigned.
        The owner is the person, workspace, or feature to which the number is assigned.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List numbers for this organization.
        :type org_id: str
        :param location_id: Return the list of phone numbers for this location within the given organization. The
            maximum length is 36.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching phone numbers. Default is 0.
        :type start: int
        :param phone_number: Search for this `phoneNumber`.
        :type phone_number: str
        :param available: Search among the available phone numbers. This parameter cannot be used along with
            `ownerType` parameter when set to `true`.
        :type available: bool
        :param order: Sort the list of phone numbers based on the following:`lastName`,`dn`,`extension`. Default sort
            will be based on number and extension in an ascending order
        :type order: str
        :param owner_name: Return the list of phone numbers that is owned by given `ownerName`. Maximum length is 255.
        :type owner_name: str
        :param owner_id: Returns only the matched number/extension entries assigned to the feature with specified
            uuid/broadsoftId.
        :type owner_id: str
        :param owner_type: Returns the list of phone numbers that are of given `ownerType`. Possible input values
        :type owner_type: GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType
        :param extension: Returns the list of PSTN phone numbers with the given extension.
        :type extension: str
        :param number_type: Returns the filtered list of PSTN phone numbers that contains given type of numbers. This
            parameter cannot be used along with `available` or `state`.
        :type number_type: str
        :param phone_number_type: Returns the filtered list of PSTN phone numbers that are of given `phoneNumberType`.
        :type phone_number_type: str
        :param state: Returns the list of PSTN phone numbers with matching state.
        :type state: str
        :param details: Returns the overall count of the PSTN phone numbers along with other details for given
            organization.
        :type details: bool
        :param toll_free_numbers: Returns the list of toll free phone numbers.
        :type toll_free_numbers: bool
        :param restricted_non_geo_numbers: Returns the list of restricted non geographical numbers.
        :type restricted_non_geo_numbers: bool
        :return: Generator yielding :class:`NumberObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if available is not None:
            params['available'] = str(available).lower()
        if order is not None:
            params['order'] = order
        if owner_name is not None:
            params['ownerName'] = owner_name
        if owner_id is not None:
            params['ownerId'] = owner_id
        if owner_type is not None:
            params['ownerType'] = owner_type
        if extension is not None:
            params['extension'] = extension
        if number_type is not None:
            params['numberType'] = number_type
        if phone_number_type is not None:
            params['phoneNumberType'] = phone_number_type
        if state is not None:
            params['state'] = state
        if details is not None:
            params['details'] = str(details).lower()
        if toll_free_numbers is not None:
            params['tollFreeNumbers'] = str(toll_free_numbers).lower()
        if restricted_non_geo_numbers is not None:
            params['restrictedNonGeoNumbers'] = str(restricted_non_geo_numbers).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=NumberObject, item_key='phoneNumbers', params=params)


class BetaFeaturesNumbersWithMNOWebexEnabledMobilePlansFeatureApi(ApiChild, base='telephony/config/numbers'):
    """
    Beta Features: Numbers with MNO Webex Enabled Mobile Plans Feature
    
    Numbers supports reading and writing of Webex Calling phone numbers for a
    specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_phone_numbers_for_an_organization_with_given_criterias(self, org_id: str = None, location_id: str = None,
                                                                   start: int = None, phone_number: str = None,
                                                                   available: bool = None, order: str = None,
                                                                   owner_name: str = None, owner_id: str = None,
                                                                   owner_type: GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType = None,
                                                                   extension: str = None, number_type: str = None,
                                                                   phone_number_type: str = None, state: str = None,
                                                                   details: bool = None,
                                                                   toll_free_numbers: bool = None,
                                                                   restricted_non_geo_numbers: bool = None,
                                                                   included_telephony_types: list[TelephonyType] = None,
                                                                   **params) -> Generator[NumberObject1, None, None]:
        """
        Get Phone Numbers for an Organization with Given Criterias

        List all the phone numbers for the given organization along with the status and owner (if any).

        Numbers can be either PSTN numbers or mobile numbers.
        Phone numbers are associated with a specific location and can be active/inactive and assigned/unassigned.
        The owner for PSTN Number is the person, workspace, or feature to which the number is assigned.
        Only a person can own a mobile number.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List numbers for this organization.
        :type org_id: str
        :param location_id: Return the list of phone numbers for this location within the given organization. The
            maximum length is 36.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching phone numbers. Default is 0.
        :type start: int
        :param phone_number: Search for this `phoneNumber`.
        :type phone_number: str
        :param available: Search among the available phone numbers. This parameter cannot be used along with
            `ownerType` parameter when set to `true`.
        :type available: bool
        :param order: Sort the list of phone numbers based on the following:`lastName`,`dn`,`extension`. Sorted by
            number and extension in ascending order.
        :type order: str
        :param owner_name: Return the list of phone numbers that is owned by given `ownerName`. Maximum length is 255.
        :type owner_name: str
        :param owner_id: Returns only the matched number/extension entries assigned to the feature with the specified
            UUID or `broadsoftId`.
        :type owner_id: str
        :param owner_type: Returns the list of phone numbers that are of given `ownerType`. Possible input values
        :type owner_type: GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType
        :param extension: Returns the list of phone numbers with the given extension.
        :type extension: str
        :param number_type: Returns the filtered list of phone numbers that contains given type of numbers. Cannot be
            used along with `available` or `state`.
        :type number_type: str
        :param phone_number_type: Returns the filtered list of phone numbers that are of given `phoneNumberType`.
        :type phone_number_type: str
        :param state: Returns the list of phone numbers with matching state.
        :type state: str
        :param details: Returns the overall count of the phone numbers along with other details for given organization.
        :type details: bool
        :param toll_free_numbers: Returns the list of toll free phone numbers.
        :type toll_free_numbers: bool
        :param restricted_non_geo_numbers: Returns the list of restricted non geographical numbers.
        :type restricted_non_geo_numbers: bool
        :param included_telephony_types: Returns the list of phone numbers that are of given `includedTelephonyTypes`.
            By default if this query parameter is not provided, it will list both PSTN and Mobile Numbers. Possible
            input values are PSTN_NUMBER, MOBILE_NUMBER.
        :type included_telephony_types: list[TelephonyType]
        :return: Generator yielding :class:`NumberObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if available is not None:
            params['available'] = str(available).lower()
        if order is not None:
            params['order'] = order
        if owner_name is not None:
            params['ownerName'] = owner_name
        if owner_id is not None:
            params['ownerId'] = owner_id
        if owner_type is not None:
            params['ownerType'] = owner_type
        if extension is not None:
            params['extension'] = extension
        if number_type is not None:
            params['numberType'] = number_type
        if phone_number_type is not None:
            params['phoneNumberType'] = phone_number_type
        if state is not None:
            params['state'] = state
        if details is not None:
            params['details'] = str(details).lower()
        if toll_free_numbers is not None:
            params['tollFreeNumbers'] = str(toll_free_numbers).lower()
        if restricted_non_geo_numbers is not None:
            params['restrictedNonGeoNumbers'] = str(restricted_non_geo_numbers).lower()
        if included_telephony_types is not None:
            params['includedTelephonyTypes'] = included_telephony_types
        url = self.ep()
        return self.session.follow_pagination(url=url, model=NumberObject1, item_key='phoneNumbers', params=params)


class BetaNumbersWithNonIntegratedCCPApi(ApiChild, base='telephony/config/locations/{locationId}/numbers'):
    """
    Beta Numbers with Non-Integrated CCP
    
    Numbers supports reading and writing of Webex Calling phone numbers for a
    specific organization.
    
    Non-Integrated CCP locations are supported for adding the numbers, activating the numbers and deleting the numbers.
    These locations are able to import the carrier provisioned numbers into Cisco.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def add_phone_numbers_to_a_location(self, location_id: str, phone_numbers: list[str],
                                        number_type: NumberTypeOptions, state: NumberStateOptions,
                                        org_id: str = None):
        """
        Add Phone Numbers to a location

        Adds a specified set of phone numbers to a location for an organization.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.

        Adding a phone number to a location requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        <br/>

        <div><Callout type="warning">This API is not supported and should never be used for locations with other PSTN
        connection types like Cisco PSTN or Integrated CCP because backend data issues may occur.</Callout></div>

        :param location_id: `LocationId` to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers needed to be added.
        :type phone_numbers: list[str]
        :param number_type: Type of the number.
        :type number_type: NumberTypeOptions
        :param state: Reflects the state of the number. By default the state of a number is `ACTIVE`.
        :type state: NumberStateOptions
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['phoneNumbers'] = phone_numbers
        body['numberType'] = enum_str(number_type)
        body['state'] = enum_str(state)
        url = self.ep(f'')
        super().post(url, params=params, json=body)

    def activate_phone_numbers_in_a_location(self, location_id: str, phone_numbers: list[str], org_id: str = None):
        """
        Activate Phone Numbers in a location

        Activate the specified set of phone numbers in a location for an organization.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.

        Activating a phone number in a location requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        <br/>

        <div><Callout type="warning">This API is not supported and should never be used for locations with other PSTN
        connection types like Cisco PSTN or Integrated CCP because backend data issues may occur.</Callout></div>

        :param location_id: `LocationId` to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers needed to be added.
        :type phone_numbers: list[str]
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['phoneNumbers'] = phone_numbers
        url = self.ep(f'')
        super().put(url, params=params, json=body)

    def remove_phone_numbers_from_a_location(self, location_id: str, phone_numbers: list[str], org_id: str = None):
        """
        Remove phone numbers from a location

        Remove the specified set of phone numbers from a location for an organization.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.

        Removing a phone number from a location requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        <br/>

        <div><Callout type="warning">This API is not supported and should never be used for locations with other PSTN
        connection types like Cisco PSTN or Integrated CCP because backend data issues may occur.</Callout></div>

        :param location_id: `LocationId` to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers that need to be deleted.
        :type phone_numbers: list[str]
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['phoneNumbers'] = phone_numbers
        url = self.ep(f'')
        super().delete(url, params=params, json=body)


class BetaUserCallSettingsWithCallBridgeFeatureApi(ApiChild, base='telephony/config/people/{personId}/features/callBridge'):
    """
    Beta User Call Settings with Call Bridge Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Person Call Settings supports modifying Webex Calling settings for a specific person.
    
    Viewing People requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by a
    person to read their own settings.
    
    Configuring People settings requires a full or user administrator auth token with the `spark-admin:people_write`
    scope or, for select APIs, a user auth token with `spark:people_write` scope can be used by a person to update
    their own settings.
    """

    def read_call_bridge_settings_for_a_person(self, person_id: str, org_id: str = None) -> bool:
        """
        Read Call Bridge Settings for a Person

        Retrieve a person's Call Bridge settings.

        This API requires a full, user or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: bool
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = data['warningToneEnabled']
        return r

    def configure_call_bridge_settings_for_a_person(self, person_id: str, warning_tone_enabled: bool,
                                                    org_id: str = None):
        """
        Configure Call Bridge Settings for a Person

        Configure a person's Call Bridge settings.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param warning_tone_enabled: Set to enable or disable a stutter dial tone being played to all the participants
            when a person is bridged on the active shared line call.
        :type warning_tone_enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['warningToneEnabled'] = warning_tone_enabled
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BetaUserCallSettingsWithComplianceAnnouncementFeatureApi(ApiChild, base='people/{personId}/features/callRecording'):
    """
    Beta User Call Settings with Compliance Announcement Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Person Call Settings supports modifying Webex Calling settings for a specific person.
    
    Viewing People requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by a
    person to read their own settings.
    
    Configuring People settings requires a full or user administrator auth token with the `spark-admin:people_write`
    scope or, for select APIs, a user auth token with `spark:people_write` scope can be used by a person to update
    their own settings.
    """

    def read_call_recording_settings_for_a_person(self, person_id: str, org_id: str = None) -> CallRecordingInfo:
        """
        Read Call Recording Settings for a Person

        Retrieve a person's Call Recording settings.

        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`CallRecordingInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = CallRecordingInfo.model_validate(data)
        return r

    def configure_call_recording_settings_for_a_person(self, person_id: str, enabled: bool,
                                                       record: CallRecordingInfoRecord,
                                                       record_voicemail_enabled: bool,
                                                       start_stop_announcement_enabled: bool,
                                                       notification: CallRecordingInfoNotification,
                                                       repeat: CallRecordingInfoRepeat,
                                                       start_stop_announcement: CallRecordingInfoStartStopAnnouncement,
                                                       org_id: str = None):
        """
        Configure Call Recording Settings for a Person

        Configure a person's Call Recording settings.

        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: `true` if call recording is enabled.
        :type enabled: bool
        :param record: Call recording scenario.
        :type record: CallRecordingInfoRecord
        :param record_voicemail_enabled: When `true`, voicemail messages are also recorded.
        :type record_voicemail_enabled: bool
        :param start_stop_announcement_enabled: When enabled, an announcement is played when call recording starts and
            an announcement is played when call recording ends.
        :type start_stop_announcement_enabled: bool
        :param notification: Pause/resume notification settings.
        :type notification: CallRecordingInfoNotification
        :param repeat: Beep sound plays periodically.
        :type repeat: CallRecordingInfoRepeat
        :param start_stop_announcement: Call Recording starts and stops announcement settings.
        :type start_stop_announcement: CallRecordingInfoStartStopAnnouncement
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['record'] = enum_str(record)
        body['recordVoicemailEnabled'] = record_voicemail_enabled
        body['startStopAnnouncementEnabled'] = start_stop_announcement_enabled
        body['notification'] = loads(notification.model_dump_json())
        body['repeat'] = loads(repeat.model_dump_json())
        body['startStopAnnouncement'] = loads(start_stop_announcement.model_dump_json())
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BetaUserCallSettingsWithDepartmentFeaturesApi(ApiChild, base='telephony/config/people/{personId}'):
    """
    Beta User Call Settings with Department Features
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Person Call Settings supports modifying Webex Calling settings for a specific person.
    
    Viewing People requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by a
    person to read their own settings.
    
    Configuring People settings requires a full or user administrator auth token with the `spark-admin:people_write`
    scope or, for select APIs, a user auth token with `spark:people_write` scope can be used by a person to update
    their own settings.
    """

    def read_department_of_a_person(self, person_id: str, org_id: str = None) -> Location:
        """
        Read Department of a Person

        Retrieve a person's department membership.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param person_id: Retrieve department membership of this person.
        :type person_id: str
        :param org_id: Person is in this organization.
        :type org_id: str
        :rtype: Location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = Location.model_validate(data['department'])
        return r

    def update_department_of_a_person(self, person_id: str, department: DepartmentResponseWithId, org_id: str = None):
        """
        Update Department of a Person

        Modify a person's department membership.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param person_id: Modify department membership of this person.
        :type person_id: str
        :param department: Specifies the department information.
        :type department: DepartmentResponseWithId
        :param org_id: Person is in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['department'] = loads(department.model_dump_json())
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BetaUserCallSettingsWithESNFeatureApi(ApiChild, base=''):
    """
    Beta User Call Settings with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Person Call Settings supports modifying Webex Calling settings for a specific person.
    
    Viewing People requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by a
    person to read their own settings.
    
    Configuring People settings requires a full or user administrator auth token with the `spark-admin:people_write`
    scope or, for select APIs, a user auth token with `spark:people_write` scope can be used by a person to update
    their own settings.
    """

    def retrieve_list_of_call_queue_caller_id_information(self, person_id: str) -> list[CallQueueObject]:
        """
        Retrieve List of Call Queue Caller ID information

        Retrieve the list of the person's available call queues and the associated Caller ID information.

        If the Agent is to enable `queueCallerIdEnabled`, they must choose which queue to use as the source for
        outgoing Caller ID.  This API returns a list of Call Queues from which the person must select.  If this
        setting is disabled or the Agent does not belong to any queue, this list will be empty.

        This API requires a full admin or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :rtype: list[CallQueueObject]
        """
        url = self.ep(f'telephony/config/people/{person_id}/queues/availableCallerIds')
        data = super().get(url)
        r = TypeAdapter(list[CallQueueObject]).validate_python(data['availableQueues'])
        return r

    def retrieve_a_call_queue_agent_s_caller_id_information(self, person_id: str) -> AgentCallQueueId:
        """
        Retrieve a Call Queue Agent's Caller ID information

        Retrieve a call queue agent's Caller ID information.

        Each agent in the Call Queue will be able to set their outgoing Caller ID as either the Call Queue's phone
        number or their own configured Caller ID. This API fetches the configured Caller ID for the agent in the
        system.

        This API requires a full admin or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :rtype: :class:`AgentCallQueueId`
        """
        url = self.ep(f'telephony/config/people/{person_id}/queues/callerId')
        data = super().get(url)
        r = AgentCallQueueId.model_validate(data)
        return r

    def retrieve_a_person_s_monitoring_settings(self, person_id: str, org_id: str = None) -> MonitoringSettings:
        """
        Retrieve a person's Monitoring Settings

        Retrieves the monitoring settings of the person, which shows specified people, places, virtual lines or call
        park extenions that are being monitored.
        Monitors the line status which indicates if a person, place or virtual line is on a call and if a call has been
        parked on that extension.

        This API requires a full, user, or read-only administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`MonitoringSettings`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/monitoring')
        data = super().get(url, params=params)
        r = MonitoringSettings.model_validate(data)
        return r

    def get_a_list_of_phone_numbers_for_a_person(self, person_id: str, org_id: str = None) -> GetNumbers:
        """
        Get a List of Phone Numbers for a Person

        Get a person's phone numbers including alternate numbers.

        A person can have one or more phone numbers and/or extensions via which they can be called.

        This API requires a full or user administrator auth token with the `spark-admin:people_read` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`GetNumbers`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/numbers')
        data = super().get(url, params=params)
        r = GetNumbers.model_validate(data)
        return r

    def get_a_person_s_privacy_settings(self, person_id: str, org_id: str = None) -> PrivacyGet:
        """
        Get a person's Privacy Settings

        Get a person's privacy settings for the specified person ID.

        The privacy feature enables the person's line to be monitored by others and determine if they can be reached by
        Auto Attendant services.

        This API requires a full, user, or read-only administrator auth token with a scope of spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`PrivacyGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/privacy')
        data = super().get(url, params=params)
        r = PrivacyGet.model_validate(data)
        return r

    def read_push_to_talk_settings_for_a_person(self, person_id: str, org_id: str = None) -> PushToTalkInfo:
        """
        Read Push-to-Talk Settings for a Person

        Retrieve a person's Push-to-Talk settings.

        Push-to-Talk allows the use of desk phones as either a one-way or two-way intercom that connects people in
        different parts of your organization.

        This API requires a full, user, or read-only administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`PushToTalkInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/pushToTalk')
        data = super().get(url, params=params)
        r = PushToTalkInfo.model_validate(data)
        return r

    def read_receptionist_client_settings_for_a_person(self, person_id: str, org_id: str = None) -> ReceptionInfo:
        """
        Read Receptionist Client Settings for a Person

        Retrieve a person's Receptionist Client settings.

        To help support the needs of your front-office personnel, you can set up people, workspaces or virtual lines as
        telephone attendants so that they can screen all incoming calls to certain numbers within your organization.

        This API requires a full, user, or read-only administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`ReceptionInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/reception')
        data = super().get(url, params=params)
        r = ReceptionInfo.model_validate(data)
        return r

    def search_shared_line_appearance_members(self, person_id: str, application_id: str, max_: str = None,
                                              start: str = None, location: str = None, name: str = None,
                                              number: str = None, order: str = None, extension: Union[str,
                                              datetime] = None) -> list[AvailableSharedLineMemberItem]:
        """
        Search Shared-Line Appearance Members

        Get members available for shared-line assignment to a Webex Calling Apps Desktop device.

        This API requires a full or user administrator auth token with the `spark-admin:people_read` scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str
        :param max_: Number of records per page.
        :type max_: str
        :param start: Page number.
        :type start: str
        :param location: Location ID for the user.
        :type location: str
        :param name: Search for users with names that match the query.
        :type name: str
        :param number: Search for users with numbers that match the query.
        :type number: str
        :param order: Sort by first name (`fname`) or last name (`lname`).
        :type order: str
        :param extension: Search for users with extensions that match the query.
        :type extension: Union[str, datetime]
        :rtype: list[AvailableSharedLineMemberItem]
        """
        body = dict()
        body['max'] = max_
        body['start'] = start
        body['location'] = location
        body['name'] = name
        body['number'] = number
        body['order'] = order
        body['extension'] = extension
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/availableMembers')
        data = super().get(url, json=body)
        r = TypeAdapter(list[AvailableSharedLineMemberItem]).validate_python(data['members'])
        return r

    def get_shared_line_appearance_members(self, person_id: str, application_id: str) -> GetSharedLineMemberList:
        """
        Get Shared-Line Appearance Members

        Get primary and secondary members assigned to a shared line on a Webex Calling Apps Desktop device.

        This API requires a full or user administrator auth token with the `spark-admin:people_read` scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str
        :rtype: :class:`GetSharedLineMemberList`
        """
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/members')
        data = super().get(url)
        r = GetSharedLineMemberList.model_validate(data)
        return r


class BetaUserCallSettingsWithLocationAdminSupportApi(ApiChild, base='telephony/config/people/{personId}/musicOnHold'):
    """
    Beta User Call Settings with Location Admin Support
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Person Call Settings supports modifying Webex Calling settings for a specific person.
    
    Viewing People requires a full, user, or read-only administrator or location administrator auth token with a scope
    of `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by
    a person to read their own settings.
    
    Configuring People settings requires a full or user administrator or location administrator auth token with the
    `spark-admin:people_write` scope or, for select APIs, a user auth token with `spark:people_write` scope can be
    used by a person to update their own settings.
    """

    def retrieve_music_on_hold_settings_for_a_person(self, person_id: str,
                                                     org_id: str = None) -> GetMusicOnHoldObject1:
        """
        Retrieve Music On Hold Settings for a Person

        Retrieve the person's music on hold settings.

        Music on hold is played when a caller is put on hold, or the call is parked.

        Retrieving a person's music on hold settings requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`GetMusicOnHoldObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = GetMusicOnHoldObject1.model_validate(data)
        return r

    def configure_music_on_hold_settings_for_a_person(self, person_id: str, moh_enabled: bool,
                                                      greeting: HoursMenuObjectGreeting,
                                                      audio_announcement_file: AudioAnnouncementFileGetObject1,
                                                      org_id: str = None):
        """
        Configure Music On Hold Settings for a Person

        Configure a person's music on hold settings.

        Music on hold is played when a caller is put on hold, or the call is parked.

        To configure music on hold settings for a person, music on hold setting must be enabled for this location.

        Updating a person's music on hold settings requires a full or user administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param moh_enabled: Music on hold is enabled or disabled for the person.
        :type moh_enabled: bool
        :param greeting: Greeting type for the person.
        :type greeting: HoursMenuObjectGreeting
        :param audio_announcement_file: Announcement Audio File details when greeting is selected to be `CUSTOM`.
        :type audio_announcement_file: AudioAnnouncementFileGetObject1
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['mohEnabled'] = moh_enabled
        body['greeting'] = enum_str(greeting)
        body['audioAnnouncementFile'] = loads(audio_announcement_file.model_dump_json())
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BetaUserCallSettingsWithSelectCallerIDFeatureApi(ApiChild, base='telephony/config'):
    """
    Beta User Call Settings with Select Caller ID Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Person Call Settings supports modifying Webex Calling settings for a specific person.
    
    Viewing People requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by a
    person to read their settings.
    
    Configuring People settings requires a full or user administrator auth token with the `spark-admin:people_write`
    scope or, for select APIs, a user auth token with `spark:people_write` scope can be used by a person to update
    their settings.
    """

    def retrieve_list_of_available_caller_ids_for_a_person(self, person_id: str,
                                                           org_id: str = None) -> list[AvailableCallerIdObject]:
        """
        Retrieve List of Available Caller IDs for a Person

        Get the list of call queues and hunt groups that this person belongs to as an agent.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: list[AvailableCallerIdObject]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/agent/availableCallerIds')
        data = super().get(url, params=params)
        r = TypeAdapter(list[AvailableCallerIdObject]).validate_python(data['availableCallerIds'])
        return r

    def retrieve_agent_s_caller_id_information(self, person_id: str) -> AvailableCallerIdObject:
        """
        Retrieve Agent's Caller ID Information

        Retrieve the Agent's Caller ID Information.

        Each agent will be able to set their outgoing Caller ID as either the Call Queue's Caller ID, Hunt Group's
        Caller ID or their own configured Caller ID.

        This API requires a full admin or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :rtype: AvailableCallerIdObject
        """
        url = self.ep(f'people/{person_id}/agent/callerId')
        data = super().get(url)
        r = AvailableCallerIdObject.model_validate(data['selectedCallerId'])
        return r

    def modify_agent_s_caller_id_information(self, person_id: str, id: str):
        """
        Modify Agent's Caller ID Information

        Modify Agent's Caller ID Information.

        Each Agent will be able to set their outgoing Caller ID as either the designated Call Queue's Caller ID or Hunt
        Group's Caller ID or their own configured Caller ID

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:telephony_config_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param id: Call queue's or hunt group's unique identifier.
        :type id: str
        :rtype: None
        """
        body = dict()
        body['id'] = id
        url = self.ep(f'people/{person_id}/agent/callerId')
        super().put(url, json=body)

    def get_the_list_of_phone_numbers_across_location_for_external_caller_id(self,
                                                                             location_id: str) -> list[NumberObject2]:
        """
        GET The List Of Phone Numbers Across Location For External Caller ID

        GET the List of phone numbers across location for external caller id(for india location it should not allow to
        send the phone number across location).

        Numbers can be either PSTN numbers or mobile numbers.
        Phone numbers are associated with a specific location and can be active/inactive and assigned/unassigned.
        The owner for PSTN Number is the person, workspace, or feature to which the number is assigned.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param location_id: Return the list of phone numbers across location with same PSTN.
        :type location_id: str
        :rtype: list[NumberObject2]
        """
        url = self.ep(f'locations/{location_id}/externalCallerId/numbers')
        data = super().get(url)
        r = TypeAdapter(list[NumberObject2]).validate_python(data['phoneNumbers'])
        return r


class BetaVirtualLineCallSettingsWithESNFeatureApi(ApiChild, base='telephony/config/virtualLines'):
    """
    Beta Virtual Line Call Settings with ESN Feature
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Viutual Line Settings supports listing Webex Calling virtual lines.
    
    Viewing Virtual Lines requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read.
    """

    def read_the_list_of_virtual_lines(self, org_id: str = None, location_id: list[str] = None, start: int = None,
                                       id: list[str] = None, owner_name: list[str] = None,
                                       phone_number: list[str] = None, location_name: list[str] = None,
                                       order: list[str] = None, has_device_assigned: bool = None,
                                       has_extension_assigned: bool = None, has_dn_assigned: bool = None,
                                       **params) -> Generator[ListVirtualLineObject, None, None]:
        """
        Read the List of Virtual Lines

        List all Virtual Lines for the organization.

        Virtual line is a capability in Webex Calling that allows administrators to configure multiple lines to Webex
        Calling users.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List virtual lines for this organization.
        :type org_id: str
        :param location_id: Return the list of virtual lines matching these location ids. Example for multiple values -
            `?locationId=locId1&locationId=locId2`.
        :type location_id: list[str]
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param id: Return the list of virtual lines matching these virtualLineIds. Example for multiple values -
            `?id=id1&id=id2`.
        :type id: list[str]
        :param owner_name: Return the list of virtual lines matching these owner names. Example for multiple values -
            `?ownerName=name1&ownerName=name2`.
        :type owner_name: list[str]
        :param phone_number: Return the list of virtual lines matching these phone numbers. Example for multiple values
            - `?phoneNumber=number1&phoneNumber=number2`.
        :type phone_number: list[str]
        :param location_name: Return the list of virtual lines matching the location names. Example for multiple values
            - `?locationName=loc1&locationName=loc2`.
        :type location_name: list[str]
        :param order: Return the list of virtual lines based on the order. Default sort will bein an Ascending order.
            Maximum 3 orders allowed at a time. Example for multiple values - `?order=order1&order=order2`.
        :type order: list[str]
        :param has_device_assigned: If `true`, includes onlyvirtual lines with devices assigned. When not explicitly
            specified, the default includes bothvirtual lines with devices assigned and not assigned.
        :type has_device_assigned: bool
        :param has_extension_assigned: If `true`, includesonly virtual lines withan extension assigned. When not
            explicitly specified, the default includes both virtual lines withextension assigned and not assigned.
        :type has_extension_assigned: bool
        :param has_dn_assigned: If `true`, includes only virtual lines withan assigned directory number, also known as
            a Dn. When not explicitly specified, the default includes both virtual lines witha Dn assigned and not
            assigned.
        :type has_dn_assigned: bool
        :return: Generator yielding :class:`ListVirtualLineObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = ','.join(location_id)
        if start is not None:
            params['start'] = start
        if id is not None:
            params['id'] = ','.join(id)
        if owner_name is not None:
            params['ownerName'] = ','.join(owner_name)
        if phone_number is not None:
            params['phoneNumber'] = ','.join(phone_number)
        if location_name is not None:
            params['locationName'] = ','.join(location_name)
        if order is not None:
            params['order'] = ','.join(order)
        if has_device_assigned is not None:
            params['hasDeviceAssigned'] = str(has_device_assigned).lower()
        if has_extension_assigned is not None:
            params['hasExtensionAssigned'] = str(has_extension_assigned).lower()
        if has_dn_assigned is not None:
            params['hasDnAssigned'] = str(has_dn_assigned).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ListVirtualLineObject, item_key='virtualLines', params=params)


class BetaVirtualLineCallSettingsWithVirtualLineCallRecordingApi(ApiChild, base='telephony/config/virtualLines/{virtualLineId}/callRecording'):
    """
    Beta Virtual Line Call Settings with Virtual Line Call Recording
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Viutual Line Settings supports listing Webex Calling virtual lines.
    
    Viewing Virtual Lines requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read.
    """

    def read_call_recording_settings_for_a_virtual_line(self, virtual_line_id: str,
                                                        org_id: str = None) -> CallRecordingInfo1:
        """
        Read Call Recording Settings for a Virtual Line

        Retrieve Virtual Line's Call Recording settings.

        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.

        This API requires a full or user administrator auth token with the `spark-admin:telephony_config_read` scope.

        :param virtual_line_id: Unique identifier for the virtual line.
        :type virtual_line_id: str
        :param org_id: ID of the organization in which the virtual line resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`CallRecordingInfo1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = CallRecordingInfo1.model_validate(data)
        return r

    def configure_call_recording_settings_for_a_virtual_line(self, virtual_line_id: str, enabled: bool,
                                                             record: CallRecordingInfoRecord,
                                                             record_voicemail_enabled: bool,
                                                             notification: CallRecordingInfoNotification,
                                                             repeat: CallRecordingInfoRepeat,
                                                             start_stop_announcement: CallRecordingInfoStartStopAnnouncement,
                                                             org_id: str = None):
        """
        Configure Call Recording Settings for a Virtual Line

        Configure virtual line's Call Recording settings.

        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.

        This API requires a full or user administrator auth token with the `spark-admin:telephony_config_write` scope.

        :param virtual_line_id: Unique identifier for the virtual line.
        :type virtual_line_id: str
        :param enabled: `true` if call recording is enabled.
        :type enabled: bool
        :param record: Call recording scenario.
        :type record: CallRecordingInfoRecord
        :param record_voicemail_enabled: When `true`, voicemail messages are also recorded.
        :type record_voicemail_enabled: bool
        :param notification: Pause/resume notification settings.
        :type notification: CallRecordingInfoNotification
        :param repeat: Beep sound plays periodically.
        :type repeat: CallRecordingInfoRepeat
        :param start_stop_announcement: Call Recording starts and stops announcement settings.
        :type start_stop_announcement: CallRecordingInfoStartStopAnnouncement
        :param org_id: ID of the organization in which the virtual profile resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['record'] = enum_str(record)
        body['recordVoicemailEnabled'] = record_voicemail_enabled
        body['notification'] = loads(notification.model_dump_json())
        body['repeat'] = loads(repeat.model_dump_json())
        body['startStopAnnouncement'] = loads(start_stop_announcement.model_dump_json())
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BetaWholesaleDeviceFulfillmentWithDistributorsApi(ApiChild, base='wholesale/deviceFulfillment'):
    """
    Beta Wholesale Device Fulfillment with Distributors
    
    """

    def list_wholesale_device_catalog(self, distributor_id: str = None, product_name: str = None, sku: str = None,
                                      **params) -> Generator[CatalogResponse, None, None]:
        """
        List Wholesale Device Catalog

        List the device fulfillment catalog items associated with a Service Provider. There are a number of filter
        options, which can be combined in a single request.

        :param distributor_id: The distributor ID.
        :type distributor_id: str
        :param product_name: The device product name.
        :type product_name: str
        :param sku: The device SKU.
        :type sku: str
        :return: Generator yielding :class:`CatalogResponse` instances
        """
        if distributor_id is not None:
            params['distributorId'] = distributor_id
        if product_name is not None:
            params['productName'] = product_name
        if sku is not None:
            params['sku'] = sku
        url = self.ep('deviceCatalog')
        return self.session.follow_pagination(url=url, model=CatalogResponse, item_key='items', params=params)

    def get_wholesale_device_catalog_details(self, catalog_id: str) -> CatalogResponse:
        """
        Get Wholesale Device Catalog Details

        Retrieve details of a Wholesale device fulfillment catalog item.

        :param catalog_id: A unique identifier for the device fulfillment catalog item.
        :type catalog_id: str
        :rtype: :class:`CatalogResponse`
        """
        url = self.ep(f'deviceCatalog/{catalog_id}')
        data = super().get(url)
        r = CatalogResponse.model_validate(data)
        return r

    def list_wholesale_device_distributors(self) -> list[DistributorResponse]:
        """
        List Wholesale Device Distributors

        List the device fulfillment distributors associated with a Service Provider.

        :rtype: list[DistributorResponse]
        """
        url = self.ep('distributors')
        data = super().get(url)
        r = TypeAdapter(list[DistributorResponse]).validate_python(data['items'])
        return r

    def get_wholesale_device_distributor_details(self, distributor_id: str) -> DistributorDetailsResponse:
        """
        Get Wholesale Device Distributor Details

        Retrieve distributor information.

        :param distributor_id: The distributor ID.
        :type distributor_id: str
        :rtype: :class:`DistributorDetailsResponse`
        """
        url = self.ep(f'distributors/{distributor_id}')
        data = super().get(url)
        r = DistributorDetailsResponse.model_validate(data)
        return r

    def list_wholesale_device_orders(self, org_id: str = None, status: str = None,
                                     **params) -> Generator[OrderResponse, None, None]:
        """
        List Wholesale Device Orders

        List the device fulfillment orders associated with a Service Provider. There are a number of filter options,
        which can be combined in a single request.

        :param org_id: Wholesale customer ID.
        :type org_id: str
        :param status: The aggregated order status.
        :type status: str
        :return: Generator yielding :class:`OrderResponse` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if status is not None:
            params['status'] = status
        url = self.ep('orders')
        return self.session.follow_pagination(url=url, model=OrderResponse, item_key='items', params=params)

    def create_a_wholesale_device_order(self, description: str, org_id: str, shipping_details: OrderShippingDetails,
                                        line_items: list[OrderRequestLineItem]) -> OrderResponse:
        """
        Create a Wholesale Device Order

        Create a Wholesale device fulfillment order.

        :param description: Description of the order.
        :type description: str
        :param org_id: A unique identifier for the customer.
        :type org_id: str
        :param shipping_details: The order delivery shipping details.
        :type shipping_details: OrderShippingDetails
        :param line_items: A list of order line items.
        :type line_items: list[OrderRequestLineItem]
        :rtype: :class:`OrderResponse`
        """
        body = dict()
        body['description'] = description
        body['orgId'] = org_id
        body['shippingDetails'] = loads(shipping_details.model_dump_json())
        body['lineItems'] = loads(TypeAdapter(list[OrderRequestLineItem]).dump_json(line_items))
        url = self.ep('orders')
        data = super().post(url, json=body)
        r = OrderResponse.model_validate(data)
        return r

    def cancel_a_wholesale_device_order(self, order_number: str):
        """
        Cancel a Wholesale Device Order

        Cancel a Wholesale device fulfillment order.

        :param order_number: A unique identifier for the device fulfillment order.
        :type order_number: str
        :rtype: None
        """
        url = self.ep(f'orders/{order_number}')
        super().delete(url)

    def get_a_wholesale_device_order(self, order_number: str) -> OrderResponse:
        """
        Get a Wholesale Device Order

        Retrieve details of a Wholesale device fulfillment order.

        :param order_number: A unique identifier for the device fulfillment order.
        :type order_number: str
        :rtype: :class:`OrderResponse`
        """
        url = self.ep(f'orders/{order_number}')
        data = super().get(url)
        r = OrderResponse.model_validate(data)
        return r


class BetaWorkspaceCallSettingsWithDepartmentFeaturesApi(ApiChild, base='telephony/config/workspaces/{workspaceId}'):
    """
    Beta Workspace Call Settings with Department Features
    
    Workspaces represent places where people work, such as conference rooms, meeting spaces, lobbies, and lunchrooms.
    Devices may be associated with workspaces.
    
    Webex Calling Workspace Settings support reading and writing of Webex Calling settings for a specific workspace
    within the organization.
    
    Viewing the list of settings in a workspace /v1/workspaces API requires an full, device, or read-only administrator
    auth token with the `spark-admin:workspaces_read` scope.
    
    Adding, updating, or deleting settings in a workspace /v1/workspaces API requires an full or device administrator
    auth token with the `spark-admin:workspaces_write` scope.
    
    This API can also be used by partner administrators acting as administrators of a different organization than their
    own. In those cases, an `orgId` must be supplied, as indicated in the reference documentation for the relevant
    endpoints.
    """

    def read_department_of_a_workspace(self, workspace_id: str, org_id: str = None) -> Location:
        """
        Read Department of a Workspace

        Retrieve a workspace's department membership.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param workspace_id: Retrieve department membership of this workspace.
        :type workspace_id: str
        :param org_id: Workspace is in this organization.
        :type org_id: str
        :rtype: Location
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = Location.model_validate(data['department'])
        return r

    def update_department_of_a_workspace(self, workspace_id: str, department: DepartmentResponseWithId,
                                         org_id: str = None):
        """
        Update Department of a Workspace

        Modify a workspace's department membership. A department can only be assigned to WxC workspace.

        An admin can organize people, workspaces, and features by placing them into departments. Departments can span
        locations.

        This API requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param workspace_id: Modify department membership of this workspace.
        :type workspace_id: str
        :param department: Specifies the department information.
        :type department: DepartmentResponseWithId
        :param org_id: Workspace is in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['department'] = loads(department.model_dump_json())
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BetaWorkspaceCallSettingsWithESNFeatureApi(ApiChild, base='workspaces/{workspaceId}/features'):
    """
    Beta Workspace Call Settings with ESN Feature
    
    Workspaces represent places where people work, such as conference rooms, meeting spaces, lobbies, and lunchrooms.
    Devices may be associated with workspaces.
    
    Webex Calling Workspace Settings support reading and writing of Webex Calling settings for a specific workspace
    within the organization.
    
    Viewing the list of settings in a workspace /v1/workspaces API requires an full, device, or read-only administrator
    auth token with the `spark-admin:workspaces_read` scope.
    
    Adding, updating, or deleting settings in a workspace /v1/workspaces API requires an full or device administrator
    auth token with the `spark-admin:workspaces_write` scope.
    
    This API can also be used by partner administrators acting as administrators of a different organization than their
    own. In those cases, an `orgId` must be supplied, as indicated in the reference documentation for the relevant
    endpoints.
    """

    def retrieve_monitoring_settings_for_a_workspace(self, workspace_id: str, org_id: str = None) -> UserMonitoringGet:
        """
        Retrieve Monitoring Settings for a Workspace

        Retrieves Monitoring settings for a Workspace.

        Allow workspaces to monitor the line status of specified agents, workspaces, or call park extensions. The line
        status indicates if a monitored agent or a workspace is on a call, or if a call has been parked on the
        monitored call park extension.

        This API requires a full or read-only administrator auth token with a scope of `spark-admin:workspaces_read` or
        a user auth token with `spark:workspaces_read` scope can be used to read workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`UserMonitoringGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'monitoring')
        data = super().get(url, params=params)
        r = UserMonitoringGet.model_validate(data)
        return r

    def list_numbers_associated_with_a_specific_workspace(self, workspace_id: str,
                                                          org_id: str = None) -> ListNumbersAssociatedWithASpecificWorkspaceResponse:
        """
        List numbers associated with a specific workspace

        List the PSTN phone numbers associated with a specific workspace, by ID, within the organization. Also shows
        the location and organization associated with the workspace.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:workspaces_read`.

        :param workspace_id: List numbers for this workspace.
        :type workspace_id: str
        :param org_id: Workspace is in this organization. Only admin users of another organization (such as partners)
            can use this parameter as the default is the same organization as the token used to access API.
        :type org_id: str
        :rtype: :class:`ListNumbersAssociatedWithASpecificWorkspaceResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'numbers')
        data = super().get(url, params=params)
        r = ListNumbersAssociatedWithASpecificWorkspaceResponse.model_validate(data)
        return r


class BetaWorkspaceCallSettingsWithLocationAdminSupportApi(ApiChild, base='telephony/config/workspaces/{workspaceId}/musicOnHold'):
    """
    Beta Workspace Call Settings with Location Admin Support
    
    Workspaces represent places where people work, such as conference rooms, meeting spaces, lobbies, and lunchrooms.
    Devices may be associated with workspaces.
    
    Webex Calling Workspace Settings support reading and writing of Webex Calling settings for a specific workspace
    within the organization.
    
    Viewing the list of settings in a workspace /v1/workspaces API requires an full, device, or read-only administrator
    or location administrator  auth token with the `spark-admin:workspaces_read` scope.
    
    Adding, updating, or deleting settings in a workspace /v1/workspaces API requires an full or device administrator
    auth token with the `spark-admin:workspaces_write` scope.
    
    This API can also be used by partner administrators acting as administrators of a different organization than their
    own. In those cases, an `orgId` must be supplied, as indicated in the reference documentation for the relevant
    endpoints.
    """

    def retrieve_music_on_hold_settings_for_a_workspace(self, workspace_id: str,
                                                        org_id: str = None) -> GetMusicOnHoldObject1:
        """
        Retrieve Music On Hold Settings for a Workspace

        Retrieve Music On Hold Settings for a Workspace.

        Music on hold is played when a caller is put on hold, or the call is parked.

        Retrieving a workspace's music on hold settings requires a full, device or read-only administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`GetMusicOnHoldObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = GetMusicOnHoldObject1.model_validate(data)
        return r

    def modify_music_on_hold_settings_for_a_workspace(self, workspace_id: str, moh_enabled: bool,
                                                      greeting: HoursMenuObjectGreeting,
                                                      audio_announcement_file: AudioAnnouncementFileGetObject1,
                                                      org_id: str = None):
        """
        Modify Music On Hold Settings for a Workspace

        Modify music on hold settings for a Workspace.

        Music on hold is played when a caller is put on hold, or the call is parked.

        To configure music on hold setting for a workspace, music on hold setting must be enabled for this location.

        This API requires a full or device administrator or location administrator auth token with the
        `spark-admin:telephony_config_write` scope.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param moh_enabled: Music on hold is enabled or disabled for the workspace.
        :type moh_enabled: bool
        :param greeting: Greeting type for the workspace.
        :type greeting: HoursMenuObjectGreeting
        :param audio_announcement_file: Announcement Audio File details when greeting is selected to be `CUSTOM`.
        :type audio_announcement_file: AudioAnnouncementFileGetObject1
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['mohEnabled'] = moh_enabled
        body['greeting'] = enum_str(greeting)
        body['audioAnnouncementFile'] = loads(audio_announcement_file.model_dump_json())
        url = self.ep(f'')
        super().put(url, params=params, json=body)


class BroadWorksBillingReportsApi(ApiChild, base='broadworks/billing/reports'):
    """
    BroadWorks Billing Reports
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. These APIs helps Service Providers to generate monthly billing reports with user billing data.
    Service Providers can use these reports to reconcile their monthly invoice. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks billing reports information requires a partner administrator auth token with
    `spark-admin:broadworks_billing_reports_read` scope. Creating, Deleting billing reports require a partner
    administrator auth token with `spark-admin:broadworks_billing_reports_write` scope.
    """

    def list_broad_works_billing_reports(self, before: Union[str, datetime] = None, after: Union[str, datetime] = None,
                                         sort_by: str = None) -> list[ListReport]:
        """
        List BroadWorks Billing Reports

        Search for reports. There are a number of filter options which can be combined in a single request.

        :param before: Only include billing reports created before this date.
        :type before: Union[str, datetime]
        :param after: Only include billing reports created after this date.
        :type after: Union[str, datetime]
        :param sort_by: Sort the reports.

        + Members:
        + id
        + status
        + billingPeriod
        :type sort_by: str
        :rtype: list[ListReport]
        """
        params = {}
        if before is not None:
            if isinstance(before, str):
                before = isoparse(before)
            before = dt_iso_str(before)
            params['before'] = before
        if after is not None:
            if isinstance(after, str):
                after = isoparse(after)
            after = dt_iso_str(after)
            params['after'] = after
        if sort_by is not None:
            params['sortBy'] = sort_by
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[ListReport]).validate_python(data['items'])
        return r

    def get_a_broad_works_billing_report(self, id: str) -> Report:
        """
        Get a BroadWorks Billing Report

        Retrieve a specific billing reconciliation report.

        :param id: A unique identifier for the report in request.
        :type id: str
        :rtype: :class:`Report`
        """
        url = self.ep(f'{id}')
        data = super().get(url)
        r = Report.model_validate(data)
        return r

    def create_a_broad_works_billing_report(self, billing_period: Union[str, datetime]) -> str:
        """
        Create a BroadWorks Billing Report

        Generate a monthly reconciliation report.

        :param billing_period: The year and month (`YYYY-MM`) for which the billing report is to be generated.
        :type billing_period: Union[str, datetime]
        :rtype: str
        """
        body = dict()
        body['billingPeriod'] = billing_period
        url = self.ep()
        data = super().post(url, json=body)
        r = data['id']
        return r

    def delete_a_broad_works_billing_report(self, id: str):
        """
        Delete a BroadWorks Billing Report

        Delete a monthly reconciliation report using a report ID.

        :param id: A unique report ID that corresponds to a billing report.
        :type id: str
        :rtype: None
        """
        url = self.ep(f'{id}')
        super().delete(url)


class BroadWorksEnterprisesApi(ApiChild, base='broadworks/enterprises'):
    """
    BroadWorks Enterprises
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks enterprise information requires an administrator auth token with
    `spark-admin:broadworks_enterprises_read` scope.
    Updating directory sync configuration or trigger directory sync for a Webex for BroadWorks enterprise require an
    administrator auth token with `spark-admin:broadworks_enterprises_write` scope.
    """

    def list_broad_works_enterprises(self, sp_enterprise_id: str = None, starts_with: str = None,
                                     **params) -> Generator[Enterprise, None, None]:
        """
        List BroadWorks Enterprises

        List the provisioned enterprises for a Service Provider. This API also lets a Service Provider search for their
        provisioned enterprises on Webex. A search on enterprises can be performed by either a full or partial
        enterprise identifier.

        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param starts_with: The starting string of the enterprise identifiers to match against.
        :type starts_with: str
        :return: Generator yielding :class:`Enterprise` instances
        """
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if starts_with is not None:
            params['startsWith'] = starts_with
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Enterprise, item_key='items', params=params)

    def update_directory_sync_for_a_broad_works_enterprise(self, id: str,
                                                           enable_dir_sync: str) -> TriggerDirectorySyncResponse:
        """
        Update Directory Sync for a BroadWorks Enterprise

        This API lets a Partner Admin enable or disable directory sync for the customer's Broadworks enterprise on
        Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param enable_dir_sync: The toggle to enable/disable directory sync.
        :type enable_dir_sync: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['enableDirSync'] = enable_dir_sync
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().put(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def trigger_directory_sync_for_an_enterprise(self, id: str, sync_status: str) -> TriggerDirectorySyncResponse:
        """
        Trigger Directory Sync for an Enterprise

        This API lets a Partner Admin trigger a directory sync for the customer's Broadworks enterprise on Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param sync_status: At this time, the only value allowed for this attribute is `SYNC_NOW` which will trigger
            the directory sync for the BroadWorks enterprise.
        :type sync_status: str
        :rtype: :class:`TriggerDirectorySyncResponse`
        """
        body = dict()
        body['syncStatus'] = sync_status
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().post(url, json=body)
        r = TriggerDirectorySyncResponse.model_validate(data)
        return r

    def get_directory_sync_status_for_an_enterprise(self, id: str) -> EnterpriseBroadworksDirectorySync:
        """
        Get Directory Sync Status for an Enterprise

        This API lets a Partner Admin get the most recent directory sync status for a customer's Broadworks enterprise
        on Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :rtype: :class:`EnterpriseBroadworksDirectorySync`
        """
        url = self.ep(f'{id}/broadworksDirectorySync')
        data = super().get(url)
        r = EnterpriseBroadworksDirectorySync.model_validate(data)
        return r

    def trigger_directory_sync_for_a_user(self, id: str, user_id: str = None) -> TriggerUserDirectorySyncResponse:
        """
        Trigger Directory Sync for a User

        This API lets a Partner Admin trigger a directory sync for an external user (real or virtual user) on
        Broadworks enterprise with Webex.

        :param id: A unique identifier for the enterprise in question.
        :type id: str
        :param user_id: The user ID of the Broadworks user to be synced (A non-webex user).
        :type user_id: str
        :rtype: :class:`TriggerUserDirectorySyncResponse`
        """
        body = dict()
        body['userId'] = user_id
        url = self.ep(f'{id}/broadworksDirectorySync/externalUser')
        data = super().post(url, json=body)
        r = TriggerUserDirectorySyncResponse.model_validate(data)
        return r


class BroadWorksSubscribersApi(ApiChild, base='broadworks/subscribers'):
    """
    BroadWorks Subscribers
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Webex Services for their subscribers. Please note
    these APIs require a functional BroadWorks system configured for Webex for BroadWorks. Read more about using this
    API
    at https://www.cisco.com/go/WebexBroadworksAPI.
    
    Viewing Webex for BroadWorks subscriber information requires an administrator auth token with
    `spark-admin:broadworks_subscribers_read` scope. Provisioning, updating, and removing subscribers requires an
    administrator auth token with the `spark-admin:broadworks_subscribers_write` scope.
    
    <div>
    <Callout type="info">Additional Infocodes are given for all success cases. To learn more about the Infocodes used
    in Broadworks Subscriber Provisioning Precheck APIs, see the `Provisioning Precheck API Info Codes
    <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#whats-possible-with-webex-for-broadworks-provisioning-precheck-apis>`_
    guides.</Callout>
    </div>
    """

    def list_broad_works_subscribers(self, user_id: str = None, person_id: str = None, email: str = None,
                                     provisioning_id: str = None, sp_enterprise_id: str = None,
                                     last_status_change: str = None, status: SubscriberStatus = None,
                                     after: str = None, self_activated: bool = None,
                                     **params) -> Generator[Subscriber1, None, None]:
        """
        List BroadWorks Subscribers

        This API lets a Service Provider search for their associated subscribers. There are a number of filter options
        that can be combined in a single request.

        :param user_id: The user ID of the subscriber on BroadWorks.
        :type user_id: str
        :param person_id: The Person ID of the Webex subscriber.
        :type person_id: str
        :param email: The email address of the subscriber.
        :type email: str
        :param provisioning_id: The Provisioning ID associated with this subscriber.
        :type provisioning_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param last_status_change: Only include subscribers with a provisioning status change after this date and time.
            Epoch time (in milliseconds) preferred, but ISO 8601 date format also accepted.
        :type last_status_change: str
        :param status: The provisioning status of the subscriber. This Parameter supports multiple comma separated
            values. For example : status=error,provisioned,provisioning.
        :type status: SubscriberStatus
        :param after: Only include subscribers created after this date and time. Epoch time (in milliseconds)
            preferred, but ISO 8601 date format also accepted.
        :type after: str
        :param self_activated: Indicates if the subscriber was self activated, rather than provisioned via these APIs.
        :type self_activated: bool
        :return: Generator yielding :class:`Subscriber1` instances
        """
        if user_id is not None:
            params['userId'] = user_id
        if person_id is not None:
            params['personId'] = person_id
        if email is not None:
            params['email'] = email
        if provisioning_id is not None:
            params['provisioningId'] = provisioning_id
        if sp_enterprise_id is not None:
            params['spEnterpriseId'] = sp_enterprise_id
        if last_status_change is not None:
            params['lastStatusChange'] = last_status_change
        if status is not None:
            params['status'] = status
        if after is not None:
            params['after'] = after
        if self_activated is not None:
            params['selfActivated'] = str(self_activated).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Subscriber1, item_key='items', params=params)

    def provision_a_broad_works_subscriber(self, provisioning_id: str, user_id: str, sp_enterprise_id: str,
                                           first_name: str, last_name: str, package: SubscriberPackage,
                                           primary_phone_number: str = None, mobile_phone_number: str = None,
                                           extension: Union[str, datetime] = None, email: str = None,
                                           language: str = None, timezone: str = None) -> Subscriber1:
        """
        Provision a BroadWorks Subscriber

        Provision a new BroadWorks subscriber for Webex services.

        This API lets a Service Provider map a BroadWorks subscriber to a new or existing Webex user and assign the
        required licenses and entitlements for Webex and Meetings.

        :param provisioning_id: This Provisioning ID defines how this subscriber is to be provisioned for Webex
            Services.

        Each Customer Template will have their own unique Provisioning ID. This ID will be displayed under the chosen
        Customer Template
        on Webex Partner Hub.
        :type provisioning_id: str
        :param user_id: The user ID of the subscriber on BroadWorks.
        :type user_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param package: The Webex for BroadWorks package to be assigned to the subscriber.
        :type package: SubscriberPackage
        :param primary_phone_number: The primary phone number configured against the subscriber on BroadWorks.
        :type primary_phone_number: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks. Any empty
            value on update will remove the already configured mobile phone number.
        :type mobile_phone_number: str
        :param extension: The extension number configured against the subscriber on BroadWorks.
        :type extension: Union[str, datetime]
        :param email: The email address of the subscriber (mandatory for the trusted email provisioning flow).
        :type email: str
        :param language: The {ISO-639-1}_{ISO-3166} or {ISO-639-1} locale or language code used as preferred language
            for organization and Webex Meeting Sites. Refer to the `help page
            <https://www.cisco.com/content/en/us/td/docs/voice_ip_comm/cloudCollaboration/wx4bwks/Solution_Guide/wbxbw_b_solution-guide/wbxbw_b_SolutionGuide-PDF_chapter_01.html#Cisco_Reference.dita_f10351e1-f775-418d-a700-ec8487e0a33b>`_ for more information.
        :type language: str
        :param timezone: The time zone associated with the subscriber. Refer to the `Webex Meetings Site Timezone
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_
            section of the `Webex for BroadWorks
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide>`_ guide for more information.
        :type timezone: str
        :rtype: :class:`Subscriber1`
        """
        body = dict()
        body['provisioningId'] = provisioning_id
        body['userId'] = user_id
        body['spEnterpriseId'] = sp_enterprise_id
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['package'] = enum_str(package)
        body['primaryPhoneNumber'] = primary_phone_number
        body['mobilePhoneNumber'] = mobile_phone_number
        body['extension'] = extension
        body['email'] = email
        body['language'] = language
        body['timezone'] = timezone
        url = self.ep()
        data = super().post(url, json=body)
        r = Subscriber1.model_validate(data)
        return r

    def get_a_broad_works_subscriber(self, subscriber_id: str) -> Subscriber1:
        """
        Get a BroadWorks Subscriber

        This API lets a Service Provider retrieve details of a provisioned BroadWorks subscriber on Webex.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :rtype: :class:`Subscriber1`
        """
        url = self.ep(f'{subscriber_id}')
        data = super().get(url)
        r = Subscriber1.model_validate(data)
        return r

    def update_a_broad_works_subscriber(self, subscriber_id: str, user_id: str = None, first_name: str = None,
                                        last_name: str = None, primary_phone_number: str = None,
                                        mobile_phone_number: str = None, extension: Union[str, datetime] = None,
                                        timezone: str = None, package: str = None) -> Subscriber1:
        """
        Update a BroadWorks Subscriber

        This API lets a Service Provider update certain details of a provisioned BroadWorks subscriber
        on Webex.

        <div>
        <Callout type='info'>The updated items will not be immediately reflected in the response body, but can be
        subsequently obtained via the `Get a BroadWorks Subscriber
        <https://developer.webex.com/docs/api/v1/broadworks-subscribers/get-a-broadworks-subscriber>`_ API once the status has transitioned from the
        updating state to the provisioned state.</Callout>
        </div>

        o

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :param user_id: The user ID of the subscriber on BroadWorks.
        :type user_id: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param primary_phone_number: The primary phone number configured against the subscriber on BroadWorks.
        :type primary_phone_number: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks. Any empty
            value on update will remove the already configured mobile phone number.
        :type mobile_phone_number: str
        :param extension: The extension number configured against the subscriber on BroadWorks.
        :type extension: Union[str, datetime]
        :param timezone: The time zone associated with the subscriber. Refer to the `Webex Meetings Site Timezone
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_
            section of the `Webex for BroadWorks
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide>`_ guide for more information.
        :type timezone: str
        :param package: The Webex for BroadWorks Package to be assigned to the subscriber.
        :type package: str
        :rtype: :class:`Subscriber1`
        """
        body = dict()
        body['userId'] = user_id
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['primaryPhoneNumber'] = primary_phone_number
        body['mobilePhoneNumber'] = mobile_phone_number
        body['extension'] = extension
        body['timezone'] = timezone
        body['package'] = package
        url = self.ep(f'{subscriber_id}')
        data = super().put(url, json=body)
        r = Subscriber1.model_validate(data)
        return r

    def remove_a_broad_works_subscriber(self, subscriber_id: str):
        """
        Remove a BroadWorks Subscriber

        This API will allow a Service Provider to remove the mapping between a BroadWorks Subscriber and Webex user.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :rtype: None
        """
        url = self.ep(f'{subscriber_id}')
        super().delete(url)

    def precheck_a_broadworks_subscriber_provisioning(self, email: str, provisioning_id: str = None,
                                                      user_id: str = None, sp_enterprise_id: str = None,
                                                      first_name: str = None, last_name: str = None,
                                                      package: SubscriberPackage = None,
                                                      primary_phone_number: str = None,
                                                      mobile_phone_number: str = None, extension: Union[str,
                                                      datetime] = None, language: str = None, timezone: str = None,
                                                      customer_info: PrecheckABroadworksSubscriberProvisioningCustomerInfo = None) -> SubscriberProvisioningPrecheckResponse:
        """
        Precheck a Broadworks Subscriber Provisioning

        Verify the likely success of provisioning a broadworks subscriber.

        <div>
        <Callout type='info'>
        The Prerequisite for using this API is to have at least one Broadworks Cluster configured against partner using
        Partner Hub. The Provisioning Precheck APIs supports two variants of Broadworks Provisioning Precheck
        Requests. Please refer to `Using the Provisioning Precheck API
        <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#using-the-precheck-provisioning-api>`_ section in `Webex for BroadWorks
        information.
        </Callout>
        </div>

        :param email: The email address of the subscriber.
        :type email: str
        :param provisioning_id: Provisioning ID that defines how this subscriber is to be provisioned for Cisco Webex
            Services. Each Customer Template has its unique Provisioning ID. This ID will be displayed under the
            chosen Customer Template on Cisco Webex Control Hub.
        :type provisioning_id: str
        :param user_id: The user ID of the Broadworks subscriber.
        :type user_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the subscriber's enterprise.
        :type sp_enterprise_id: str
        :param first_name: The first name of the subscriber.
        :type first_name: str
        :param last_name: The last name of the subscriber.
        :type last_name: str
        :param package: The Webex for BroadWorks package to be assigned to the subscriber.
        :type package: SubscriberPackage
        :param primary_phone_number: The primary phone number configured for the subscriber on BroadWorks.
        :type primary_phone_number: str
        :param mobile_phone_number: The mobile phone number configured against the subscriber on BroadWorks.
        :type mobile_phone_number: str
        :param extension: The extension number configured against the subscriber on BroadWorks.
        :type extension: Union[str, datetime]
        :param language: The ISO 639-1 language code associated with the subscriber. Reserved for future use. Any value
            currently specified will be ignored during subscriber provisioning.
        :type language: str
        :param timezone: The time zone associated with the subscriber. Refer to the `Webex Meetings Site Timezone
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_
            section of the `Webex for BroadWorks
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide>`_ guide for more information.
        :type timezone: str
        :type customer_info: PrecheckABroadworksSubscriberProvisioningCustomerInfo
        :rtype: :class:`SubscriberProvisioningPrecheckResponse`
        """
        body = dict()
        body['provisioningId'] = provisioning_id
        body['userId'] = user_id
        body['spEnterpriseId'] = sp_enterprise_id
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['package'] = enum_str(package)
        body['primaryPhoneNumber'] = primary_phone_number
        body['mobilePhoneNumber'] = mobile_phone_number
        body['extension'] = extension
        body['email'] = email
        body['language'] = language
        body['timezone'] = timezone
        body['customerInfo'] = loads(customer_info.model_dump_json())
        url = self.ep('validate')
        data = super().post(url, json=body)
        r = SubscriberProvisioningPrecheckResponse.model_validate(data)
        return r


class BroadWorksWorkspacesApi(ApiChild, base='broadworks/workspaces'):
    """
    BroadWorks Workspaces
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    These are a set of APIs that are specifically targeted at BroadWorks Service Providers who sign up to the Webex for
    BroadWorks solution. They enable Service Providers to provision Cisco Webex Services for their workspaces. Please
    note these APIs require a
    functional BroadWorks system configured for Webex for BroadWorks. Read more about using this API at
    https://www.cisco.com/go/WebexBroadworksAPI.
    
    Provisioning, updating, and removing workspaces requires an administrator auth token with the
    `spark-admin:places_write` scope.
    """

    def provision_a_broad_works_workspace(self, provisioning_id: str, user_id: str, sp_enterprise_id: str,
                                          display_name: str, primary_phone_number: str = None,
                                          extension: str = None) -> WorkspaceResponse:
        """
        Provision a BroadWorks Workspace

        Provision a new BroadWorks workspace for Cisco Webex services.

        This API allows a Service Provider to provision a workspace for an existing customer.

        :param provisioning_id: Provisioning ID that defines how this workspace is to be provisioned for Cisco Webex
            Services. Each Customer Template will have their own unique Provisioning ID. This ID will be displayed
            under the chosen Customer Template on Cisco Webex Control Hub.
        :type provisioning_id: str
        :param user_id: The user ID of the workspace on BroadWorks.
        :type user_id: str
        :param sp_enterprise_id: The Service Provider supplied unique identifier for the workspace's enterprise.
        :type sp_enterprise_id: str
        :param display_name: The display name of the workspace.
        :type display_name: str
        :param primary_phone_number: The primary phone number configured against the workspace on BroadWorks.
        :type primary_phone_number: str
        :param extension: The extension number configured against the workspace on BroadWorks.
        :type extension: str
        :rtype: :class:`WorkspaceResponse`
        """
        body = dict()
        body['provisioningId'] = provisioning_id
        body['userId'] = user_id
        body['spEnterpriseId'] = sp_enterprise_id
        body['displayName'] = display_name
        body['primaryPhoneNumber'] = primary_phone_number
        body['extension'] = extension
        url = self.ep()
        data = super().post(url, json=body)
        r = WorkspaceResponse.model_validate(data)
        return r

    def update_a_broadworks_workspace(self, workspace_id: str, user_id: str = None, primary_phone_number: str = None,
                                      extension: str = None) -> WorkspaceResponse:
        """
        Update a Broadworks Workspace

        Update certain details of a provisioned BroadWorks workspace on Cisco Webex.

        :param workspace_id: A unique Cisco identifier for the workspace.
        :type workspace_id: str
        :param user_id: The user ID of the workspace on BroadWorks.
        :type user_id: str
        :param primary_phone_number: The primary phone number configured against the workspace on BroadWorks.
        :type primary_phone_number: str
        :param extension: The extension number configured against the workspace on BroadWorks.
        :type extension: str
        :rtype: :class:`WorkspaceResponse`
        """
        body = dict()
        body['userId'] = user_id
        body['primaryPhoneNumber'] = primary_phone_number
        body['extension'] = extension
        url = self.ep(f'{workspace_id}')
        data = super().put(url, json=body)
        r = WorkspaceResponse.model_validate(data)
        return r

    def remove_a_broad_works_workspace(self, workspace_id: str):
        """
        Remove a BroadWorks Workspace

        Remove the mapping between a BroadWorks workspace and Cisco Webex device.

        :param workspace_id: A unique Cisco identifier for the workspace.
        :type workspace_id: str
        :rtype: None
        """
        url = self.ep(f'{workspace_id}')
        super().delete(url)


class CallControlsApi(ApiChild, base='telephony/calls'):
    """
    Call Controls
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Call Control APIs in support of Webex Calling.
    
    All `GET` commands require the `spark:calls_read` scope while all other commands require the `spark:calls_write`
    scope.
    
    **NOTE**: These APIs support 3rd Party Call Control only.
    """

    def dial(self, destination: str, endpoint_id: str = None) -> DialResponse:
        """
        Dial

        Initiate an outbound call to a specified destination. This is also commonly referred to as Click to Call or
        Click to Dial. Alerts occur on all the devices belonging to a user unless an optional endpointId is specified
        in which case only the device or application identified by the endpointId is alerted. When a user answers an
        alerting device, an outbound call is placed from that device to the destination.

        :param destination: The destination to be dialed. The destination can be digits or a URI. Some examples for
            destination include: `1234`, `2223334444`, `+12223334444`, `*73`, `tel:+12223334444`,
            `user@company.domain`, and `sip:user@company.domain`.
        :type destination: str
        :param endpoint_id: The ID of the device or application to use for the call. The `endpointId` must be one of
            the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['destination'] = destination
        body['endpointId'] = endpoint_id
        url = self.ep('dial')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def answer(self, call_id: str, endpoint_id: str = None):
        """
        Answer

        Answer an incoming call. When no endpointId is specified, the call is answered on the user's primary device.
        When an endpointId is specified, the call is answered on the device or application identified by the
        endpointId. The answer API is rejected if the device is not alerting for the call or the device does not
        support answer via API.

        :param call_id: The call identifier of the call to be answered.
        :type call_id: str
        :param endpoint_id: The ID of the device or application to answer the call on. The `endpointId` must be one of
            the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['endpointId'] = endpoint_id
        url = self.ep('answer')
        super().post(url, json=body)

    def reject(self, call_id: str, action: RejectActionEnum = None):
        """
        Reject

        Reject an unanswered incoming call.

        :param call_id: The call identifier of the call to be rejected.
        :type call_id: str
        :param action: The rejection action to apply to the call. The busy action is applied if no specific action is
            provided.
        :type action: RejectActionEnum
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['action'] = enum_str(action)
        url = self.ep('reject')
        super().post(url, json=body)

    def hangup(self, call_id: str):
        """
        Hangup

        Hangup a call. If used on an unanswered incoming call, the call is rejected and sent to busy.

        :param call_id: The call identifier of the call to hangup.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('hangup')
        super().post(url, json=body)

    def hold(self, call_id: str):
        """
        Hold

        Hold a connected call.

        :param call_id: The call identifier of the call to hold.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('hold')
        super().post(url, json=body)

    def resume(self, call_id: str):
        """
        Resume

        Resume a held call.

        :param call_id: The call identifier of the call to resume.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('resume')
        super().post(url, json=body)

    def divert(self, call_id: str, destination: str = None, to_voicemail: str = None):
        """
        Divert

        Divert a call to a destination or a user's voicemail. This is also commonly referred to as a Blind Transfer.

        :param call_id: The call identifier of the call to divert.
        :type call_id: str
        :param destination: The destination to divert the call to. If toVoicemail is false, destination is required.
            The destination can be digits or a URI. Some examples for destination include: `1234`, `2223334444`,
            `+12223334444`, `*73`, `tel:+12223334444`, `user@company.domain`, `sip:user@company.domain`
        :type destination: str
        :param to_voicemail: If set to true, the call is diverted to voicemail. If no destination is specified, the
            call is diverted to the user's own voicemail. If a destination is specified, the call is diverted to the
            specified user's voicemail.
        :type to_voicemail: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['destination'] = destination
        body['toVoicemail'] = to_voicemail
        url = self.ep('divert')
        super().post(url, json=body)

    def transfer(self, call_id1: str = None, call_id2: str = None, destination: str = None):
        """
        Transfer

        Transfer two calls together.

        Unanswered incoming calls cannot be transferred but can be diverted using the divert API.

        If the user has only two calls and wants to transfer them together, the `callId1` and `callId2` parameters are
        optional and when not provided the calls are automatically selected and transferred.

        If the user has more than two calls and wants to transfer two of them together, the `callId1` and `callId2`
        parameters are mandatory to specify which calls are being transferred. Those are also commonly referred to as
        Attended Transfer, Consultative Transfer, or Supervised Transfer and will return a `204` response.

        If the user wants to transfer one call to a new destination but only when the destination responds, the
        `callId1` and destination parameters are mandatory to specify the call being transferred and the destination.

        This is referred to as a Mute Transfer and is similar to the divert API with the difference of waiting for the
        destination to respond prior to transferring the call. If the destination does not respond, the call is not
        transferred. This will return a `201` response.

        :param call_id1: The call identifier of the first call to transfer. This parameter is mandatory if either
            `callId2` or `destination` is provided.
        :type call_id1: str
        :param call_id2: The call identifier of the second call to transfer. This parameter is mandatory if `callId1`
            is provided and `destination` is not provided.
        :type call_id2: str
        :param destination: The destination to be transferred to. The destination can be digits or a URI. Some examples
            for destination include: `1234`, `2223334444`, `+12223334444`, `tel:+12223334444`, `user@company.domain`,
            `sip:user@company.domain`. This parameter is mandatory if `callId1` is provided and `callId2` is not
            provided.
        :type destination: str
        :rtype: None
        """
        body = dict()
        body['callId1'] = call_id1
        body['callId2'] = call_id2
        body['destination'] = destination
        url = self.ep('transfer')
        super().post(url, json=body)

    def park(self, call_id: str, destination: Union[str, datetime] = None,
             is_group_park: str = None) -> PartyInformation:
        """
        Park

        Park a connected call. The number field in the response can be used as the destination for the retrieve command
        to retrieve the parked call.

        :param call_id: The call identifier of the call to park.
        :type call_id: str
        :param destination: Identifes where the call is to be parked. If not provided, the call is parked against the
            parking user. The destination can be digits or a URI. Some examples for destination include: `1234`,
            `2223334444`, `+12223334444`, `*73`, `tel:+12223334444`, `user@company.domain`, `sip:user@company.domain`
        :type destination: Union[str, datetime]
        :param is_group_park: If set to`true`, the call is parked against an automatically selected member of the
            user's call park group and the destination parameter is ignored.
        :type is_group_park: str
        :rtype: PartyInformation
        """
        body = dict()
        body['callId'] = call_id
        body['destination'] = destination
        body['isGroupPark'] = is_group_park
        url = self.ep('park')
        data = super().post(url, json=body)
        r = PartyInformation.model_validate(data['parkedAgainst'])
        return r

    def retrieve(self, destination: Union[str, datetime] = None, endpoint_id: str = None) -> DialResponse:
        """
        Retrieve

        Retrieve a parked call. A new call is initiated to perform the retrieval in a similar manner to the dial
        command. The number field from the park command response can be used as the destination for the retrieve
        command.

        :param destination: Identifies where the call is parked. The number field from the park command response can be
            used as the destination for the retrieve command. If not provided, the call parked against the retrieving
            user is retrieved. The destination can be digits or a URI. Some examples for destination include: `1234`,
            `2223334444`, `+12223334444`, `*73`, `tel:+12223334444`, `user@company.domain`, `sip:user@company.domain`
        :type destination: Union[str, datetime]
        :param endpoint_id: The ID of the device or application to use for the retrieval. The `endpointId` must be one
            of the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['destination'] = destination
        body['endpointId'] = endpoint_id
        url = self.ep('retrieve')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def start_recording(self, call_id: str = None):
        """
        Start Recording

        Start recording a call. Use of this API is only valid when the user's call recording mode is set to "On
        Demand".

        :param call_id: The call identifier of the call to start recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('startRecording')
        super().post(url, json=body)

    def stop_recording(self, call_id: str = None):
        """
        Stop Recording

        Stop recording a call. Use of this API is only valid when a call is being recorded and the user's call
        recording mode is set to "On Demand".

        :param call_id: The call identifier of the call to stop recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('stopRecording')
        super().post(url, json=body)

    def pause_recording(self, call_id: str = None):
        """
        Pause Recording

        Pause recording on a call. Use of this API is only valid when a call is being recorded and the user's call
        recording mode is set to "On Demand" or "Always with Pause/Resume".

        :param call_id: The call identifier of the call to pause recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('pauseRecording')
        super().post(url, json=body)

    def resume_recording(self, call_id: str = None):
        """
        Resume Recording

        Resume recording a call. Use of this API is only valid when a call's recording is paused and the user's call
        recording mode is set to "On Demand" or "Always with Pause/Resume".

        :param call_id: The call identifier of the call to resume recording.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('resumeRecording')
        super().post(url, json=body)

    def transmit_dtmf(self, call_id: str = None, dtmf: Union[str, datetime] = None):
        """
        Transmit DTMF

        Transmit DTMF digits to a call.

        :param call_id: The call identifier of the call to transmit DTMF digits for.
        :type call_id: str
        :param dtmf: The DTMF digits to transmit. Each digit must be part of the following set: `[0, 1, 2, 3, 4, 5, 6,
            7, 8, 9, *, #, A, B, C, D]`. A comma "," may be included to indicate a pause between digits. For the value
            1,234, the DTMF 1 digit is initially sent. After a pause, the DTMF 2, 3, and 4 digits are sent
            successively.
        :type dtmf: Union[str, datetime]
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        body['dtmf'] = dtmf
        url = self.ep('transmitDtmf')
        super().post(url, json=body)

    def push(self, call_id: str = None):
        """
        Push

        Pushes a call from the assistant to the executive the call is associated with. Use of this API is only valid
        when the assistant's call is associated with an executive.

        :param call_id: The call identifier of the call to push.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('push')
        super().post(url, json=body)

    def pickup(self, target: Union[str, datetime] = None, endpoint_id: str = None) -> DialResponse:
        """
        Pickup

        Picks up an incoming call to another user. A new call is initiated to perform the pickup in a similar manner to
        the dial command. When target is not present, the API pickups up a call from the user's call pickup group.
        When target is present, the API pickups an incoming call from the specified target user.

        :param target: Identifies the user to pickup an incoming call from. If not provided, an incoming call to the
            user's call pickup group is picked up. The target can be digits or a URI. Some examples for target
            include: `1234`, `2223334444`, `+12223334444`, `tel:+12223334444`, `user@company.domain`,
            `sip:user@company.domain`
        :type target: Union[str, datetime]
        :param endpoint_id: The ID of the device or application to use for the pickup. The `endpointId` must be one of
            the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['target'] = target
        body['endpointId'] = endpoint_id
        url = self.ep('pickup')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def barge_in(self, target: Union[str, datetime], endpoint_id: str = None) -> DialResponse:
        """
        Barge In

        Barge-in on another user's answered call. A new call is initiated to perform the barge-in in a similar manner
        to the dial command.

        :param target: Identifies the user to barge-in on. The target can be digits or a URI. Some examples for target
            include: `1234`, `2223334444`, `+12223334444`, `tel:+12223334444`, `user@company.domain`,
            `sip:user@company.domain`
        :type target: Union[str, datetime]
        :param endpoint_id: The ID of the device or application to use for the barge-in. The `endpointId` must be one
            of the endpointIds returned by the `Get Preferred Answer Endpoint API
            <https://developer.webex.com/docs/api/v1/user-call-settings/get-preferred-answer-endpoint>`_.
        :type endpoint_id: str
        :rtype: :class:`DialResponse`
        """
        body = dict()
        body['target'] = target
        body['endpointId'] = endpoint_id
        url = self.ep('bargeIn')
        data = super().post(url, json=body)
        r = DialResponse.model_validate(data)
        return r

    def list_calls(self) -> list[Call]:
        """
        List Calls

        Get the list of details for all active calls associated with the user.

        :rtype: list[Call]
        """
        url = self.ep()
        data = super().get(url)
        r = TypeAdapter(list[Call]).validate_python(data['items'])
        return r

    def get_call_details(self, call_id: str) -> Call:
        """
        Get Call Details

        Get the details of the specified active call for the user.

        :param call_id: The call identifier of the call.
        :type call_id: str
        :rtype: :class:`Call`
        """
        url = self.ep(f'{call_id}')
        data = super().get(url)
        r = Call.model_validate(data)
        return r

    def list_call_history(self, type: CallHistoryRecordTypeEnum = None) -> list[CallHistoryRecord]:
        """
        List Call History

        Get the list of call history records for the user. A maximum of 20 call history records per type (`placed`,
        `missed`, `received`) are returned.

        :param type: The type of call history records to retrieve. If not specified, then all call history records are
            retrieved.
        :type type: CallHistoryRecordTypeEnum
        :rtype: list[CallHistoryRecord]
        """
        params = {}
        if type is not None:
            params['type'] = type
        url = self.ep('history')
        data = super().get(url, params=params)
        r = TypeAdapter(list[CallHistoryRecord]).validate_python(data['items'])
        return r


class CallMembershipsApi(ApiChild, base='call/memberships'):
    """
    Call Memberships
    
    The Call Memberships functionality and API endpoints described here are
    currently pre-release features which are not available to all Webex users. If
    you have any questions, or if you need help, please contact the Webex
    Developer Support team at devsupport@webex.com.
    
    
    
    Call Memberships represent a person's relationship to a call. Use this API to list members of any call that you're
    in or have been invited to.
    
    To see information about calls, use the `Calls API
    <https://developer.webex.com/docs/api/v1/calls>`_.
    
    For more information about Calls and Call Memberships, see the `Calls
    <https://developer.webex.com/docs/api/guides/calls>`_ guide.
    """

    def list_call_memberships(self, call_status: ListCallMembershipsCallStatus, call_id: str = None,
                              is_host: ListCallMembershipsIsHost = None, person_id: str = None,
                              status: CallMembershipStatus = None, from_: Union[str, datetime] = None, to_: Union[str,
                              datetime] = None, **params) -> Generator[CallMembership, None, None]:
        """
        List Call Memberships

        List call memberships.

        By default, lists call memberships for all calls in which the authenticated user is an active participant.
        Viewing all call memberships in your Organization requires an administrator auth token with the
        `spark-admin:call_memberships_read` scope.

        Use query parameters to filter the result set. Results are in descending `created` order.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param call_status: Limit results to call memberships for calls with the specified status.
        :type call_status: ListCallMembershipsCallStatus
        :param call_id: Limit results to call memberships for a call, by call ID.
        :type call_id: str
        :param is_host: Limit results to call memberships for calls hosted by the authenticated user.
        :type is_host: ListCallMembershipsIsHost
        :param person_id: Limit results to call memberships belonging to a person, by person ID.
        :type person_id: str
        :param status: Limit to call memberships with the specified status.
        :type status: CallMembershipStatus
        :param from_: Limit results to call memberships for calls that started from the inclusive start date, in
            ISO8601 format.
        :type from_: Union[str, datetime]
        :param to_: Limit results to call memberships for calls that ended before the exclusive end date, in ISO8601
            format.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`CallMembership` instances
        """
        params['callStatus'] = call_status
        if call_id is not None:
            params['callId'] = call_id
        if is_host is not None:
            params['isHost'] = is_host
        if person_id is not None:
            params['personId'] = person_id
        if status is not None:
            params['status'] = status
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep()
        return self.session.follow_pagination(url=url, model=CallMembership, item_key='items', params=params)

    def get_call_membership_details(self, call_membership_id: str) -> CallMembership:
        """
        Get Call Membership Details

        Shows details for a call, by call ID.

        Specify the call ID in the `callId` parameter in the URI.

        :param call_membership_id: The unique identifier for the call membership.
        :type call_membership_id: str
        :rtype: :class:`CallMembership`
        """
        url = self.ep(f'{call_membership_id}')
        data = super().get(url)
        r = CallMembership.model_validate(data)
        return r


class CallQualitiesApi(ApiChild, base='call/qualities'):
    """
    Call Qualities
    
    After a meeting has ended, meeting quality information is available for review by organization administrators.
    Quality information is available 30 minutes after a meeting has ended and may be retrieved for up to 30 days. To
    retrieve quality information, you must use an administrator API access token with the
    `spark-admin:call_qualities_read` `scope
    <https://developer.webex.com/docs/integrations#scopes>`_.
    
    For more information, see the `Calls
    <https://developer.webex.com/docs/api/guides/calls>`_ guide.
    """

    def get_call_qualities(self, call_id: str, **params) -> Generator[MediaSessionQuality, None, None]:
        """
        Get Call Qualities

        Provides quality data for a meeting, by `callId`. Only organization administrators can retrieve meeting quality
        data. Quality information is available 30 minutes after a meeting has ended and may be retrieved for up to 30
        days.

        :param call_id: The identifier of the call.
        :type call_id: str
        :return: Generator yielding :class:`MediaSessionQuality` instances
        """
        params['callId'] = call_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=MediaSessionQuality, item_key='items', params=params)


class CallRoutingApi(ApiChild, base='telephony/config'):
    """
    Call Routing
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Routing supports reading and writing of Webex Calling On-premises, also known as Local Gateway, Call
    Routing PSTN settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def test_call_routing(self, originator_id: str, originator_type: OriginatorType, destination: Union[str, datetime],
                          org_id: str = None, originator_number: str = None) -> TestCallRoutingPostResponse:
        """
        Test Call Routing

        Validates that an incoming call can be routed.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Test call routing requires a full or write-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param originator_id: This element is used to identify the originating party.  It can be user UUID or trunk
            UUID.
        :type originator_id: str
        :param originator_type: `USER` or `TRUNK`.
        :type originator_type: OriginatorType
        :param destination: This element specifies called party.  It can be any dialable string, for example, an ESN
            number, E.164 number, hosted user DN, extension, extension with location code, URL, FAC code.
        :type destination: Union[str, datetime]
        :param org_id: Organization in which we are validating a call routing.
        :type org_id: str
        :param originator_number: Only used when originatorType is `TRUNK`. This element could be a phone number or
            URI.
        :type originator_number: str
        :rtype: :class:`TestCallRoutingPostResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['originatorId'] = originator_id
        body['originatorType'] = enum_str(originator_type)
        body['originatorNumber'] = originator_number
        body['destination'] = destination
        url = self.ep('actions/testCallRouting/invoke')
        data = super().post(url, params=params, json=body)
        r = TestCallRoutingPostResponse.model_validate(data)
        return r

    def get_local_gateway_dial_plan_usage_for_a_trunk(self, trunk_id: str, org_id: str = None, start: int = None,
                                                      order: str = None, name: list[str] = None,
                                                      **params) -> Generator[Location, None, None]:
        """
        Get Local Gateway Dial Plan Usage for a Trunk

        Get Local Gateway Dial Plan Usage for a Trunk.

        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.

        Retrieving this information requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the trunks according to the designated fields.  Available sort fields are `name`, and
            `locationName`. Sort order is ascending by default
        :type order: str
        :param name: Return the list of trunks matching the local gateway names
        :type name: list[str]
        :return: Generator yielding :class:`Location` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = ','.join(name)
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usageDialPlan')
        return self.session.follow_pagination(url=url, model=Location, item_key='dialPlans', params=params)

    def get_locations_using_the_local_gateway_as_pstn_connection_routing(self, trunk_id: str,
                                                                         org_id: str = None) -> list[Location]:
        """
        Get Locations Using the Local Gateway as PSTN Connection Routing

        Get Locations Using the Local Gateway as PSTN Connection Routing.

        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.

        Retrieving this information requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str
        :rtype: list[Location]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usagePstnConnection')
        data = super().get(url, params=params)
        r = TypeAdapter(list[Location]).validate_python(data['locations'])
        return r

    def get_route_groups_using_the_local_gateway(self, trunk_id: str, org_id: str = None) -> list[RouteGroup]:
        """
        Get Route Groups Using the Local Gateway

        Get Route Groups Using the Local Gateway.

        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.

        Retrieving this information requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str
        :rtype: list[RouteGroup]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usageRouteGroup')
        data = super().get(url, params=params)
        r = TypeAdapter(list[RouteGroup]).validate_python(data['routeGroup'])
        return r

    def get_local_gateway_usage_count(self, trunk_id: str, org_id: str = None) -> LocalGatewayUsageCount:
        """
        Get Local Gateway Usage Count

        Get Local Gateway Usage Count

        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.

        Retrieving this information requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str
        :rtype: :class:`LocalGatewayUsageCount`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usage')
        data = super().get(url, params=params)
        r = LocalGatewayUsageCount.model_validate(data)
        return r

    def modify_dial_patterns(self, dial_plan_id: str, dial_patterns: list[DialPattern], delete_all_dial_patterns: bool,
                             org_id: str = None):
        """
        Modify Dial Patterns

        Modify dial patterns for the Dial Plan.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Modifying a dial pattern requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param dial_plan_id: ID of the dial plan being modified.
        :type dial_plan_id: str
        :param dial_patterns: Array of dial patterns to add or delete. Dial Pattern that is not present in the request
            is not modified.
        :type dial_patterns: list[DialPattern]
        :param delete_all_dial_patterns: Delete all the dial patterns for a dial plan.
        :type delete_all_dial_patterns: bool
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['dialPatterns'] = loads(TypeAdapter(list[DialPattern]).dump_json(dial_patterns))
        body['deleteAllDialPatterns'] = delete_all_dial_patterns
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}/dialPatterns')
        super().put(url, params=params, json=body)

    def validate_a_dial_pattern(self, dial_patterns: list[str], org_id: str = None) -> DialPatternValidateResult:
        """
        Validate a Dial Pattern

        Validate a Dial Pattern.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Validating a dial pattern requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param dial_patterns: Array of dial patterns.
        :type dial_patterns: list[str]
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :rtype: :class:`DialPatternValidateResult`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['dialPatterns'] = dial_patterns
        url = self.ep('premisePstn/actions/validateDialPatterns/invoke')
        data = super().post(url, params=params, json=body)
        r = DialPatternValidateResult.model_validate(data)
        return r

    def read_the_list_of_dial_plans(self, org_id: str = None, dial_plan_name: str = None, route_group_name: str = None,
                                    trunk_name: str = None, start: int = None, order: str = None,
                                    **params) -> Generator[DialPlan, None, None]:
        """
        Read the List of Dial Plans

        List all Dial Plans for the organization.

        Dial plans route calls to on-premises destinations by use of the trunks or route groups with which the dial
        plan is associated. Multiple dial patterns can be defined as part of your dial plan.  Dial plans are
        configured globally for an enterprise and apply to all users, regardless of location.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List dial plans for this organization.
        :type org_id: str
        :param dial_plan_name: Return the list of dial plans matching the dial plan name.
        :type dial_plan_name: str
        :param route_group_name: Return the list of dial plans matching the Route group name..
        :type route_group_name: str
        :param trunk_name: Return the list of dial plans matching the Trunk name..
        :type trunk_name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the dial plans according to the designated fields.  Available sort fields: `name`,
            `routeName`, `routeType`. Sort order is ascending by default
        :type order: str
        :return: Generator yielding :class:`DialPlan` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if dial_plan_name is not None:
            params['dialPlanName'] = dial_plan_name
        if route_group_name is not None:
            params['routeGroupName'] = route_group_name
        if trunk_name is not None:
            params['trunkName'] = trunk_name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/dialPlans')
        return self.session.follow_pagination(url=url, model=DialPlan, item_key='dialPlans', params=params)

    def create_a_dial_plan(self, name: str, route_id: str, route_type: RouteType, dial_patterns: list[str],
                           org_id: str = None) -> str:
        """
        Create a Dial Plan

        Create a Dial Plan for the organization.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Creating a dial plan requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param name: A unique name for the dial plan.
        :type name: str
        :param route_id: ID of route type associated with the dial plan.
        :type route_id: str
        :param route_type: Route Type associated with the dial plan.
        :type route_type: RouteType
        :param dial_patterns: An Array of dial patterns.
        :type dial_patterns: list[str]
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['routeId'] = route_id
        body['routeType'] = enum_str(route_type)
        body['dialPatterns'] = dial_patterns
        url = self.ep('premisePstn/dialPlans')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_a_dial_plan(self, dial_plan_id: str, org_id: str = None) -> DialPlanGet:
        """
        Get a Dial Plan

        Get a Dial Plan for the organization.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Retrieving a dial plan requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param dial_plan_id: ID of the dial plan.
        :type dial_plan_id: str
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :rtype: :class:`DialPlanGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}')
        data = super().get(url, params=params)
        r = DialPlanGet.model_validate(data)
        return r

    def modify_a_dial_plan(self, dial_plan_id: str, name: str, route_id: str, route_type: RouteType,
                           org_id: str = None):
        """
        Modify a Dial Plan

        Modify a Dial Plan for the organization.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Modifying a dial plan requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param dial_plan_id: ID of the dial plan being modified.
        :type dial_plan_id: str
        :param name: A unique name for the dial plan.
        :type name: str
        :param route_id: ID of route type associated with the dial plan.
        :type route_id: str
        :param route_type: Route Type associated with the dial plan.
        :type route_type: RouteType
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['routeId'] = route_id
        body['routeType'] = enum_str(route_type)
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}')
        super().put(url, params=params, json=body)

    def delete_a_dial_plan(self, dial_plan_id: str, org_id: str = None):
        """
        Delete a Dial Plan

        Delete a Dial Plan for the organization.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Deleting a dial plan requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param dial_plan_id: ID of the dial plan.
        :type dial_plan_id: str
        :param org_id: Organization to which dial plan belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}')
        super().delete(url, params=params)

    def validate_local_gateway_fqdn_and_domain_for_a_trunk(self, address: str, domain: str, port: int,
                                                           org_id: str = None):
        """
        Validate Local Gateway FQDN and Domain for a Trunk

        Validate Local Gateway FQDN and Domain for the organization trunks.

        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.

        Validating Local Gateway FQDN and Domain requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param address: FQDN or SRV address of the trunk.
        :type address: str
        :param domain: Domain name of the trunk.
        :type domain: str
        :param port: FQDN port of the trunk.
        :type port: int
        :param org_id: Organization to which trunk types belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['address'] = address
        body['domain'] = domain
        body['port'] = port
        url = self.ep('premisePstn/trunks/actions/fqdnValidation/invoke')
        super().post(url, params=params, json=body)

    def read_the_list_of_trunks(self, org_id: str = None, name: list[str] = None, location_name: list[str] = None,
                                trunk_type: str = None, start: int = None, order: str = None,
                                **params) -> Generator[Trunk, None, None]:
        """
        Read the List of Trunks

        List all Trunks for the organization.

        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List trunks for this organization.
        :type org_id: str
        :param name: Return the list of trunks matching the local gateway names.
        :type name: list[str]
        :param location_name: Return the list of trunks matching the location names.
        :type location_name: list[str]
        :param trunk_type: Return the list of trunks matching the trunk type.
        :type trunk_type: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the trunks according to the designated fields.  Available sort fields: name, locationName.
            Sort order is ascending by default
        :type order: str
        :return: Generator yielding :class:`Trunk` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = ','.join(name)
        if location_name is not None:
            params['locationName'] = ','.join(location_name)
        if trunk_type is not None:
            params['trunkType'] = trunk_type
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/trunks')
        return self.session.follow_pagination(url=url, model=Trunk, item_key='trunks', params=params)

    def create_a_trunk(self, name: str, location_id: str, password: str, dual_identity_support_enabled: bool,
                       trunk_type: TrunkType, device_type: str, address: str, domain: str, port: int,
                       max_concurrent_calls: int, org_id: str = None) -> str:
        """
        Create a Trunk

        Create a Trunk for the organization.

        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.

        Creating a trunk requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param name: A unique name for the trunk.
        :type name: str
        :param location_id: ID of location associated with the trunk.
        :type location_id: str
        :param password: A password to use on the trunk.
        :type password: str
        :param dual_identity_support_enabled: Dual Identity Support setting impacts the handling of the From header and
            P-Asserted-Identity header when sending an initial SIP `INVITE` to the trunk for an outbound call.
        :type dual_identity_support_enabled: bool
        :param trunk_type: Trunk Type associated with the trunk.
        :type trunk_type: TrunkType
        :param device_type: Device type assosiated with trunk.
        :type device_type: str
        :param address: FQDN or SRV address. Required to create a static certificate-based trunk.
        :type address: str
        :param domain: Domain name. Required to create a static certificate based trunk.
        :type domain: str
        :param port: FQDN port. Required to create a static certificate-based trunk.
        :type port: int
        :param max_concurrent_calls: Max Concurrent call. Required to create a static certificate based trunk.
        :type max_concurrent_calls: int
        :param org_id: Organization to which trunk belongs.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['locationId'] = location_id
        body['password'] = password
        body['dualIdentitySupportEnabled'] = dual_identity_support_enabled
        body['trunkType'] = enum_str(trunk_type)
        body['deviceType'] = device_type
        body['address'] = address
        body['domain'] = domain
        body['port'] = port
        body['maxConcurrentCalls'] = max_concurrent_calls
        url = self.ep('premisePstn/trunks')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_a_trunk(self, trunk_id: str, org_id: str = None) -> TrunkGet:
        """
        Get a Trunk

        Get a Trunk for the organization.

        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.

        Retrieving a trunk requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which trunk belongs.
        :type org_id: str
        :rtype: :class:`TrunkGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}')
        data = super().get(url, params=params)
        r = TrunkGet.model_validate(data)
        return r

    def modify_a_trunk(self, trunk_id: str, name: str, password: str, dual_identity_support_enabled: bool,
                       max_concurrent_calls: int, org_id: str = None):
        """
        Modify a Trunk

        Modify a Trunk for the organization.

        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.

        Modifying a trunk requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param trunk_id: ID of the trunk being modified.
        :type trunk_id: str
        :param name: A unique name for the dial plan.
        :type name: str
        :param password: A password to use on the trunk.
        :type password: str
        :param dual_identity_support_enabled: Determines the behavior of the From and PAI headers on outbound calls.
        :type dual_identity_support_enabled: bool
        :param max_concurrent_calls: Max Concurrent call. Required to create a static certificate-based trunk.
        :type max_concurrent_calls: int
        :param org_id: Organization to which trunk belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['password'] = password
        body['dualIdentitySupportEnabled'] = dual_identity_support_enabled
        body['maxConcurrentCalls'] = max_concurrent_calls
        url = self.ep(f'premisePstn/trunks/{trunk_id}')
        super().put(url, params=params, json=body)

    def delete_a_trunk(self, trunk_id: str, org_id: str = None):
        """
        Delete a Trunk

        Delete a Trunk for the organization.

        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group - a group of trunks that allow Webex Calling to distribute calls
        over multiple trunks or to provide redundancy.

        Deleting a trunk requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which trunk belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/trunks/{trunk_id}')
        super().delete(url, params=params)

    def read_the_list_of_trunk_types(self, org_id: str = None) -> list[TrunkTypeWithDeviceType]:
        """
        Read the List of Trunk Types

        List all Trunk Types with Device Types for the organization.

        A Trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy. Trunk Types are Registering or Certificate Based and are
        configured in Call Manager.

        Retrieving trunk types requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Organization to which the trunk types belong.
        :type org_id: str
        :rtype: list[TrunkTypeWithDeviceType]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('premisePstn/trunks/trunkTypes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[TrunkTypeWithDeviceType]).validate_python(data['trunkTypes'])
        return r

    def read_the_list_of_routing_groups(self, org_id: str = None, name: str = None, start: int = None,
                                        order: str = None, **params) -> Generator[RouteGroup, None, None]:
        """
        Read the List of Routing Groups

        List all Route Groups for an organization. A Route Group is a group of trunks that allows further scale and
        redundancy with the connection to the premises.

        Retrieving this route group list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List route groups for this organization.
        :type org_id: str
        :param name: Return the list of route groups matching the Route group name..
        :type name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the route groups according to designated fields.  Available sort orders are `asc` and
            `desc`.
        :type order: str
        :return: Generator yielding :class:`RouteGroup` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/routeGroups')
        return self.session.follow_pagination(url=url, model=RouteGroup, item_key='routeGroups', params=params)

    def create_route_group_for_a_organization(self, name: str, local_gateways: list[LocalGateways],
                                              org_id: str = None) -> str:
        """
        Create Route Group for a Organization

        Creates a Route Group for the organization.

        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.

        Creating a Route Group requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param name: A unique name for the Route Group.
        :type name: str
        :param local_gateways: Local Gateways that are part of this Route Group.
        :type local_gateways: list[LocalGateways]
        :param org_id: Organization to which the Route Group belongs.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['localGateways'] = loads(TypeAdapter(list[LocalGateways]).dump_json(local_gateways))
        url = self.ep('premisePstn/routeGroups')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def read_a_route_group_for_a_organization(self, route_group_id: str, org_id: str = None) -> RouteGroupGet:
        """
        Read a Route Group for a Organization

        Reads a Route Group for the organization based on id.

        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.

        Reading a Route Group requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param route_group_id: Route Group for which details are being requested.
        :type route_group_id: str
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: :class:`RouteGroupGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}')
        data = super().get(url, params=params)
        r = RouteGroupGet.model_validate(data)
        return r

    def modify_a_route_group_for_a_organization(self, route_group_id: str, name: str,
                                                local_gateways: list[LocalGateways], org_id: str = None):
        """
        Modify a Route Group for a Organization

        Modifies an existing Route Group for an organization based on id.

        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.

        Modifying a Route Group requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param route_group_id: Route Group for which details are being requested.
        :type route_group_id: str
        :param name: A unique name for the Route Group.
        :type name: str
        :param local_gateways: Local Gateways that are part of this Route Group.
        :type local_gateways: list[LocalGateways]
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['localGateways'] = loads(TypeAdapter(list[LocalGateways]).dump_json(local_gateways))
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}')
        super().put(url, params=params, json=body)

    def remove_a_route_group_from_an_organization(self, route_group_id: str, org_id: str = None):
        """
        Remove a Route Group from an Organization

        Remove a Route Group from an Organization based on id.

        A Route Group is a collection of trunks that allows further scale and redundancy with the connection to the
        premises. Route groups can include up to 10 trunks from different locations.

        Removing a Route Group requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param route_group_id: Route Group for which details are being requested.
        :type route_group_id: str
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}')
        super().delete(url, params=params)

    def read_the_usage_of_a_routing_group(self, route_group_id: str,
                                          org_id: str = None) -> ReadTheUsageOfARoutingGroupResponse:
        """
        Read the Usage of a Routing Group

        List the number of "Call to" on-premises Extensions, Dial Plans, PSTN Connections, and Route Lists used by a
        specific Route Group.
        Users within Call to Extension locations are registered to a PBX which allows you to route unknown extensions
        (calling number length of 2-6 digits) to the PBX using an existing Trunk or Route Group.
        PSTN Connections may be a Cisco PSTN, a cloud-connected PSTN, or a premises-based PSTN (local gateway).
        Dial Plans allow you to route calls to on-premises extensions via your trunk or route group.
        Route Lists are a list of numbers that can be reached via a route group and can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Retrieving usage information requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with the specific route group.
        :type org_id: str
        :rtype: :class:`ReadTheUsageOfARoutingGroupResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usage')
        data = super().get(url, params=params)
        r = ReadTheUsageOfARoutingGroupResponse.model_validate(data)
        return r

    def read_the_call_to_extension_locations_of_a_routing_group(self, route_group_id: str, org_id: str = None,
                                                                location_name: str = None, start: int = None,
                                                                order: str = None,
                                                                **params) -> Generator[Location, None, None]:
        """
        Read the Call to Extension Locations of a Routing Group

        List "Call to" on-premises Extension Locations for a specific route group. Users within these locations are
        registered to a PBX which allows you to route unknown extensions (calling number length of 2-6 digits) to the
        PBX using an existing trunk or route group.

        Retrieving this location list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param location_name: Return the list of locations matching the location name.
        :type location_name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the locations according to designated fields.  Available sort orders are `asc`, and `desc`.
        :type order: str
        :return: Generator yielding :class:`Location` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_name is not None:
            params['locationName'] = location_name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usageCallToExtension')
        return self.session.follow_pagination(url=url, model=Location, item_key='locations', params=params)

    def read_the_dial_plan_locations_of_a_routing_group(self, route_group_id: str, org_id: str = None,
                                                        location_name: str = None, start: int = None,
                                                        order: str = None,
                                                        **params) -> Generator[Location, None, None]:
        """
        Read the Dial Plan Locations of a Routing Group

        List Dial Plan Locations for a specific route group.

        Dial Plans allow you to route calls to on-premises destinations by use of trunks or route groups. They are
        configured globally for an enterprise and apply to all users, regardless of location.
        A Dial Plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns. Specific dial patterns can be defined as part of your dial plan.

        Retrieving this location list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param location_name: Return the list of locations matching the location name.
        :type location_name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the locations according to designated fields.  Available sort orders are `asc`, and `desc`.
        :type order: str
        :return: Generator yielding :class:`Location` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_name is not None:
            params['locationName'] = location_name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usageDialPlan')
        return self.session.follow_pagination(url=url, model=Location, item_key='locations', params=params)

    def read_the_pstn_connection_locations_of_a_routing_group(self, route_group_id: str, org_id: str = None,
                                                              location_name: str = None, start: int = None,
                                                              order: str = None,
                                                              **params) -> Generator[Location, None, None]:
        """
        Read the PSTN Connection Locations of a Routing Group

        List PSTN Connection Locations for a specific route group. This solution lets you configure users to use Cloud
        PSTN (CCP or Cisco PSTN) or Premises-based PSTN.

        Retrieving this Location list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param location_name: Return the list of locations matching the location name.
        :type location_name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the locations according to designated fields.  Available sort orders are `asc`, and `desc`.
        :type order: str
        :return: Generator yielding :class:`Location` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_name is not None:
            params['locationName'] = location_name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usagePstnConnection')
        return self.session.follow_pagination(url=url, model=Location, item_key='locations', params=params)

    def read_the_route_lists_of_a_routing_group(self, route_group_id: str, org_id: str = None, name: str = None,
                                                start: int = None, order: str = None,
                                                **params) -> Generator[RouteGroupUsageRouteListGet, None, None]:
        """
        Read the Route Lists of a Routing Group

        List Route Lists for a specific route group. Route Lists are a list of numbers that can be reached via a Route
        Group. It can be used to provide cloud PSTN connectivity to Webex Calling Dedicated Instance.

        Retrieving this list of Route Lists requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param route_group_id: ID of the requested Route group.
        :type route_group_id: str
        :param org_id: Organization associated with specific route group.
        :type org_id: str
        :param name: Return the list of locations matching the location name.
        :type name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the locations according to designated fields.  Available sort orders are `asc`, and `desc`.
        :type order: str
        :return: Generator yielding :class:`RouteGroupUsageRouteListGet` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/routeGroups/{route_group_id}/usageRouteList')
        return self.session.follow_pagination(url=url, model=RouteGroupUsageRouteListGet, item_key='routeGroupUsageRouteListGet', params=params)

    def read_the_list_of_route_lists(self, org_id: str = None, name: list[str] = None, location_id: list[str] = None,
                                     start: int = None, order: str = None,
                                     **params) -> Generator[RouteList, None, None]:
        """
        Read the List of Route Lists

        List all Route Lists for the organization.

        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Retrieving the Route List requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List all Route List for this organization.
        :type org_id: str
        :param name: Return the list of Route List matching the route list name.
        :type name: list[str]
        :param location_id: Return the list of Route Lists matching the location id.
        :type location_id: list[str]
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the Route List according to the designated fields. Available sort fields are `name`, and
            `locationId`. Sort order is ascending by default
        :type order: str
        :return: Generator yielding :class:`RouteList` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = ','.join(name)
        if location_id is not None:
            params['locationId'] = ','.join(location_id)
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep('premisePstn/routeLists')
        return self.session.follow_pagination(url=url, model=RouteList, item_key='routeLists', params=params)

    def create_a_route_list(self, name: str, location_id: str, route_group_id: str, org_id: str = None) -> str:
        """
        Create a Route List

        Create a Route List for the organization.

        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Creating a Route List requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param name: Name of the Route List
        :type name: str
        :param location_id: Location associated with the Route List.
        :type location_id: str
        :param route_group_id: ID of the route group associated with Route List.
        :type route_group_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['locationId'] = location_id
        body['routeGroupId'] = route_group_id
        url = self.ep('premisePstn/routeLists')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_route_list(self, route_list_id: str, org_id: str = None):
        """
        Delete a Route List

        Delete a route list for a customer.

        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Deleting a Route List requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeLists/{route_list_id}')
        super().delete(url, params=params)

    def get_a_route_list(self, route_list_id: str, org_id: str = None) -> RouteListGet:
        """
        Get a Route List

        Get a rout list details.

        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :rtype: :class:`RouteListGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'premisePstn/routeLists/{route_list_id}')
        data = super().get(url, params=params)
        r = RouteListGet.model_validate(data)
        return r

    def modify_a_route_list(self, route_list_id: str, name: str, route_group_id: str, org_id: str = None):
        """
        Modify a Route List

        Modify the details for a Route List.

        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param name: Route List new name.
        :type name: str
        :param route_group_id: New route group ID.
        :type route_group_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['routeGroupId'] = route_group_id
        url = self.ep(f'premisePstn/routeLists/{route_list_id}')
        super().put(url, params=params, json=body)

    def modify_numbers_for_route_list(self, route_list_id: str, org_id: str = None,
                                      numbers: list[RouteListNumberPatch] = None,
                                      delete_all_numbers: str = None) -> list[RouteListNumberPatchResponse]:
        """
        Modify Numbers for Route List

        Modify numbers for a specific Route List of a Customer.

        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :param numbers: Array of the numbers to be deleted/added.
        :type numbers: list[RouteListNumberPatch]
        :param delete_all_numbers: If present, the numbers array is ignored and all numbers in the route list are
            deleted.
        :type delete_all_numbers: str
        :rtype: list[RouteListNumberPatchResponse]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['numbers'] = loads(TypeAdapter(list[RouteListNumberPatch]).dump_json(numbers))
        body['deleteAllNumbers'] = delete_all_numbers
        url = self.ep(f'premisePstn/routeLists/{route_list_id}/numbers')
        data = super().put(url, params=params, json=body)
        r = TypeAdapter(list[RouteListNumberPatchResponse]).validate_python(data['numberStatus'])
        return r

    def get_numbers_assigned_to_a_route_list(self, route_list_id: str, org_id: str = None, start: int = None,
                                             order: str = None, number: str = None,
                                             **params) -> Generator[str, None, None]:
        """
        Get Numbers assigned to a Route List

        Get numbers assigned to a Route List

        A Route List is a list of numbers that can be reached via a Route Group. It can be used to provide cloud PSTN
        connectivity to Webex Calling Dedicated Instance.

        Retrieving a Route List requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param route_list_id: ID of the Route List.
        :type route_list_id: str
        :param org_id: Organization to which the Route List belongs.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the Route Lists according to number, ascending or descending.
        :type order: str
        :param number: Number assigned to the route list.
        :type number: str
        :return: Numbers assigned to the Route list.
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if number is not None:
            params['number'] = number
        url = self.ep(f'premisePstn/routeLists/{route_list_id}/numbers')
        return self.session.follow_pagination(url=url, model=None, item_key='numbers', params=params)

    def get_local_gateway_call_to_on_premises_extension_usage_for_a_trunk(self, trunk_id: str, org_id: str = None,
                                                                          start: int = None, order: str = None,
                                                                          name: list[str] = None,
                                                                          **params) -> Generator[Location, None, None]:
        """
        Get Local Gateway Call to On-Premises Extension Usage for a Trunk

        Get local gateway call to on-premises extension usage for a trunk.

        A trunk is a connection between Webex Calling and the premises, which terminates on the premises with a local
        gateway or other supported device.
        The trunk can be assigned to a Route Group which is a group of trunks that allow Webex Calling to distribute
        calls over multiple trunks or to provide redundancy.

        Retrieving this information requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param trunk_id: ID of the trunk.
        :type trunk_id: str
        :param org_id: Organization to which the trunk belongs.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the trunks according to the designated fields.  Available sort fields are `name`, and
            `locationName`. Sort order is ascending by default
        :type order: str
        :param name: Return the list of trunks matching the local gateway names
        :type name: list[str]
        :return: Generator yielding :class:`Location` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = ','.join(name)
        url = self.ep(f'premisePstn/trunks/{trunk_id}/usageCallToExtension')
        return self.session.follow_pagination(url=url, model=Location, item_key='locations', params=params)


class CallingServiceSettingsApi(ApiChild, base='telephony/config'):
    """
    Calling Service Settings
    
    Calling Service Settings supports reading and writing of Webex Calling service settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_announcement_languages(self) -> list[FeatureAccessCode]:
        """
        Read the List of Announcement Languages

        List all languages supported by Webex Calling for announcements and voice prompts.

        Retrieving announcement languages requires a full or read-only administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_read`.

        :rtype: list[FeatureAccessCode]
        """
        url = self.ep('announcementLanguages')
        data = super().get(url)
        r = TypeAdapter(list[FeatureAccessCode]).validate_python(data['languages'])
        return r

    def get_voicemail_settings(self, org_id: str = None) -> GetVoicemailSettingsObject:
        """
        Get Voicemail Settings

        Retrieve the organization's voicemail settings.

        Organizational voicemail settings determines what voicemail features a person can configure and automatic
        message expiration.

        Retrieving organization's voicemail settings requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param org_id: Retrieve voicemail settings for this organization.
        :type org_id: str
        :rtype: :class:`GetVoicemailSettingsObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('voicemail/settings')
        data = super().get(url, params=params)
        r = GetVoicemailSettingsObject.model_validate(data)
        return r

    def update_voicemail_settings(self, message_expiry_enabled: bool, number_of_days_for_message_expiry: int,
                                  strict_deletion_enabled: bool, voice_message_forwarding_enabled: bool,
                                  org_id: str = None):
        """
        Update Voicemail Settings

        Update the organization's voicemail settings.

        Organizational voicemail settings determines what voicemail features a person can configure and automatic
        message expiration.

        Updating an organization's voicemail settings requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param message_expiry_enabled: Set to `true` to enable voicemail deletion and set the deletion conditions for
            expired messages.
        :type message_expiry_enabled: bool
        :param number_of_days_for_message_expiry: Number of days after which messages expire.
        :type number_of_days_for_message_expiry: int
        :param strict_deletion_enabled: Set to `true` to delete all read and unread voicemail messages based on the
            time frame you set. Set to `false` to keep all the unread voicemail messages.
        :type strict_deletion_enabled: bool
        :param voice_message_forwarding_enabled: Set to `true` to allow people to configure the email forwarding of
            voicemails.
        :type voice_message_forwarding_enabled: bool
        :param org_id: Update voicemail settings for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['messageExpiryEnabled'] = message_expiry_enabled
        body['numberOfDaysForMessageExpiry'] = number_of_days_for_message_expiry
        body['strictDeletionEnabled'] = strict_deletion_enabled
        body['voiceMessageForwardingEnabled'] = voice_message_forwarding_enabled
        url = self.ep('voicemail/settings')
        super().put(url, params=params, json=body)

    def get_voicemail_rules(self, org_id: str = None) -> GetVoicemailRulesObject:
        """
        Get Voicemail Rules

        Retrieve the organization's voicemail rules.

        Organizational voicemail rules specify the default passcode requirements. They are provided for informational
        purposes only and cannot be modified.

        Retrieving the organization's voicemail rules requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param org_id: Retrieve voicemail rules for this organization.
        :type org_id: str
        :rtype: :class:`GetVoicemailRulesObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('voicemail/rules')
        data = super().get(url, params=params)
        r = GetVoicemailRulesObject.model_validate(data)
        return r

    def update_voicemail_rules(self, default_voicemail_pin_enabled: bool, default_voicemail_pin: str,
                               expire_passcode: GetVoicemailRulesObjectExpirePasscode,
                               change_passcode: GetVoicemailRulesObjectExpirePasscode,
                               block_previous_passcodes: GetVoicemailRulesObjectBlockPreviousPasscodes,
                               org_id: str = None):
        """
        Update Voicemail Rules

        Update the organization's default voicemail passcode and/or rules.

        Organizational voicemail rules specify the default passcode requirements.

        If you choose to set a default passcode for new people added to your organization, communicate to your people
        what that passcode is, and that it must be reset before they can access their voicemail. If this feature is
        not turned on, each new person must initially set their own passcode.

        Updating an organization's voicemail passcode and/or rules requires a full administrator auth token with a
        scope of `spark-admin:telephony_config_write`.

        :param default_voicemail_pin_enabled: Set to `true` to enable the default voicemail passcode.
        :type default_voicemail_pin_enabled: bool
        :param default_voicemail_pin: Default voicemail passcode.
        :type default_voicemail_pin: str
        :param expire_passcode: Settings for passcode expiry.
        :type expire_passcode: GetVoicemailRulesObjectExpirePasscode
        :param change_passcode: Settings for passcode changes.
        :type change_passcode: GetVoicemailRulesObjectExpirePasscode
        :param block_previous_passcodes: Settings for previous passcode usage.
        :type block_previous_passcodes: GetVoicemailRulesObjectBlockPreviousPasscodes
        :param org_id: Update voicemail rules for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['defaultVoicemailPinEnabled'] = default_voicemail_pin_enabled
        body['defaultVoicemailPin'] = default_voicemail_pin
        body['expirePasscode'] = loads(expire_passcode.model_dump_json())
        body['changePasscode'] = loads(change_passcode.model_dump_json())
        body['blockPreviousPasscodes'] = loads(block_previous_passcodes.model_dump_json())
        url = self.ep('voicemail/rules')
        super().put(url, params=params, json=body)


class CallsApi(ApiChild, base='calls'):
    """
    Calls
    
    The Calls functionality and API endpoints described here are currently pre-
    release features which are not available to all Webex users. If you have any
    questions, or if you need help, please contact the Webex Developer Support
    team at devsupport@webex.com.
    
    
    
    Calls represent real-time, collaborative meetings between two or more people. Calls take place in permanent or
    temporary Webex `Spaces (rooms)
    <https://developer.webex.com/docs/api/v1/rooms>`_. To see the participants of a call, use the `Call Memberships API
    
    For more information about Calls, see the `Calls
    <https://developer.webex.com/docs/api/guides/calls>`_ guide.
    """

    def list_calls(self, status: ListCallMembershipsCallStatus, room_id: str = None, from_: Union[str,
                   datetime] = None, to_: Union[str, datetime] = None, **params) -> Generator[Call2, None, None]:
        """
        List Calls

        Lists all calls that the authenticated user either initiated or was invited to.

        To list currently active calls, use `connected` for the `status` query parameter; for call history, use
        `disconnected`. Use the `from` and `to` parameters to specify a time period. By default, call information is
        kept for 90 days.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param status: List calls with this state.
        :type status: ListCallMembershipsCallStatus
        :param room_id: List calls placed in the specified room.
        :type room_id: str
        :param from_: Limit to calls that started from the inclusive start date, in ISO8601 format.
        :type from_: Union[str, datetime]
        :param to_: Limit to calls that ended before the exclusive end date, in ISO8601 format.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`Call2` instances
        """
        params['status'] = status
        if room_id is not None:
            params['roomId'] = room_id
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Call2, item_key='items', params=params)

    def get_call_details(self, call_id: str) -> Call2:
        """
        Get Call Details

        Shows details for a call, by call ID.

        Specify the call ID in the `callId` parameter in the URI.

        :param call_id: The unique identifier for the call.
        :type call_id: str
        :rtype: :class:`Call2`
        """
        url = self.ep(f'{call_id}')
        data = super().get(url)
        r = Call2.model_validate(data)
        return r


class ClassificationsApi(ApiChild, base='classifications'):
    """
    Classifications
    
    Each Webex organization has its own `Space Classification
    <https://help.webex.com/en-us/article/nlcju6g/Data-classifications-for-spaces-in-Webex-App>`_ object that contains exactly five (5) space
    classifications.
    """

    def list_classifications(self) -> list[HydraClassification]:
        """
        List classifications

        List all the space classifications configured in your org.

        :rtype: list[HydraClassification]
        """
        url = self.ep()
        data = super().get(url)
        r = TypeAdapter(list[HydraClassification]).validate_python(data['items'])
        return r


class BetaConferenceControlsApi(ApiChild, base='telephony/conference'):
    """
    Beta Conference Controls
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Conference Control APIs in support of Webex Calling.
    
    All `GET` commands require the `spark:calls_read` scope while all other commands require the `spark:calls_write`
    scope.
    """

    def start_conference(self, call_ids: list[str]):
        """
        Start Conference

        Join the user's calls into a conference.  A minimum of two call IDs are required. Each call ID identifies an
        existing call between the user
        and a participant to be added to the conference.

        :param call_ids: List of call identifiers of the participants to join into the conference. A minimum of two
            call IDs are required.
        :type call_ids: list[str]
        :rtype: None
        """
        body = dict()
        body['callIds'] = call_ids
        url = self.ep()
        super().post(url, json=body)

    def release_conference(self):
        """
        Release Conference

        Release the conference (the host and all participants). Note that for a 3WC (three-way call) the `Transfer API
        <https://developer.webex.com/docs/api/v1/call-controls/transfer>`_
        can be used to perform an attended transfer so that the participants remain connected.

        :rtype: None
        """
        url = self.ep()
        super().delete(url)

    def get_conference_details(self) -> ConferenceDetails:
        """
        Get Conference Details

        Get the details of the conference.  An empty JSON object body is returned if there is no conference.

        :rtype: :class:`ConferenceDetails`
        """
        url = self.ep()
        data = super().get(url)
        r = ConferenceDetails.model_validate(data)
        return r

    def add_participant(self, call_id: str):
        """
        Add Participant

        Adds a participant to an existing conference.  The request body contains the participant's call ID.

        :param call_id: The call identifier of the participant to add.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('addParticipant')
        super().post(url, json=body)

    def mute(self, call_id: str = None):
        """
        Mute

        Mutes the host or a participant. Mutes the host when no request body is provided (i.e. media stream from the
        host will not be transmitted to the conference).  Mutes a participant when the request body contains the
        participant's call ID (i.e. media stream from the participant will not be transmitted to the conference).

        :param call_id: The call identifier of the participant to mute. The conference host is muted when this
            attribute is not provided.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('mute')
        super().post(url, json=body)

    def unmute(self, call_id: str = None):
        """
        Unmute

        Unmutes the host or a participant. Unmutes the host when no request body is provided (i.e. media stream from
        the host will be transmitted to the conference).  Unmutes a participant when the request body contains the
        participant's call ID (i.e. media stream from the participant will be transmitted to the conference).

        :param call_id: The call identifier of the participant to unmute. The conference host is unmuted when this
            attribute is not provided.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('unmute')
        super().post(url, json=body)

    def deafen_participant(self, call_id: str):
        """
        Deafen Participant

        Deafens a participant (i.e. media stream will not be transmitted to the participant).
        The request body contains the call ID of the participant to deafen

        :param call_id: The call identifier of the participant to deafen.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('deafen')
        super().post(url, json=body)

    def undeafen_participant(self, call_id: str):
        """
        Undeafen Participant

        Undeafens a participant (i.e. resume transmitting the conference media stream to the participant).
        The request body contains the call ID of the participant to undeafen.

        :param call_id: The call identifier of the participant to undeafen.
        :type call_id: str
        :rtype: None
        """
        body = dict()
        body['callId'] = call_id
        url = self.ep('undeafen')
        super().post(url, json=body)

    def hold(self):
        """
        Hold

        Hold the conference host.  There is no request body.

        :rtype: None
        """
        url = self.ep('hold')
        super().post(url)

    def resume(self):
        """
        Resume

        Resumes the held conference host.  There is no request body.

        :rtype: None
        """
        url = self.ep('resume')
        super().post(url)


class ContactCenterApi(ApiChild, base='contactCenter'):
    """
    Contact Center
    
    The Webex Contact Center functionality and API endpoints described here are
    currently pre-release features which are not available to all Webex users. If
    you have any questions, or if you need help, please contact the Webex
    Developer Support team at devsupport@webex.com.
    
    
    
    This set of WxCC API endpoints allow developers to use `AI API` for entity recognition, `Analytics API` to fetch
    session and activity based records for customer and agent in WxCC and `Media API` for providing agent/customer
    interaction recordings.
    """

    def analyze_entities(self, org_id: str, contact_id: str, party_id: str,
                         document: AnalyzeEntitiesDocument) -> EntityRecognition:
        """
        Analyze Entities

        Entity Recognition allows consumers to get named entities for the input call transcript.
        It requires an auth token with the `cjp:organization` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ to use this end point.

        Note that each API request:

        - Only considers the first 3,000 characters in the input for recognition

        - Return a maximum of 100 entities per request.

        If the text is too large, it is recommended to break it up into multiple requests to get the entities.

        :param org_id: The ID of the organization.
        :type org_id: str
        :param contact_id: The ID of the contact.
        :type contact_id: str
        :param party_id: The ID of the call leg/party.
        :type party_id: str
        :param document: The document.
        :type document: AnalyzeEntitiesDocument
        :rtype: :class:`EntityRecognition`
        """
        body = dict()
        body['orgId'] = org_id
        body['contactId'] = contact_id
        body['partyId'] = party_id
        body['document'] = loads(document.model_dump_json())
        url = self.ep('document:analyzeEntities')
        data = super().post(url, json=body)
        r = EntityRecognition.model_validate(data)
        return r

    def get_agent_activity_record_list(self, org_id: str, q: str) -> ActivityList:
        """
        Get Agent Activity Record List

        Get a list of agent activity records for the specified query, `q`. The query must be an encoded JSON object.

        Listing agent activity records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations with a
        WxCC license, or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :type org_id: str
        :param q: An encoded json query. Example of json query:

        ```
        {
        "anchorId":"1",
        "dateBegin": [
        1514793600000
        ],
        "dateEnd": [
        1530860400000
        ],
        "numberOfRecords": 100,
        "aggregateQueryProperties": {
        "rowSegmentSet": [
        {
        "columnName": "channelType__s",
        "name": "channelType__s"
        }
        ],
        "columnSegmentSet": []
        },
        "activityType": "AAR",
        "aggregations": [
        {
        "id": 0,
        "aggregationType": "COUNT",
        "computeColumnName": "agentSessionId__s"
        }
        ]
        }
        ```
        :type q: str
        :rtype: :class:`ActivityList`
        """
        params = {}
        params['orgId'] = org_id
        params['q'] = q
        url = self.ep('aars')
        data = super().get(url, params=params)
        r = ActivityList.model_validate(data)
        return r

    def get_agent_activity_record(self, id: str, org_id: str) -> AgentActivity:
        """
        Get Agent Activity Record

        Get details of an agent activity for the `id` specified in the URI.

        Retrieving agent activity records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations
        with a WxCC license or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :param id: A unique identifier for AAR is required. Must be of the format:
            `agentSessionId-channelType-timestamp-eventName`.
        :type id: str
        :param org_id: The organization ID.
        :type org_id: str
        :rtype: :class:`AgentActivity`
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep(f'aars/{id}')
        data = super().get(url, params=params)
        r = AgentActivity.model_validate(data)
        return r

    def get_agent_session_record_list(self, org_id: str, q: str) -> ActivityList:
        """
        Get Agent Session Record List

        Get a list of agent session records for the specified query, `q`. The query must be an encoded JSON object.

        Listing agent session records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations with a
        WxCC license or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :type org_id: str
        :param q: An encoded JSON query. Example JSON query:

        ```
        {
        "anchorId":"1",
        "dateBegin": [
        1514793600000
        ],
        "dateEnd": [
        1530860400000
        ],
        "numberOfRecords": 100,
        "aggregateQueryProperties": {
        "rowSegmentSet": [
        {
        "columnName": "channelType__s",
        "name": "channelType__s"
        }
        ],
        "columnSegmentSet": []
        },
        "activityType": "ASR",
        "aggregations": [
        {
        "id": 0,
        "aggregationType": "VALUE",
        "computeColumnName": "agentSessionId"
        }
        ]
        }
        ```
        :type q: str
        :rtype: :class:`ActivityList`
        """
        params = {}
        params['orgId'] = org_id
        params['q'] = q
        url = self.ep('asrs')
        data = super().get(url, params=params)
        r = ActivityList.model_validate(data)
        return r

    def get_agent_session_record(self, id: str, org_id: str) -> AgentSession:
        """
        Get Agent Session Record

        Get details of an agent session record specified by `id` in the URI.

        Retrieving agent session records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations with
        a WxCC license or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :param id: A unique identifier for ASR is required.
        :type id: str
        :param org_id: The organization ID.
        :type org_id: str
        :rtype: :class:`AgentSession`
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep(f'asrs/{id}')
        data = super().get(url, params=params)
        r = AgentSession.model_validate(data)
        return r

    def get_customer_activity_record_list(self, org_id: str, q: str) -> ActivityList:
        """
        Get Customer Activity Record List

        Get a list of customer activity records for the specified query, `q`. The query must be an encoded JSON object.

        Listing customer activity records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations
        with a WxCC license or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :type org_id: str
        :param q: An encoded JSON query. Example JSON query:

        ```
        {
        "anchorId":"1",
        "dateBegin": [
        1514793600000
        ],
        "dateEnd": [
        1530860400000
        ],
        "numberOfRecords": 100,
        "aggregateQueryProperties": {
        "rowSegmentSet": [
        {
        "columnName": "channelType__s",
        "name": "channelType__s"
        }
        ],
        "columnSegmentSet": []
        },
        "activityType": "CAR",
        "aggregations": [
        {
        "id": 0,
        "aggregationType": "COUNT",
        "computeColumnName": "callSessionId__s"
        }
        ]
        }
        ```
        :type q: str
        :rtype: :class:`ActivityList`
        """
        params = {}
        params['orgId'] = org_id
        params['q'] = q
        url = self.ep('cars')
        data = super().get(url, params=params)
        r = ActivityList.model_validate(data)
        return r

    def get_customer_activity_record(self, id: str, org_id: str) -> CustomerActivity:
        """
        Get Customer Activity Record

        Get details of a customer activity record by `id` in the URI.

        Retrieving customer activity records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations
        with a WxCC license or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :param id: A unique identifier for CAR is required. Must be of the format: callSessionId-timestamp-eventName.
        :type id: str
        :param org_id: The organization ID.
        :type org_id: str
        :rtype: :class:`CustomerActivity`
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep(f'cars/{id}')
        data = super().get(url, params=params)
        r = CustomerActivity.model_validate(data)
        return r

    def get_customer_session_record_list(self, org_id: str, q: str) -> ActivityList:
        """
        Get Customer Session Record List

        Get a list of customer session records for the specified query, `q`. The query must be an encoded JSON object.

        Listing customer session records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations with
        a WxCC license or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :type org_id: str
        :param q: An encoded JSON query. Example JSON query:

        ```
        {
        "anchorId":"1",
        "dateBegin": [
        1514793600000
        ],
        "dateEnd": [
        1530860400000
        ],
        "numberOfRecords": 100,
        "aggregateQueryProperties": {
        "rowSegmentSet": [
        {
        "columnName": "channelType__s",
        "name": "channelType__s"
        }
        ],
        "columnSegmentSet": []
        },
        "activityType": "CSR",
        "aggregations": [
        {
        "id": 0,
        "aggregationType": "COUNT",
        "computeColumnName": "sid"
        }
        ]
        }
        ```
        :type q: str
        :rtype: :class:`ActivityList`
        """
        params = {}
        params['orgId'] = org_id
        params['q'] = q
        url = self.ep('csrs')
        data = super().get(url, params=params)
        r = ActivityList.model_validate(data)
        return r

    def get_customer_session_record(self, id: str, org_id: str) -> CustomerSession:
        """
        Get Customer Session Record

        Get details of a customer session record for the specified `id`.

        Retrieving customer session records requires an auth token with the `cjp:config_read` `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ for organizations
        with a WxCC license or the `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.

        :param id: A unique identifier for CSR is required.
        :type id: str
        :param org_id: The organization ID.
        :type org_id: str
        :rtype: :class:`CustomerSession`
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep(f'csrs/{id}')
        data = super().get(url, params=params)
        r = CustomerSession.model_validate(data)
        return r

    def get_decrypted_recording(self, session_id: str, org_id: str):
        """
        Get Decrypted Recording

        Recording management endpoints allow consumers to retrieve session recordings for customer or agent. It
        requires an auth token with a `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ of `cjp:config_read` for a WxCC license and `cjp-analyzer:read` for
        organizations with only a Hybrid Analyzer license.

        Get decrypted recording of a customer or agent session by ID. Specify `sessionId` in the URI.

        :param session_id: A unique identifier for session recording is required.
        :type session_id: str
        :param org_id: The organization ID.
        :type org_id: str
        :rtype: None
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep(f'get-decrypted-recording/{session_id}')
        super().get(url, params=params)

    def get_encrypted_recording(self, session_id: str, key_id: int, org_id: str):
        """
        Get Encrypted Recording

        Recording management endpoints allow consumers to retrieve session recordings for customer or agent. It
        requires an auth token with a `scope
        <https://developer.webex.com/docs/integrations#scopes>`_ of `cjp:config_read` for a WxCC license and `cjp-analyzer:read` for
        organizations having only Hybrid Analyzer license.

        Get encrypted recording of a customer or agent session by ID. Specify `sessionId` and `keyId` in the URI.

        :param session_id: A unique identifier for session recording is required.
        :type session_id: str
        :param key_id: An encryption key is required.
        :type key_id: int
        :param org_id: The organization ID.
        :type org_id: str
        :rtype: None
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep(f'get-encrypted-recording/{session_id}/{key_id}')
        super().get(url, params=params)


class ContactCenterApi(ApiChild, base='contactCenter'):
    """
    Contact Center
    
    The Webex Contact Center functionality and API endpoints described here are
    currently pre-release features which are not available to all Webex users. If
    you have any questions, or if you need help, please contact the Webex
    Developer Support team at devsupport@webex.com.
    
    
    
    The set of WxCC API endpoints below allow developers to view Tasks for insights into the interactions between
    agents and customers, Agents Statistics for details related to specific agents, Queues Statistics for details on
    specific queues, and Captures for the actual media related to an interaction.
    
    These endpoints require an auth token with the `cjp:config_read` scope for organizations with a WxCC license or the
    `cjp-analyzer:read` scope for organizations with a Hybrid Analyzer license.
    """

    def get_tasks(self, from_: int, to_: int = None, channel_types: list[str] = None, org_id: str = None,
                  page_size: int = None) -> TasksResponse:
        """
        Get Tasks

        A Task represents a request or demand for attention/work from agents. Concretely, a telephony Task is an
        incoming call. For chat, a Task is a chat session. For email, a Task is an email chain. This API returns a
        list of Tasks (open or closed) within a date range.

        :param from_: Filter tasks created after given epoch timestamp (in milliseconds).
        :type from_: int
        :param to_: Filter tasks created before given epoch timestamp (in milliseconds). If unspecified, queries up to
            the present.
        :type to_: int
        :param channel_types: Task channel type(s) permitted in response. Must be lowercase. By default, there is no
            channelType filtering.
        :type channel_types: list[str]
        :param org_id: Organization ID to use for this operation. If unspecified, inferred from token. Token must have
            permission to interact with this organization.
        :type org_id: str
        :param page_size: Maximum page size in response. Max allowable value is 1000.
        :type page_size: int
        :rtype: :class:`TasksResponse`
        """
        params = {}
        params['from'] = from_
        if to_ is not None:
            params['to'] = to_
        if channel_types is not None:
            params['channelTypes'] = ','.join(channel_types)
        if org_id is not None:
            params['orgId'] = org_id
        if page_size is not None:
            params['pageSize'] = page_size
        url = self.ep('tasks')
        data = super().get(url, params=params)
        r = TasksResponse.model_validate(data)
        return r

    def get_agents_statistics(self, from_: int, to_: int, interval: GetAgentsStatisticsInterval, agent_ids: str = None,
                              org_id: str = None) -> AgentStatsResponse:
        """
        Get Agents Statistics

        Get Agents statistics given a time range.

        :param from_: Start time for the query (in epoch milliseconds). Must have minutes set to one of the 15 minute
            increments within an hour (i.e. XX:00, XX:15, XX:30, XX:45)(e.g. 12:00, 12:15, 12:30, 12:45)
        :type from_: int
        :param to_: End time for the query (in epoch milliseconds). Max of 36 months allowed between `from` and `to`.
            Must have minutes set to one of the 15 minute increments within an hour (i.e. XX:00, XX:15, XX:30,
            XX:45)(e.g. 12:00, 12:15, 12:30, 12:45)
        :type to_: int
        :param interval: Interval value in minutes.
        :type interval: GetAgentsStatisticsInterval
        :param agent_ids: Comma separated list of agent ids. Maximum 100 values permitted. If not supplied, all agents
            for an organization are returned.
        :type agent_ids: str
        :param org_id: Organization ID to use for this operation. If unspecified, inferred from token. Token must have
            permission to interact with this organization.
        :type org_id: str
        :rtype: :class:`AgentStatsResponse`
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        if agent_ids is not None:
            params['agentIds'] = agent_ids
        if org_id is not None:
            params['orgId'] = org_id
        params['interval'] = interval
        url = self.ep('agents/statistics')
        data = super().get(url, params=params)
        r = AgentStatsResponse.model_validate(data)
        return r

    def get_queues_statistics(self, from_: int, to_: int, interval: GetAgentsStatisticsInterval, queue_ids: str = None,
                              org_id: str = None) -> QueueStatsResponse:
        """
        Get Queues Statistics

        This API will provide queues statistics given a time duration.

        :param from_: Start time for the query (in epoch milliseconds). Must have minutes set to one of the 15 minute
            increments within an hour (i.e. XX:00, XX:15, XX:30, XX:45)(e.g. 12:00, 12:15, 12:30, 12:45)
        :type from_: int
        :param to_: End time for the query (in epoch milliseconds). Max of 36 months allowed between `from` and `to`.
            Must have minutes set to one of the 15 minute increments within an hour (i.e. XX:00, XX:15, XX:30,
            XX:45)(e.g. 12:00, 12:15, 12:30, 12:45)
        :type to_: int
        :param interval: Interval value in minutes.
        :type interval: GetAgentsStatisticsInterval
        :param queue_ids: Comma separated list of queue ids. Maximum 100 values permitted. If not supplied, all queues
            for an organization are returned.
        :type queue_ids: str
        :param org_id: Organization ID to use for this operation. If unspecified, inferred from token. Token must have
            permission to interact with this organization.
        :type org_id: str
        :rtype: :class:`QueueStatsResponse`
        """
        params = {}
        params['from'] = from_
        params['to'] = to_
        if queue_ids is not None:
            params['queueIds'] = queue_ids
        if org_id is not None:
            params['orgId'] = org_id
        params['interval'] = interval
        url = self.ep('queues/statistics')
        data = super().get(url, params=params)
        r = QueueStatsResponse.model_validate(data)
        return r

    def list_captures(self, query: ListCapturesQuery) -> ListCapturesResponse:
        """
        List Captures

        Retrieve a list of captures given a set of taskIds. A capture is a specific snippet of media.

        :type query: ListCapturesQuery
        :rtype: :class:`ListCapturesResponse`
        """
        body = dict()
        body['query'] = loads(query.model_dump_json())
        url = self.ep('captures/query')
        data = super().post(url, json=body)
        r = ListCapturesResponse.model_validate(data)
        return r


class DeviceCallSettingsApi(ApiChild, base='telephony/config'):
    """
    Device Call Settings
    
    These APIs manages Webex Calling settings for devices with are of the Webex Calling type.
    
    Viewing these read-only device settings requires a full, device, or
    read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these device settings requires a full or device
    administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    """

    def get_device_members(self, device_id: str, org_id: str = None) -> GetMemberResponse1:
        """
        Get Device Members

        Get the list of all the members of the device including primary and secondary users.

        A device member can be either a person or a workspace. An admin can access the list of member details, modify
        member details and
        search for available members on a device.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: Retrieves the list of all members of the device in this organization.
        :type org_id: str
        :rtype: :class:`GetMemberResponse1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'devices/{device_id}/members')
        data = super().get(url, params=params)
        r = GetMemberResponse1.model_validate(data)
        return r

    def update_members_on_the_device(self, device_id: str, members: list[PutMemberObject], org_id: str = None):
        """
        Update Members on the device

        Modify member details on the device.

        A device member can be either a person or a workspace. An admin can access the list of member details, modify
        member details and
        search for available members on a device.

        Modifying members on the device requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param members: If the member's list is missing then all the users are removed except the primary user.
        :type members: list[PutMemberObject]
        :param org_id: Modify members on the device in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['members'] = loads(TypeAdapter(list[PutMemberObject]).dump_json(members))
        url = self.ep(f'devices/{device_id}/members')
        super().put(url, params=params, json=body)

    def search_members(self, device_id: str, location_id: str, org_id: str = None, start: int = None,
                       member_name: str = None, phone_number: str = None, extension: Union[str, datetime] = None,
                       order: str = None, **params) -> Generator[SearchMemberObject, None, None]:
        """
        Search Members

        Search members that can be assigned to the device.

        A device member can be either a person or a workspace. A admin can access the list of member details, modify
        member details and
        search for available members on a device.

        This requires a full or read-only administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param location_id: Unique identifier for the location.
        :type location_id: str
        :param org_id: Retrieves the list of available members on the device in this organization.
        :type org_id: str
        :param start: Specifies the offset from the first result that you want to fetch.
        :type start: int
        :param member_name: Search (Contains) numbers based on member name.
        :type member_name: str
        :param phone_number: Search (Contains) based on number.
        :type phone_number: str
        :param extension: Search (Contains) based on extension.
        :type extension: Union[str, datetime]
        :param order: Sort the list of available members on the device in ascending order by name, use either last name
            `lname` or first name `fname`. Default sort is last name in ascending order.
        :type order: str
        :return: Generator yielding :class:`SearchMemberObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if member_name is not None:
            params['memberName'] = member_name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if extension is not None:
            if isinstance(extension, str):
                extension = isoparse(extension)
            extension = dt_iso_str(extension)
            params['extension'] = extension
        if order is not None:
            params['order'] = order
        url = self.ep(f'devices/{device_id}/availableMembers')
        return self.session.follow_pagination(url=url, model=SearchMemberObject, item_key='members', params=params)

    def apply_changes_for_a_specific_device(self, device_id: str, org_id: str = None):
        """
        Apply Changes for a specific device

        Issues request to the device to download and apply changes to the configuration.

        Applying changes for a specific device requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: Apply changes for a device in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'devices/{device_id}/actions/applyChanges/invoke')
        super().post(url, params=params)

    def get_device_settings(self, device_id: str, device_model: str,
                            org_id: str = None) -> DeviceSettingsObjectForDeviceLevel:
        """
        Get Device Settings

        Get override settings for a device.

        Device settings lists all the applicable settings for MPP, ATA and Wifi devices at the device level. An admin
        can also modify the settings. DECT devices do not support settings at the device level.

        This requires a full or read-only administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param device_model: Model type of the device.
        :type device_model: str
        :param org_id: Settings on the device in this organization.
        :type org_id: str
        :rtype: :class:`DeviceSettingsObjectForDeviceLevel`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        params['deviceModel'] = device_model
        url = self.ep(f'devices/{device_id}/settings')
        data = super().get(url, params=params)
        r = DeviceSettingsObjectForDeviceLevel.model_validate(data)
        return r

    def update_device_settings(self, device_id: str, customizations: CustomizationDeviceLevelObjectDevice,
                               custom_enabled: bool, org_id: str = None, device_model: str = None):
        """
        Update device settings

        Modify override settings for a device.

        Device settings list all the applicable settings for an MPP and an ATA devices at the device level. Admins can
        also modify the settings. NOTE: DECT devices do not support settings at the device level.

        Updating settings on the device requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param customizations: Indicates the customization object of the device settings.
        :type customizations: CustomizationDeviceLevelObjectDevice
        :param custom_enabled: Indicates if customization is allowed at a device level. If true, customized at a device
            level. If false, not customized; uses customer-level configuration.
        :type custom_enabled: bool
        :param org_id: Organization in which the device resides..
        :type org_id: str
        :param device_model: Device model name.
        :type device_model: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if device_model is not None:
            params['deviceModel'] = device_model
        body = dict()
        body['customizations'] = loads(customizations.model_dump_json())
        body['customEnabled'] = custom_enabled
        url = self.ep(f'devices/{device_id}/settings')
        super().put(url, params=params, json=body)

    def get_location_device_settings(self, location_id: str, org_id: str = None) -> DeviceSettingsObject:
        """
        Get Location Device Settings

        Get device override settings for a location.

        This requires a full or read-only administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Unique identifier for the location.
        :type location_id: str
        :param org_id: Organization in which the device resides.
        :type org_id: str
        :rtype: :class:`DeviceSettingsObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/devices/settings')
        data = super().get(url, params=params)
        r = DeviceSettingsObject.model_validate(data)
        return r

    def get_third_party_device(self, device_id: str, org_id: str = None) -> GetThirdPartyDeviceObject:
        """
        Get third party device

        Get third party device details.

        Retrieves customer managed and partner managed device details.

        This requires a full administrator auth token with scope of `spark-admin:telephony_config_read`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: ID of the organization in which the device resides.
        :type org_id: str
        :rtype: :class:`GetThirdPartyDeviceObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'devices/{device_id}')
        data = super().get(url, params=params)
        r = GetThirdPartyDeviceObject.model_validate(data)
        return r

    def update_third_party_device(self, device_id: str, sip_password: str, org_id: str = None):
        """
        Update third party device

        Modify a device's `sipPassword`.

        Updating `sipPassword` on the device requires a full or user administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param sip_password: Password to be updated.
        :type sip_password: str
        :param org_id: ID of the organization in which the device resides.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['sipPassword'] = sip_password
        url = self.ep(f'devices/{device_id}')
        super().put(url, params=params, json=body)

    def get_user_devices(self, person_id: str, org_id: str = None) -> DeviceList:
        """
        Get User Devices

        Get all devices for a person.

        This requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param person_id: Person for whom to retrieve devices.
        :type person_id: str
        :param org_id: Organization to which the person belongs.
        :type org_id: str
        :rtype: :class:`DeviceList`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/devices')
        data = super().get(url, params=params)
        r = DeviceList.model_validate(data)
        return r

    def get_workspace_devices(self, workspace_id: str, org_id: str = None) -> DeviceList:
        """
        Get Workspace Devices

        Get all devices for a workspace.

        This requires a full or read-only administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param workspace_id: ID of the workspace for which to retrieve devices.
        :type workspace_id: str
        :param org_id: Organization to which the workspace belongs.
        :type org_id: str
        :rtype: :class:`DeviceList`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/devices')
        data = super().get(url, params=params)
        r = DeviceList.model_validate(data)
        return r

    def modify_workspace_devices(self, workspace_id: str, enabled: bool, limit_guest_use: bool, guest_hours_limit: int,
                                 org_id: str = None):
        """
        Modify Workspace Devices

        Modify devices for a workspace.

        Modifying devices for a workspace requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param workspace_id: ID of the workspace for which to modify devices.
        :type workspace_id: str
        :param enabled: Enable/Disable hoteling Host. Enabling the device for hoteling means that a guest(end user) can
            log into this host(workspace device) and use this device

        as if it were their own. This is useful when traveling to a remote office but still needing to place/receive
        calls with their telephone number and access features normally available to them on their office phone.
        :type enabled: bool
        :param limit_guest_use: Enable limiting the time a guest can use the device. The time limit is configured via
            `guestHoursLimit`.
        :type limit_guest_use: bool
        :param guest_hours_limit: Time Limit in hours until hoteling is enabled. Mandatory if `limitGuestUse` is
            enabled.
        :type guest_hours_limit: int
        :param org_id: Organization to which the workspace belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['limitGuestUse'] = limit_guest_use
        body['guestHoursLimit'] = guest_hours_limit
        url = self.ep(f'workspaces/{workspace_id}/devices')
        super().put(url, params=params, json=body)

    def read_the_list_of_supported_devices(self, org_id: str = None) -> list[DeviceObject]:
        """
        Read the List of Supported Devices

        Gets the list of supported devices for an organization.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List supported devices for an organization.
        :type org_id: str
        :rtype: list[DeviceObject]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('supportedDevices')
        data = super().get(url, params=params)
        r = TypeAdapter(list[DeviceObject]).validate_python(data['devices'])
        return r

    def read_the_device_override_settings_for_a_organization(self, org_id: str = None) -> ListDeviceSettingsObject:
        """
        Read the device override settings for a organization

        Get device override settings for an organization.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List supported devices for an organization.
        :type org_id: str
        :rtype: :class:`ListDeviceSettingsObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('devices/settings')
        data = super().get(url, params=params)
        r = ListDeviceSettingsObject.model_validate(data)
        return r

    def create_a_line_key_template(self, template_name: str, device_model: str, user_reorder_enabled: bool,
                                   line_keys: list[ProgrammableLineKeys], org_id: str = None) -> str:
        """
        Create a Line Key Template

        Create a Line Key Template in this organization.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows customers to create a Line Key Template for a device model.

        Creating a Line Key Template requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param template_name: Name of the Line Key Template.
        :type template_name: str
        :param device_model: The Device Model for which the Line Key Template is applicable.
        :type device_model: str
        :param user_reorder_enabled: User Customization Enabled.
        :type user_reorder_enabled: bool
        :param line_keys: Contains a mapping of Line Keys and their corresponding actions.
        :type line_keys: list[ProgrammableLineKeys]
        :param org_id: Organization to which line key template belongs.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['templateName'] = template_name
        body['deviceModel'] = device_model
        body['userReorderEnabled'] = user_reorder_enabled
        body['lineKeys'] = loads(TypeAdapter(list[ProgrammableLineKeys]).dump_json(line_keys))
        url = self.ep('devices/lineKeyTemplates')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def read_the_list_of_line_key_templates(self, org_id: str = None) -> list[LineKeyTemplatesResponse]:
        """
        Read the list of Line Key Templates

        List all Line Key Templates available for this organization.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to retrieve the list of Line Key Templates that are available for the organization.

        Retrieving this list requires a full, user or read-only administrator or location administrator auth token with
        a scope of `spark-admin:telephony_config_read`.

        :param org_id: List line key templates for this organization.
        :type org_id: str
        :rtype: list[LineKeyTemplatesResponse]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('devices/lineKeyTemplates')
        data = super().get(url, params=params)
        r = TypeAdapter(list[LineKeyTemplatesResponse]).validate_python(data['lineKeyTemplates'])
        return r

    def get_details_of_a_line_key_template(self, template_id: str, org_id: str = None) -> GetLineKeyTemplateResponse:
        """
        Get details of a Line Key Template

        Get detailed information about a Line Key Template by template ID in an organization.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to retrieve a line key template by its ID in an organization.

        Retrieving a line key template requires a full, user or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param template_id: Get line key template for this template ID.
        :type template_id: str
        :param org_id: Retrieve a line key template for this organization.
        :type org_id: str
        :rtype: :class:`GetLineKeyTemplateResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'devices/lineKeyTemplates/{template_id}')
        data = super().get(url, params=params)
        r = GetLineKeyTemplateResponse.model_validate(data)
        return r

    def modify_a_line_key_template(self, template_id: str, user_reorder_enabled: bool,
                                   line_keys: list[ProgrammableLineKeys], org_id: str = None):
        """
        Modify a Line Key Template

        Modify a line key template by its template ID in an organization.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to modify an existing Line Key Template by its ID in an organization.

        Modifying an existing line key template requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param template_id: Modify line key template with this template ID.
        :type template_id: str
        :param user_reorder_enabled: Indicates whether the user can reorder the line keys.
        :type user_reorder_enabled: bool
        :param line_keys: List of line keys that are being updated.
        :type line_keys: list[ProgrammableLineKeys]
        :param org_id: Modify a line key template for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['userReorderEnabled'] = user_reorder_enabled
        body['lineKeys'] = loads(TypeAdapter(list[ProgrammableLineKeys]).dump_json(line_keys))
        url = self.ep(f'devices/lineKeyTemplates/{template_id}')
        super().put(url, params=params, json=body)

    def delete_a_line_key_template(self, template_id: str, org_id: str = None):
        """
        Delete a Line Key Template

        Delete a Line Key Template by its template ID in an organization.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to delete an existing Line Key Templates by its ID in an organization.

        Deleting an existing line key template requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param template_id: Delete line key template with this template ID.
        :type template_id: str
        :param org_id: Delete a line key template for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'devices/lineKeyTemplates/{template_id}')
        super().delete(url, params=params)

    def preview_apply_line_key_template(self, action: PostApplyLineKeyTemplateRequestAction, template_id: str,
                                        location_ids: list[str], exclude_devices_with_custom_layout: bool,
                                        include_device_tags: list[str], exclude_device_tags: list[str],
                                        more_shared_appearances_enabled: bool, few_shared_appearances_enabled: bool,
                                        more_monitor_appearances_enabled: bool, org_id: str = None) -> int:
        """
        Preview Apply Line Key Template

        Preview the number of devices that will be affected by the application of a Line Key Template or when resetting
        devices to their factory Line Key settings.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to preview the number of devices that will be affected if a customer were to apply a Line
        Key Template or apply factory default Line Key settings to devices.

        Retrieving the number of devices affected requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param action: Line key Template action to perform.
        :type action: PostApplyLineKeyTemplateRequestAction
        :param template_id: `templateId` is required for `APPLY_TEMPLATE` action.
        :type template_id: str
        :param location_ids: Used to search for devices only in the given locations.
        :type location_ids: list[str]
        :param exclude_devices_with_custom_layout: Indicates whether to exclude devices with custom layout.
        :type exclude_devices_with_custom_layout: bool
        :param include_device_tags: Include devices only with these tags.
        :type include_device_tags: list[str]
        :param exclude_device_tags: Exclude devices with these tags.
        :type exclude_device_tags: list[str]
        :param more_shared_appearances_enabled: Refine search by warnings for More shared appearances than shared
            users.
        :type more_shared_appearances_enabled: bool
        :param few_shared_appearances_enabled: Refine search by warnings for Fewer shared appearances than shared
            users.
        :type few_shared_appearances_enabled: bool
        :param more_monitor_appearances_enabled: Refine search by warnings for more monitor appearances than monitors.
        :type more_monitor_appearances_enabled: bool
        :param org_id: Preview Line Key Template for this organization.
        :type org_id: str
        :rtype: int
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['action'] = enum_str(action)
        body['templateId'] = template_id
        body['locationIds'] = location_ids
        body['excludeDevicesWithCustomLayout'] = exclude_devices_with_custom_layout
        body['includeDeviceTags'] = include_device_tags
        body['excludeDeviceTags'] = exclude_device_tags
        body['moreSharedAppearancesEnabled'] = more_shared_appearances_enabled
        body['fewSharedAppearancesEnabled'] = few_shared_appearances_enabled
        body['moreMonitorAppearancesEnabled'] = more_monitor_appearances_enabled
        url = self.ep('devices/actions/previewApplyLineKeyTemplate/invoke')
        data = super().post(url, params=params, json=body)
        r = data['deviceCount']
        return r

    def apply_a_line_key_template(self, action: PostApplyLineKeyTemplateRequestAction, template_id: str,
                                  location_ids: list[str], exclude_devices_with_custom_layout: bool,
                                  include_device_tags: list[str], exclude_device_tags: list[str],
                                  more_shared_appearances_enabled: bool, few_shared_appearances_enabled: bool,
                                  more_monitor_appearances_enabled: bool,
                                  org_id: str = None) -> ApplyLineKeyTemplateJobDetails:
        """
        Apply a Line key Template

        Apply a Line Key Template or reset devices to their factory Line Key settings.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to apply a line key template or apply factory default Line Key settings to devices in a
        set of locations or across all locations in the organization.

        Applying a Line Key Template or resetting devices to their default Line Key configuration requires a full
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param action: Line key Template action to perform.
        :type action: PostApplyLineKeyTemplateRequestAction
        :param template_id: `templateId` is required for `APPLY_TEMPLATE` action.
        :type template_id: str
        :param location_ids: Used to search for devices only in the given locations.
        :type location_ids: list[str]
        :param exclude_devices_with_custom_layout: Indicates whether to exclude devices with custom layout.
        :type exclude_devices_with_custom_layout: bool
        :param include_device_tags: Include devices only with these tags.
        :type include_device_tags: list[str]
        :param exclude_device_tags: Exclude devices with these tags.
        :type exclude_device_tags: list[str]
        :param more_shared_appearances_enabled: Refine search by warnings for More shared appearances than shared
            users.
        :type more_shared_appearances_enabled: bool
        :param few_shared_appearances_enabled: Refine search by warnings for Fewer shared appearances than shared
            users.
        :type few_shared_appearances_enabled: bool
        :param more_monitor_appearances_enabled: Refine search by warnings for more monitor appearances than monitors.
        :type more_monitor_appearances_enabled: bool
        :param org_id: Apply Line Key Template for this organization.
        :type org_id: str
        :rtype: :class:`ApplyLineKeyTemplateJobDetails`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['action'] = enum_str(action)
        body['templateId'] = template_id
        body['locationIds'] = location_ids
        body['excludeDevicesWithCustomLayout'] = exclude_devices_with_custom_layout
        body['includeDeviceTags'] = include_device_tags
        body['excludeDeviceTags'] = exclude_device_tags
        body['moreSharedAppearancesEnabled'] = more_shared_appearances_enabled
        body['fewSharedAppearancesEnabled'] = few_shared_appearances_enabled
        body['moreMonitorAppearancesEnabled'] = more_monitor_appearances_enabled
        url = self.ep('jobs/devices/applyLineKeyTemplate')
        data = super().post(url, params=params, json=body)
        r = ApplyLineKeyTemplateJobDetails.model_validate(data)
        return r

    def get_list_of_apply_line_key_template_jobs(self, org_id: str = None) -> list[ApplyLineKeyTemplateJobDetails]:
        """
        Get List of Apply Line Key Template jobs

        Get the list of all apply line key templates jobs in an organization.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to retrieve all the apply line key templates jobs in an organization.

        Retrieving the list of apply line key templates jobs in an organization requires a full, user or read-only
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param org_id: Retrieve list of line key templates jobs in this organization.
        :type org_id: str
        :rtype: list[ApplyLineKeyTemplateJobDetails]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('jobs/devices/applyLineKeyTemplate')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ApplyLineKeyTemplateJobDetails]).validate_python(data['items'])
        return r

    def get_the_job_status_of_an_apply_line_key_template_job(self, job_id: str,
                                                             org_id: str = None) -> ApplyLineKeyTemplateJobDetails:
        """
        Get the job status of an Apply Line Key Template job

        Get the status of an apply line key template job by its job ID.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to check the status of an apply line key templates job by job ID in an organization.

        Checking the the status of an apply line key templates job in an organization requires a full, user or
        read-only administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job status for this `jobId`.
        :type job_id: str
        :param org_id: Check a line key template job status in this organization.
        :type org_id: str
        :rtype: :class:`ApplyLineKeyTemplateJobDetails`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/devices/applyLineKeyTemplate/{job_id}')
        data = super().get(url, params=params)
        r = ApplyLineKeyTemplateJobDetails.model_validate(data)
        return r

    def get_job_errors_for_an_apply_line_key_template_job(self, job_id: str,
                                                          org_id: str = None) -> ApplyLineKeyTemplateJobErrors:
        """
        Get job errors for an Apply Line Key Template job

        GET job errors for an apply Line Key Template job in an organization.

        Line Keys also known as Programmable Line Keys (PLK) are the keys found on either sides of a typical desk phone
        display.
        A Line Key Template is a definition of actions that will be performed by each of the Line Keys for a particular
        device model.
        This API allows users to retrieve all the errors of an apply line key templates job by job ID in an
        organization.

        Retrieving all the errors of an apply line key templates job in an organization requires a full, user or
        read-only administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job errors for this `jobId`.
        :type job_id: str
        :param org_id: Retrieve list of errors for an apply line key template job in this organization.
        :type org_id: str
        :rtype: :class:`ApplyLineKeyTemplateJobErrors`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/devices/applyLineKeyTemplate/{job_id}/errors')
        data = super().get(url, params=params)
        r = ApplyLineKeyTemplateJobErrors.model_validate(data)
        return r

    def read_the_dect_device_type_list(self, org_id: str = None) -> list[DectDeviceList]:
        """
        Read the DECT device type list

        Get DECT device type list with base stations and line ports supported count. This is a static list.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :type org_id: str
        :rtype: list[DectDeviceList]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('devices/dects/supportedDevices')
        data = super().get(url, params=params)
        r = TypeAdapter(list[DectDeviceList]).validate_python(data['devices'])
        return r

    def validate_a_list_of_mac_address(self, macs: list[str], org_id: str = None) -> MACAddressResponse:
        """
        Validate a list of MAC address

        Validate a list of MAC addresses.

        Validating this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param macs: MAC addresses to be validated.
        :type macs: list[str]
        :param org_id: Validate the mac address(es) for this organization.
        :type org_id: str
        :rtype: :class:`MACAddressResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['macs'] = macs
        url = self.ep('devices/actions/validateMacs/invoke')
        data = super().post(url, params=params, json=body)
        r = MACAddressResponse.model_validate(data)
        return r

    def change_device_settings_across_organization_or_location_job(self, location_id: str,
                                                                   location_customizations_enabled: bool,
                                                                   customizations: CustomizationObject,
                                                                   org_id: str = None) -> StartJobResponse:
        """
        Change Device Settings Across Organization Or Location Job

        Change device settings across organization or locations jobs.

        Performs bulk and asynchronous processing for all types of device settings initiated by organization and system
        admins in a stateful persistent manner. This job will modify the requested device settings across all the
        devices. Whenever a location ID is specified in the request, it will modify the requested device settings only
        for the devices that are part of the provided location within an organization.

        Returns a unique job ID which can then be utilized further to retrieve status and errors for the same.

        Only one job per customer can be running at any given time within the same organization. An attempt to run
        multiple jobs at the same time will result in a 409 error response.

        Running a job requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location within an organization where changes of device setings will be applied to all the
            devices within it.
        :type location_id: str
        :param location_customizations_enabled: Indicates if all the devices within this location will be customized
            with new requested customizations(if set to `true`) or will be overridden with the one at organization
            level (if set to `false` or any other value). This field has no effect when the job is being triggered at
            organization level.
        :type location_customizations_enabled: bool
        :param customizations: Indicates the settings for ATA devices, DECT devices and MPP devices.
        :type customizations: CustomizationObject
        :param org_id: Apply change device settings for all the devices under this organization.
        :type org_id: str
        :rtype: :class:`StartJobResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['locationId'] = location_id
        body['locationCustomizationsEnabled'] = location_customizations_enabled
        body['customizations'] = loads(customizations.model_dump_json())
        url = self.ep('jobs/devices/callDeviceSettings')
        data = super().post(url, params=params, json=body)
        r = StartJobResponse.model_validate(data)
        return r

    def list_change_device_settings_jobs(self, org_id: str = None, start: int = None,
                                         **params) -> Generator[StartJobResponse, None, None]:
        """
        List Change Device Settings Jobs

        List change device settings jobs.

        Lists all the jobs for jobType `calldevicesettings` for the given organization in order of most recent one to
        oldest one irrespective of its status.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Retrieve list of 'calldevicesettings' jobs for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of jobs. Default is 0.
        :type start: int
        :return: Generator yielding :class:`StartJobResponse` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        url = self.ep('jobs/devices/callDeviceSettings')
        return self.session.follow_pagination(url=url, model=StartJobResponse, item_key='items', params=params)

    def get_change_device_settings_job_status(self, job_id: str) -> JobIdResponseObject:
        """
        Get Change Device Settings Job Status

        Get change device settings job status.

        Provides details of the job with `jobId` of `jobType` `calldevicesettings`.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job details for this `jobId`.
        :type job_id: str
        :rtype: :class:`JobIdResponseObject`
        """
        url = self.ep(f'jobs/devices/callDeviceSettings/{job_id}')
        data = super().get(url)
        r = JobIdResponseObject.model_validate(data)
        return r

    def list_change_device_settings_job_errors(self, job_id: str, org_id: str = None, start: int = None,
                                               **params) -> Generator[ItemObject, None, None]:
        """
        List Change Device Settings Job Errors

        List change device settings job errors.

        Lists all error details of the job with `jobId` of `jobType` `calldevicesettings`.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job details for this `jobId`.
        :type job_id: str
        :param org_id: Retrieve list of jobs for this organization.
        :type org_id: str
        :param start: Specifies the offset from the first result that you want to fetch. Default is 0.
        :type start: int
        :return: Generator yielding :class:`ItemObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        url = self.ep(f'jobs/devices/callDeviceSettings/{job_id}/errors')
        return self.session.follow_pagination(url=url, model=ItemObject, item_key='items', params=params)


class DevicesApi(ApiChild, base='devices'):
    """
    Devices
    
    Devices represent cloud-registered Webex RoomOS devices and Webex Calling phones. Devices may be associated with
    `Workspaces
    <https://developer.webex.com/docs/api/v1/workspaces>`_.
    
    The following scopes are required for performing the specified actions:
    
    * Searching and viewing details for devices requires an auth token with the `spark:devices_read` scope.
    
    * Updating or deleting your devices requires an auth token with the `spark:devices_write` scope.
    
    * Viewing the list of all devices in an organization requires an administrator auth token with the
    `spark-admin:devices_read` scope.
    
    * Adding, updating, or deleting all devices in an organization requires an administrator auth token with the
    `spark-admin:devices_write` scope.
    
    * Generating an activation code requires an auth token with the `identity:placeonetimepassword_create` scope.
    """

    def list_devices(self, person_id: str = None, workspace_id: str = None, org_id: str = None,
                     workspace_location_id: str = None, display_name: str = None, product: ListDevicesProduct = None,
                     type: ListDevicesType = None, tag: str = None, connection_status: str = None, serial: str = None,
                     software: str = None, upgrade_channel: str = None, error_code: str = None,
                     capability: DeviceCapabilities = None, permission: str = None, mac: str = None,
                     start: int = None, **params) -> Generator[Device, None, None]:
        """
        List Devices

        Lists all active Webex devices associated with the authenticated user, such as devices activated in personal
        mode. This requires the `spark:devices_read` scope. Administrators can list all devices within their
        organization. This requires an administrator auth token with the `spark-admin:devices_read` scope.

        :param person_id:
        List devices by person ID.
        :type person_id: str
        :param workspace_id:
        List devices by workspace ID.
        :type workspace_id: str
        :param org_id:
        List devices in this organization. Only admin users of another organization (such as partners) may use this
        parameter.
        :type org_id: str
        :param workspace_location_id:
        List devices by workspace location ID.
        :type workspace_location_id: str
        :param display_name:
        List devices with this display name.
        :type display_name: str
        :param product:
        List devices with this product name.
        :type product: ListDevicesProduct
        :param type:
        List devices with this type.
        :type type: ListDevicesType
        :param tag:
        List devices which have a tag. Searching for multiple tags (logical AND) can be done by comma separating the
        `tag` values or adding several `tag` parameters.
        :type tag: str
        :param connection_status:
        List devices with this connection status.
        :type connection_status: str
        :param serial:
        List devices with this serial number.
        :type serial: str
        :param software:
        List devices with this software version.
        :type software: str
        :param upgrade_channel:
        List devices with this upgrade channel.
        :type upgrade_channel: str
        :param error_code:
        List devices with this error code.
        :type error_code: str
        :param capability:
        List devices with this capability.
        :type capability: DeviceCapabilities
        :param permission:
        List devices with this permission.
        :type permission: str
        :param mac:
        List devices with this MAC address.
        :type mac: str
        :param start:
        Offset. Default is 0.
        :type start: int
        :return: Generator yielding :class:`Device` instances
        """
        if person_id is not None:
            params['personId'] = person_id
        if workspace_id is not None:
            params['workspaceId'] = workspace_id
        if org_id is not None:
            params['orgId'] = org_id
        if workspace_location_id is not None:
            params['workspaceLocationId'] = workspace_location_id
        if display_name is not None:
            params['displayName'] = display_name
        if product is not None:
            params['product'] = product
        if type is not None:
            params['type'] = type
        if tag is not None:
            params['tag'] = tag
        if connection_status is not None:
            params['connectionStatus'] = connection_status
        if serial is not None:
            params['serial'] = serial
        if software is not None:
            params['software'] = software
        if upgrade_channel is not None:
            params['upgradeChannel'] = upgrade_channel
        if error_code is not None:
            params['errorCode'] = error_code
        if capability is not None:
            params['capability'] = capability
        if permission is not None:
            params['permission'] = permission
        if mac is not None:
            params['mac'] = mac
        if start is not None:
            params['start'] = start
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Device, item_key='items', params=params)

    def get_device_details(self, device_id: str, org_id: str = None) -> Device:
        """
        Get Device Details

        Shows details for a device, by ID. This requires an auth token with the `spark:devices_read` scope to see your
        own device, or `spark-admin:devices_read` to see any other device in your organization.

        Specify the device ID in the `deviceId` parameter in the URI.

        :param device_id:
        A unique identifier for the device.
        :type device_id: str
        :param org_id: The organization associated with the device. If left empty, the organization associated with the
            caller will be used.
        :type org_id: str
        :rtype: :class:`Device`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{device_id}')
        data = super().get(url, params=params)
        r = Device.model_validate(data)
        return r

    def delete_a_device(self, device_id: str, org_id: str = None):
        """
        Delete a Device

        Deletes a device, by ID. Deleting your own device requires an auth token with the `spark:devices_write` scope.
        Deleting any other device in the organization will require an administrator auth token with the
        `spark-admin:devices_write` scope.

        Specify the device ID in the `deviceId` parameter in the URI.

        :param device_id: A unique identifier for the device.
        :type device_id: str
        :param org_id: The organization associated with the device. If left empty, the organization associated with the
            caller will be used.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{device_id}')
        super().delete(url, params=params)

    def modify_device_tags(self, device_id: str, org_id: str = None, op: ModifyDeviceTagsOp = None, path: str = None,
                           value: list[str] = None) -> Device:
        """
        Modify Device Tags

        Create, delete or update tags on a device. For your own device, this requires an auth token with the
        `spark:devices_write` scope. An auth token with the `spark-admin:devices_write` scope is required to operate
        on other devices within the organization.

        Specify the device ID in the `deviceId` parameter in the URI.

        Include only the tag array in the request body, no other device attributes can be changed. This action will
        overwrite any previous tags. A common approach is to first `GET the devices's details
        <https://developer.webex.com/docs/api/v1/devices/get-device-details>`_, make changes to the
        `tags` array, and then PATCH the new complete array with this endpoint.

        :param device_id: Unique identifier for the device.
        :type device_id: str
        :param org_id: The organization associated with the device. If left empty, the organization associated with the
            caller will be used.
        :type org_id: str
        :type op: ModifyDeviceTagsOp
        :param path: Only the tags path is supported to patch.
        :type path: str
        :type value: list[str]
        :rtype: :class:`Device`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['op'] = enum_str(op)
        body['path'] = path
        body['value'] = value
        url = self.ep(f'{device_id}')
        data = super().patch(url, params=params, json=body)
        r = Device.model_validate(data)
        return r

    def create_a_device_activation_code(self, org_id: str = None, workspace_id: str = None, person_id: str = None,
                                        model: str = None) -> ActivationCode:
        """
        Create a Device Activation Code

        Generate an activation code for a device in a specific workspace by `workspaceId` or for a person by
        `personId`. This requires an auth token with the `identity:placeonetimepassword_create` scope.

        * Adding a device to a workspace with calling type `none` or `thirdPartySipCalling` will reset the workspace
        calling type to `freeCalling`.

        * Either `workspaceId` or `personId` should be provided. If both are supplied, the request will be invalid.

        * If no `model` is supplied, the `code` returned will only be accepted on RoomOS devices.

        * If your device is a phone, you must provide the `model` as a field. You can get the `model` from the
        `supported devices
        <https://developer.webex.com/docs/api/v1/device-call-settings/read-the-list-of-supported-devices>`_ API.

        :param org_id: The organization associated with the activation code generated. If left empty, the organization
            associated with the caller will be used.
        :type org_id: str
        :param workspace_id: The ID of the workspace where the device will be activated.
        :type workspace_id: str
        :param person_id: The ID of the person who will own the device once activated.
        :type person_id: str
        :param model: The model of the device being created.
        :type model: str
        :rtype: :class:`ActivationCode`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['workspaceId'] = workspace_id
        body['personId'] = person_id
        body['model'] = model
        url = self.ep('activationCode')
        data = super().post(url, params=params, json=body)
        r = ActivationCode.model_validate(data)
        return r

    def create_a_device_by_mac_address(self, mac: str, model: str, org_id: str = None, workspace_id: str = None,
                                       person_id: str = None, password: str = None) -> Device:
        """
        Create a Device by MAC Address

        Create a phone by its MAC address in a specific workspace or for a person.

        Specify the `mac`, `model` and either `workspaceId` or `personId`.

        * You can get the `model` from the `supported devices
        <https://developer.webex.com/docs/api/v1/device-call-settings/read-the-list-of-supported-devices>`_ API.

        * Either `workspaceId` or `personId` should be provided. If both are supplied, the request will be invalid.

        * The `password` field is only required for third party devices. You can obtain the required third party phone
        configuration from `here
        <https://developer.webex.com/docs/api/v1/beta-device-call-settings-with-third-party-device-support/get-third-party-device>`_.

        :param mac: The MAC address of the device being created.
        :type mac: str
        :param model: The model of the device being created.
        :type model: str
        :param org_id: The organization associated with the device. If left empty, the organization associated with the
            caller will be used.
        :type org_id: str
        :param workspace_id: The ID of the workspace where the device will be created.
        :type workspace_id: str
        :param person_id: The ID of the person who will own the device once created.
        :type person_id: str
        :param password: SIP password to be configured for the phone, only required with third party devices.
        :type password: str
        :rtype: :class:`Device`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['mac'] = mac
        body['model'] = model
        body['workspaceId'] = workspace_id
        body['personId'] = person_id
        body['password'] = password
        url = self.ep()
        data = super().post(url, params=params, json=body)
        r = Device.model_validate(data)
        return r


class ECMFolderLinkingApi(ApiChild, base='room/linkedFolders'):
    """
    ECM folder linking
    
    Enterprise Content Management folder-linking in Webex is how users configure existing OneDrive and SharePoint
    online folders as the (default or reference) storage backend for spaces. This configuration can be done in our
    native clients and via API.
    A space participant will be able to configure an ECM folder for a space. Only one ECM folder per space and only
    OneDrive and SharePoint online are currently supported.
    """

    def list_ecm_folder(self, room_id: str) -> list[ECMFolder]:
        """
        List ECM folder

        Lists the ECM folder of a room specified by the `roomId` query parameter.

        :param room_id: ID of the room for which to list the ECM folder.
        :type room_id: str
        :rtype: list[ECMFolder]
        """
        params = {}
        params['roomId'] = room_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[ECMFolder]).validate_python(data['items'])
        return r

    def create_an_ecm_folder_configuration(self, room_id: str, content_url: str, display_name: str,
                                           drive_id: Union[str, datetime], item_id: Union[str, datetime],
                                           default_folder: str) -> ECMFolder:
        """
        Create an ECM folder configuration

        Adds an existing ECM folder to a room as (default or reference) file storage. There is no data validation
        happening for the request. Please ensure the correct `driveId` and `itemId.` These can be collected from the
        MS Graph API. The `contentUrl` and `displayName` are used only for user convenience. The folder will be
        configured with the MS folder name as `displayName`, and the `contentURL` may be updated or corrected as
        needed. To assess final configuration, please make a GET request on the linkedFolder.

        :param room_id: A unique identifier for the room.
        :type room_id: str
        :param content_url: URL of the ECM folder.
        :type content_url: str
        :param display_name: This should match the folder name in the ECM backend.
        :type display_name: str
        :param drive_id: Sharepoint or OneDrive drive id. It can be queried via MS Graph APIs.
        :type drive_id: Union[str, datetime]
        :param item_id: Sharepoint or OneDrive item id. It can be queried via MS Graph APIs.
        :type item_id: Union[str, datetime]
        :param default_folder: Makes the folder the default storage for the space.
        :type default_folder: str
        :rtype: :class:`ECMFolder`
        """
        body = dict()
        body['roomId'] = room_id
        body['contentUrl'] = content_url
        body['displayName'] = display_name
        body['driveId'] = drive_id
        body['itemId'] = item_id
        body['defaultFolder'] = default_folder
        url = self.ep()
        data = super().post(url, json=body)
        r = ECMFolder.model_validate(data)
        return r

    def get_ecm_folder_details(self, id: str) -> ECMFolder:
        """
        Get ECM Folder Details

        Get details for a room ECM folder with the specified folder id.

        :param id: The unique identifier for the folder.
        :type id: str
        :rtype: :class:`ECMFolder`
        """
        url = self.ep(f'{id}')
        data = super().get(url)
        r = ECMFolder.model_validate(data)
        return r

    def update_an_ecm_linked_folder(self, id: str, room_id: str, content_url: str, display_name: str,
                                    drive_id: Union[str, datetime], item_id: Union[str, datetime],
                                    default_folder: str) -> ECMFolder:
        """
        Update an ECM Linked Folder

        Updates the configuration of the specified Room folder. There is no data validation happening for the request.
        Please ensure the correct `driveId` and `itemId.` These can be collected from the MS Graph API. The
        `contentUrl` and `displayName` are used only for user convenience. The folder will be configured with the MS
        folder name as `displayName`, and the `contentURL` may be updated or corrected as needed. To assess final
        configuration, please make a GET request on the linkedFolder.

        :param id: The unique identifier for the room folder.
        :type id: str
        :param room_id: ID of the room that contains the room tab in question.
        :type room_id: str
        :param content_url: Content URL of the folder.
        :type content_url: str
        :param display_name: This should match the folder name in the ECM backend.
        :type display_name: str
        :param drive_id: Sharepoint or OneDrive drive id. It can be queried via MS Graph APIs.
        :type drive_id: Union[str, datetime]
        :param item_id: Sharepoint or OneDrive item id. It can be queried via MS Graph APIs.
        :type item_id: Union[str, datetime]
        :param default_folder: Makes the folder the default storage for the space.
        :type default_folder: str
        :rtype: :class:`ECMFolder`
        """
        body = dict()
        body['roomId'] = room_id
        body['contentUrl'] = content_url
        body['displayName'] = display_name
        body['driveId'] = drive_id
        body['itemId'] = item_id
        body['defaultFolder'] = default_folder
        url = self.ep(f'{id}')
        data = super().put(url, json=body)
        r = ECMFolder.model_validate(data)
        return r

    def unlink_an_ecm_linked_folder(self, id: str):
        """
        Unlink an ECM linked folder

        Unlinks the room-linked folder with the specified ID from the space.

        :param id: The unique identifier for the folder to disassociate from the space.
        :type id: str
        :rtype: None
        """
        url = self.ep(f'{id}')
        super().delete(url)


class EventsApi(ApiChild, base='events'):
    """
    Events
    
    Events are generated when actions take place within Webex, such as when someone creates or deletes a message.
    Compliance Officers may use the Events API to retrieve events for all users within an organization. See the
    `Compliance Guide
    <https://developer.webex.com/docs/api/guides/compliance>`_ for more information.
    """

    def list_events(self, has_attachments: bool, resource: EventResourceEnum = None, type: EventTypeEnum = None,
                    actor_id: str = None, from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                    **params) -> Generator[Event, None, None]:
        """
        List Events

        List events in your organization. Several query parameters are available to filter the response.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param has_attachments: If enabled, filters message events to only those that contain the `attachments`
            attribute.
        :type has_attachments: bool
        :param resource: List events with a specific resource type.
        :type resource: EventResourceEnum
        :param type: List events with a specific event type.
        :type type: EventTypeEnum
        :param actor_id: List events performed by this person, by ID.
        :type actor_id: str
        :param from_: List events which occurred after a specific date and time.
        :type from_: Union[str, datetime]
        :param to_: List events which occurred before a specific date and time.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`Event` instances
        """
        if resource is not None:
            params['resource'] = resource
        if type is not None:
            params['type'] = type
        if actor_id is not None:
            params['actorId'] = actor_id
        params['hasAttachments'] = str(has_attachments).lower()
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Event, item_key='items', params=params)

    def get_event_details(self, event_id: str) -> Event:
        """
        Get Event Details

        Shows details for an event, by event ID.

        Specify the event ID in the `eventId` parameter in the URI.

        :param event_id: The unique identifier for the event.
        :type event_id: str
        :rtype: :class:`Event`
        """
        url = self.ep(f'{event_id}')
        data = super().get(url)
        r = Event.model_validate(data)
        return r


class EventsApi(ApiChild, base='events'):
    """
    Events
    
    Events are generated when actions take place within Webex, such as when someone creates or deletes a message.
    
    The Events API can only be used by a Compliance Officer with an API access token that contains the
    `spark-compliance:events_read` scope. See the `Compliance Guide
    <https://developer.webex.com/docs/compliance#compliance>`_ for more information.
    """

    def list_events(self, resource: EventResourceEnum1 = None, type: EventTypeEnum1 = None, actor_id: str = None,
                    from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                    **params) -> Generator[Event1, None, None]:
        """
        List Events

        List events in your organization. Several query parameters are available to filter the events returned in the
        response.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param resource: List events with a specific resource type.
        :type resource: EventResourceEnum1
        :param type: List events with a specific event type.
        :type type: EventTypeEnum1
        :param actor_id: List events performed by this person, by person ID.
        :type actor_id: str
        :param from_: List events which occurred after a specific date and time.
        :type from_: Union[str, datetime]
        :param to_: List events which occurred before a specific date and time. If unspecified, or set to a time in the
            future, lists events up to the present.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`Event1` instances
        """
        if resource is not None:
            params['resource'] = resource
        if type is not None:
            params['type'] = type
        if actor_id is not None:
            params['actorId'] = actor_id
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Event1, item_key='items', params=params)

    def get_event_details(self, event_id: str) -> Event1:
        """
        Get Event Details

        Shows details for an event, by event ID.

        Specify the event ID in the `eventId` parameter in the URI.

        :param event_id: The unique identifier for the event.
        :type event_id: str
        :rtype: :class:`Event1`
        """
        url = self.ep(f'{event_id}')
        data = super().get(url)
        r = Event1.model_validate(data)
        return r


class FeaturesAnnouncementRepositoryApi(ApiChild, base='telephony/config'):
    """
    Features:  Announcement Repository
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Announcement Repository support reading and writing of Webex Calling Announcement Repository settings for
    a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def fetch_list_of_announcement_greetings_on_location_and_organization_level(self, org_id: str = None,
                                                                                location_id: FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelLocationId = None,
                                                                                start: int = None, order: str = None,
                                                                                file_name: str = None,
                                                                                file_type: str = None,
                                                                                media_file_type: str = None,
                                                                                name: str = None,
                                                                                **params) -> Generator[AnnouncementsListResponse, None, None]:
        """
        Fetch list of announcement greetings on location and organization level

        Fetch a list of binary announcement greetings at an organization as well as location level.

        An admin can upload a file at an organization level. This file will be uploaded to the announcement repository.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Get announcements in this organization.
        :type org_id: str
        :param location_id: Return the list of enterprise or Location announcement files. Without this parameter, the
            Enterprise level announcements are returned.
        :type location_id: FetchListOfAnnouncementGreetingsOnLocationAndOrganizationLevelLocationId
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Sort the list according to fileName or fileSize. The default sort will be in Ascending order.
        :type order: str
        :param file_name: Return the list of announcements with the given fileName.
        :type file_name: str
        :param file_type: Return the list of announcement files for this fileType.
        :type file_type: str
        :param media_file_type: Return the list of announcement files for this mediaFileType.
        :type media_file_type: str
        :param name: Return the list of announcement files for this announcement label.
        :type name: str
        :return: Generator yielding :class:`AnnouncementsListResponse` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if file_name is not None:
            params['fileName'] = file_name
        if file_type is not None:
            params['fileType'] = file_type
        if media_file_type is not None:
            params['mediaFileType'] = media_file_type
        if name is not None:
            params['name'] = name
        url = self.ep('announcements')
        return self.session.follow_pagination(url=url, model=AnnouncementsListResponse, item_key='announcements', params=params)

    def upload_a_binary_announcement_greeting_at_organization_level(self, org_id: str = None) -> str:
        """
        Upload a binary announcement greeting at organization level

        Upload a binary file to the announcement repository at an organization level.

        An admin can upload a file at an organization level. This file will be uploaded to the announcement repository.

        Your request will need to be a `multipart/form-data` request rather than JSON, using the `audio/wav`
        Content-Type.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write` .

        :param org_id: Create an announcement in this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('announcements')
        data = super().post(url, params=params)
        r = data['id']
        return r

    def fetch_repository_usage_for_announcements_for_an_organization(self,
                                                                     org_id: str = None) -> AnnouncementUsageResponse:
        """
        Fetch repository usage for announcements for an organization

        Retrieves repository usage for announcements for an organization.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Get announcement usage in this organization.
        :type org_id: str
        :rtype: :class:`AnnouncementUsageResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('announcements/usage')
        data = super().get(url, params=params)
        r = AnnouncementUsageResponse.model_validate(data)
        return r

    def delete_an_announcement_greeting_of_the_organization(self, announcement_id: str, org_id: str = None):
        """
        Delete an announcement greeting of the organization

        Delete an announcement greeting for an organization.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param announcement_id: Unique identifier of an announcement.
        :type announcement_id: str
        :param org_id: Delete an announcement in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        params['announcementId'] = announcement_id
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('announcements/{announcementsId}')
        super().delete(url, params=params)

    def fetch_details_of_a_binary_announcement_greeting_at_the_organization_level(self, announcement_id: str,
                                                                                  org_id: str = None) -> AnnouncementResponse:
        """
        Fetch details of a binary announcement greeting at the organization level

        Fetch details of a binary announcement greeting by its ID at an organization level.

        An admin can upload a file at an organization level. This file will be uploaded to the announcement repository.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param announcement_id: Unique identifier of an announcement.
        :type announcement_id: str
        :param org_id: Get an announcement in this organization.
        :type org_id: str
        :rtype: :class:`AnnouncementResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'announcements/{announcement_id}')
        data = super().get(url, params=params)
        r = AnnouncementResponse.model_validate(data)
        return r

    def modify_a_binary_announcement_greeting_at_organization_level(self, announcement_id: str, org_id: str = None):
        """
        Modify a binary announcement greeting at organization level

        Modify an existing announcement greeting at an organization level.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param announcement_id: Unique identifier of an announcement.
        :type announcement_id: str
        :param org_id: Modify an announcement in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'announcements/{announcement_id}')
        super().put(url, params=params)

    def upload_a_binary_announcement_greeting_at_the_location_level(self, location_id: str, org_id: str = None) -> str:
        """
        Upload a binary announcement greeting at the location level

        Upload a binary file to the announcement repository at a location level.

        An admin can upload a file at a location level. This file will be uploaded to the announcement repository.

        Your request will need to be a `multipart/form-data` request rather than JSON, using the `audio/wav`
        Content-Type.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write` .

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param org_id: Create an announcement for location in this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements')
        data = super().post(url, params=params)
        r = data['id']
        return r

    def fetch_repository_usage_for_announcements_in_a_location(self, location_id: str,
                                                               org_id: str = None) -> AnnouncementUsageResponse:
        """
        Fetch repository usage for announcements in a location

        Retrieves repository usage for announcements in a location.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param org_id: Get announcement usage for location in this organization.
        :type org_id: str
        :rtype: :class:`AnnouncementUsageResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/usage')
        data = super().get(url, params=params)
        r = AnnouncementUsageResponse.model_validate(data)
        return r

    def delete_an_announcement_greeting_in_a_location(self, location_id: str, org_id: str = None):
        """
        Delete an announcement greeting in a location

        Delete an announcement greeting in a location.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Unique identifier of a location where announcement is being created.
        :type location_id: str
        :param org_id: Delete an announcement for location in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/{announcementsId}')
        super().delete(url, params=params)

    def fetch_details_of_a_binary_announcement_greeting_at_location_level(self, location_id: str, announcement_id: str,
                                                                          org_id: str = None) -> AnnouncementResponse:
        """
        Fetch details of a binary announcement greeting at location level

        Fetch details of a binary announcement greeting by its ID at a location level.

        An admin can upload a file at a location level. This file will be uploaded to the announcement repository.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param announcement_id: Unique identifier of an announcement.
        :type announcement_id: str
        :param org_id: Fetch an announcement for location in this organization.
        :type org_id: str
        :rtype: :class:`AnnouncementResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/{announcement_id}')
        data = super().get(url, params=params)
        r = AnnouncementResponse.model_validate(data)
        return r

    def modify_a_binary_announcement_greeting_at_location_level(self, location_id: str, announcement_id: str,
                                                                org_id: str = None):
        """
        Modify a binary announcement greeting at location level

        Modify an existing announcement greeting at a location level.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Unique identifier of a location where an announcement is being created.
        :type location_id: str
        :param announcement_id: Unique identifier of an announcement.
        :type announcement_id: str
        :param org_id: Modify an announcement for location in this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/announcements/{announcement_id}')
        super().put(url, params=params)


class FeaturesAutoAttendantApi(ApiChild, base='telephony/config'):
    """
    Features:  Auto Attendant
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Auto Attendant support reading and writing of Webex Calling Auto Attendant settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_auto_attendants(self, org_id: str = None, location_id: str = None, start: int = None,
                                         name: str = None, phone_number: str = None,
                                         **params) -> Generator[ListAutoAttendantObject2, None, None]:
        """
        Read the List of Auto Attendants

        List all Auto Attendants for the organization.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List auto attendants for this organization.
        :type org_id: str
        :param location_id: Return the list of auto attendants for this location.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return auto attendants with the matching name.
        :type name: str
        :param phone_number: Only return auto attendants with the matching phone number.
        :type phone_number: str
        :return: Generator yielding :class:`ListAutoAttendantObject2` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('autoAttendants')
        return self.session.follow_pagination(url=url, model=ListAutoAttendantObject2, item_key='autoAttendants', params=params)

    def get_details_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                          org_id: str = None) -> GetAutoAttendantObject2:
        """
        Get Details for an Auto Attendant

        Retrieve an Auto Attendant details.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Retrieving an auto attendant details requires a full or read-only administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve an auto attendant details in this location.
        :type location_id: str
        :param auto_attendant_id: Retrieve the auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param org_id: Retrieve auto attendant details from this organization.
        :type org_id: str
        :rtype: :class:`GetAutoAttendantObject2`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        data = super().get(url, params=params)
        r = GetAutoAttendantObject2.model_validate(data)
        return r

    def create_an_auto_attendant(self, location_id: str, name: str, phone_number: str, extension: Union[str, datetime],
                                 first_name: str, last_name: str, alternate_numbers: list[AlternateNumbersObject],
                                 language_code: str, business_schedule: str, holiday_schedule: str,
                                 extension_dialing: GetAutoAttendantObjectExtensionDialing,
                                 name_dialing: GetAutoAttendantObjectExtensionDialing, time_zone: str,
                                 business_hours_menu: HoursMenuGetObject, after_hours_menu: HoursMenuGetObject,
                                 org_id: str = None) -> str:
        """
        Create an Auto Attendant

        Create new Auto Attendant for the given location.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Creating an auto attendant requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the auto attendant for this location.
        :type location_id: str
        :param name: Unique name for the auto attendant.
        :type name: str
        :param phone_number: Auto attendant phone number.  Either `phoneNumber` or `extension` is mandatory.
        :type phone_number: str
        :param extension: Auto attendant extension.  Either `phoneNumber` or `extension` is mandatory.
        :type extension: Union[str, datetime]
        :param first_name: First name defined for an auto attendant.
        :type first_name: str
        :param last_name: Last name defined for an auto attendant.
        :type last_name: str
        :param alternate_numbers: Alternate numbers defined for the auto attendant.
        :type alternate_numbers: list[AlternateNumbersObject]
        :param language_code: Language code for the auto attendant.
        :type language_code: str
        :param business_schedule: Business hours defined for the auto attendant.
        :type business_schedule: str
        :param holiday_schedule: Holiday defined for the auto attendant.
        :type holiday_schedule: str
        :param extension_dialing: Extension dialing setting. If the values are not set default will be set as
            `ENTERPRISE`.
        :type extension_dialing: GetAutoAttendantObjectExtensionDialing
        :param name_dialing: Name dialing setting. If the values are not set default will be set as `ENTERPRISE`.
        :type name_dialing: GetAutoAttendantObjectExtensionDialing
        :param time_zone: Time zone defined for the auto attendant.
        :type time_zone: str
        :param business_hours_menu: Business hours menu defined for the auto attendant.
        :type business_hours_menu: HoursMenuGetObject
        :param after_hours_menu: After hours menu defined for the auto attendant.
        :type after_hours_menu: HoursMenuGetObject
        :param org_id: Create the auto attendant for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['alternateNumbers'] = loads(TypeAdapter(list[AlternateNumbersObject]).dump_json(alternate_numbers))
        body['languageCode'] = language_code
        body['businessSchedule'] = business_schedule
        body['holidaySchedule'] = holiday_schedule
        body['extensionDialing'] = enum_str(extension_dialing)
        body['nameDialing'] = enum_str(name_dialing)
        body['timeZone'] = time_zone
        body['businessHoursMenu'] = loads(business_hours_menu.model_dump_json())
        body['afterHoursMenu'] = loads(after_hours_menu.model_dump_json())
        url = self.ep(f'locations/{location_id}/autoAttendants')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def update_an_auto_attendant(self, location_id: str, auto_attendant_id: str, name: str, phone_number: str,
                                 extension: Union[str, datetime], first_name: str, last_name: str,
                                 alternate_numbers: list[AlternateNumbersObject], language_code: str,
                                 business_schedule: str, holiday_schedule: str,
                                 extension_dialing: GetAutoAttendantObjectExtensionDialing,
                                 name_dialing: GetAutoAttendantObjectExtensionDialing, time_zone: str,
                                 business_hours_menu: HoursMenuGetObject, after_hours_menu: HoursMenuGetObject,
                                 org_id: str = None):
        """
        Update an Auto Attendant

        Update the designated Auto Attendant.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Updating an auto attendant requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Update an auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param name: Unique name for the auto attendant.
        :type name: str
        :param phone_number: Auto attendant phone number.  Either `phoneNumber` or `extension` is mandatory.
        :type phone_number: str
        :param extension: Auto attendant extension.  Either `phoneNumber` or `extension` is mandatory.
        :type extension: Union[str, datetime]
        :param first_name: First name defined for an auto attendant.
        :type first_name: str
        :param last_name: Last name defined for an auto attendant.
        :type last_name: str
        :param alternate_numbers: Alternate numbers defined for the auto attendant.
        :type alternate_numbers: list[AlternateNumbersObject]
        :param language_code: Language code for the auto attendant.
        :type language_code: str
        :param business_schedule: Business hours defined for the auto attendant.
        :type business_schedule: str
        :param holiday_schedule: Holiday defined for the auto attendant.
        :type holiday_schedule: str
        :param extension_dialing: Extension dialing setting. If the values are not set default will be set as
            `ENTERPRISE`.
        :type extension_dialing: GetAutoAttendantObjectExtensionDialing
        :param name_dialing: Name dialing setting. If the values are not set default will be set as `ENTERPRISE`.
        :type name_dialing: GetAutoAttendantObjectExtensionDialing
        :param time_zone: Time zone defined for the auto attendant.
        :type time_zone: str
        :param business_hours_menu: Business hours menu defined for the auto attendant.
        :type business_hours_menu: HoursMenuGetObject
        :param after_hours_menu: After hours menu defined for the auto attendant.
        :type after_hours_menu: HoursMenuGetObject
        :param org_id: Update an auto attendant from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['alternateNumbers'] = loads(TypeAdapter(list[AlternateNumbersObject]).dump_json(alternate_numbers))
        body['languageCode'] = language_code
        body['businessSchedule'] = business_schedule
        body['holidaySchedule'] = holiday_schedule
        body['extensionDialing'] = enum_str(extension_dialing)
        body['nameDialing'] = enum_str(name_dialing)
        body['timeZone'] = time_zone
        body['businessHoursMenu'] = loads(business_hours_menu.model_dump_json())
        body['afterHoursMenu'] = loads(after_hours_menu.model_dump_json())
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        super().put(url, params=params, json=body)

    def delete_an_auto_attendant(self, location_id: str, auto_attendant_id: str, org_id: str = None):
        """
        Delete an Auto Attendant

        Delete the designated Auto Attendant.

        Auto attendants play customized prompts and provide callers with menu options for routing their calls through
        your system.

        Deleting an auto attendant requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete an auto attendant.
        :type location_id: str
        :param auto_attendant_id: Delete the auto attendant with the matching ID.
        :type auto_attendant_id: str
        :param org_id: Delete the auto attendant from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}')
        super().delete(url, params=params)

    def get_call_forwarding_settings_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                                           org_id: str = None) -> AutoAttendantCallForwardSettingsDetailsObject:
        """
        Get Call Forwarding Settings for an Auto Attendant

        Retrieve Call Forwarding settings for the designated Auto Attendant including the list of call forwarding
        rules.

        Retrieving call forwarding settings for an auto attendant requires a full or read-only administrator or
        location administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Retrieve the call forwarding settings for this auto attendant.
        :type auto_attendant_id: str
        :param org_id: Retrieve auto attendant forwarding settings from this organization.
        :type org_id: str
        :rtype: AutoAttendantCallForwardSettingsDetailsObject
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding')
        data = super().get(url, params=params)
        r = AutoAttendantCallForwardSettingsDetailsObject.model_validate(data['callForwarding'])
        return r

    def update_call_forwarding_settings_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                                              call_forwarding: AutoAttendantCallForwardSettingsModifyDetailsObject,
                                                              org_id: str = None):
        """
        Update Call Forwarding Settings for an Auto Attendant

        Update Call Forwarding settings for the designated Auto Attendant.

        Updating call forwarding settings for an auto attendant requires a full administrator or location administrator
        auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Update call forwarding settings for this auto attendant.
        :type auto_attendant_id: str
        :param call_forwarding: Settings related to `Always`, `Busy`, and `No Answer` call forwarding.
        :type call_forwarding: AutoAttendantCallForwardSettingsModifyDetailsObject
        :param org_id: Update auto attendant forwarding settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callForwarding'] = loads(call_forwarding.model_dump_json())
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding')
        super().put(url, params=params, json=body)

    def create_a_selective_call_forwarding_rule_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                                                      name: str, enabled: bool,
                                                                      business_schedule: str, holiday_schedule: str,
                                                                      forward_to: CallForwardSelectiveForwardToObject,
                                                                      calls_from: CallForwardSelectiveCallsFromObject,
                                                                      calls_to: CallForwardSelectiveCallsToObject,
                                                                      org_id: str = None) -> str:
        """
        Create a Selective Call Forwarding Rule for an Auto Attendant

        Create a Selective Call Forwarding Rule for the designated Auto Attendant.

        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.

        Creating a selective call forwarding rule for an auto attendant requires a full administrator auth token with a
        scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which the auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Create the rule for this auto attendant.
        :type auto_attendant_id: str
        :param name: Unique name for the selective rule in the auto attendant.
        :type name: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject
        :param org_id: Create the auto attendant rule for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['enabled'] = enabled
        body['businessSchedule'] = business_schedule
        body['holidaySchedule'] = holiday_schedule
        body['forwardTo'] = loads(forward_to.model_dump_json())
        body['callsFrom'] = loads(calls_from.model_dump_json())
        body['callsTo'] = loads(calls_to.model_dump_json())
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_selective_call_forwarding_rule_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                                                 rule_id: str,
                                                                 org_id: str = None) -> GetAutoAttendantCallForwardSelectiveRuleObject:
        """
        Get Selective Call Forwarding Rule for an Auto Attendant

        Retrieve a Selective Call Forwarding Rule's settings for the designated Auto Attendant.

        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.

        Retrieving a selective call forwarding rule's settings for an auto attendant requires a full or read-only
        administrator or location administrator

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Retrieve settings for a rule for this auto attendant.
        :type auto_attendant_id: str
        :param rule_id: Auto attendant rule you are retrieving settings for.
        :type rule_id: str
        :param org_id: Retrieve auto attendant rule settings for this organization.
        :type org_id: str
        :rtype: :class:`GetAutoAttendantCallForwardSelectiveRuleObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().get(url, params=params)
        r = GetAutoAttendantCallForwardSelectiveRuleObject.model_validate(data)
        return r

    def update_selective_call_forwarding_rule_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                                                    rule_id: str, name: str, enabled: bool,
                                                                    business_schedule: str, holiday_schedule: str,
                                                                    forward_to: CallForwardSelectiveForwardToObject,
                                                                    calls_from: CallForwardSelectiveCallsFromObject,
                                                                    calls_to: CallForwardSelectiveCallsToObject,
                                                                    org_id: str = None) -> str:
        """
        Update Selective Call Forwarding Rule for an Auto Attendant

        Update a Selective Call Forwarding Rule's settings for the designated Auto Attendant.

        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.

        Updating a selective call forwarding rule's settings for an auto attendant requires a full administrator or
        location administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Update settings for a rule for this auto attendant.
        :type auto_attendant_id: str
        :param rule_id: Auto attendant rule you are updating settings for.
        :type rule_id: str
        :param name: Unique name for the selective rule in the auto attendant.
        :type name: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject
        :param org_id: Update auto attendant rule settings for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['enabled'] = enabled
        body['businessSchedule'] = business_schedule
        body['holidaySchedule'] = holiday_schedule
        body['forwardTo'] = loads(forward_to.model_dump_json())
        body['callsFrom'] = loads(calls_from.model_dump_json())
        body['callsTo'] = loads(calls_to.model_dump_json())
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_selective_call_forwarding_rule_for_an_auto_attendant(self, location_id: str, auto_attendant_id: str,
                                                                      rule_id: str, org_id: str = None):
        """
        Delete a Selective Call Forwarding Rule for an Auto Attendant

        Delete a Selective Call Forwarding Rule for the designated Auto Attendant.

        A selective call forwarding rule for an auto attendant allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the auto attendant's call forwarding
        settings.

        Deleting a selective call forwarding rule for an auto attendant requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this auto attendant exists.
        :type location_id: str
        :param auto_attendant_id: Delete the rule for this auto attendant.
        :type auto_attendant_id: str
        :param rule_id: Auto attendant rule you are deleting.
        :type rule_id: str
        :param org_id: Delete auto attendant rule from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/autoAttendants/{auto_attendant_id}/callForwarding/selectiveRules/{rule_id}')
        super().delete(url, params=params)


class FeaturesCallParkApi(ApiChild, base='telephony/config'):
    """
    Features:  Call Park
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Park supports reading and writing of Webex Calling Call Park settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_call_parks(self, location_id: str, org_id: str = None, start: int = None, order: str = None,
                                    name: str = None,
                                    **params) -> Generator[RouteGroupUsageRouteListItem, None, None]:
        """
        Read the List of Call Parks

        List all Call Parks for the organization.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        **NOTE**: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Return the list of call parks for this location.
        :type location_id: str
        :param org_id: List call parks for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching call parks. Default is 0.
        :type start: int
        :param order: Sort the list of call parks by name, either ASC or DSC. Default is ASC.
        :type order: str
        :param name: Return the list of call parks that contains the given name. The maximum length is 80.
        :type name: str
        :return: Generator yielding :class:`RouteGroupUsageRouteListItem` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = name
        url = self.ep(f'locations/{location_id}/callParks')
        return self.session.follow_pagination(url=url, model=RouteGroupUsageRouteListItem, item_key='callParks', params=params)

    def create_a_call_park(self, location_id: str, name: str, recall: PutRecallHuntGroupObject, agents: list[str],
                           org_id: str = None) -> str:
        """
        Create a Call Park

        Create new Call Parks for the given location.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Creating a call park requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Create the call park for this location.
        :type location_id: str
        :param name: Unique name for the call park. The maximum length is 80.
        :type name: str
        :param recall: Recall options that are added to the call park.
        :type recall: PutRecallHuntGroupObject
        :param agents: Array of ID strings of people, workspaces and virtual lines that are added to the call park.
        :type agents: list[str]
        :param org_id: Create the call park for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['recall'] = loads(recall.model_dump_json())
        body['agents'] = agents
        url = self.ep(f'locations/{location_id}/callParks')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_call_park(self, location_id: str, call_park_id: str, org_id: str = None):
        """
        Delete a Call Park

        Delete the designated Call Park.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Deleting a call park requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Location from which to delete a call park.
        :type location_id: str
        :param call_park_id: Delete the call park with the matching ID.
        :type call_park_id: str
        :param org_id: Delete the call park from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParks/{call_park_id}')
        super().delete(url, params=params)

    def get_details_for_a_call_park(self, location_id: str, call_park_id: str,
                                    org_id: str = None) -> GetCallParkObject1:
        """
        Get Details for a Call Park

        Retrieve Call Park details.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Retrieving call park details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        **NOTE**: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Retrieve settings for a call park in this location.
        :type location_id: str
        :param call_park_id: Retrieve settings for a call park with the matching ID.
        :type call_park_id: str
        :param org_id: Retrieve call park settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallParkObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParks/{call_park_id}')
        data = super().get(url, params=params)
        r = GetCallParkObject1.model_validate(data)
        return r

    def update_a_call_park(self, location_id: str, call_park_id: str, name: str, recall: PutRecallHuntGroupObject,
                           agents: list[str], org_id: str = None) -> str:
        """
        Update a Call Park

        Update the designated Call Park.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Updating a call park requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Park ID will change upon modification of the Call Park name.

        :param location_id: Location in which this call park exists.
        :type location_id: str
        :param call_park_id: Update settings for a call park with the matching ID.
        :type call_park_id: str
        :param name: Unique name for the call park. The maximum length is 80.
        :type name: str
        :param recall: Recall options that are added to call park.
        :type recall: PutRecallHuntGroupObject
        :param agents: Array of ID strings of people, workspaces and virtual lines that are added to call park.
        :type agents: list[str]
        :param org_id: Update call park settings from this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['recall'] = loads(recall.model_dump_json())
        body['agents'] = agents
        url = self.ep(f'locations/{location_id}/callParks/{call_park_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def get_available_agents_from_call_parks(self, location_id: str, org_id: str = None, call_park_name: str = None,
                                             start: int = None, name: str = None, phone_number: str = None,
                                             order: str = None,
                                             **params) -> Generator[GetPersonPlaceVirtualLineCallParksObject1, None, None]:
        """
        Get available agents from Call Parks

        Retrieve available agents from call parks for a given location.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Retrieving available agents from call parks requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Return the available agents for this location.
        :type location_id: str
        :param org_id: Return the available agents for this organization.
        :type org_id: str
        :param call_park_name: Only return available agents from call parks with the matching name.
        :type call_park_name: str
        :param start: Start at the zero-based offset in the list of matching available agents.
        :type start: int
        :param name: Only return available agents with the matching name.
        :type name: str
        :param phone_number: Only return available agents with the matching primary number.
        :type phone_number: str
        :param order: Order the available agents according to the designated fields. Up to three vertical bar (|)
            separated sort order fields may be specified. Available sort fields: fname, lname, number and extension.
            The maximum supported sort order value is 3.
        :type order: str
        :return: Generator yielding :class:`GetPersonPlaceVirtualLineCallParksObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if call_park_name is not None:
            params['callParkName'] = call_park_name
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if order is not None:
            params['order'] = order
        url = self.ep(f'locations/{location_id}/callParks/availableUsers')
        return self.session.follow_pagination(url=url, model=GetPersonPlaceVirtualLineCallParksObject1, item_key='agents', params=params)

    def get_available_recall_hunt_groups_from_call_parks(self, location_id: str, org_id: str = None, start: int = None,
                                                         name: str = None, order: str = None,
                                                         **params) -> Generator[Location, None, None]:
        """
        Get available recall hunt groups from Call Parks

        Retrieve available recall hunt groups from call parks for a given location.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Retrieving available recall hunt groups from call parks requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Return the available recall hunt groups for this location.
        :type location_id: str
        :param org_id: Return the available recall hunt groups for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching available recall hunt groups.
        :type start: int
        :param name: Only return available recall hunt groups with the matching name.
        :type name: str
        :param order: Order the available recall hunt groups according to the designated fields. Available sort fields:
            lname.
        :type order: str
        :return: Generator yielding :class:`Location` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if order is not None:
            params['order'] = order
        url = self.ep(f'locations/{location_id}/callParks/availableRecallHuntGroups')
        return self.session.follow_pagination(url=url, model=Location, item_key='huntGroups', params=params)

    def get_call_park_settings(self, location_id: str, org_id: str = None) -> GetCallParkSettingsObject:
        """
        Get Call Park Settings

        Retrieve Call Park Settings from call parks for a given location.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Retrieving settings from call parks requires a full or read-only administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Return the call park settings for this location.
        :type location_id: str
        :param org_id: Return the call park settings for this organization.
        :type org_id: str
        :rtype: :class:`GetCallParkSettingsObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParks/settings')
        data = super().get(url, params=params)
        r = GetCallParkSettingsObject.model_validate(data)
        return r

    def update_call_park_settings(self, location_id: str, call_park_recall: PutRecallHuntGroupObject,
                                  call_park_settings: CallParkSettingsObject, org_id: str = None):
        """
        Update Call Park settings

        Update Call Park settings for the designated location.

        Call Park allows call recipients to place a call on hold so that it can be retrieved from another device.

        Updating call park settings requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location for which call park settings will be updated.
        :type location_id: str
        :param call_park_recall: Recall options that are added to call park.
        :type call_park_recall: PutRecallHuntGroupObject
        :param call_park_settings: Setting controlling call park behavior.
        :type call_park_settings: CallParkSettingsObject
        :param org_id: Update call park settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callParkRecall'] = loads(call_park_recall.model_dump_json())
        body['callParkSettings'] = loads(call_park_settings.model_dump_json())
        url = self.ep(f'locations/{location_id}/callParks/settings')
        super().put(url, params=params, json=body)

    def read_the_list_of_call_park_extensions(self, org_id: str = None, start: int = None, extension: Union[str,
                                              datetime] = None, name: str = None, location_id: str = None,
                                              location_name: str = None, order: str = None,
                                              **params) -> Generator[ListCallParkExtensionObject1, None, None]:
        """
        Read the List of Call Park Extensions

        List all Call Park Extensions for the organization.

        The Call Park service, enabled for all users by default, allows a user to park a call against an available
        user's extension or to a Call Park Extension. Call Park Extensions are extensions defined within the Call Park
        service for holding parked calls.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List call park extensions for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param extension: Only return call park extensions with the matching extension.
        :type extension: Union[str, datetime]
        :param name: Only return call park extensions with the matching name.
        :type name: str
        :param location_id: Only return call park extensions with matching location ID.
        :type location_id: str
        :param location_name: Only return call park extensions with the matching extension.
        :type location_name: str
        :param order: Order the available agents according to the designated fields.  Available sort fields:
            `groupName`, `callParkExtension`, `callParkExtensionName`, `callParkExtensionExternalId`.
        :type order: str
        :return: Generator yielding :class:`ListCallParkExtensionObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if extension is not None:
            if isinstance(extension, str):
                extension = isoparse(extension)
            extension = dt_iso_str(extension)
            params['extension'] = extension
        if name is not None:
            params['name'] = name
        if location_id is not None:
            params['locationId'] = location_id
        if location_name is not None:
            params['locationName'] = location_name
        if order is not None:
            params['order'] = order
        url = self.ep('callParkExtensions')
        return self.session.follow_pagination(url=url, model=ListCallParkExtensionObject1, item_key='callParkExtensions', params=params)

    def get_details_for_a_call_park_extension(self, location_id: str, call_park_extension_id: str,
                                              org_id: str = None) -> GetCallParkExtensionObject1:
        """
        Get Details for a Call Park Extension

        Retrieve Call Park Extension details.

        The Call Park service, enabled for all users by default, allows a user to park a call against an available
        user's extension or to a Call Park Extension. Call Park Extensions are extensions defined within the Call Park
        service for holding parked calls.

        Retrieving call park extension details requires a full or read-only administrator or location administrator
        auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve details for a call park extension in this location.
        :type location_id: str
        :param call_park_extension_id: Retrieve details for a call park extension with the matching ID.
        :type call_park_extension_id: str
        :param org_id: Retrieve call park extension details from this organization.
        :type org_id: str
        :rtype: :class:`GetCallParkExtensionObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParkExtensions/{call_park_extension_id}')
        data = super().get(url, params=params)
        r = GetCallParkExtensionObject1.model_validate(data)
        return r

    def create_a_call_park_extension(self, location_id: str, name: str, extension: str, org_id: str = None) -> str:
        """
        Create a Call Park Extension

        Create new Call Park Extensions for the given location.

        Call Park Extension enables a call recipient to park a call to an extension, so someone else within the same
        Organization can retrieve the parked call by dialing that extension. Call Park Extensions can be added as
        monitored lines by users' Cisco phones, so users can park and retrieve calls by pressing the associated phone
        line key.

        Creating a call park extension requires a full administrator or location administrator auth token with a scope
        of `spark-admin:telephony_config_write`.

        :param location_id: Create the call park extension for this location.
        :type location_id: str
        :param name: Name for the call park extension. The maximum length is 30.
        :type name: str
        :param extension: Unique extension which will be assigned to call park extension. The minimum length is 2,
            maximum length is 6.
        :type extension: str
        :param org_id: Create the call park extension for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['extension'] = extension
        url = self.ep(f'locations/{location_id}/callParkExtensions')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_call_park_extension(self, location_id: str, call_park_extension_id: str, org_id: str = None):
        """
        Delete a Call Park Extension

        Delete the designated Call Park Extension.

        Call Park Extension enables a call recipient to park a call to an extension, so someone else within the same
        Organization can retrieve the parked call by dialing that extension. Call Park Extensions can be added as
        monitored lines by users' Cisco phones, so users can park and retrieve calls by pressing the associated phone
        line key.

        Deleting a call park extension requires a full administrator or location administrator auth token with a scope
        of `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete a call park extension.
        :type location_id: str
        :param call_park_extension_id: Delete the call park extension with the matching ID.
        :type call_park_extension_id: str
        :param org_id: Delete the call park extension from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callParkExtensions/{call_park_extension_id}')
        super().delete(url, params=params)

    def update_a_call_park_extension(self, location_id: str, call_park_extension_id: str, name: str, extension: str,
                                     org_id: str = None):
        """
        Update a Call Park Extension

        Update the designated Call Park Extension.

        Call Park Extension enables a call recipient to park a call to an extension, so someone else within the same
        Organization can retrieve the parked call by dialing that extension. Call Park Extensions can be added as
        monitored lines by users' Cisco phones, so users can park and retrieve calls by pressing the associated phone
        line key.

        Updating a call park extension requires a full administrator or location administrator auth token with a scope
        of `spark-admin:telephony_config_write`.

        :param location_id: Location in which this call park extension exists.
        :type location_id: str
        :param call_park_extension_id: Update a call park extension with the matching ID.
        :type call_park_extension_id: str
        :param name: Name for the call park extension. The maximum length is 30.
        :type name: str
        :param extension: Unique extension which will be assigned to call park extension. The minimum length is 2,
            maximum length is 6.
        :type extension: str
        :param org_id: Update a call park extension from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['extension'] = extension
        url = self.ep(f'locations/{location_id}/callParkExtensions/{call_park_extension_id}')
        super().put(url, params=params, json=body)


class FeaturesCallPickupApi(ApiChild, base='telephony/config/locations/{locationId}/callPickups'):
    """
    Features:  Call Pickup
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Pickup supports reading and writing of Webex Calling Call Pickup settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_call_pickups(self, location_id: str, org_id: str = None, start: int = None, order: str = None,
                                      name: str = None,
                                      **params) -> Generator[RouteGroupUsageRouteListItem, None, None]:
        """
        Read the List of Call Pickups

        List all Call Pickups for the organization.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Return the list of call pickups for this location.
        :type location_id: str
        :param org_id: List call pickups for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching call pickups. Default is 0.
        :type start: int
        :param order: Sort the list of call pickups by name, either ASC or DSC. Default is ASC.
        :type order: str
        :param name: Return the list of call pickups that contains the given name. The maximum length is 80.
        :type name: str
        :return: Generator yielding :class:`RouteGroupUsageRouteListItem` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        if name is not None:
            params['name'] = name
        url = self.ep(f'')
        return self.session.follow_pagination(url=url, model=RouteGroupUsageRouteListItem, item_key='callPickups', params=params)

    def create_a_call_pickup(self, location_id: str, name: str, agents: list[str], org_id: str = None) -> str:
        """
        Create a Call Pickup

        Create new Call Pickups for the given location.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Creating a call pickup requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Create the call pickup for this location.
        :type location_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param agents: An Array of ID strings of people, workspaces and virtual lines that are added to call pickup.
        :type agents: list[str]
        :param org_id: Create the call pickup for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['agents'] = agents
        url = self.ep(f'')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_call_pickup(self, location_id: str, call_pickup_id: str, org_id: str = None):
        """
        Delete a Call Pickup

        Delete the designated Call Pickup.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Deleting a call pickup requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Location from which to delete a call pickup.
        :type location_id: str
        :param call_pickup_id: Delete the call pickup with the matching ID.
        :type call_pickup_id: str
        :param org_id: Delete the call pickup from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{call_pickup_id}')
        super().delete(url, params=params)

    def get_details_for_a_call_pickup(self, location_id: str, call_pickup_id: str,
                                      org_id: str = None) -> GetCallPickupObject2:
        """
        Get Details for a Call Pickup

        Retrieve Call Pickup details.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Retrieving call pickup details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Retrieve settings for a call pickup in this location.
        :type location_id: str
        :param call_pickup_id: Retrieve settings for a call pickup with the matching ID.
        :type call_pickup_id: str
        :param org_id: Retrieve call pickup settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallPickupObject2`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{call_pickup_id}')
        data = super().get(url, params=params)
        r = GetCallPickupObject2.model_validate(data)
        return r

    def update_a_call_pickup(self, location_id: str, call_pickup_id: str, name: str, agents: list[str],
                             org_id: str = None) -> str:
        """
        Update a Call Pickup

        Update the designated Call Pickup.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Updating a call pickup requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Call Pickup ID will change upon modification of the Call Pickup name.

        :param location_id: Location in which this call pickup exists.
        :type location_id: str
        :param call_pickup_id: Update settings for a call pickup with the matching ID.
        :type call_pickup_id: str
        :param name: Unique name for the call pickup. The maximum length is 80.
        :type name: str
        :param agents: An array of people, workspace, and virtual lines IDs, that are added to call pickup.
        :type agents: list[str]
        :param org_id: Update call pickup settings from this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['agents'] = agents
        url = self.ep(f'{call_pickup_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def get_available_agents_from_call_pickups(self, location_id: str, org_id: str = None,
                                               call_pickup_name: str = None, start: int = None, name: str = None,
                                               phone_number: str = None, order: str = None,
                                               **params) -> Generator[GetPersonPlaceVirtualLineCallPickupObject1, None, None]:
        """
        Get available agents from Call Pickups

        Retrieve available agents from call pickups for a given location.

        Call Pickup enables a user (agent) to answer any ringing line within their pickup group.

        Retrieving available agents from call pickups requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Return the available agents for this location.
        :type location_id: str
        :param org_id: Return the available agents for this organization.
        :type org_id: str
        :param call_pickup_name: Only return available agents from call pickups with the matching name.
        :type call_pickup_name: str
        :param start: Start at the zero-based offset in the list of matching available agents.
        :type start: int
        :param name: Only return available agents with the matching name.
        :type name: str
        :param phone_number: Only return available agents with the matching primary number.
        :type phone_number: str
        :param order: Order the available agents according to the designated fields. Up to three vertical bar (|)
            separated sort order fields may be specified. Available sort fields: `fname`, `lname`, `extension`,
            `number`.
        :type order: str
        :return: Generator yielding :class:`GetPersonPlaceVirtualLineCallPickupObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if call_pickup_name is not None:
            params['callPickupName'] = call_pickup_name
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if order is not None:
            params['order'] = order
        url = self.ep(f'availableUsers')
        return self.session.follow_pagination(url=url, model=GetPersonPlaceVirtualLineCallPickupObject1, item_key='agents', params=params)


class FeaturesCallQueueApi(ApiChild, base='telephony/config'):
    """
    Features:  Call Queue
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Queue supports reading and writing of Webex Calling Call Queue settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_call_queues(self, org_id: str = None, location_id: str = None, start: int = None,
                                     name: str = None, phone_number: str = None,
                                     **params) -> Generator[ListCallQueueObject2, None, None]:
        """
        Read the List of Call Queues

        List all Call Queues for the organization.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List call queues for this organization.
        :type org_id: str
        :param location_id: Only return call queues with matching location ID.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return call queues with the matching name.
        :type name: str
        :param phone_number: Only return call queues with matching primary phone number or extension.
        :type phone_number: str
        :return: Generator yielding :class:`ListCallQueueObject2` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('queues')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject2, item_key='queues', params=params)

    def create_a_call_queue(self, location_id: str, name: str, phone_number: str, extension: Union[str, datetime],
                            language_code: str, first_name: str, last_name: str, time_zone: str,
                            call_policies: GetCallQueueCallPolicyObject1,
                            queue_settings: CallQueueQueueSettingsGetObject,
                            agents: list[PostPersonPlaceVirtualLineCallQueueObject], allow_agent_join_enabled: bool,
                            phone_number_for_outgoing_calls_enabled: bool, org_id: str = None) -> str:
        """
        Create a Call Queue

        Create new Call Queues for the given location.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Creating a call queue requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the call queue for this location.
        :type location_id: str
        :param name: Unique name for the call queue.
        :type name: str
        :param phone_number: Primary phone number of the call queue. Either a `phoneNumber` or `extension` is
            mandatory.
        :type phone_number: str
        :param extension: Primary phone extension of the call queue. Either a `phoneNumber` or extension is mandatory.
        :type extension: Union[str, datetime]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this call queue. Defaults to ".".
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this call queue. Defaults to
            `phoneNumber` if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the call queue.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to `agents`.
        :type call_policies: GetCallQueueCallPolicyObject1
        :param queue_settings: Overall call queue settings.
        :type queue_settings: CallQueueQueueSettingsGetObject
        :param agents: People, workspaces and virtual lines that are eligible to receive calls.
        :type agents: list[PostPersonPlaceVirtualLineCallQueueObject]
        :param allow_agent_join_enabled: Whether or not to allow agents to join or unjoin a queue.
        :type allow_agent_join_enabled: bool
        :param phone_number_for_outgoing_calls_enabled: When true, indicates that the agent's configuration allows them
            to use the queue's Caller ID for outgoing calls.
        :type phone_number_for_outgoing_calls_enabled: bool
        :param org_id: Create the call queue for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['queueSettings'] = loads(queue_settings.model_dump_json())
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceVirtualLineCallQueueObject]).dump_json(agents))
        body['allowAgentJoinEnabled'] = allow_agent_join_enabled
        body['phoneNumberForOutgoingCallsEnabled'] = phone_number_for_outgoing_calls_enabled
        url = self.ep(f'locations/{location_id}/queues')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_call_queue(self, location_id: str, queue_id: str, org_id: str = None):
        """
        Delete a Call Queue

        Delete the designated Call Queue.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Deleting a call queue requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete a call queue.
        :type location_id: str
        :param queue_id: Delete the call queue with the matching ID.
        :type queue_id: str
        :param org_id: Delete the call queue from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        super().delete(url, params=params)

    def get_details_for_a_call_queue(self, location_id: str, queue_id: str, org_id: str = None) -> GetCallQueueObject2:
        """
        Get Details for a Call Queue

        Retrieve Call Queue details.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Retrieving call queue details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallQueueObject2`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        data = super().get(url, params=params)
        r = GetCallQueueObject2.model_validate(data)
        return r

    def update_a_call_queue(self, location_id: str, queue_id: str, enabled: bool, name: str, language_code: str,
                            first_name: str, last_name: str, time_zone: str, phone_number: str, extension: Union[str,
                            datetime], alternate_number_settings: GetCallQueueObjectAlternateNumberSettings,
                            call_policies: GetCallQueueCallPolicyObject1,
                            queue_settings: CallQueueQueueSettingsGetObject,
                            allow_call_waiting_for_agents_enabled: bool,
                            agents: list[ModifyPersonPlaceVirtualLineCallQueueObject], allow_agent_join_enabled: bool,
                            phone_number_for_outgoing_calls_enabled: bool, org_id: str = None):
        """
        Update a Call Queue

        Update the designated Call Queue.

        Call queues temporarily hold calls in the cloud when all agents, which
        can be users or agents, assigned to receive calls from the queue are
        unavailable. Queued calls are routed to an available agent when not on an
        active call. Each call queue is assigned a Lead Number, which is a telephone
        number outside callers can dial to reach users assigned to the call queue.
        Call queues are also assigned an internal extension, which can be dialed
        internally to reach users assigned to the call queue.

        Updating a call queue requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param enabled: Whether or not the call queue is enabled.
        :type enabled: bool
        :param name: Unique name for the call queue.
        :type name: str
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this call queue. Defaults to `.`.
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this call queue. Defaults to the
            `phoneNumber` if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param phone_number: Primary phone number of the call queue.
        :type phone_number: str
        :param extension: Extension of the call queue.
        :type extension: Union[str, datetime]
        :param alternate_number_settings: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a call queue. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the call queue.
        :type alternate_number_settings: GetCallQueueObjectAlternateNumberSettings
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: GetCallQueueCallPolicyObject1
        :param queue_settings: Overall call queue settings.
        :type queue_settings: CallQueueQueueSettingsGetObject
        :param allow_call_waiting_for_agents_enabled: Flag to indicate whether call waiting is enabled for agents.
        :type allow_call_waiting_for_agents_enabled: bool
        :param agents: People, workspaces and virtual lines that are eligible to receive calls.
        :type agents: list[ModifyPersonPlaceVirtualLineCallQueueObject]
        :param allow_agent_join_enabled: Whether or not to allow agents to join or unjoin a queue.
        :type allow_agent_join_enabled: bool
        :param phone_number_for_outgoing_calls_enabled: When `true`, indicates that the agent's configuration allows
            them to use the queue's Caller ID for outgoing calls.
        :type phone_number_for_outgoing_calls_enabled: bool
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['name'] = name
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['alternateNumberSettings'] = loads(alternate_number_settings.model_dump_json())
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['queueSettings'] = loads(queue_settings.model_dump_json())
        body['allowCallWaitingForAgentsEnabled'] = allow_call_waiting_for_agents_enabled
        body['agents'] = loads(TypeAdapter(list[ModifyPersonPlaceVirtualLineCallQueueObject]).dump_json(agents))
        body['allowAgentJoinEnabled'] = allow_agent_join_enabled
        body['phoneNumberForOutgoingCallsEnabled'] = phone_number_for_outgoing_calls_enabled
        url = self.ep(f'locations/{location_id}/queues/{queue_id}')
        super().put(url, params=params, json=body)

    def read_the_list_of_call_queue_announcement_files(self, location_id: str, queue_id: str,
                                                       org_id: str = None) -> list[GetAnnouncementFileInfo]:
        """
        Read the List of Call Queue Announcement Files

        List file info for all Call Queue announcement files associated with this Call Queue.

        Call Queue announcement files contain messages and music that callers hear while waiting in the queue. A call
        queue can be configured to play whatever subset of these announcement files is desired.

        Retrieving this list of files requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        Note that uploading of announcement files via API is not currently supported, but is available via Webex
        Control Hub.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Retrieve anouncement files for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve announcement files for a call queue from this organization.
        :type org_id: str
        :rtype: list[GetAnnouncementFileInfo]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/announcements')
        data = super().get(url, params=params)
        r = TypeAdapter(list[GetAnnouncementFileInfo]).validate_python(data['announcements'])
        return r

    def delete_a_call_queue_announcement_file(self, location_id: str, queue_id: str, file_name: str,
                                              org_id: str = None):
        """
        Delete a Call Queue Announcement File

        Delete an announcement file for the designated Call Queue.

        Call Queue announcement files contain messages and music that callers hear while waiting in the queue. A call
        queue can be configured to play whatever subset of these announcement files is desired.

        Deleting an announcement file for a call queue requires a full administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Delete an announcement for a call queue in this location.
        :type location_id: str
        :param queue_id: Delete an announcement for the call queue with this identifier.
        :type queue_id: str
        :type file_name: str
        :param org_id: Delete call queue announcement from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/announcements/{file_name}')
        super().delete(url, params=params)

    def get_call_forwarding_settings_for_a_call_queue(self, location_id: str, queue_id: str,
                                                      org_id: str = None) -> CallForwardSettingsGetCallForwarding:
        """
        Get Call Forwarding Settings for a Call Queue

        Retrieve Call Forwarding settings for the designated Call Queue including the list of call forwarding rules.

        Retrieving call forwarding settings for a call queue requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Retrieve the call forwarding settings for this call queue.
        :type queue_id: str
        :param org_id: Retrieve call queue forwarding settings from this organization.
        :type org_id: str
        :rtype: CallForwardSettingsGetCallForwarding
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding')
        data = super().get(url, params=params)
        r = CallForwardSettingsGetCallForwarding.model_validate(data['callForwarding'])
        return r

    def update_call_forwarding_settings_for_a_call_queue(self, location_id: str, queue_id: str,
                                                         call_forwarding: ModifyCallForwardingObjectCallForwarding,
                                                         org_id: str = None):
        """
        Update Call Forwarding Settings for a Call Queue

        Update Call Forwarding settings for the designated Call Queue.

        Updating call forwarding settings for a call queue requires a full administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update call forwarding settings for this call queue.
        :type queue_id: str
        :param call_forwarding: Settings related to `Always`, `Busy`, and `No Answer` call forwarding.
        :type call_forwarding: ModifyCallForwardingObjectCallForwarding
        :param org_id: Update call queue forwarding settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callForwarding'] = loads(call_forwarding.model_dump_json())
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding')
        super().put(url, params=params, json=body)

    def create_a_selective_call_forwarding_rule_for_a_call_queue(self, location_id: str, queue_id: str, name: str,
                                                                 enabled: bool, holiday_schedule: str,
                                                                 business_schedule: str,
                                                                 forward_to: CallForwardSelectiveForwardToObject,
                                                                 calls_from: CallForwardSelectiveCallsFromObject,
                                                                 calls_to: CallForwardSelectiveCallsToObject,
                                                                 org_id: str = None) -> str:
        """
        Create a Selective Call Forwarding Rule for a Call Queue

        Create a Selective Call Forwarding Rule for the designated Call Queue.

        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.

        Creating a selective call forwarding rule for a call queue requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which the call queue exists.
        :type location_id: str
        :param queue_id: Create the rule for this call queue.
        :type queue_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject
        :param org_id: Create the call queue rule for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['enabled'] = enabled
        body['holidaySchedule'] = holiday_schedule
        body['businessSchedule'] = business_schedule
        body['forwardTo'] = loads(forward_to.model_dump_json())
        body['callsFrom'] = loads(calls_from.model_dump_json())
        body['callsTo'] = loads(calls_to.model_dump_json())
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_selective_call_forwarding_rule_for_a_call_queue(self, location_id: str, queue_id: str, rule_id: str,
                                                            org_id: str = None) -> GetAutoAttendantCallForwardSelectiveRuleObject:
        """
        Get Selective Call Forwarding Rule for a Call Queue

        Retrieve a Selective Call Forwarding Rule's settings for the designated Call Queue.

        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.

        Retrieving a selective call forwarding rule's settings for a call queue requires a full or read-only
        administrator or location administrator auth token with a scope of `spark-admin:telephony_config_read`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which to call queue exists.
        :type location_id: str
        :param queue_id: Retrieve setting for a rule for this call queue.
        :type queue_id: str
        :param rule_id: Call queue rule you are retrieving settings for.
        :type rule_id: str
        :param org_id: Retrieve call queue rule settings for this organization.
        :type org_id: str
        :rtype: :class:`GetAutoAttendantCallForwardSelectiveRuleObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().get(url, params=params)
        r = GetAutoAttendantCallForwardSelectiveRuleObject.model_validate(data)
        return r

    def update_a_selective_call_forwarding_rule_for_a_call_queue(self, location_id: str, queue_id: str, rule_id: str,
                                                                 name: str, enabled: bool, holiday_schedule: str,
                                                                 business_schedule: str,
                                                                 forward_to: CallForwardSelectiveForwardToObject,
                                                                 calls_from: CallForwardSelectiveCallsFromObject,
                                                                 calls_to: CallForwardSelectiveCallsToObject,
                                                                 org_id: str = None) -> str:
        """
        Update a Selective Call Forwarding Rule for a Call Queue

        Update a Selective Call Forwarding Rule's settings for the designated Call Queue.

        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.

        Updating a selective call forwarding rule's settings for a call queue requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update settings for a rule for this call queue.
        :type queue_id: str
        :param rule_id: Call queue rule you are updating settings for.
        :type rule_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject
        :param org_id: Update call queue rule settings for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['enabled'] = enabled
        body['holidaySchedule'] = holiday_schedule
        body['businessSchedule'] = business_schedule
        body['forwardTo'] = loads(forward_to.model_dump_json())
        body['callsFrom'] = loads(calls_from.model_dump_json())
        body['callsTo'] = loads(calls_to.model_dump_json())
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_selective_call_forwarding_rule_for_a_call_queue(self, location_id: str, queue_id: str, rule_id: str,
                                                                 org_id: str = None):
        """
        Delete a Selective Call Forwarding Rule for a Call Queue

        Delete a Selective Call Forwarding Rule for the designated Call Queue.

        A selective call forwarding rule for a call queue allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the call queue's call forwarding settings.

        Deleting a selective call forwarding rule for a call queue requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Delete the rule for this call queue.
        :type queue_id: str
        :param rule_id: Call queue rule you are deleting.
        :type rule_id: str
        :param org_id: Delete call queue rule from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/callForwarding/selectiveRules/{rule_id}')
        super().delete(url, params=params)

    def get_details_for_a_call_queue_holiday_service(self, location_id: str, queue_id: str,
                                                     org_id: str = None) -> GetCallQueueHolidayObject:
        """
        Get Details for a Call Queue Holiday Service

        Retrieve Call Queue Holiday Service details.

        Configure the call queue to route calls differently during the holidays.

        Retrieving call queue holiday service details requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallQueueHolidayObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/holidayService')
        data = super().get(url, params=params)
        r = GetCallQueueHolidayObject.model_validate(data)
        return r

    def update_a_call_queue_holiday_service(self, location_id: str, queue_id: str, holiday_service_enabled: bool,
                                            action: GetCallQueueHolidayObjectAction,
                                            holiday_schedule_level: AudioAnnouncementFileGetObjectLevel,
                                            holiday_schedule_name: str, transfer_phone_number: str,
                                            play_announcement_before_enabled: bool,
                                            audio_message_selection: HoursMenuObjectGreeting,
                                            audio_files: list[AudioAnnouncementFileFeatureGetObject],
                                            org_id: str = None):
        """
        Update a Call Queue Holiday Service

        Update the designated Call Queue Holiday Service.

        Configure the call queue to route calls differently during the holidays.

        Updating a call queue holiday service requires a full administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_write`.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param holiday_service_enabled: Enable or Disable the call queue holiday service routing policy.
        :type holiday_service_enabled: bool
        :param action: Specifies call processing action type.
        :type action: GetCallQueueHolidayObjectAction
        :param holiday_schedule_level: Specifies whether the schedule mentioned in `holidayScheduleName` is org or
            location specific. (Must be from `holidaySchedules` list)
        :type holiday_schedule_level: AudioAnnouncementFileGetObjectLevel
        :param holiday_schedule_name: Name of the schedule configured for a holiday service as one of from
            `holidaySchedules` list.
        :type holiday_schedule_name: str
        :param transfer_phone_number: Call gets transferred to this number when action is set to `TRANSFER`. This can
            also be an extension.
        :type transfer_phone_number: str
        :param play_announcement_before_enabled: Specifies if an announcement plays to callers before applying the
            action.
        :type play_announcement_before_enabled: bool
        :param audio_message_selection: Specifies what type of announcement to be played.
        :type audio_message_selection: HoursMenuObjectGreeting
        :param audio_files: List of pre-configured Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
        :type audio_files: list[AudioAnnouncementFileFeatureGetObject]
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['holidayServiceEnabled'] = holiday_service_enabled
        body['action'] = enum_str(action)
        body['holidayScheduleLevel'] = enum_str(holiday_schedule_level)
        body['holidayScheduleName'] = holiday_schedule_name
        body['transferPhoneNumber'] = transfer_phone_number
        body['playAnnouncementBeforeEnabled'] = play_announcement_before_enabled
        body['audioMessageSelection'] = enum_str(audio_message_selection)
        body['audioFiles'] = loads(TypeAdapter(list[AudioAnnouncementFileFeatureGetObject]).dump_json(audio_files))
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/holidayService')
        super().put(url, params=params, json=body)

    def get_details_for_a_call_queue_night_service(self, location_id: str, queue_id: str,
                                                   org_id: str = None) -> GetCallQueueNightServiceObject:
        """
        Get Details for a Call Queue Night Service

        Retrieve Call Queue Night service details.

        Configure the call queue to route calls differently during the hours when the queue is not in service. This is
        determined by a schedule that defines the business hours of the queue.

        Retrieving call queue details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue night service with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue night service settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallQueueNightServiceObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/nightService')
        data = super().get(url, params=params)
        r = GetCallQueueNightServiceObject.model_validate(data)
        return r

    def update_a_call_queue_night_service(self, location_id: str, queue_id: str, night_service_enabled: bool,
                                          action: GetCallQueueHolidayObjectAction, transfer_phone_number: Union[str,
                                          datetime], play_announcement_before_enabled: bool,
                                          announcement_mode: GetCallQueueNightServiceObjectAnnouncementMode,
                                          audio_message_selection: HoursMenuObjectGreeting,
                                          audio_files: list[AudioAnnouncementFileFeatureGetObject],
                                          business_hours_name: str,
                                          business_hours_level: AudioAnnouncementFileGetObjectLevel,
                                          force_night_service_enabled: bool,
                                          manual_audio_message_selection: HoursMenuObjectGreeting,
                                          manual_audio_files: list[AudioAnnouncementFileFeatureGetObject],
                                          org_id: str = None):
        """
        Update a Call Queue Night Service

        Update Call Queue Night Service details.

        Configure the call queue to route calls differently during the hours when the queue is not in service. This is
        determined by a schedule that defines the business hours of the queue.

        Updating call queue night service details requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue night service with this identifier.
        :type queue_id: str
        :param night_service_enabled: Enable or disable call queue night service routing policy.
        :type night_service_enabled: bool
        :param action: Specifies call processing action type.
        :type action: GetCallQueueHolidayObjectAction
        :param transfer_phone_number: Call gets transferred to this number when action is set to `TRANSFER`. This can
            also be an extension.
        :type transfer_phone_number: Union[str, datetime]
        :param play_announcement_before_enabled: Specifies if an announcement plays to callers before applying the
            action.
        :type play_announcement_before_enabled: bool
        :param announcement_mode: Specifies the type of announcements to played.
        :type announcement_mode: GetCallQueueNightServiceObjectAnnouncementMode
        :param audio_message_selection: Specifies what type of announcements to be played when `announcementMode` is
            `NORMAL`.
        :type audio_message_selection: HoursMenuObjectGreeting
        :param audio_files: List of pre-configured Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
        :type audio_files: list[AudioAnnouncementFileFeatureGetObject]
        :param business_hours_name: Name of the schedule configured for a night service as one of from
            `businessHourSchedules` list.
        :type business_hours_name: str
        :param business_hours_level: Specifies whether the above mentioned schedule is org or location specific. (Must
            be from `businessHourSchedules` list)
        :type business_hours_level: AudioAnnouncementFileGetObjectLevel
        :param force_night_service_enabled: Force night service regardless of business hour schedule.
        :type force_night_service_enabled: bool
        :param manual_audio_message_selection: Specifies what type of announcement to be played when `announcementMode`
            is `MANUAL`.
        :type manual_audio_message_selection: HoursMenuObjectGreeting
        :param manual_audio_files: List Of pre-configured Audio Files.
        :type manual_audio_files: list[AudioAnnouncementFileFeatureGetObject]
        :param org_id: Retrieve call queue night service settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['nightServiceEnabled'] = night_service_enabled
        body['action'] = enum_str(action)
        body['transferPhoneNumber'] = transfer_phone_number
        body['playAnnouncementBeforeEnabled'] = play_announcement_before_enabled
        body['announcementMode'] = enum_str(announcement_mode)
        body['audioMessageSelection'] = enum_str(audio_message_selection)
        body['audioFiles'] = loads(TypeAdapter(list[AudioAnnouncementFileFeatureGetObject]).dump_json(audio_files))
        body['businessHoursName'] = business_hours_name
        body['businessHoursLevel'] = enum_str(business_hours_level)
        body['forceNightServiceEnabled'] = force_night_service_enabled
        body['manualAudioMessageSelection'] = enum_str(manual_audio_message_selection)
        body['manualAudioFiles'] = loads(TypeAdapter(list[AudioAnnouncementFileFeatureGetObject]).dump_json(manual_audio_files))
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/nightService')
        super().put(url, params=params, json=body)

    def get_details_for_a_call_queue_forced_forward(self, location_id: str, queue_id: str,
                                                    org_id: str = None) -> GetCallQueueForcedForwardObject:
        """
        Get Details for a Call Queue Forced Forward

        Retrieve Call Queue policy Forced Forward details.

        This policy allows calls to be temporarily diverted to a configured destination.

        Retrieving call queue Forced Forward details requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallQueueForcedForwardObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/forcedForward')
        data = super().get(url, params=params)
        r = GetCallQueueForcedForwardObject.model_validate(data)
        return r

    def update_a_call_queue_forced_forward_service(self, location_id: str, queue_id: str, forced_forward_enabled: bool,
                                                   transfer_phone_number: str, play_announcement_before_enabled: bool,
                                                   audio_message_selection: HoursMenuObjectGreeting,
                                                   audio_files: list[AudioAnnouncementFileFeatureGetObject],
                                                   org_id: str = None):
        """
        Update a Call Queue Forced Forward service

        Update the designated Forced Forward Service.

        If the option is enabled, then incoming calls to the queue are forwarded to the configured destination. Calls
        that are already in the queue remain queued.
        The policy can be configured to play an announcement prior to proceeding with the forward.

        Updating a call queue Forced Forward service requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param forced_forward_enabled: Enable or disable call forced forward service routing policy.
        :type forced_forward_enabled: bool
        :param transfer_phone_number: Call gets transferred to this number when action is set to `TRANSFER`. This can
            also be an extension.
        :type transfer_phone_number: str
        :param play_announcement_before_enabled: Specifies if an announcement plays to callers before applying the
            action.
        :type play_announcement_before_enabled: bool
        :param audio_message_selection: Specifies what type of announcement to be played.
        :type audio_message_selection: HoursMenuObjectGreeting
        :param audio_files: List of pre-configured Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
        :type audio_files: list[AudioAnnouncementFileFeatureGetObject]
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['forcedForwardEnabled'] = forced_forward_enabled
        body['transferPhoneNumber'] = transfer_phone_number
        body['playAnnouncementBeforeEnabled'] = play_announcement_before_enabled
        body['audioMessageSelection'] = enum_str(audio_message_selection)
        body['audioFiles'] = loads(TypeAdapter(list[AudioAnnouncementFileFeatureGetObject]).dump_json(audio_files))
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/forcedForward')
        super().put(url, params=params, json=body)

    def get_details_for_a_call_queue_stranded_calls(self, location_id: str, queue_id: str,
                                                    org_id: str = None) -> GetCallQueueStrandedCallsObject:
        """
        Get Details for a Call Queue Stranded Calls

        Allow admin to view default/configured Stranded Calls settings.

        Stranded-All agents logoff Policy: If the last agent staffing a queue unjoins the queue or signs out, then
        all calls in the queue become stranded.
        Stranded-Unavailable Policy: This policy allows for the configuration of the processing of calls that are in a
        staffed queue when all agents are unavailable.

        Retrieving call queue Stranded Calls details requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a call queue in this location.
        :type location_id: str
        :param queue_id: Retrieve settings for the call queue with this identifier.
        :type queue_id: str
        :param org_id: Retrieve call queue settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallQueueStrandedCallsObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/strandedCalls')
        data = super().get(url, params=params)
        r = GetCallQueueStrandedCallsObject.model_validate(data)
        return r

    def update_a_call_queue_stranded_calls_service(self, location_id: str, queue_id: str,
                                                   action: GetCallQueueStrandedCallsObjectAction,
                                                   transfer_phone_number: str,
                                                   audio_message_selection: HoursMenuObjectGreeting,
                                                   audio_files: list[AudioAnnouncementFileFeatureGetObject],
                                                   org_id: str = None):
        """
        Update a Call Queue Stranded Calls service

        Update the designated Call Stranded Calls Service.

        Allow admin to modify configured Stranded Calls settings.

        Updating a call queue stranded calls requires a full administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_write`.

        :param location_id: Location in which this call queue exists.
        :type location_id: str
        :param queue_id: Update setting for the call queue with the matching ID.
        :type queue_id: str
        :param action: Specifies call processing action type.
        :type action: GetCallQueueStrandedCallsObjectAction
        :param transfer_phone_number: Call gets transferred to this number when action is set to `TRANSFER`. This can
            also be an extension.
        :type transfer_phone_number: str
        :param audio_message_selection: Specifies what type of announcement to be played.
        :type audio_message_selection: HoursMenuObjectGreeting
        :param audio_files: List of pre-configured Announcement Audio Files when `audioMessageSelection` is `CUSTOM`.
        :type audio_files: list[AudioAnnouncementFileFeatureGetObject]
        :param org_id: Update call queue settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['action'] = enum_str(action)
        body['transferPhoneNumber'] = transfer_phone_number
        body['audioMessageSelection'] = enum_str(audio_message_selection)
        body['audioFiles'] = loads(TypeAdapter(list[AudioAnnouncementFileFeatureGetObject]).dump_json(audio_files))
        url = self.ep(f'locations/{location_id}/queues/{queue_id}/strandedCalls')
        super().put(url, params=params, json=body)


class FeaturesCallRecordingApi(ApiChild, base='telephony/config'):
    """
    Features:  Call Recording
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Call Recording supports reading and writing of Webex Calling Call Recording settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_call_recording_settings(self, org_id: str = None) -> GetCallRecordingObject:
        """
        Get Call Recording Settings

        Retrieve Call Recording settings for the organization.

        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.

        Retrieving call recording settings requires a full or read-only administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_read`.

        :param org_id: Retrieve call recording settings from this organization.
        :type org_id: str
        :rtype: :class:`GetCallRecordingObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('callRecording')
        data = super().get(url, params=params)
        r = GetCallRecordingObject.model_validate(data)
        return r

    def update_call_recording_settings(self, enabled: bool, org_id: str = None):
        """
        Update Call Recording Settings

        Update Call Recording settings for the organization.

        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.

        Updating call recording settings requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: This API is for Cisco partners only.

        :param enabled: Whether or not the call recording is enabled.
        :type enabled: bool
        :param org_id: Retrieve call recording settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        url = self.ep('callRecording')
        super().put(url, params=params, json=body)

    def get_call_recording_terms_of_service_settings(self, vendor_id: str,
                                                     org_id: str = None) -> GetCallRecordingTermsOfServiceObject:
        """
        Get Call Recording Terms Of Service Settings

        Retrieve Call Recording Terms Of Service settings for the organization.

        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.

        Retrieving call recording terms of service settings requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param vendor_id: Retrieve call recording terms of service details for the given vendor.
        :type vendor_id: str
        :param org_id: Retrieve call recording terms of service details from this organization.
        :type org_id: str
        :rtype: :class:`GetCallRecordingTermsOfServiceObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'callRecording/vendors/{vendor_id}/termsOfService')
        data = super().get(url, params=params)
        r = GetCallRecordingTermsOfServiceObject.model_validate(data)
        return r

    def update_call_recording_terms_of_service_settings(self, vendor_id: str, terms_of_service_enabled: bool,
                                                        org_id: str = None):
        """
        Update Call Recording Terms Of Service Settings

        Update Call Recording Terms Of Service settings for the given vendor.

        Call Recording feature enables authorized agents to record any active call that Webex Contact Center manages.

        Updating call recording terms of service settings requires a full administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param vendor_id: Update call recording terms of service settings for the given vendor.
        :type vendor_id: str
        :param terms_of_service_enabled: Whether or not the call recording terms of service are enabled.
        :type terms_of_service_enabled: bool
        :param org_id: Update call recording terms of service settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['termsOfServiceEnabled'] = terms_of_service_enabled
        url = self.ep(f'callRecording/vendors/{vendor_id}/termsOfService')
        super().put(url, params=params, json=body)

    def get_details_for_the_organization_compliance_announcement_setting(self,
                                                                         org_id: str = None) -> GetOrgComplianceAnnouncementObject:
        """
        Get Details for the organization compliance announcement setting

        Retrieve the organization compliance announcement settings.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Retrieving organization compliance announcement setting requires a full or read-only administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param org_id: Retrieve compliance announcement setting from this organization.
        :type org_id: str
        :rtype: :class:`GetOrgComplianceAnnouncementObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep('callRecording/complianceAnnouncement')
        data = super().get(url, params=params)
        r = GetOrgComplianceAnnouncementObject.model_validate(data)
        return r

    def update_the_organization_compliance_announcement(self, inbound_pstncalls_enabled: bool,
                                                        outbound_pstncalls_enabled: bool,
                                                        outbound_pstncalls_delay_enabled: bool, delay_in_seconds: int,
                                                        org_id: str = None):
        """
        Update the organization compliance announcement

        Update the organization compliance announcement.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Updating the organization compliance announcement requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param inbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is played
            to an inbound caller.
        :type inbound_pstncalls_enabled: bool
        :param outbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is
            played to an outbound caller.
        :type outbound_pstncalls_enabled: bool
        :param outbound_pstncalls_delay_enabled: Flag to indicate whether compliance announcement is played after a
            specified delay in seconds.
        :type outbound_pstncalls_delay_enabled: bool
        :param delay_in_seconds: Number of seconds to wait before playing the compliance announcement.
        :type delay_in_seconds: int
        :param org_id: Update the compliance announcement setting from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['inboundPSTNCallsEnabled'] = inbound_pstncalls_enabled
        body['outboundPSTNCallsEnabled'] = outbound_pstncalls_enabled
        body['outboundPSTNCallsDelayEnabled'] = outbound_pstncalls_delay_enabled
        body['delayInSeconds'] = delay_in_seconds
        url = self.ep('callRecording/complianceAnnouncement')
        super().put(url, params=params, json=body)

    def get_details_for_the_location_compliance_announcement_setting(self, location_id: str,
                                                                     org_id: str = None) -> GetComplianceAnnouncementObject:
        """
        Get Details for the location compliance announcement setting

        Retrieve the location compliance announcement settings.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Retrieving location compliance announcement setting requires a full or read-only administrator auth token with
        a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve compliance announcement settings for this location.
        :type location_id: str
        :param org_id: Retrieve compliance announcement setting from this organization.
        :type org_id: str
        :rtype: :class:`GetComplianceAnnouncementObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/callRecording/complianceAnnouncement')
        data = super().get(url, params=params)
        r = GetComplianceAnnouncementObject.model_validate(data)
        return r

    def update_the_location_compliance_announcement(self, location_id: str, inbound_pstncalls_enabled: bool,
                                                    use_org_settings_enabled: bool, outbound_pstncalls_enabled: bool,
                                                    outbound_pstncalls_delay_enabled: bool, delay_in_seconds: int,
                                                    org_id: str = None):
        """
        Update the location compliance announcement

        Update the location compliance announcement.

        The Compliance Announcement feature interacts with the Call Recording feature, specifically with the playback
        of the start/stop announcement. When the compliance announcement is played to the PSTN party, and the PSTN
        party is connected to a party with call recording enabled, then the start/stop announcement is inhibited.

        Updating the location compliance announcement requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update the compliance announcement settings for this location.
        :type location_id: str
        :param inbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is played
            to an inbound caller.
        :type inbound_pstncalls_enabled: bool
        :param use_org_settings_enabled: Flag to indicate whether to use the customer level compliance announcement
            default settings.
        :type use_org_settings_enabled: bool
        :param outbound_pstncalls_enabled: Flag to indicate whether the Call Recording START/STOP announcement is
            played to an outbound caller.
        :type outbound_pstncalls_enabled: bool
        :param outbound_pstncalls_delay_enabled: Flag to indicate whether compliance announcement is played after a
            specified delay in seconds.
        :type outbound_pstncalls_delay_enabled: bool
        :param delay_in_seconds: Number of seconds to wait before playing the compliance announcement.
        :type delay_in_seconds: int
        :param org_id: Update the compliance announcement setting from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['inboundPSTNCallsEnabled'] = inbound_pstncalls_enabled
        body['useOrgSettingsEnabled'] = use_org_settings_enabled
        body['outboundPSTNCallsEnabled'] = outbound_pstncalls_enabled
        body['outboundPSTNCallsDelayEnabled'] = outbound_pstncalls_delay_enabled
        body['delayInSeconds'] = delay_in_seconds
        url = self.ep(f'locations/{location_id}/callRecording/complianceAnnouncement')
        super().put(url, params=params, json=body)


class FeaturesHuntGroupApi(ApiChild, base='telephony/config'):
    """
    Features:  Hunt Group
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Hunt Group supports reading and writing of Webex Calling Hunt Group settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_hunt_groups(self, org_id: str = None, location_id: str = None, start: int = None,
                                     name: str = None, phone_number: str = None,
                                     **params) -> Generator[ListCallQueueObject2, None, None]:
        """
        Read the List of Hunt Groups

        List all calling Hunt Groups for the organization.

        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List hunt groups for this organization.
        :type org_id: str
        :param location_id: Only return hunt groups with matching location ID.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return hunt groups with the matching name.
        :type name: str
        :param phone_number: Only return hunt groups with the matching primary phone number or extension.
        :type phone_number: str
        :return: Generator yielding :class:`ListCallQueueObject2` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('huntGroups')
        return self.session.follow_pagination(url=url, model=ListCallQueueObject2, item_key='huntGroups', params=params)

    def create_a_hunt_group(self, location_id: str, name: str, phone_number: str, extension: Union[str, datetime],
                            language_code: str, first_name: str, last_name: str, time_zone: str,
                            call_policies: PostHuntGroupCallPolicyObject, agents: list[PostPersonPlaceObject],
                            enabled: bool, org_id: str = None) -> str:
        """
        Create a Hunt Group

        Create new Hunt Groups for the given location.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Creating a hunt group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the hunt group for the given location.
        :type location_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group. Either phone number or extension are required.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group. Either phone number or extension are required.
        :type extension: Union[str, datetime]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param agents: People, workspaces and virtual lines that are eligible to  receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param enabled: Whether or not the hunt group is enabled.
        :type enabled: bool
        :param org_id: Create the hunt group for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['enabled'] = enabled
        url = self.ep(f'locations/{location_id}/huntGroups')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_hunt_group(self, location_id: str, hunt_group_id: str, org_id: str = None):
        """
        Delete a Hunt Group

        Delete the designated Hunt Group.

        Hunt groups can route incoming calls to a group of people or workspaces. You can even configure a pattern to
        route to a whole group.

        Deleting a hunt group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete a hunt group.
        :type location_id: str
        :param hunt_group_id: Delete the hunt group with the matching ID.
        :type hunt_group_id: str
        :param org_id: Delete the hunt group from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        super().delete(url, params=params)

    def get_details_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                     org_id: str = None) -> GetHuntGroupObject4:
        """
        Get Details for a Hunt Group

        Retrieve Hunt Group details.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Retrieving hunt group details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a hunt group in this location.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for the hunt group with this identifier.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetHuntGroupObject4`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        data = super().get(url, params=params)
        r = GetHuntGroupObject4.model_validate(data)
        return r

    def update_a_hunt_group(self, location_id: str, hunt_group_id: str, name: str, phone_number: str,
                            extension: Union[str, datetime], distinctive_ring: bool,
                            alternate_numbers: list[AlternateNumbersWithPattern], language_code: str, first_name: str,
                            last_name: str, time_zone: str, call_policies: PostHuntGroupCallPolicyObject,
                            agents: list[PostPersonPlaceObject], enabled: bool, org_id: str = None):
        """
        Update a Hunt Group

        Update the designated Hunt Group.

        Hunt groups can route incoming calls to a group of people, workspaces or virtual lines. You can even configure
        a pattern to route to a whole group.

        Updating a hunt group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update the hunt group for this location.
        :type location_id: str
        :param hunt_group_id: Update settings for the hunt group with the matching ID.
        :type hunt_group_id: str
        :param name: Unique name for the hunt group.
        :type name: str
        :param phone_number: Primary phone number of the hunt group.
        :type phone_number: str
        :param extension: Primary phone extension of the hunt group.
        :type extension: Union[str, datetime]
        :param distinctive_ring: Whether or not the hunt group has the distinctive ring option enabled.
        :type distinctive_ring: bool
        :param alternate_numbers: The alternate numbers feature allows you to assign multiple phone numbers or
            extensions to a hunt group. Each number will reach the same greeting and each menu will function
            identically to the main number. The alternate numbers option enables you to have up to ten (10) phone
            numbers ring into the hunt group.
        :type alternate_numbers: list[AlternateNumbersWithPattern]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this hunt group. Defaults to `.`.
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this hunt group. Defaults to the phone
            number if set, otherwise defaults to call group name.
        :type last_name: str
        :param time_zone: Time zone for the hunt group.
        :type time_zone: str
        :param call_policies: Policy controlling how calls are routed to agents.
        :type call_policies: PostHuntGroupCallPolicyObject
        :param agents: People, workspaces and virtual lines that are eligible to  receive calls.
        :type agents: list[PostPersonPlaceObject]
        :param enabled: Whether or not the hunt group is enabled.
        :type enabled: bool
        :param org_id: Update hunt group settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['distinctiveRing'] = distinctive_ring
        body['alternateNumbers'] = loads(TypeAdapter(list[AlternateNumbersWithPattern]).dump_json(alternate_numbers))
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['timeZone'] = time_zone
        body['callPolicies'] = loads(call_policies.model_dump_json())
        body['agents'] = loads(TypeAdapter(list[PostPersonPlaceObject]).dump_json(agents))
        body['enabled'] = enabled
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}')
        super().put(url, params=params, json=body)

    def get_call_forwarding_settings_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                                      org_id: str = None) -> CallForwardSettingsGetCallForwarding:
        """
        Get Call Forwarding Settings for a Hunt Group

        Retrieve Call Forwarding settings for the designated Hunt Group including the list of call forwarding rules.

        Retrieving call forwarding settings for a hunt group requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Read the call forwarding settings for this hunt group.
        :type hunt_group_id: str
        :param org_id: Retrieve hunt group forwarding settings from this organization.
        :type org_id: str
        :rtype: CallForwardSettingsGetCallForwarding
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding')
        data = super().get(url, params=params)
        r = CallForwardSettingsGetCallForwarding.model_validate(data['callForwarding'])
        return r

    def update_call_forwarding_settings_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                                         call_forwarding: ModifyCallForwardingObjectCallForwarding,
                                                         org_id: str = None):
        """
        Update Call Forwarding Settings for a Hunt Group

        Update Call Forwarding settings for the designated Hunt Group.

        Updating call forwarding settings for a hunt group requires a full administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Location from which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Update call forwarding settings for this hunt group.
        :type hunt_group_id: str
        :param call_forwarding: Settings related to `Always`, `Busy`, and `No Answer` call forwarding.
        :type call_forwarding: ModifyCallForwardingObjectCallForwarding
        :param org_id: Update hunt group forwarding settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callForwarding'] = loads(call_forwarding.model_dump_json())
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding')
        super().put(url, params=params, json=body)

    def create_a_selective_call_forwarding_rule_for_a_hunt_group(self, location_id: str, hunt_group_id: str, name: str,
                                                                 enabled: bool, holiday_schedule: str,
                                                                 business_schedule: str,
                                                                 forward_to: CallForwardSelectiveForwardToObject,
                                                                 calls_from: CallForwardSelectiveCallsFromObject,
                                                                 calls_to: CallForwardSelectiveCallsToObject,
                                                                 org_id: str = None) -> str:
        """
        Create a Selective Call Forwarding Rule for a Hunt Group

        Create a Selective Call Forwarding Rule for the designated Hunt Group.

        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.

        Creating a selective call forwarding rule for a hunt group requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Create the rule for this hunt group.
        :type hunt_group_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related to the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject
        :param org_id: Create the hunt group rule for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['enabled'] = enabled
        body['holidaySchedule'] = holiday_schedule
        body['businessSchedule'] = business_schedule
        body['forwardTo'] = loads(forward_to.model_dump_json())
        body['callsFrom'] = loads(calls_from.model_dump_json())
        body['callsTo'] = loads(calls_to.model_dump_json())
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_selective_call_forwarding_rule_for_a_hunt_group(self, location_id: str, hunt_group_id: str, rule_id: str,
                                                            org_id: str = None) -> GetAutoAttendantCallForwardSelectiveRuleObject:
        """
        Get Selective Call Forwarding Rule for a Hunt Group

        Retrieve a Selective Call Forwarding Rule's settings for the designated Hunt Group.

        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.

        Retrieving a selective call forwarding rule's settings for a hunt group requires a full or read-only
        administrator or location administrator auth token with a scope of `spark-admin:telephony_config_read`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Retrieve settings for a rule for this hunt group.
        :type hunt_group_id: str
        :param rule_id: Hunt group rule you are retrieving settings for.
        :type rule_id: str
        :param org_id: Retrieve hunt group rule settings for this organization.
        :type org_id: str
        :rtype: :class:`GetAutoAttendantCallForwardSelectiveRuleObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().get(url, params=params)
        r = GetAutoAttendantCallForwardSelectiveRuleObject.model_validate(data)
        return r

    def update_a_selective_call_forwarding_rule_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                                                 rule_id: str, name: str, enabled: bool,
                                                                 holiday_schedule: str, business_schedule: str,
                                                                 forward_to: CallForwardSelectiveForwardToObject,
                                                                 calls_from: CallForwardSelectiveCallsFromObject,
                                                                 calls_to: CallForwardSelectiveCallsToObject,
                                                                 org_id: str = None) -> str:
        """
        Update a Selective Call Forwarding Rule for a Hunt Group

        Update a Selective Call Forwarding Rule's settings for the designated Hunt Group.

        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.

        Updating a selective call forwarding rule's settings for a hunt group requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Update settings for a rule for this hunt group.
        :type hunt_group_id: str
        :param rule_id: Hunt group rule you are updating settings for.
        :type rule_id: str
        :param name: Unique name for the selective rule in the hunt group.
        :type name: str
        :param enabled: Reflects if rule is enabled.
        :type enabled: bool
        :param holiday_schedule: Name of the location's holiday schedule which determines when this selective call
            forwarding rule is in effect.
        :type holiday_schedule: str
        :param business_schedule: Name of the location's business schedule which determines when this selective call
            forwarding rule is in effect.
        :type business_schedule: str
        :param forward_to: Controls what happens when the rule matches including the destination number for the call
            forwarding.
        :type forward_to: CallForwardSelectiveForwardToObject
        :param calls_from: Settings related the rule matching based on incoming caller ID.
        :type calls_from: CallForwardSelectiveCallsFromObject
        :param calls_to: Settings related to the rule matching based on the destination number.
        :type calls_to: CallForwardSelectiveCallsToObject
        :param org_id: Update hunt group rule settings for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['enabled'] = enabled
        body['holidaySchedule'] = holiday_schedule
        body['businessSchedule'] = business_schedule
        body['forwardTo'] = loads(forward_to.model_dump_json())
        body['callsFrom'] = loads(calls_from.model_dump_json())
        body['callsTo'] = loads(calls_to.model_dump_json())
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules/{rule_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_selective_call_forwarding_rule_for_a_hunt_group(self, location_id: str, hunt_group_id: str,
                                                                 rule_id: str, org_id: str = None):
        """
        Delete a Selective Call Forwarding Rule for a Hunt Group

        Delete a Selective Call Forwarding Rule for the designated Hunt Group.

        A selective call forwarding rule for a hunt group allows calls to be forwarded or not forwarded to the
        designated number, based on the defined criteria.

        Note that the list of existing call forward rules is available in the hunt group's call forwarding settings.

        Deleting a selective call forwarding rule for a hunt group requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        **NOTE**: The Call Forwarding Rule ID will change upon modification of the Call Forwarding Rule name.

        :param location_id: Location in which this hunt group exists.
        :type location_id: str
        :param hunt_group_id: Delete the rule for this hunt group.
        :type hunt_group_id: str
        :param rule_id: Hunt group rule you are deleting.
        :type rule_id: str
        :param org_id: Delete hunt group rule from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/huntGroups/{hunt_group_id}/callForwarding/selectiveRules/{rule_id}')
        super().delete(url, params=params)


class FeaturesPagingGroupApi(ApiChild, base='telephony/config'):
    """
    Features:  Paging Group
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Features: Paging Group supports reading and writing of Webex Calling Paging Group settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_paging_groups(self, org_id: str = None, start: int = None, location_id: str = None,
                                       name: str = None, phone_number: str = None,
                                       **params) -> Generator[ListAutoAttendantObject2, None, None]:
        """
        Read the List of Paging Groups

        List all Paging Groups for the organization.

        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List paging groups for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of matching objects. Default is 0
        :type start: int
        :param location_id: Return only paging groups with matching location ID. Default is all locations
        :type location_id: str
        :param name: Return only paging groups with the matching name.
        :type name: str
        :param phone_number: Return only paging groups with matching primary phone number or extension.
        :type phone_number: str
        :return: Generator yielding :class:`ListAutoAttendantObject2` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if location_id is not None:
            params['locationId'] = location_id
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('paging')
        return self.session.follow_pagination(url=url, model=ListAutoAttendantObject2, item_key='locationPaging', params=params)

    def create_a_new_paging_group(self, location_id: str, name: str, phone_number: str, extension: Union[str,
                                  datetime], language_code: str, first_name: str, last_name: str,
                                  originator_caller_id_enabled: bool, originators: list[str], targets: list[str],
                                  org_id: str = None) -> str:
        """
        Create a new Paging Group

        Create a new Paging Group for the given location.

        Group Paging allows a one-way call or group page to up to 75 people, workspaces and virtual lines by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Creating a paging group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the paging group for this location.
        :type location_id: str
        :param name: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
        :type name: str
        :param phone_number: Paging group phone number. Minimum length is 1. Maximum length is 23.  Either
            `phoneNumber` or `extension` is mandatory.
        :type phone_number: str
        :param extension: Paging group extension. Minimum length is 2. Maximum length is 6.  Either `phoneNumber` or
            `extension` is mandatory.
        :type extension: Union[str, datetime]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name that displays when a group page is performed. Minimum length is 1. Maximum length
            is 30.
        :type first_name: str
        :param last_name: Last name that displays when a group page is performed. Minimum length is 1. Maximum length
            is 30.
        :type last_name: str
        :param originator_caller_id_enabled: Determines what is shown on target users caller ID when a group page is
            performed. If true shows page originator ID.
        :type originator_caller_id_enabled: bool
        :param originators: An array of people, workspace, and virtual lines IDs who can originate pages to this paging
            group.
        :type originators: list[str]
        :param targets: An array of people, workspaces and virtual lines IDs will add to a paging group as paging call
            targets.
        :type targets: list[str]
        :param org_id: Create the paging group for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['originatorCallerIdEnabled'] = originator_caller_id_enabled
        body['originators'] = originators
        body['targets'] = targets
        url = self.ep(f'locations/{location_id}/paging')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_paging_group(self, location_id: str, paging_id: str, org_id: str = None):
        """
        Delete a Paging Group

        Delete the designated Paging Group.

        Group Paging allows a person to place a one-way call or group page to up to 75 people and/or workspaces by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Deleting a paging group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete a paging group.
        :type location_id: str
        :param paging_id: Delete the paging group with the matching ID.
        :type paging_id: str
        :param org_id: Delete the paging group from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        super().delete(url, params=params)

    def get_details_for_a_paging_group(self, location_id: str, paging_id: str,
                                       org_id: str = None) -> GetPagingGroupObject2:
        """
        Get Details for a Paging Group

        Retrieve Paging Group details.

        Group Paging allows a person, place or virtual line a one-way call or group page to up to 75 people and/or
        workspaces and/or virtual line by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Retrieving paging group details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve settings for a paging group in this location.
        :type location_id: str
        :param paging_id: Retrieve settings for the paging group with this identifier.
        :type paging_id: str
        :param org_id: Retrieve paging group settings from this organization.
        :type org_id: str
        :rtype: :class:`GetPagingGroupObject2`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        data = super().get(url, params=params)
        r = GetPagingGroupObject2.model_validate(data)
        return r

    def update_a_paging_group(self, location_id: str, paging_id: str, enabled: bool, name: str, phone_number: str,
                              extension: Union[str, datetime], language_code: str, first_name: str, last_name: str,
                              originator_caller_id_enabled: bool, originators: list[str], targets: list[str],
                              org_id: str = None):
        """
        Update a Paging Group

        Update the designated Paging Group.

        Group Paging allows a person to place a one-way call or group page to up to 75 people, workspaces and virtual
        lines by
        dialing a number or extension assigned to a specific paging group. The Group Paging service makes a
        simultaneous call to all the assigned targets.

        Updating a paging group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Update settings for a paging group in this location.
        :type location_id: str
        :param paging_id: Update settings for the paging group with this identifier.
        :type paging_id: str
        :param enabled: Whether or not the paging group is enabled.
        :type enabled: bool
        :param name: Unique name for the paging group. Minimum length is 1. Maximum length is 30.
        :type name: str
        :param phone_number: Paging group phone number. Minimum length is 1. Maximum length is 23.  Either
            `phoneNumber` or `extension` is mandatory.
        :type phone_number: str
        :param extension: Paging group extension. Minimum length is 2. Maximum length is 6.  Either `phoneNumber` or
            `extension` is mandatory.
        :type extension: Union[str, datetime]
        :param language_code: Language code.
        :type language_code: str
        :param first_name: First name to be shown when calls are forwarded out of this paging group. Defaults to ".".
        :type first_name: str
        :param last_name: Last name to be shown when calls are forwarded out of this paging group. Defaults to the
            phone number if set, otherwise defaults to call group name.
        :type last_name: str
        :param originator_caller_id_enabled: Determines what is shown on target users caller ID when a group page is
            performed. If true shows page originator ID.
        :type originator_caller_id_enabled: bool
        :param originators: An array of people and/or workspaces, who may originate pages to this paging group.
        :type originators: list[str]
        :param targets: People, including workspaces, that are added to paging group as paging call targets.
        :type targets: list[str]
        :param org_id: Update paging group settings from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['languageCode'] = language_code
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['originatorCallerIdEnabled'] = originator_caller_id_enabled
        body['originators'] = originators
        body['targets'] = targets
        url = self.ep(f'locations/{location_id}/paging/{paging_id}')
        super().put(url, params=params, json=body)


class FilesApi(ApiChild, base='files/{fileId}'):
    """
    Files
    
    """

    def get_file_details(self, file_id: str) -> File:
        """
        Get File Details

        :param file_id: The unique identifier for the file.
        :type file_id: str
        :rtype: :class:`File`
        """
        url = self.ep(f'')
        data = super().get(url)
        r = File.model_validate(data)
        return r


class GroupsApi(ApiChild, base='groups'):
    """
    Groups
    
    Groups contain a collection of members in Webex. A member represents a Webex user. A group is used to assign
    templates and settings to the set of members contained in a group.  To create and manage a group, including adding
    and removing members from a group, an auth token containing the `identity:groups_rw` is required.  Searching and
    viewing members of a group requires an auth token with a scope of `identity:groups_read`.
    
    To learn more about managing people to use as members in the /groups API please refer to the `People API
    <https://developer.webex.com/docs/api/v1/people>`_.
    """

    def create_a_group(self, display_name: str, org_id: str, description: str,
                       members: list[DepartmentResponseWithId]) -> GroupResponse:
        """
        Create a Group

        Create a new group for a given organization. The group may optionally be created with group members.

        :param display_name: The name of the group.
        :type display_name: str
        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param description: Description of the group.
        :type description: str
        :param members: An array of members. Maximum of 500 members can be provided. To add more members, use the
            `Update a Group
            <https://developer.webex.com/docs/api/v1/groups/update-a-group>`_ API to add additional members.
        :type members: list[DepartmentResponseWithId]
        :rtype: :class:`GroupResponse`
        """
        body = dict()
        body['displayName'] = display_name
        body['orgId'] = org_id
        body['description'] = description
        body['members'] = loads(TypeAdapter(list[DepartmentResponseWithId]).dump_json(members))
        url = self.ep()
        data = super().post(url, json=body)
        r = GroupResponse.model_validate(data)
        return r

    def update_a_group(self, group_id: str, display_name: str, description: str,
                       members: list[PatchMemberWithOperation]) -> GroupResponse:
        """
        Update a Group

        Update the group details, by ID.

        Specify the group ID in the `groupId` parameter in the URI.

        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param display_name: The name of the group.
        :type display_name: str
        :param description: Description of the group.
        :type description: str
        :param members: An array of members operations.
        :type members: list[PatchMemberWithOperation]
        :rtype: :class:`GroupResponse`
        """
        body = dict()
        body['displayName'] = display_name
        body['description'] = description
        body['members'] = loads(TypeAdapter(list[PatchMemberWithOperation]).dump_json(members))
        url = self.ep(f'{group_id}')
        data = super().patch(url, json=body)
        r = GroupResponse.model_validate(data)
        return r

    def get_group_details(self, group_id: str, include_members: bool = None) -> GroupResponse:
        """
        Get Group Details

        Get details for a group, by ID.

        Optionally, the members may be retrieved with this request. The maximum number of members returned is 500.

        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param include_members: Include the members as part of the response.
        :type include_members: bool
        :rtype: :class:`GroupResponse`
        """
        params = {}
        if include_members is not None:
            params['includeMembers'] = str(include_members).lower()
        url = self.ep(f'{group_id}')
        data = super().get(url, params=params)
        r = GroupResponse.model_validate(data)
        return r

    def list_and_search_groups(self, org_id: str = None, filter: str = None, attributes: str = None,
                               sort_by: str = None, sort_order: str = None, include_members: bool = None,
                               start_index: int = None, count: int = None) -> GroupsCollectionResponse:
        """
        List and Search Groups

        List groups in your organization.

        * Set the `includeMembers` parameter to `true` to return group members. The total number of members returned is
        limited to 500.

        * Use the `startIndex` and `count` parameters to page through result set.

        * To search for a specific group use the `filter` parameter.

        * Use `sortBy` parameter to sort the responses by `id` or `displayName`.

        :param org_id: List groups in this organization. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str
        :param filter: Searches the group by `displayName` with an operator and a value.  The available operators are
            `eq` (equal) and `sw` (starts with).  Only `displayName` can be used to filter results.
        :type filter: str
        :param attributes: The attributes to return.
        :type attributes: str
        :param sort_by: Sort the results based by group `displayName`.
        :type sort_by: str
        :param sort_order: Sort results alphabetically by group display name, in ascending or descending order.
        :type sort_order: str
        :param include_members: Optionally return group members in the response. The maximum number of members returned
            is 500.
        :type include_members: bool
        :param start_index: The index to start for group pagination.
        :type start_index: int
        :param count: Specifies the desired number of search results per page.
        :type count: int
        :rtype: :class:`GroupsCollectionResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if filter is not None:
            params['filter'] = filter
        if attributes is not None:
            params['attributes'] = attributes
        if sort_by is not None:
            params['sortBy'] = sort_by
        if sort_order is not None:
            params['sortOrder'] = sort_order
        if include_members is not None:
            params['includeMembers'] = str(include_members).lower()
        if start_index is not None:
            params['startIndex'] = start_index
        if count is not None:
            params['count'] = count
        url = self.ep()
        data = super().get(url, params=params)
        r = GroupsCollectionResponse.model_validate(data)
        return r

    def get_group_members(self, group_id: str, start_index: int = None, count: int = None) -> GroupResponse:
        """
        Get Group Members

        Gets the members of a group.

        * The default maximum members returned is 500.

        * Control parameters is available to page through the members and to control the size of the results.

        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param start_index: The index to start for group pagination.
        :type start_index: int
        :param count: Non-negative integer that specifies the desired number of search results per page. Maximum value
            for the count is 500.
        :type count: int
        :rtype: :class:`GroupResponse`
        """
        params = {}
        if start_index is not None:
            params['startIndex'] = start_index
        if count is not None:
            params['count'] = count
        url = self.ep(f'{group_id}/members')
        data = super().get(url, params=params)
        r = GroupResponse.model_validate(data)
        return r

    def delete_a_group(self, group_id: str):
        """
        Delete a Group

        Remove a group from the system.

        Specify the group ID in the `groupId` parameter in the URI.

        :param group_id: A unique identifier for the group.
        :type group_id: str
        :rtype: None
        """
        url = self.ep(f'{group_id}')
        super().delete(url)


class HistoricalAnalyticsAPIsApi(ApiChild, base='v1/analytics'):
    """
    Historical Analytics APIs
    
    The base URL for these APIs is **analytics.webexapis.com**, which does not
    work with the **Try It** feature. If you have any questions or need help
    please contact the Webex Developer Support team at devsupport@webex.com.
    
    
    
    These APIs allow an administrator to pull historical analytics data for meetings, messaging and room devices.
    
    This API requires a `Pro Pack for Control Hub
    <https://help.webex.com/article/np3c1rm>`_ license. API requests require an access token representing an
    administrator with either a read-only admin or full-admin role for the associated organization. The token must
    have the `analytics:read_all` scope.
    
    By default, the calls to analytics.webexapis.com for historical data are sent to the closest region servers. The
    other possible region servers are analytics-eu.webexapis.com and analytics-ca.webexapis.com. If the region servers
    host the organization's data, then the data is returned. Otherwise, an HTTP 451 error code ('Unavailable For Legal
    Reasons') is returned. The body of the response in this case contains the end point information from where user
    can get historical data for the user's organization. Below is a sample error message looks in this condition.
    
    ```javascript
    {
    "message": "This server cannot serve the data for this organization. Please use {another region's VIP}",
    "errorCode": 451,
    "trackingId": {trackingId}
    }
    ```
    
    To use this API the org needs to be licensed for pro pack.
    """

    def historical_data_related_to_messaging(self, from_: Union[str, datetime] = None, to_: Union[str,
                                             datetime] = None) -> HistoricalDataRelatedToMessagingResponse:
        """
        Historical Data related to Messaging

        Returns daily aggregates of various metrics related to Webex messaging.

        <div><Callout type="error">The base URL for these APIs is **analytics.webexapis.com**, which does not work with
        the **Try It** feature. </Callout></div>

        :param from_: UTC date starting from which the data needs to be returned.
        :type from_: Union[str, datetime]
        :param to_: UTC date up to which the data needs to be returned
        :type to_: Union[str, datetime]
        :rtype: :class:`HistoricalDataRelatedToMessagingResponse`
        """
        params = {}
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('messagingMetrics/dailyTotals')
        data = super().get(url, params=params)
        r = HistoricalDataRelatedToMessagingResponse.model_validate(data)
        return r

    def historical_data_related_to_room_devices(self, from_: Union[str, datetime] = None, to_: Union[str,
                                                datetime] = None) -> HistoricalDataRelatedToRoomDevicesResponse:
        """
        Historical Data related to Room Devices

        Returns daily aggregates of various metrics related to Room Devices.

        <div><Callout type="error">The base URL for these APIs is **analytics.webexapis.com**, which does not work with
        the **Try It** feature. </Callout></div>

        :param from_: Starting UTC Date from which historical data should be returned.
        :type from_: Union[str, datetime]
        :param to_: Ending UTC Date for which data should be returned.
        :type to_: Union[str, datetime]
        :rtype: :class:`HistoricalDataRelatedToRoomDevicesResponse`
        """
        params = {}
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('roomDeviceMetrics/dailyTotals')
        data = super().get(url, params=params)
        r = HistoricalDataRelatedToRoomDevicesResponse.model_validate(data)
        return r

    def historical_data_related_to_meetings(self, site_url: str, from_: Union[str, datetime] = None, to_: Union[str,
                                            datetime] = None) -> HistoricalDataRelatedToMeetingsResponse:
        """
        Historical Data related to Meetings

        Return aggregates of various metrics related to meetings for a given Webex site over a specified time range.

        <div><Callout type="error">The base URL for these APIs is **analytics.webexapis.com**, which does not work with
        the **Try It** feature.</Callout></div>

        :param site_url: URL of the Webex site for which historical data is requested.
        :type site_url: str
        :param from_: UTC Date starting from which the data needs to be returned
        :type from_: Union[str, datetime]
        :param to_: UTC Date up to which the data needs to be returned
        :type to_: Union[str, datetime]
        :rtype: :class:`HistoricalDataRelatedToMeetingsResponse`
        """
        params = {}
        params['siteUrl'] = site_url
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('meetingsMetrics/aggregates')
        data = super().get(url, params=params)
        r = HistoricalDataRelatedToMeetingsResponse.model_validate(data)
        return r


class HybridClustersApi(ApiChild, base='hybrid/clusters'):
    """
    Hybrid Clusters
    
    `Hybrid Clusters
    <https://www.cisco.com/c/en/us/solutions/collaboration/webex-hybrid-services/index.html>`_ are groups of hosts, and the connectors these hosts contain, that are managed as a unit.  All the
    connectors of a single type in a cluster share the same configuration.
    
    Listing and viewing Hybrid Clusters requires an administrator auth token with the
    `spark-admin:hybrid_clusters_read` scope.
    
    Hybrid Clusters are associated with Resource Groups. See the `Resource Groups API
    <https://developer.webex.com/docs/api/v1/resource-groups>`_ for more information.
    """

    def list_hybrid_clusters(self, org_id: str = None) -> list[Cluster]:
        """
        List Hybrid Clusters

        List hybrid clusters for an organization. If no `orgId` is specified, the default is the organization of the
        authenticated user.

        Only an admin auth token with the `spark-admin:hybrid_clusters_read` scope can list clusters.

        :param org_id: List hybrid clusters in this organization. If an organization is not specified, the organization
            of the caller will be used.
        :type org_id: str
        :rtype: list[Cluster]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[Cluster]).validate_python(data['items'])
        return r

    def get_hybrid_cluster_details(self, hybrid_cluster_id: str, org_id: str = None) -> Cluster:
        """
        Get Hybrid Cluster Details

        Shows details for a hybrid cluster, by ID.

        Only an admin auth token with the `spark-admin:hybrid_clusters_read` scope can see cluster details.

        :param hybrid_cluster_id: The ID of the cluster.
        :type hybrid_cluster_id: str
        :param org_id:
        Find the cluster in this specific organization.
        If this is not specified, the organization of the caller
        will be used.
        :type org_id: str
        :rtype: :class:`Cluster`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{hybrid_cluster_id}')
        data = super().get(url, params=params)
        r = Cluster.model_validate(data)
        return r


class HybridConnectorsApi(ApiChild, base='hybrid/connectors'):
    """
    Hybrid Connectors
    
    `Hybrid Connectors
    <https://www.cisco.com/c/en/us/solutions/collaboration/webex-hybrid-services/index.html>`_ are pieces of software that run on-premise and provide a link between the Webex Cloud and
    on-premise resources.
    
    For example, the Calendar Connector enables the linking of information from an on-premise Exchange server with the
    Webex Cloud. It allows, among other things, for the cloud to set up a Webex meeting when a user specifies `@webex`
    as the *Location* of a meeting in Outlook.
    
    Listing and viewing Hybrid Connectors requires an administrator auth token with the
    `spark-admin:hybrid_connectors_read` scope.
    
    Use this API to list the connectors configured in an organization and to determine if any connectors have any
    `unresolved alarms
    <https://help.webex.com/nuej5gfb/>`_ associated with them.
    """

    def list_hybrid_connectors(self, org_id: str = None) -> list[Connector]:
        """
        List Hybrid Connectors

        List hybrid connectors for an organization. If no `orgId` is specified, the default is the organization of the
        authenticated user.

        Only an admin auth token with the `spark-admin:hybrid_connectors_read` scope can list connectors.

        :param org_id: List hybrid connectors in this organization. If an organization is not specified, the
            organization of the caller will be used.
        :type org_id: str
        :rtype: list[Connector]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[Connector]).validate_python(data['items'])
        return r

    def get_hybrid_connector_details(self, connector_id: str) -> Connector:
        """
        Get Hybrid Connector Details

        Shows details for a hybrid connector, by ID.

        Only an admin auth token with the `spark-admin:hybrid_connectors_read` scope can see connector details.

        :param connector_id: The ID of the connector.
        :type connector_id: str
        :rtype: :class:`Connector`
        """
        url = self.ep(f'{connector_id}')
        data = super().get(url)
        r = Connector.model_validate(data)
        return r


class IssuesAPIApi(ApiChild, base='issues'):
    """
    Issues API
    
    Issues are support feedback entries from users of Webex clients and portals.
    
    Adding, searching, and viewing Issues requires an auth token with a scope of `support:issues_read`.
    
    Updating an issue by a user is also supported, but limited to the `subject` and `description`
    attributes.
    
    Viewing the list of all Issues in the Organization(s) managed by the admin user requires an
    auth token with scope of `support:org_issues_read`.
    
    Updating an Issue's `status` requires an auth token with the `support:org_issues_write` scope.
    
    An Issue cannot be deleted, but the `status` can be updated to `CLOSED`.
    """

    def list_issues(self, created_for: str = None, org_id: str = None, from_: Union[str, datetime] = None,
                    to_: Union[str, datetime] = None, after_issue: str = None,
                    **params) -> Generator[Issue, None, None]:
        """
        List Issues

        List issues in your organization.

        Admin users can list all issues for all organizations they manage.
        Admin users can also use the `createdFor` parameter to list issues for a specific person ID, or use the
        `orgId` to list issues for a specific organization.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param created_for:
        List issues created for this person ID.
        :type created_for: str
        :param org_id:
        List issues in this organization. Admins of another organization such as partners might use this parameter.
        :type org_id: str
        :param from_:
        List events which occurred after a specific date and time.
        :type from_: Union[str, datetime]
        :param to_:
        List events which occurred before a specific date and time.
        :type to_: Union[str, datetime]
        :param after_issue:
        List issues created or modified after a specific issue, by ID.
        :type after_issue: str
        :return: Generator yielding :class:`Issue` instances
        """
        if created_for is not None:
            params['createdFor'] = created_for
        if org_id is not None:
            params['orgId'] = org_id
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if after_issue is not None:
            params['afterIssue'] = after_issue
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Issue, item_key='items', params=params)

    def create_an_issue(self, subject: str, description: str, type: IssueType = None, log_id: str = None,
                        meeting_id: str = None, external_key: str = None) -> Issue:
        """
        Create an Issue

        Create a new issue.

        Users can create issues for themselves and
        admins can create issues for both themselves and on behalf of other users.

        :param subject: The subject title for the issue.
        :type subject: str
        :param description: The full description of the issue.
        :type description: str
        :param type: The initial type for the issue.
        :type type: IssueType
        :type log_id: str
        :param meeting_id: The meeting ID related to the issue.
        :type meeting_id: str
        :param external_key: Any custom identifier associated with the issue, such as from an external ticketing
            system.
        :type external_key: str
        :rtype: :class:`Issue`
        """
        body = dict()
        body['subject'] = subject
        body['description'] = description
        body['type'] = enum_str(type)
        body['logId'] = log_id
        body['meetingId'] = meeting_id
        body['externalKey'] = external_key
        url = self.ep()
        data = super().post(url, json=body)
        r = Issue.model_validate(data)
        return r

    def get_issue_details(self, id: str) -> Issue:
        """
        Get Issue Details

        Show details for an issue, by ID.

        Specify the issue ID in the `id` parameter in the URI.

        :param id: A unique identifier for the issue.
        :type id: str
        :rtype: :class:`Issue`
        """
        url = self.ep(f'{id}')
        data = super().get(url)
        r = Issue.model_validate(data)
        return r

    def update_an_issue(self, id: str, subject: str = None, description: str = None, type: IssueType = None,
                        status: IssueStatus = None, assignee: str = None, resolution: str = None, log_id: str = None,
                        meeting_id: str = None, external_key: str = None) -> Issue:
        """
        Update an Issue

        Update details for an issue, by ID.

        Specify the issue ID in the `id` parameter in the URI.
        Users may update only the `subject` and `description` attributes.
        Admin users can update the `subject`, `description`, `type`, and `status` attributes.

        Include all details for the issue. This action expects all issue details to be present in the
        request. A common approach is to first `GET the issue's details
        <https://developer.webex.com/docs/api/v1/issues/get-issue-details>`_,
        make changes, then PUT both the changed and unchanged values.

        :param id: A unique identifier for the issue.
        :type id: str
        :param subject: The subject title for the issue.
        :type subject: str
        :param description: The full description of the issue.
        :type description: str
        :param type: The type for the issue.
        :type type: IssueType
        :param status: The status of the issue.
        :type status: IssueStatus
        :param assignee: The person ID of user assigned to resolve the issue.
        :type assignee: str
        :param resolution: A description of how the issue was resolved.
        :type resolution: str
        :type log_id: str
        :param meeting_id: The meeting ID related to the issue.
        :type meeting_id: str
        :param external_key: Any custom identifier associated with the issue, such as from an external ticketing
            system.
        :type external_key: str
        :rtype: :class:`Issue`
        """
        body = dict()
        body['subject'] = subject
        body['description'] = description
        body['type'] = enum_str(type)
        body['status'] = enum_str(status)
        body['assignee'] = assignee
        body['resolution'] = resolution
        body['logId'] = log_id
        body['meetingId'] = meeting_id
        body['externalKey'] = external_key
        url = self.ep(f'{id}')
        data = super().put(url, json=body)
        r = Issue.model_validate(data)
        return r


class LicensesApi(ApiChild, base='licenses'):
    """
    Licenses
    
    An allowance for features and services that are provided to users on a Webex services subscription. Cisco and its
    partners manage the amount of licenses provided to administrators and users. License can be assigned only by
    admins.
    
    Viewing the list of all licenses in your organization and viewing license details requires an administrator auth
    token with a `scope
    <https://developer.webex.com/docs/integrations#scopes>`_ of `spark-admin:licenses_read`.
    
    Updating the licenses of users requires an administrator auth token with a `scope
    <https://developer.webex.com/docs/integrations#scopes>`_ of `spark-admin:people_write`.
    
    To learn about how to allocate Hybrid Services licenses, see the `Managing Hybrid Services
    <https://developer.webex.com/docs/api/guides/managing-hybrid-services-licenses>`_ guide.
    """

    def list_licenses(self, org_id: str = None) -> list[License]:
        """
        List Licenses

        List all licenses for a given organization.  If no `orgId` is specified, the default is the organization of the
        authenticated user.

        Response properties that are not applicable to the license will not be present in the response.

        :param org_id: List licenses for this organization.
        :type org_id: str
        :rtype: list[License]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[License]).validate_python(data['items'])
        return r

    def get_license_details(self, license_id: str, include_assigned_to: GetLicenseDetailsIncludeAssignedTo = None,
                            next: str = None, limit: int = None) -> LicensewithUsers:
        """
        Get License Details

        Shows details for a license, by ID.

        Specify the license ID in the `licenseId` parameter in the URI.
        Use the optional query parameter `includeAssignedTo` to get a list of all objects that are assigned with the
        license. The objects include but not limited to, users including external users. Long result sets will be
        split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        Response properties that are not applicable to the license will not be present in the response.

        :param license_id: The unique identifier for the license.
        :type license_id: str
        :param include_assigned_to: The type of object to whom the license is assigned to.
        :type include_assigned_to: GetLicenseDetailsIncludeAssignedTo
        :param next: List the next set of users. Applicable only if `includeAssignedTo` is populated.
        :type next: str
        :param limit: A limit on the number of users to be returned in the response. Applicable only if
            `includeAssignedTo` is populated. limit cannot be more than 300.
        :type limit: int
        :rtype: :class:`LicensewithUsers`
        """
        params = {}
        if include_assigned_to is not None:
            params['includeAssignedTo'] = include_assigned_to
        if next is not None:
            params['next'] = next
        if limit is not None:
            params['limit'] = limit
        url = self.ep(f'{license_id}')
        data = super().get(url, params=params)
        r = LicensewithUsers.model_validate(data)
        return r

    def assign_licenses_to_users(self, email: str, person_id: str, org_id: str, licenses: list[LicenseRequest],
                                 site_urls: list[SiteUrlsRequest]) -> UserLicensesResponse:
        """
        Assign Licenses to Users

        Assign licenses and attendee `siteUrls` to existing users. Only an admin can assign licenses. Only existing
        users can be assigned a license. Assign meeting licenses to users outside your organization (Status will be
        pending until the user accepts the invite)

        At least one of the following body parameters is required to assign license to the user: `email`, `personId`.
        For Calling license assignment, properties `phoneNumber` or `extension` are required. If `phoneNumber` is not
        provided then `locationId` is mandatory.

        When assigning licenses and attendee siteUrls to a user who does not belong to the organization, the licenses
        and siteUrls remain in pending state until the user accepts them. The `pendingLicenses` and `pendingSiteUrls`
        are part of the response.

        :param email: Email address of the user.
        :type email: str
        :param person_id: A unique identifier for the user.
        :type person_id: str
        :param org_id: The ID of the organization to which the licenses and siteUrls belong. If not specified, the
            organization ID from the OAuth token is used.
        :type org_id: str
        :param licenses: An array of licenses to be assigned to the user.
        :type licenses: list[LicenseRequest]
        :param site_urls: An array of siteUrls to be assigned to the user.
        :type site_urls: list[SiteUrlsRequest]
        :rtype: :class:`UserLicensesResponse`
        """
        body = dict()
        body['email'] = email
        body['personId'] = person_id
        body['orgId'] = org_id
        body['licenses'] = loads(TypeAdapter(list[LicenseRequest]).dump_json(licenses))
        body['siteUrls'] = loads(TypeAdapter(list[SiteUrlsRequest]).dump_json(site_urls))
        url = self.ep('users')
        data = super().patch(url, json=body)
        r = UserLicensesResponse.model_validate(data)
        return r


class LocationCallSettingsCallHandlingApi(ApiChild, base='telephony/config/locations/{locationId}'):
    """
    Location Call Settings:  Call Handling
    
    Location Call Settings: Call Handling supports reading and writing of Webex
    Calling Location settings involving permissions and intercepting of inbound and
    outbound calls for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def generate_example_password_for_location(self, location_id: str, org_id: str = None,
                                               generate: list[PasswordGenerate] = None) -> str:
        """
        Generate example password for Location

        Generates an example password using the effective password settings for the location. If you don't specify
        anything in the `generate` field or don't provide a request body, then you will receive a SIP password by
        default.

        Used while creating a trunk and shouldn't be used anywhere else.

        Generating an example password requires a full or write-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Location for which example password has to be generated.
        :type location_id: str
        :param org_id: Organization to which the location belongs.
        :type org_id: str
        :param generate: password settings array.
        :type generate: list[PasswordGenerate]
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['generate'] = loads(TypeAdapter(list[PasswordGenerate]).dump_json(generate))
        url = self.ep(f'actions/generatePassword/invoke')
        data = super().post(url, params=params, json=body)
        r = data['exampleSipPassword']
        return r

    def read_the_internal_dialing_configuration_for_a_location(self, location_id: str,
                                                               org_id: str = None) -> InternalDialingGet:
        """
        Read the Internal Dialing configuration for a location

        Get current configuration for routing unknown extensions to the Premises as internal calls

        If some users in a location are registered to a PBX, retrieve the setting to route unknown extensions (digits
        that match the extension length) to the PBX.

        Retrieving the internal dialing configuration requires a full or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: location for which internal calling configuration is being requested
        :type location_id: str
        :param org_id: List route identities for this organization.
        :type org_id: str
        :rtype: :class:`InternalDialingGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'internalDialing')
        data = super().get(url, params=params)
        r = InternalDialingGet.model_validate(data)
        return r

    def modify_the_internal_dialing_configuration_for_a_location(self, location_id: str,
                                                                 enable_unknown_extension_route_policy: bool,
                                                                 unknown_extension_route_identity: GetTelephonyLocationObjectConnection,
                                                                 org_id: str = None):
        """
        Modify the Internal Dialing configuration for a location

        Modify current configuration for routing unknown extensions to the premise as internal calls

        If some users in a location are registered to a PBX, enable the setting to route unknown extensions (digits
        that match the extension length) to the PBX.

        Editing the internal dialing configuration requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: location for which internal calling configuration is being requested
        :type location_id: str
        :param enable_unknown_extension_route_policy: When enabled, calls made by users at the location to an unknown
            extension (between 2-6 digits) are routed to the selected route group/trunk as premises calls.
        :type enable_unknown_extension_route_policy: bool
        :param unknown_extension_route_identity: Type associated with the identity.
        :type unknown_extension_route_identity: GetTelephonyLocationObjectConnection
        :param org_id: List route identities for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enableUnknownExtensionRoutePolicy'] = enable_unknown_extension_route_policy
        body['unknownExtensionRouteIdentity'] = loads(unknown_extension_route_identity.model_dump_json())
        url = self.ep(f'internalDialing')
        super().put(url, params=params, json=body)

    def get_location_intercept(self, location_id: str, org_id: str = None) -> GetLocationInterceptObject:
        """
        Get Location Intercept

        Retrieve intercept location details for a customer location.

        Intercept incoming or outgoing calls for persons in your organization. If this is enabled, calls are either
        routed to a designated number the person chooses, or to the person's voicemail.

        Retrieving intercept location details requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve intercept details for this location.
        :type location_id: str
        :param org_id: Retrieve intercept location details for a customer location.
        :type org_id: str
        :rtype: :class:`GetLocationInterceptObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'intercept')
        data = super().get(url, params=params)
        r = GetLocationInterceptObject.model_validate(data)
        return r

    def put_location_intercept(self, location_id: str, enabled: bool, incoming: GetLocationInterceptObjectIncoming,
                               outgoing: GetLocationInterceptObjectOutgoing, org_id: str = None):
        """
        Put Location Intercept

        Modifies the intercept location details for a customer location.

        Intercept incoming or outgoing calls for users in your organization. If this is enabled, calls are either
        routed to a designated number the user chooses, or to the user's voicemail.

        Modifying the intercept location details requires a full, user administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Modifies the intercept details for this location.
        :type location_id: str
        :param enabled: Enable/disable location intercept. Enable this feature to override any location's Call
            Intercept settings that a person configures.
        :type enabled: bool
        :param incoming: Inbound call details.
        :type incoming: GetLocationInterceptObjectIncoming
        :param outgoing: Outbound Call details
        :type outgoing: GetLocationInterceptObjectOutgoing
        :param org_id: Modifies the intercept location details for a customer location.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['incoming'] = loads(incoming.model_dump_json())
        body['outgoing'] = loads(outgoing.model_dump_json())
        url = self.ep(f'intercept')
        super().put(url, params=params, json=body)

    def get_location_outgoing_permission(self, location_id: str, org_id: str = None) -> list[CallingPermissionObject]:
        """
        Get Location Outgoing Permission

        Retrieve the location's outgoing call settings.

        A location's outgoing call settings allow you to determine the types of calls the people/workspaces at the
        location are allowed to make, as well as configure the default calling permission for each call type at the
        location.

        Retrieving a location's outgoing call settings requires a full, user or read-only administrator or location
        administrator auth token with a scope of spark-admin:telephony_config_read.

        :param location_id: Retrieve outgoing call settings for this location.
        :type location_id: str
        :param org_id: Retrieve outgoing call settings for this organization.
        :type org_id: str
        :rtype: list[CallingPermissionObject]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'outgoingPermission')
        data = super().get(url, params=params)
        r = TypeAdapter(list[CallingPermissionObject]).validate_python(data['callingPermissions'])
        return r

    def update_location_outgoing_permission(self, location_id: str, org_id: str = None,
                                            calling_permissions: list[CallingPermissionObject] = None):
        """
        Update Location Outgoing Permission

        Update the location's outgoing call settings.

        Location's outgoing call settings allows you to determine the types of calls the people/workspaces at this
        location are allowed to make and configure the default calling permission for each call type at a location.

        Updating a location's outgoing call settings requires a full administrator or location administrator auth token
        with a scope of spark-admin:telephony_config_write.

        :param location_id: Update outgoing call settings for this location.
        :type location_id: str
        :param org_id: Update outgoing call settings for this organization.
        :type org_id: str
        :param calling_permissions: Array specifying the subset of calling permissions to be updated.
        :type calling_permissions: list[CallingPermissionObject]
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callingPermissions'] = loads(TypeAdapter(list[CallingPermissionObject]).dump_json(calling_permissions))
        url = self.ep(f'outgoingPermission')
        super().put(url, params=params, json=body)

    def get_outgoing_permission_auto_transfer_number(self, location_id: str,
                                                     org_id: str = None) -> GetAutoTransferNumberObject:
        """
        Get Outgoing Permission Auto Transfer Number

        Get the transfer numbers for the outbound permission in a location.

        Outbound permissions can specify which transfer number an outbound call should transfer to via the `action`
        field.

        Retrieving an auto transfer number requires a full, user or read-only administrator or location administrator
        auth token with a scope of spark-admin:telephony_config_read.

        :param location_id: Retrieve auto transfer number for this location.
        :type location_id: str
        :param org_id: Retrieve auto transfer number for this organization.
        :type org_id: str
        :rtype: :class:`GetAutoTransferNumberObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'outgoingPermission/autoTransferNumbers')
        data = super().get(url, params=params)
        r = GetAutoTransferNumberObject.model_validate(data)
        return r

    def put_outgoing_permission_auto_transfer_number(self, location_id: str, auto_transfer_number1: str,
                                                     auto_transfer_number2: str, auto_transfer_number3: str,
                                                     org_id: str = None):
        """
        Put Outgoing Permission Auto Transfer Number

        Modifies the transfer numbers for the outbound permission in a location.

        Outbound permissions can specify which transfer number an outbound call should transfer to via the `action`
        field.

        Updating auto transfer number requires a full administrator or location administrator auth token with a scope
        of `spark-admin:telephony_config_write`.

        :param location_id: Updating auto transfer number for this location.
        :type location_id: str
        :param auto_transfer_number1: Calls placed meeting the criteria in an outbound rule whose `action` is
            `TRANSFER_NUMBER_1` will be transferred to this number.
        :type auto_transfer_number1: str
        :param auto_transfer_number2: Calls placed meeting the criteria in an outbound rule whose `action` is
            `TRANSFER_NUMBER_2` will be transferred to this number.
        :type auto_transfer_number2: str
        :param auto_transfer_number3: Calls placed meeting the criteria in an outbound rule whose `action` is
            `TRANSFER_NUMBER_3` will be transferred to this number.
        :type auto_transfer_number3: str
        :param org_id: Updating auto transfer number for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['autoTransferNumber1'] = auto_transfer_number1
        body['autoTransferNumber2'] = auto_transfer_number2
        body['autoTransferNumber3'] = auto_transfer_number3
        url = self.ep(f'outgoingPermission/autoTransferNumbers')
        super().put(url, params=params, json=body)

    def get_outgoing_permission_location_access_code(self, location_id: str, org_id: str = None) -> AuthorizationCode:
        """
        Get Outgoing Permission Location Access Code

        Retrieve access codes details for a customer location.

        Use Access Codes to bypass the set permissions for all persons/workspaces at this location.

        Retrieving access codes details requires a full, user or read-only administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve access codes details for this location.
        :type location_id: str
        :param org_id: Retrieve access codes details for a customer location.
        :type org_id: str
        :rtype: AuthorizationCode
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'outgoingPermission/accessCodes')
        data = super().get(url, params=params)
        r = AuthorizationCode.model_validate(data['accessCodes'])
        return r

    def create_outgoing_permission_a_new_access_code_for_a_customer_location(self, location_id: str,
                                                                             access_codes: AuthorizationCode,
                                                                             org_id: str = None):
        """
        Create Outgoing Permission a new access code for a customer location

        Add a new access code for the given location for a customer.

        Use Access Codes to bypass the set permissions for all persons/workspaces at this location.

        Creating an access code for the given location requires a full or user administrator or location administrator
        auth token with a scope of spark-admin:telephony_config_write.

        :param location_id: Add new access code for this location.
        :type location_id: str
        :param access_codes: Access code details
        :type access_codes: AuthorizationCode
        :param org_id: Add new access code for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['accessCodes'] = loads(access_codes.model_dump_json())
        url = self.ep(f'outgoingPermission/accessCodes')
        super().post(url, params=params, json=body)

    def delete_outgoing_permission_access_code_location(self, location_id: str, delete_codes: list[str],
                                                        org_id: str = None):
        """
        Delete Outgoing Permission Access Code Location

        Deletes the access code details for a particular location for a customer.

        Use Access Codes to bypass the set permissions for all persons/workspaces at this location.

        Modifying the access code location details requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Deletes the access code details for this location.
        :type location_id: str
        :param delete_codes: Array of string to delete access codes. For example, ["1234","2345"]
        :type delete_codes: list[str]
        :param org_id: Deletes the access code details for a customer location.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['deleteCodes'] = delete_codes
        url = self.ep(f'outgoingPermission/accessCodes')
        super().put(url, params=params, json=body)


class LocationCallSettingsSchedulesApi(ApiChild, base='telephony/config/locations/{locationId}/schedules'):
    """
    Location Call Settings:  Schedules
    
    Location Call Settings: Schedules supports reading and writing of Webex
    Calling Location Schedule and Event settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_schedules(self, location_id: str, org_id: str = None, type: GetScheduleObjectType = None,
                                   start: int = None, name: str = None,
                                   **params) -> Generator[ListScheduleObject, None, None]:
        """
        Read the List of Schedules

        List all schedules for the given location of the organization.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param location_id: Return the list of schedules for this location.
        :type location_id: str
        :param org_id: List schedules for this organization.
        :type org_id: str
        :param type: Type of the schedule.
        :type type: GetScheduleObjectType
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param name: Only return schedules with the matching name.
        :type name: str
        :return: Generator yielding :class:`ListScheduleObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if type is not None:
            params['type'] = type
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        url = self.ep(f'')
        return self.session.follow_pagination(url=url, model=ListScheduleObject, item_key='schedules', params=params)

    def get_details_for_a_schedule(self, location_id: str, type: GetScheduleObjectType, schedule_id: str,
                                   org_id: str = None) -> GetScheduleObject:
        """
        Get Details for a Schedule

        Retrieve Schedule details.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Retrieving schedule details requires a full or read-only administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve schedule details in this location.
        :type location_id: str
        :param type: Type of the schedule.
        :type type: GetScheduleObjectType
        :param schedule_id: Retrieve the schedule with the matching ID.
        :type schedule_id: str
        :param org_id: Retrieve schedule details from this organization.
        :type org_id: str
        :rtype: :class:`GetScheduleObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{type}/{schedule_id}')
        data = super().get(url, params=params)
        r = GetScheduleObject.model_validate(data)
        return r

    def create_a_schedule(self, location_id: str, type: GetScheduleObjectType, name: str,
                          events: list[ModifyScheduleEventObject], org_id: str = None) -> str:
        """
        Create a Schedule

        Create new Schedule for the given location.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Creating a schedule requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the schedule for this location.
        :type location_id: str
        :param type: Type of the schedule.
        :type type: GetScheduleObjectType
        :param name: Unique name for the schedule.
        :type name: str
        :param events: List of schedule events.
        :type events: list[ModifyScheduleEventObject]
        :param org_id: Create the schedule for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['type'] = enum_str(type)
        body['name'] = name
        body['events'] = loads(TypeAdapter(list[ModifyScheduleEventObject]).dump_json(events))
        url = self.ep(f'')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def update_a_schedule(self, location_id: str, type: GetScheduleObjectType, schedule_id: str, name: str,
                          events: list[ModifyScheduleEventListObject], org_id: str = None) -> str:
        """
        Update a Schedule

        Update the designated schedule.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Updating a schedule requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The Schedule ID will change upon modification of the Schedule name.

        :param location_id: Location in which this schedule exists.
        :type location_id: str
        :param type: Type of schedule.
        :type type: GetScheduleObjectType
        :param schedule_id: Update schedule with the matching ID.
        :type schedule_id: str
        :param name: Unique name for the schedule.
        :type name: str
        :param events: List of schedule events.
        :type events: list[ModifyScheduleEventListObject]
        :param org_id: Update schedule from this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['events'] = loads(TypeAdapter(list[ModifyScheduleEventListObject]).dump_json(events))
        url = self.ep(f'{type}/{schedule_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_schedule(self, location_id: str, type: GetScheduleObjectType, schedule_id: str, org_id: str = None):
        """
        Delete a Schedule

        Delete the designated Schedule.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Deleting a schedule requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete a schedule.
        :type location_id: str
        :param type: Type of the schedule.
        :type type: GetScheduleObjectType
        :param schedule_id: Delete the schedule with the matching ID.
        :type schedule_id: str
        :param org_id: Delete the schedule from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{type}/{schedule_id}')
        super().delete(url, params=params)

    def get_details_for_a_schedule_event(self, location_id: str, type: GetScheduleObjectType, schedule_id: str,
                                         event_id: str, org_id: str = None) -> GetScheduleEventObject:
        """
        Get Details for a Schedule Event

        Retrieve Schedule Event details.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Retrieving a schedule event's details requires a full or read-only administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve schedule event details in this location.
        :type location_id: str
        :param type: Type of schedule.
        :type type: GetScheduleObjectType
        :param schedule_id: Retrieve the schedule event with the matching schedule ID.
        :type schedule_id: str
        :param event_id: Retrieve the schedule event with the matching schedule event ID.
        :type event_id: str
        :param org_id: Retrieve schedule event details from this organization.
        :type org_id: str
        :rtype: :class:`GetScheduleEventObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{type}/{schedule_id}/events/{event_id}')
        data = super().get(url, params=params)
        r = GetScheduleEventObject.model_validate(data)
        return r

    def create_a_schedule_event(self, location_id: str, type: GetScheduleObjectType, schedule_id: str, name: str,
                                start_date: Union[str, datetime], end_date: Union[str, datetime],
                                start_time: Union[str, datetime], end_time: Union[str, datetime],
                                all_day_enabled: bool, recurrence: RecurrenceObject, org_id: str = None) -> str:
        """
        Create a Schedule Event

        Create new Event for the given location Schedule.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Creating a schedule event requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Create the schedule for this location.
        :type location_id: str
        :param type: Type of schedule.
        :type type: GetScheduleObjectType
        :param schedule_id: Create event for a given schedule ID.
        :type schedule_id: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start Date of Event.
        :type start_date: Union[str, datetime]
        :param end_date: End Date of Event.
        :type end_date: Union[str, datetime]
        :param start_time: Start time of event. Mandatory if the event is not all day.
        :type start_time: Union[str, datetime]
        :param end_time: End time of event. Mandatory if the event is not all day.
        :type end_time: Union[str, datetime]
        :param all_day_enabled: An indication of whether given event is an all-day event or not. Mandatory if the
            `startTime` and `endTime` are not defined.
        :type all_day_enabled: bool
        :param recurrence: Recurrence definition.
        :type recurrence: RecurrenceObject
        :param org_id: Create the schedule for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['startDate'] = start_date
        body['endDate'] = end_date
        body['startTime'] = start_time
        body['endTime'] = end_time
        body['allDayEnabled'] = all_day_enabled
        body['recurrence'] = loads(recurrence.model_dump_json())
        url = self.ep(f'{type}/{schedule_id}/events')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def update_a_schedule_event(self, location_id: str, type: GetScheduleObjectType, schedule_id: str, event_id: str,
                                name: str, start_date: Union[str, datetime], end_date: Union[str, datetime],
                                start_time: Union[str, datetime], end_time: Union[str, datetime],
                                all_day_enabled: bool, recurrence: RecurrenceObject, org_id: str = None) -> str:
        """
        Update a Schedule Event

        Update the designated Schedule Event.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Updating a schedule event requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        **NOTE**: The schedule event ID will change upon modification of the schedule event name.

        :param location_id: Location in which this schedule event exists.
        :type location_id: str
        :param type: Type of schedule.
        :type type: GetScheduleObjectType
        :param schedule_id: Update schedule event with the matching schedule ID.
        :type schedule_id: str
        :param event_id: Update the schedule event with the matching schedule event ID.
        :type event_id: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start date of event.
        :type start_date: Union[str, datetime]
        :param end_date: End date of event.
        :type end_date: Union[str, datetime]
        :param start_time: Start time of event. Mandatory if the event is not all day.
        :type start_time: Union[str, datetime]
        :param end_time: End time of event. Mandatory if the event is not all day.
        :type end_time: Union[str, datetime]
        :param all_day_enabled: An indication of whether given event is an all-day event or not. Mandatory if the
            `startTime` and `endTime` are not defined.
        :type all_day_enabled: bool
        :param recurrence: Recurrence definition.
        :type recurrence: RecurrenceObject
        :param org_id: Update schedule from this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['startDate'] = start_date
        body['endDate'] = end_date
        body['startTime'] = start_time
        body['endTime'] = end_time
        body['allDayEnabled'] = all_day_enabled
        body['recurrence'] = loads(recurrence.model_dump_json())
        url = self.ep(f'{type}/{schedule_id}/events/{event_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_schedule_event(self, location_id: str, type: GetScheduleObjectType, schedule_id: str, event_id: str,
                                org_id: str = None):
        """
        Delete a Schedule Event

        Delete the designated Schedule Event.

        A time schedule establishes a set of times during the day or holidays in the year in which a feature, for
        example auto attendants, can perform a specific action.

        Deleting a schedule event requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete a schedule.
        :type location_id: str
        :param type: Type of schedule.
        :type type: GetScheduleObjectType
        :param schedule_id: Delete the schedule with the matching ID.
        :type schedule_id: str
        :param event_id: Delete the schedule event with the matching schedule event ID.
        :type event_id: str
        :param org_id: Delete the schedule from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{type}/{schedule_id}/events/{event_id}')
        super().delete(url, params=params)


class LocationCallSettingsVoicemailApi(ApiChild, base='telephony/config'):
    """
    Location Call Settings:  Voicemail
    
    Location Call Settings: Voicemail supports reading and writing of Webex
    Calling Location Voicemail settings for a specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def get_location_voicemail(self, location_id: str, org_id: str = None) -> bool:
        """
        Get Location Voicemail

        Retrieve voicemail settings for a specific location.

        Location voicemail settings allows you to enable voicemail transcription for a specific location.

        Retrieving a location's voicemail settings requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve voicemail settings for this location.
        :type location_id: str
        :param org_id: Retrieve voicemail settings for this organization.
        :type org_id: str
        :rtype: bool
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicemail')
        data = super().get(url, params=params)
        r = data['voicemailTranscriptionEnabled']
        return r

    def update_location_voicemail(self, location_id: str, voicemail_transcription_enabled: bool, org_id: str = None):
        """
        Update Location Voicemail

        Update the voicemail settings for a specific location.

        Location voicemail settings allows you to enable voicemail transcription for a specific location.

        Updating a location's voicemail settings requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Update voicemail settings for this location.
        :type location_id: str
        :param voicemail_transcription_enabled: Set to `true` to enable voicemail transcription.
        :type voicemail_transcription_enabled: bool
        :param org_id: Update voicemail settings for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['voicemailTranscriptionEnabled'] = voicemail_transcription_enabled
        url = self.ep(f'locations/{location_id}/voicemail')
        super().put(url, params=params, json=body)

    def get_voice_portal(self, location_id: str, org_id: str = None) -> GetVoicePortalObject:
        """
        Get VoicePortal

        Retrieve Voice portal information for the location.

        Voice portals provide an interactive voice response (IVR)
        system so administrators can manage auto attendant announcements.

        Retrieving voice portal information for an organization requires a full read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Location to which the voice portal belongs.
        :type location_id: str
        :param org_id: Organization to which the voice portal belongs.
        :type org_id: str
        :rtype: :class:`GetVoicePortalObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicePortal')
        data = super().get(url, params=params)
        r = GetVoicePortalObject.model_validate(data)
        return r

    def update_voice_portal(self, location_id: str, name: str, language_code: str, extension: Union[str, datetime],
                            phone_number: str, first_name: str, last_name: str,
                            passcode: PutVoicePortalObjectPasscode, org_id: str = None):
        """
        Update VoicePortal

        Update Voice portal information for the location.

        Voice portals provide an interactive voice response (IVR)
        system so administrators can manage auto attendant anouncements.

        Updating voice portal information for an organization and/or rules requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Location to which the voice portal belongs.
        :type location_id: str
        :param name: Voice Portal Name.
        :type name: str
        :param language_code: Language code for voicemail group audio announcement.
        :type language_code: str
        :param extension: Extension of incoming call.
        :type extension: Union[str, datetime]
        :param phone_number: Phone Number of incoming call.
        :type phone_number: str
        :param first_name: Caller ID First Name.
        :type first_name: str
        :param last_name: Caller ID Last Name.
        :type last_name: str
        :param passcode: Voice Portal Admin Passcode.
        :type passcode: PutVoicePortalObjectPasscode
        :param org_id: Update voicemail rules for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['languageCode'] = language_code
        body['extension'] = extension
        body['phoneNumber'] = phone_number
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['passcode'] = loads(passcode.model_dump_json())
        url = self.ep(f'locations/{location_id}/voicePortal')
        super().put(url, params=params, json=body)

    def get_voice_portal_passcode_rule(self, location_id: str, org_id: str = None) -> GetVoicePortalPasscodeRuleObject:
        """
        Get VoicePortal Passcode Rule

        Retrieve the voice portal passcode rule for a location.

        Voice portals provide an interactive voice response (IVR) system so administrators can manage auto attendant
        anouncements

        Retrieving the voice portal passcode rule requires a full read-only administrator or location administrator
        auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve voice portal passcode rules for this location.
        :type location_id: str
        :param org_id: Retrieve voice portal passcode rules for this organization.
        :type org_id: str
        :rtype: :class:`GetVoicePortalPasscodeRuleObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicePortal/passcodeRules')
        data = super().get(url, params=params)
        r = GetVoicePortalPasscodeRuleObject.model_validate(data)
        return r

    def list_voicemail_group(self, location_id: str = None, org_id: str = None, start: int = None, name: str = None,
                             phone_number: str = None, **params) -> Generator[GetVoicemailGroupObject1, None, None]:
        """
        List VoicemailGroup

        List the voicemail group information for the organization.

        You can create a shared voicemail box and inbound FAX box to
        assign to users or call routing features like an auto attendant, call queue, or hunt group.

        Retrieving a voicemail group for the organization requires a full read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Location to which the voicemail group belongs.
        :type location_id: str
        :param org_id: Organization to which the voicemail group belongs.
        :type org_id: str
        :param start: Offset from the first result that you want to fetch.
        :type start: int
        :param name: Search (Contains) based on voicemail group name
        :type name: str
        :param phone_number: Search (Contains) based on number or extension
        :type phone_number: str
        :return: Generator yielding :class:`GetVoicemailGroupObject1` instances
        """
        if location_id is not None:
            params['locationId'] = location_id
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        url = self.ep('voicemailGroups')
        return self.session.follow_pagination(url=url, model=GetVoicemailGroupObject1, item_key='voicemailGroups', params=params)

    def get_location_voicemail_group(self, location_id: str, voicemail_group_id: str,
                                     org_id: str = None) -> GetLocationVoicemailGroupObject1:
        """
        Get Location Voicemail Group

        Retrieve voicemail group details for a location.

        Manage your voicemail group settings for a specific location, like when you want your voicemail to be active,
        message storage settings, and how you would like to be notified of new voicemail messages.

        Retrieving voicemail group details requires a full, user or read-only administrator or location administrator
        auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve voicemail group details for this location.
        :type location_id: str
        :param voicemail_group_id: Retrieve voicemail group details for this voicemail group ID.
        :type voicemail_group_id: str
        :param org_id: Retrieve voicemail group details for a customer location.
        :type org_id: str
        :rtype: :class:`GetLocationVoicemailGroupObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicemailGroups/{voicemail_group_id}')
        data = super().get(url, params=params)
        r = GetLocationVoicemailGroupObject1.model_validate(data)
        return r

    def modify_location_voicemail_group(self, location_id: str, voicemail_group_id: str, name: str, phone_number: str,
                                        extension: int, first_name: str, last_name: str, enabled: bool, passcode: int,
                                        language_code: str, greeting: HoursMenuObjectGreeting,
                                        greeting_description: str,
                                        message_storage: GetLocationVoicemailGroupObjectMessageStorage,
                                        notifications: GetLocationVoicemailGroupObjectNotifications,
                                        fax_message: GetLocationVoicemailGroupObjectFaxMessage,
                                        transfer_to_number: GetLocationVoicemailGroupObjectNotifications,
                                        email_copy_of_message: GetLocationVoicemailGroupObjectEmailCopyOfMessage,
                                        org_id: str = None):
        """
        Modify Location Voicemail Group

        Modifies the voicemail group location details for a particular location for a customer.

        Manage your voicemail settings, like when you want your voicemail to be active, message storage settings, and
        how you would like to be notified of new voicemail messages.

        Modifying the voicemail group location details requires a full, user administrator or location administrator
        auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Modifies the voicemail group details for this location.
        :type location_id: str
        :param voicemail_group_id: Modifies the voicemail group details for this voicemail group ID.
        :type voicemail_group_id: str
        :param name: Set the name of the voicemail group.
        :type name: str
        :param phone_number: Set voicemail group phone number.
        :type phone_number: str
        :param extension: Set unique voicemail group extension number.
        :type extension: int
        :param first_name: Set the voicemail group caller ID first name.
        :type first_name: str
        :param last_name: Set the voicemail group called ID last name.
        :type last_name: str
        :param enabled: Set to `true` to enable the voicemail group.
        :type enabled: bool
        :param passcode: Set passcode to access voicemail group when calling.
        :type passcode: int
        :param language_code: Language code for the voicemail group audio announcement.
        :type language_code: str
        :param greeting: Voicemail group greeting type.
        :type greeting: HoursMenuObjectGreeting
        :param greeting_description: CUSTOM greeting for previously uploaded.
        :type greeting_description: str
        :param message_storage: Message storage information
        :type message_storage: GetLocationVoicemailGroupObjectMessageStorage
        :param notifications: Message notifications
        :type notifications: GetLocationVoicemailGroupObjectNotifications
        :param fax_message: Fax message receive settings
        :type fax_message: GetLocationVoicemailGroupObjectFaxMessage
        :param transfer_to_number: Transfer message information
        :type transfer_to_number: GetLocationVoicemailGroupObjectNotifications
        :param email_copy_of_message: Message copy information
        :type email_copy_of_message: GetLocationVoicemailGroupObjectEmailCopyOfMessage
        :param org_id: Modifies the voicemail group details for a customer location.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['enabled'] = enabled
        body['passcode'] = passcode
        body['languageCode'] = language_code
        body['greeting'] = enum_str(greeting)
        body['greetingDescription'] = greeting_description
        body['messageStorage'] = loads(message_storage.model_dump_json())
        body['notifications'] = loads(notifications.model_dump_json())
        body['faxMessage'] = loads(fax_message.model_dump_json())
        body['transferToNumber'] = loads(transfer_to_number.model_dump_json())
        body['emailCopyOfMessage'] = loads(email_copy_of_message.model_dump_json())
        url = self.ep(f'locations/{location_id}/voicemailGroups/{voicemail_group_id}')
        super().put(url, params=params, json=body)

    def create_a_new_voicemail_group_for_a_location(self, location_id: str, name: str, phone_number: str,
                                                    extension: int, first_name: str, last_name: str, passcode: int,
                                                    language_code: str,
                                                    message_storage: GetLocationVoicemailGroupObjectMessageStorage,
                                                    notifications: GetLocationVoicemailGroupObjectNotifications,
                                                    fax_message: GetLocationVoicemailGroupObjectFaxMessage,
                                                    transfer_to_number: GetLocationVoicemailGroupObjectNotifications,
                                                    email_copy_of_message: GetLocationVoicemailGroupObjectEmailCopyOfMessage,
                                                    org_id: str = None) -> str:
        """
        Create a new Voicemail Group for a Location

        Create a new voicemail group for the given location for a customer.

        A voicemail group can be created for given location for a customer.

        Creating a voicemail group for the given location requires a full or user administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Create a new voice mail group for this location.
        :type location_id: str
        :param name: Set name to create new voicemail group for a particular location for a customer.
        :type name: str
        :param phone_number: Set voicemail group phone number for this particular location.
        :type phone_number: str
        :param extension: Set unique voicemail group extension number for this particular location.
        :type extension: int
        :param first_name: Set voicemail group caller ID first name.
        :type first_name: str
        :param last_name: Set voicemail group called ID last name.
        :type last_name: str
        :param passcode: Set passcode to access voicemail group when calling.
        :type passcode: int
        :param language_code: Language code for voicemail group audio announcement.
        :type language_code: str
        :param message_storage: Message storage information
        :type message_storage: GetLocationVoicemailGroupObjectMessageStorage
        :param notifications: Message notifications
        :type notifications: GetLocationVoicemailGroupObjectNotifications
        :param fax_message: Fax message information
        :type fax_message: GetLocationVoicemailGroupObjectFaxMessage
        :param transfer_to_number: Transfer message information
        :type transfer_to_number: GetLocationVoicemailGroupObjectNotifications
        :param email_copy_of_message: Message copy information
        :type email_copy_of_message: GetLocationVoicemailGroupObjectEmailCopyOfMessage
        :param org_id: Create a new voice mail group for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['phoneNumber'] = phone_number
        body['extension'] = extension
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['passcode'] = passcode
        body['languageCode'] = language_code
        body['messageStorage'] = loads(message_storage.model_dump_json())
        body['notifications'] = loads(notifications.model_dump_json())
        body['faxMessage'] = loads(fax_message.model_dump_json())
        body['transferToNumber'] = loads(transfer_to_number.model_dump_json())
        body['emailCopyOfMessage'] = loads(email_copy_of_message.model_dump_json())
        url = self.ep(f'locations/{location_id}/voicemailGroups')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_voicemail_group_for_a_location(self, location_id: str, voicemail_group_id: str, org_id: str = None):
        """
        Delete a Voicemail Group for a Location

        Delete the designated voicemail group.

        Deleting a voicemail group requires a full administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Location from which to delete a voicemail group.
        :type location_id: str
        :param voicemail_group_id: Delete the voicemail group with the matching ID.
        :type voicemail_group_id: str
        :param org_id: Delete the voicemail group from this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/voicemailGroups/{voicemail_group_id}')
        super().delete(url, params=params)


class LocationCallSettingsApi(ApiChild, base='telephony/config'):
    """
    Location Call Settings
    
    Location Call Settings  supports reading and writing of Webex Calling Location settings for a specific
    organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def list_locations_webex_calling_details(self, org_id: str = None, start: int = None, name: str = None,
                                             order: str = None,
                                             **params) -> Generator[ListLocationObject, None, None]:
        """
        List Locations Webex Calling Details

        Lists Webex Calling locations for an organization with Webex Calling details.

        Searching and viewing locations with Webex Calling details in your
        organization require an administrator auth token with the
        `spark-admin:telephony_config_read` scope.

        :param org_id: List locations for this organization.
        :type org_id: str
        :param start: Specify the offset from the first result that you want to fetch.
        :type start: int
        :param name: List locations whose name contains this string.
        :type name: str
        :param order: Sort the list of locations based on `name`, either asc or desc.
        :type order: str
        :return: Generator yielding :class:`ListLocationObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if order is not None:
            params['order'] = order
        url = self.ep('locations')
        return self.session.follow_pagination(url=url, model=ListLocationObject, item_key='locations', params=params)

    def enable_a_location_for_webex_calling(self, id: str, name: str, time_zone: str, preferred_language: str,
                                            announcement_language: str, address: PostLocationCallingRequestAddress,
                                            org_id: str = None) -> str:
        """
        Enable a Location for Webex Calling

        Enable a location by adding it to Webex Calling. This add Webex Calling support to a
        location created created using the POST /v1/locations API.

        Locations are used to support calling features which can be defined at the location level.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param id: A unique identifier for the location.
        :type id: str
        :param name: The name of the location.
        :type name: str
        :param time_zone: Time zone associated with this location. Refer to this `link
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_ for the format.
        :type time_zone: str
        :param preferred_language: Default email language.
        :type preferred_language: str
        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param address: The address of the location.
        :type address: PostLocationCallingRequestAddress
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['id'] = id
        body['name'] = name
        body['timeZone'] = time_zone
        body['preferredLanguage'] = preferred_language
        body['announcementLanguage'] = announcement_language
        body['address'] = loads(address.model_dump_json())
        url = self.ep('locations')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_location_webex_calling_details(self, location_id: str, org_id: str = None) -> GetTelephonyLocationObject:
        """
        Get Location Webex Calling Details

        Shows Webex Calling details for a location, by ID.

        Specifies the location ID in the locationId parameter in the URI.

        Searching and viewing locations in your organization requires an administrator auth token with the
        spark-admin:telephony_config_read scope.

        :param location_id: Retrieve Webex Calling location attributes for this location.
        :type location_id: str
        :param org_id: Retrieve Webex Calling location attributes for this organization.
        :type org_id: str
        :rtype: :class:`GetTelephonyLocationObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}')
        data = super().get(url, params=params)
        r = GetTelephonyLocationObject.model_validate(data)
        return r

    def update_location_webex_calling_details(self, location_id: str, announcement_language: str,
                                              calling_line_id: GetTelephonyLocationObjectCallingLineId,
                                              connection: GetTelephonyLocationObjectConnection,
                                              external_caller_id_name: str, p_access_network_info: str,
                                              outside_dial_digit: Union[str, datetime], routing_prefix: Union[str,
                                              datetime], charge_number: str, org_id: str = None):
        """
        Update Location Webex Calling Details

        Update Webex Calling details for a location, by ID.

        Specifies the location ID in the `locationId` parameter in the URI.

        Modifying the `connection` via API is only supported for the local PSTN types of `TRUNK` and `ROUTE_GROUP`.

        Updating a location in your organization requires an administrator auth token with the
        `spark-admin:telephony_config_write` scope.

        :param location_id: Updating Webex Calling location attributes for this location.
        :type location_id: str
        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param calling_line_id: Location calling line information.
        :type calling_line_id: GetTelephonyLocationObjectCallingLineId
        :param connection: Connection details can only be modified to and from local PSTN types of `TRUNK` and
            `ROUTE_GROUP`.
        :type connection: GetTelephonyLocationObjectConnection
        :param external_caller_id_name: Denve' (string) - External Caller ID Name value. Unicode characters.
        :type external_caller_id_name: str
        :param p_access_network_info: Location Identifier.
        :type p_access_network_info: str
        :param outside_dial_digit: Must dial to reach an outside line. Default is None.
        :type outside_dial_digit: Union[str, datetime]
        :param routing_prefix: Must dial a prefix when calling between locations having same extension within same
            location; should be numeric.
        :type routing_prefix: Union[str, datetime]
        :param charge_number: Chargeable number for the line placing the call. When this is set, all calls placed from
            this location will include a P-Charge-Info header with the selected number in the SIP INVITE.
        :type charge_number: str
        :param org_id: Updating Webex Calling location attributes for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['announcementLanguage'] = announcement_language
        body['callingLineId'] = loads(calling_line_id.model_dump_json())
        body['connection'] = loads(connection.model_dump_json())
        body['externalCallerIdName'] = external_caller_id_name
        body['pAccessNetworkInfo'] = p_access_network_info
        body['outsideDialDigit'] = outside_dial_digit
        body['routingPrefix'] = routing_prefix
        body['chargeNumber'] = charge_number
        url = self.ep(f'locations/{location_id}')
        super().put(url, params=params, json=body)

    def change_announcement_language(self, location_id: str, agent_enabled: bool, service_enabled: bool,
                                     announcement_language_code: str, org_id: str = None):
        """
        Change Announcement Language

        Change announcement language for the given location.

        Change announcement language for current people/workspaces and/or existing feature configurations. This does
        not change the default announcement language which is applied to new users/workspaces and new feature
        configurations.

        Changing the announcement language for the given location requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Change announcement language for this location.
        :type location_id: str
        :param agent_enabled: Set to `true` to change announcement language for existing people and workspaces.
        :type agent_enabled: bool
        :param service_enabled: Set to `true` to change announcement language for existing feature configurations.
        :type service_enabled: bool
        :param announcement_language_code: Language code.
        :type announcement_language_code: str
        :param org_id: Change announcement language for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['agentEnabled'] = agent_enabled
        body['serviceEnabled'] = service_enabled
        body['announcementLanguageCode'] = announcement_language_code
        url = self.ep(f'locations/{location_id}/actions/modifyAnnouncementLanguage/invoke')
        super().post(url, params=params, json=body)

    def read_the_list_of_dial_patterns(self, dial_plan_id: str, org_id: str = None, dial_pattern: str = None,
                                       start: int = None, order: str = None, **params) -> Generator[str, None, None]:
        """
        Read the List of Dial Patterns

        List all Dial Patterns for the organization.

        Dial plans route calls to on-premises destinations by use of trunks or route groups.
        They are configured globally for an enterprise and apply to all users, regardless of location.
        A dial plan also specifies the routing choice (trunk or route group) for calls that match any of its dial
        patterns.
        Specific dial patterns can be defined as part of your dial plan.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param dial_plan_id: ID of the dial plan.
        :type dial_plan_id: str
        :param org_id: ID of the organization to which the dial patterns belong.
        :type org_id: str
        :param dial_pattern: An enterprise dial pattern is represented by a sequence of digits (1-9), followed by
            optional wildcard characters.
        Valid wildcard characters are `!` (matches any sequence of digits) and `X` (matches a single digit, 0-9).
        The `!` wildcard can only occur once at the end and only in an E.164 pattern
        :type dial_pattern: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the dial patterns according to the designated fields.  Available sort fields:
            `dialPattern`.
        :type order: str
        :return: Array of dial patterns. An enterprise dial pattern is represented by a sequence of digits (1-9),
            followed by optional wildcard characters.
        """
        if org_id is not None:
            params['orgId'] = org_id
        if dial_pattern is not None:
            params['dialPattern'] = dial_pattern
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep(f'premisePstn/dialPlans/{dial_plan_id}/dialPatterns')
        return self.session.follow_pagination(url=url, model=None, item_key='dialPatterns', params=params)

    def get_a_location_emergency_callback_number(self, location_id: str,
                                                 location_info: GetLocationCallBackNumberObjectLocationInfo,
                                                 location_member_info: GetLocationCallBackNumberObjectLocationMemberInfo,
                                                 selected: CallBackSelected, org_id: str = None):
        """
        Get a Location Emergency callback number

        Get location emergency callback number.

        * To retrieve location callback number requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Update location attributes for this location.
        :type location_id: str
        :param location_info: Data relevant to this location.
        :type location_info: GetLocationCallBackNumberObjectLocationInfo
        :param location_member_info: Data relevant to the user/place (member) selected for ECBN.
        :type location_member_info: GetLocationCallBackNumberObjectLocationMemberInfo
        :param selected: Selected number type to configure emergency call back.
        :type selected: CallBackSelected
        :param org_id: Update location attributes for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['locationInfo'] = loads(location_info.model_dump_json())
        body['locationMemberInfo'] = loads(location_member_info.model_dump_json())
        body['selected'] = enum_str(selected)
        url = self.ep(f'locations/{location_id}/features/emergencyCallbackNumber')
        super().get(url, params=params, json=body)

    def update_a_location_emergency_callback_number(self, location_id: str, selected: CallBackSelected,
                                                    location_member_id: str, org_id: str = None):
        """
        Update a Location Emergency callback number

        Update details for a location emergency callback number.

        * Updating a location callback number requires a full administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_write`.

        :param location_id: Update location attributes for this location.
        :type location_id: str
        :param selected: Selected number type to configure emergency call back.
        :type selected: CallBackSelected
        :param location_member_id: Member ID of user/place within the location. Required if `LOCATION_MEMBER_NUMBER` is
            selected.
        :type location_member_id: str
        :param org_id: Update location attributes for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['selected'] = enum_str(selected)
        body['locationMemberId'] = location_member_id
        url = self.ep(f'locations/{location_id}/features/emergencyCallbackNumber')
        super().put(url, params=params, json=body)

    def validate_the_list_of_extensions(self, extensions: list[str],
                                        org_id: str = None) -> PostValidateExtensionResponse:
        """
        Validate the List of Extensions

        Validate the List of Extensions.
        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param extensions: Array of Strings of IDs of the Extensions.
        :type extensions: list[str]
        :param org_id: Validate Extension for this organization.
        :type org_id: str
        :rtype: :class:`PostValidateExtensionResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['extensions'] = extensions
        url = self.ep('actions/validateExtensions/invoke')
        data = super().post(url, params=params, json=body)
        r = PostValidateExtensionResponse.model_validate(data)
        return r

    def validate_extensions(self, location_id: str, extensions: list[str],
                            org_id: str = None) -> StatusOfExtensionsObject:
        """
        Validate Extensions

        Validate extensions for a specific location.

        Validating extensions requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param location_id: Validate extensions for this location.
        :type location_id: str
        :param extensions: Array of extensions that will be validated.
        :type extensions: list[str]
        :param org_id: Validate extensions for this organization.
        :type org_id: str
        :rtype: :class:`StatusOfExtensionsObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['extensions'] = extensions
        url = self.ep(f'locations/{location_id}/actions/validateExtensions/invoke')
        data = super().post(url, params=params, json=body)
        r = StatusOfExtensionsObject.model_validate(data)
        return r

    def update_music_on_hold(self, location_id: str, call_hold_enabled: bool, call_park_enabled: bool,
                             greeting: GetMusicOnHoldObjectGreeting, audio_file: AudioAnnouncementFileGetObject,
                             org_id: str = None):
        """
        Update Music On Hold

        Update the location's music on hold settings.

        Location music on hold settings allows you to play music when a call is placed on hold or parked.

        Updating a location's music on hold settings requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Update music on hold settings for this location.
        :type location_id: str
        :param call_hold_enabled: If enabled, music will be played when call is placed on hold.
        :type call_hold_enabled: bool
        :param call_park_enabled: If enabled, music will be played when call is parked.
        :type call_park_enabled: bool
        :param greeting: Greeting type for the location.
        :type greeting: GetMusicOnHoldObjectGreeting
        :param audio_file: Announcement Audio File details when greeting is selected to be `CUSTOM`.
        :type audio_file: AudioAnnouncementFileGetObject
        :param org_id: Update music on hold settings for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callHoldEnabled'] = call_hold_enabled
        body['callParkEnabled'] = call_park_enabled
        body['greeting'] = enum_str(greeting)
        body['audioFile'] = loads(audio_file.model_dump_json())
        url = self.ep(f'locations/{location_id}/musicOnHold')
        super().put(url, params=params, json=body)

    def get_music_on_hold(self, location_id: str, org_id: str = None) -> GetMusicOnHoldObject:
        """
        Get Music On Hold

        Retrieve the location's music on hold settings.

        Location music on hold settings allows you to play music when a call is placed on hold or parked.

        Retrieving a location's music on hold settings requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve music on hold settings for this location.
        :type location_id: str
        :param org_id: Retrieve music on hold settings for this organization.
        :type org_id: str
        :rtype: :class:`GetMusicOnHoldObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/musicOnHold')
        data = super().get(url, params=params)
        r = GetMusicOnHoldObject.model_validate(data)
        return r

    def get_private_network_connect(self, location_id: str,
                                    org_id: str = None) -> GetPrivateNetworkConnectObjectNetworkConnectionType:
        """
        Get Private Network Connect

        Retrieve the location's network connection type.

        Network Connection Type determines if the location's network connection is public or private.

        Retrieving a location's network connection type requires a full, user or read-only administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_read`.

        :param location_id: Retrieve the network connection type for this location.
        :type location_id: str
        :param org_id: Retrieve the network connection type for this organization.
        :type org_id: str
        :rtype: GetPrivateNetworkConnectObjectNetworkConnectionType
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'locations/{location_id}/privateNetworkConnect')
        data = super().get(url, params=params)
        r = GetPrivateNetworkConnectObjectNetworkConnectionType.model_validate(data['networkConnectionType'])
        return r

    def update_private_network_connect(self, location_id: str,
                                       network_connection_type: GetPrivateNetworkConnectObjectNetworkConnectionType,
                                       org_id: str = None):
        """
        Update Private Network Connect

        Update the location's network connection type.

        Network Connection Type determines if the location's network connection is public or private.

        Updating a location's network connection type requires a full administrator or location administrator auth
        token with a scope of `spark-admin:telephony_config_write`.

        :param location_id: Update the network connection type for this location.
        :type location_id: str
        :param network_connection_type: Network Connection Type for the location.
        :type network_connection_type: GetPrivateNetworkConnectObjectNetworkConnectionType
        :param org_id: Update network connection type for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['networkConnectionType'] = enum_str(network_connection_type)
        url = self.ep(f'locations/{location_id}/privateNetworkConnect')
        super().put(url, params=params, json=body)

    def read_the_list_of_routing_choices(self, org_id: str = None, route_group_name: str = None,
                                         trunk_name: str = None, start: int = None, order: str = None,
                                         **params) -> Generator[RouteIdentity, None, None]:
        """
        Read the List of Routing Choices

        List all Routes for the organization.

        Trunk and Route Group qualify as Route. Trunks and Route Groups provide you the ability to configure Webex
        Calling to manage calls between Webex Calling hosted users and premises PBX users. This solution lets you
        configure users to use Cloud PSTN (CCP or Cisco PSTN) or Premises-based PSTN.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List route identities for this organization.
        :type org_id: str
        :param route_group_name: Return the list of route identities matching the Route group name..
        :type route_group_name: str
        :param trunk_name: Return the list of route identities matching the Trunk name..
        :type trunk_name: str
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param order: Order the route identities according to the designated fields.  Available sort fields:
            `routeName`, `routeType`.
        :type order: str
        :return: Generator yielding :class:`RouteIdentity` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if route_group_name is not None:
            params['routeGroupName'] = route_group_name
        if trunk_name is not None:
            params['trunkName'] = trunk_name
        if start is not None:
            params['start'] = start
        if order is not None:
            params['order'] = order
        url = self.ep('routeChoices')
        return self.session.follow_pagination(url=url, model=RouteIdentity, item_key='routeIdentities', params=params)


class LocationsApi(ApiChild, base='locations'):
    """
    Locations
    
    Locations allow you to organize users and workspaces based on a physical location. You can configure both calling
    and workspace management functions into the same location. To enable a location for Webex Calling, use the
    `Enable a Location for Webex Calling
    <https://developer.webex.com/docs/api/v1/location-call-settings/enable-a-location-for-webex-calling>`_ API.
    You can also create and inspect locations in Webex Control Hub. See `Locations on Control Hub
    <https://help.webex.com/en-us/article/ajh6iy/Locations-in-Control-Hub>`_ for more information.
    """

    def list_locations(self, name: str = None, id: str = None, org_id: str = None,
                       **params) -> Generator[Location7, None, None]:
        """
        List Locations

        List locations for an organization.

        * Use query parameters to filter the result set by location name, ID, or organization.

        * Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * Searching and viewing locations in your organization requires an administrator or location administrator auth
        token with any of the following scopes: `spark-admin:locations_read`, `spark-admin:people_read` or
        `spark-admin:device_read`.

        :param name: List locations whose name contains this string (case-insensitive).
        :type name: str
        :param id: List locations by ID.
        :type id: str
        :param org_id: List locations in this organization. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str
        :return: Generator yielding :class:`Location7` instances
        """
        if name is not None:
            params['name'] = name
        if id is not None:
            params['id'] = id
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Location7, item_key='items', params=params)

    def get_location_details(self, location_id: str, org_id: str = None) -> Location7:
        """
        Get Location Details

        Shows details for a location, by ID.

        * Specify the location ID in the `locationId` parameter in the URI.

        * Use query parameter `orgId` to filter the result set by organization(optional).

        * Searching and viewing location in your organization requires an administrator or location administrator auth
        token with any of the following scopes:

        * `spark-admin:locations_read`
        * `spark-admin:people_read`
        * `spark-admin:device_read`

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param org_id: Get location common attributes for this organization.
        :type org_id: str
        :rtype: :class:`Location7`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'{location_id}')
        data = super().get(url, params=params)
        r = Location7.model_validate(data)
        return r

    def create_a_location(self, name: str, time_zone: str, preferred_language: str, announcement_language: str,
                          address: PostLocationCallingRequestAddress, latitude: Union[str, datetime],
                          longitude: Union[str, datetime], notes: str, org_id: str = None) -> str:
        """
        Create a Location

        Create a new Location for a given organization. Only an admin in the organization can create a new Location.

        * Creating a location in your organization requires a full administrator auth token with a scope of
        `spark-admin:locations_write`.

        * Partners may specify `orgId` query parameter to create location in managed organization.

        * The following body parameters are required to create a new location:
        * `name`
        * `timeZone`
        * `preferredLanguage`
        * `address`
        * `announcementLanguage`.

        * `latitude`, `longitude` and `notes` are optional parameters to create a new location.

        :param name: The name of the location.
        :type name: str
        :param time_zone: Time zone associated with this location, refer to this `link
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_ for format.
        :type time_zone: str
        :param preferred_language: Default email language.
        :type preferred_language: str
        :param announcement_language: Location's phone announcement language.
        :type announcement_language: str
        :param address: The address of the location.
        :type address: PostLocationCallingRequestAddress
        :param latitude: Latitude
        :type latitude: Union[str, datetime]
        :param longitude: Longitude
        :type longitude: Union[str, datetime]
        :param notes: Notes
        :type notes: str
        :param org_id: Create a location common attribute for this organization.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['timeZone'] = time_zone
        body['preferredLanguage'] = preferred_language
        body['announcementLanguage'] = announcement_language
        body['address'] = loads(address.model_dump_json())
        body['latitude'] = latitude
        body['longitude'] = longitude
        body['notes'] = notes
        url = self.ep()
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def update_a_location(self, location_id: str, name: str, time_zone: str, preferred_language: str,
                          address: PostLocationCallingRequestAddress, org_id: str = None):
        """
        Update a Location

        Update details for a location, by ID.

        * Updating a location in your organization requires a full administrator or location administrator auth token
        with a scope of `spark-admin:locations_write`.

        * Specify the location ID in the `locationId` parameter in the URI.

        * Partners may specify `orgId` query parameter to update location in managed organization.

        :param location_id: Update location common attributes for this location.
        :type location_id: str
        :param name: The name of the location.
        :type name: str
        :param time_zone: Time zone associated with this location, refer to this `link
            <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#webex-meetings-site-timezone>`_ for format.
        :type time_zone: str
        :param preferred_language: Default email language.
        :type preferred_language: str
        :param address: The address of the location.
        :type address: PostLocationCallingRequestAddress
        :param org_id: Update location common attributes for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['timeZone'] = time_zone
        body['preferredLanguage'] = preferred_language
        body['address'] = loads(address.model_dump_json())
        url = self.ep(f'{location_id}')
        super().put(url, params=params, json=body)

    def list_location_floors(self, location_id: str) -> list[Floor]:
        """
        List Location Floors

        List location floors.
        Requires an administrator auth token with the `spark-admin:locations_read` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :rtype: list[Floor]
        """
        url = self.ep(f'{location_id}/floors')
        data = super().get(url)
        r = TypeAdapter(list[Floor]).validate_python(data['items'])
        return r

    def create_a_location_floor(self, location_id: str, floor_number: int, display_name: str) -> Floor:
        """
        Create a Location Floor

        Create a new floor in the given location. The `displayName` parameter is optional, and omitting it will result
        in the creation of a floor without that value set.
        Requires an administrator auth token with the `spark-admin:locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str
        :rtype: :class:`Floor`
        """
        body = dict()
        body['floorNumber'] = floor_number
        body['displayName'] = display_name
        url = self.ep(f'{location_id}/floors')
        data = super().post(url, json=body)
        r = Floor.model_validate(data)
        return r

    def get_location_floor_details(self, location_id: str, floor_id: str) -> Floor:
        """
        Get Location Floor Details

        Shows details for a floor, by ID. Specify the floor ID in the `floorId` parameter in the URI.
        Requires an administrator auth token with the `spark-admin:locations_read` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :rtype: :class:`Floor`
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().get(url)
        r = Floor.model_validate(data)
        return r

    def update_a_location_floor(self, location_id: str, floor_id: str, floor_number: int, display_name: str) -> Floor:
        """
        Update a Location Floor

        Updates details for a floor, by ID. Specify the floor ID in the `floorId` parameter in the URI. Include all
        details for the floor returned by a previous call to `Get Location Floor Details
        <https://developer.webex.com/docs/api/v1/locations/get-location-floor-details>`_. Omitting the optional
        `displayName` field will result in that field no longer being defined for the floor.
        Requires an administrator auth token with the `spark-admin:locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str
        :rtype: :class:`Floor`
        """
        body = dict()
        body['floorNumber'] = floor_number
        body['displayName'] = display_name
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().put(url, json=body)
        r = Floor.model_validate(data)
        return r

    def delete_a_location_floor(self, location_id: str, floor_id: str):
        """
        Delete a Location Floor

        Deletes a floor, by ID.
        Requires an administrator auth token with the `spark-admin:locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :rtype: None
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        super().delete(url)


class MeetingChatsApi(ApiChild, base='meetings/postMeetingChats'):
    """
    Meeting Chats
    
    Chats are content captured in a meeting when chat messages are sent between the participants within a meeting. This
    feature allows a Compliance Officer to access the in-meeting chat content.
    
    The Compliance Officer can use the Meeting Chats API to retrieve the chats of a meeting and to delete all chats
    associated with a meeting. `private` chats are text messages between two people. `group` chats are for larger
    breakout spaces. Meeting chats are different from room messages in that there is no catch-up propagation. For
    example, if a user joins a meeting late only, chat messages that are created from then on, will be propagated to
    this user. To understand which user saw which message if they joined late, you have to query the
    `meetingParticipants` REST resource for the joined/left times and compare to the `meetingsChat` `chatTime` field.
    
    The Webex meetings chat functionality and API endpoint described here is
    "upon-request" and not enabled by default. If you need it enabled for your
    org, or if you need help, please contact the Webex Developer Support team at
    devsupport@webex.com.
    
    
    
    Meetings on the Webex Meetings Suite platform rely on enhanced meeting chat
    functionality, powered by a different backend. To access meeting chats in the
    Webex Suite, please see the `meetingMessages
    <https://developer.webex.com/docs/api/v1/meeting-messages>`_
    resource.
    
    """

    def list_meeting_chats(self, meeting_id: str, **params) -> Generator[ChatObject, None, None]:
        """
        List Meeting Chats

        Lists the meeting chats of a finished `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ specified by `meetingId`. You can set a maximum number
        of chats to return.

        Use this operation to list the chats of a finished `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ when they are ready. Please note that only
        **meeting instances** in state `ended` are supported for `meetingId`. **Meeting series**, **scheduled
        meetings** and `in-progress` **meeting instances** are not supported.

        :param meeting_id: A unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the chats belong. The meeting ID of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported.
        :type meeting_id: str
        :return: Generator yielding :class:`ChatObject` instances
        """
        params['meetingId'] = meeting_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ChatObject, item_key='items', params=params)

    def delete_meeting_chats(self, meeting_id: str):
        """
        Delete Meeting Chats

        Deletes the meeting chats of a finished `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ specified by `meetingId`.

        Use this operation to delete the chats of a finished `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ when they are ready. Please note that
        only **meeting instances** in state `ended` are supported for `meetingId`. **Meeting series**, **scheduled
        meetings** and `in-progress` **meeting instances** are not supported.

        :param meeting_id: A unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the chats belong. Meeting IDs of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting are not supported.
        :type meeting_id: str
        :rtype: None
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep()
        super().delete(url, params=params)


class MeetingClosedCaptionsApi(ApiChild, base='meetingClosedCaptions'):
    """
    Meeting Closed Captions
    
    Meeting Closed Captions APIs are enabled upon request, and are not available
    by default. Please contact the Webex Developer Support team at
    devsupport@webex.com if you would like to enable this feature for your
    organization.
    
    
    
    Meeting closed captions are the automatic transcriptions of what is being said during a meeting in real-time.
    Closed captions appear after being enabled during a meeting and can be translated to a participant's language.
    
    A closed caption snippet is a short text snippet from a meeting closed caption which was spoken by a particular
    participant in the meeting. A meeting's closed captions consists of many snippets.
    
    The Closed Captions API manages meeting closed captions and snippets. You can list meeting closed captions, as well
    as list and download snippets. Closed captions can  be retrieved in either Web Video Text Tracks (VTT) or plain
    text (TXT) format via the download links provided by the `vttDownloadLink` and `txtDownloadlink` response
    properties, respectively.
    
    Refer to the `Meetings API Scopes
    <https://developer.webex.com/docs/meetings#meetings-api-scopes>`_ section of `Meetings Overview
    
    **Notes:**
    
    * Currently, closed caption APIs are only supported for the `Compliance Officer
    <https://developer.webex.com/docs/compliance#compliance>`_ role.
    
    * Closed captions will be available 15 minutes after the meeting is finished.
    """

    def list_meeting_closed_captions(self, meeting_id: str) -> list[ClosedCaptionObject]:
        """
        List Meeting Closed Captions

        Lists closed captions of a finished `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ specified by `meetingId`.

        * Closed captions are ready 15 minutes after the meeting is finished.

        * Only **meeting instances** in state `ended` are supported for `meetingId`. **Meeting series**, **scheduled
        meetings** and `in-progress` **meeting instances** are not supported.

        * Currently, a meeting may have only one closed caption associated with its `meetingId`. The response is a
        closed captions array, which may contain multiple values to allow for future expansion, but currently only one
        closed caption is included in the response.

        :param meeting_id: Unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ which the closed captions belong to. This
            parameter only applies to ended meeting instances. It does not apply to meeting series, scheduled meetings
            or scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meetings.
        :type meeting_id: str
        :rtype: list[ClosedCaptionObject]
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClosedCaptionObject]).validate_python(data['items'])
        return r

    def list_meeting_closed_caption_snippets(self, closed_caption_id: str, meeting_id: str) -> list[SnippetObject]:
        """
        List Meeting Closed Caption Snippets

        Lists snippets of a meeting closed caption specified by `closedCaptionId`.

        :param closed_caption_id: Unique identifier for the meeting closed caption which the snippets belong to.
        :type closed_caption_id: str
        :param meeting_id: Unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ which the closed caption snippets belong to. This
            parameter only applies to ended meeting instances. It does not apply to meeting series, scheduled meetings
            or scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meetings.
        :type meeting_id: str
        :rtype: list[SnippetObject]
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep(f'{closed_caption_id}/snippets')
        data = super().get(url, params=params)
        r = TypeAdapter(list[SnippetObject]).validate_python(data['items'])
        return r

    def download_meeting_closed_caption_snippets(self, closed_caption_id: str, meeting_id: str,
                                                 format: DownloadMeetingClosedCaptionSnippetsFormat = None):
        """
        Download Meeting Closed Caption Snippets

        Download meeting closed caption snippets from the meeting closed caption specified by `closedCaptionId`
        formatted either as a Video Text Track (.vtt) file or plain text (.txt) file.

        #### Request Header

        * `timezone`: *`Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.*

        :param closed_caption_id: Unique identifier for the meeting closed caption.
        :type closed_caption_id: str
        :param meeting_id: Unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ which the closed caption snippets belong to. This
            parameter only applies to meeting instances in the `ended` state. It does not apply to meeting series,
            scheduled meetings or scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meetings.
        :type meeting_id: str
        :param format: Format for the downloaded meeting closed caption snippets.
        :type format: DownloadMeetingClosedCaptionSnippetsFormat
        :rtype: None
        """
        params = {}
        if format is not None:
            params['format'] = format
        params['meetingId'] = meeting_id
        url = self.ep(f'{closed_caption_id}/download')
        super().get(url, params=params)


class MeetingInviteesApi(ApiChild, base='meetingInvitees'):
    """
    Meeting Invitees
    
    This API manages invitees' relationships to a meeting.
    
    You can use the Meeting Invitees API to list, create, update, and delete invitees.
    
    Refer to the `Meetings API Scopes` section of `Meetings Overview
    <https://developer.webex.com/docs/meetings>`_ for scopes required for each API.
    """

    def list_meeting_invitees(self, meeting_id: str, host_email: str = None, panelist: str = None,
                              **params) -> Generator[CreateInviteesItemResponseObject, None, None]:
        """
        List Meeting Invitees

        Lists meeting invitees for a meeting with a specified `meetingId`. You can set a maximum number of invitees to
        return.

        This operation can be used for meeting series, scheduled meetings, and ended or ongoing meeting instance
        objects. If the specified `meetingId` is for a meeting series, the invitees for the series will be listed; if
        the `meetingId` is for a scheduled meeting, the invitees for the particular scheduled meeting will be listed;
        if the `meetingId` is for an ended or ongoing meeting instance, the invitees for the particular meeting
        instance will be listed. See the `Webex Meetings
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ guide for more information about the types of meetings.

        The list returned is sorted in ascending order by email address.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param meeting_id: Unique identifier for the meeting for which invitees are being requested. The meeting can be
            a meeting series, a scheduled meeting, or a meeting instance which has ended or is ongoing. The meeting ID
            of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return meeting invitees that are hosted by that user.
        :type host_email: str
        :param panelist: Filter invitees or attendees for webinars only. If `true`, returns invitees. If `false`,
            returns attendees. If `null`, returns both invitees and attendees.
        :type panelist: str
        :return: Generator yielding :class:`CreateInviteesItemResponseObject` instances
        """
        params['meetingId'] = meeting_id
        if host_email is not None:
            params['hostEmail'] = host_email
        if panelist is not None:
            params['panelist'] = panelist
        url = self.ep()
        return self.session.follow_pagination(url=url, model=CreateInviteesItemResponseObject, item_key='items', params=params)

    def create_a_meeting_invitee(self, meeting_id: str, email: str, display_name: str, co_host: bool, host_email: str,
                                 send_email: bool, panelist: bool) -> CreateInviteesItemResponseObject:
        """
        Create a Meeting Invitee

        Invite a person to attend a meeting.

        Identify the invitee in the request body, by email address.

        :param meeting_id: Unique identifier for the meeting to which a person is being invited. This attribute only
            applies to meeting series and scheduled meeting. If it's a meeting series, the meeting invitee is invited
            to the entire meeting series; if it's a scheduled meeting, the meeting invitee is invited to this
            individual scheduled meeting. It doesn't apply to an ended or ongoing meeting instance. The meeting ID of
            a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param email: Email address for meeting invitee.
        :type email: str
        :param display_name: Display name for meeting invitee. The maximum length of `displayName` is 128 characters.
            In the Webex app, if the email has been associated with an existing Webex account, the display name
            associated with the Webex account will be used; otherwise, the `email` will be used as `displayName`. In a
            Webex site, if `displayName` is specified, it will show `displayName`. If `displayName` is not specified,
            and the `email` has been associated with an existing Webex account, the display name associated with the
            Webex account will be used; otherwise, the `email` will be used as `displayName`.

        If the invitee has an existing Webex account, the `displayName` shown in the meeting will be the `displayName`
        associated with the Webex account; otherwise, `displayName` shown in the meeting will be the `displayName`
        which is specified by the invitee who does not have a Webex account.
        :type display_name: str
        :param co_host: Whether or not the invitee is a designated alternate host for the meeting. See
            `Add Alternate Hosts for Cisco Webex Meetings
            <https://help.webex.com/b5z6he/>`_ for more details.
        :type co_host: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send an email to the invitee.
        :type send_email: bool
        :param panelist: If `true`, the invitee is a designated panelist for the event meeting.
        :type panelist: bool
        :rtype: :class:`CreateInviteesItemResponseObject`
        """
        body = dict()
        body['meetingId'] = meeting_id
        body['email'] = email
        body['displayName'] = display_name
        body['coHost'] = co_host
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        body['panelist'] = panelist
        url = self.ep()
        data = super().post(url, json=body)
        r = CreateInviteesItemResponseObject.model_validate(data)
        return r

    def create_meeting_invitees(self, meeting_id: str, host_email: str,
                                items: list[CreateInviteesItemObject]) -> list[CreateInviteesItemResponseObject]:
        """
        Create Meeting Invitees

        Invite people to attend a meeting in bulk.

        Identify each invitee by the email address of each item in the `items` of the request body.

        Each invitee should have a unique `email`.

        This API limits the maximum size of `items` in the request body to 100.

        :param meeting_id: Unique identifier for the meeting to which the people are being invited. This attribute only
            applies to meeting series and scheduled meetings. If it's a meeting series, the meeting invitees are
            invited to the entire meeting series; if it's a scheduled meeting, the meeting invitees are invited to
            this individual scheduled meeting. It doesn't apply to an ended or ongoing meeting instance. The meeting
            ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param items: Meeting invitees to be inserted.
        :type items: list[CreateInviteesItemObject]
        :rtype: list[CreateInviteesItemResponseObject]
        """
        body = dict()
        body['meetingId'] = meeting_id
        body['hostEmail'] = host_email
        body['items'] = loads(TypeAdapter(list[CreateInviteesItemObject]).dump_json(items))
        url = self.ep('bulkInsert')
        data = super().post(url, json=body)
        r = TypeAdapter(list[CreateInviteesItemResponseObject]).validate_python(data['items'])
        return r

    def get_a_meeting_invitee(self, meeting_invitee_id: str,
                              host_email: str = None) -> CreateInviteesItemResponseObject:
        """
        Get a Meeting Invitee

        Retrieve details for a meeting invitee identified by a `meetingInviteeId` in the URI.

        :param meeting_invitee_id: Unique identifier for the invitee whose details are being requested.
        :type meeting_invitee_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return details for a meeting invitee that is hosted by that user.
        :type host_email: str
        :rtype: :class:`CreateInviteesItemResponseObject`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_invitee_id}')
        data = super().get(url, params=params)
        r = CreateInviteesItemResponseObject.model_validate(data)
        return r

    def update_a_meeting_invitee(self, meeting_invitee_id: str, email: str, display_name: str, co_host: bool,
                                 host_email: str, send_email: bool,
                                 panelist: bool) -> CreateInviteesItemResponseObject:
        """
        Update a Meeting Invitee

        Update details for a meeting invitee identified by a `meetingInviteeId` in the URI.

        :param meeting_invitee_id: Unique identifier for the invitee to be updated. This parameter only applies to an
            invitee to a meeting series or a scheduled meeting. It doesn't apply to an invitee to an ended or ongoing
            meeting instance.
        :type meeting_invitee_id: str
        :param email: Email address for meeting invitee.
        :type email: str
        :param display_name: Display name for meeting invitee. The maximum length of `displayName` is 128 characters.
            In the Webex app, if the email has been associated with an existing Webex account, the display name
            associated with the Webex account will be used; otherwise, the `email` will be used as `displayName`. In a
            Webex site, if `displayName` is specified, it will show `displayName`. If `displayName` is not specified,
            and the `email` has been associated with an existing Webex account, the display name associated with the
            Webex account will be used; otherwise, the `email` will be used as `displayName`.

        If the invitee has an existing Webex account, the `displayName` shown in the meeting will be the `displayName`
        associated with the Webex account; otherwise, `displayName` shown in the meeting will be the `displayName`
        which is specified by the invitee who does not have a Webex account.
        :type display_name: str
        :param co_host: Whether or not the invitee is a designated alternate host for the meeting. See
            `Add Alternate Hosts for Cisco Webex Meetings
            <https://help.webex.com/b5z6he/>`_ for more details.
        :type co_host: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send an email to the invitee.
        :type send_email: bool
        :param panelist: If `true`, the invitee is a designated panelist for the event meeting.
        :type panelist: bool
        :rtype: :class:`CreateInviteesItemResponseObject`
        """
        body = dict()
        body['email'] = email
        body['displayName'] = display_name
        body['coHost'] = co_host
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        body['panelist'] = panelist
        url = self.ep(f'{meeting_invitee_id}')
        data = super().put(url, json=body)
        r = CreateInviteesItemResponseObject.model_validate(data)
        return r

    def delete_a_meeting_invitee(self, meeting_invitee_id: str, host_email: str = None, send_email: bool = None):
        """
        Delete a Meeting Invitee

        Removes a meeting invitee identified by a `meetingInviteeId` specified in the URI. The deleted meeting invitee
        cannot be recovered.

        If the meeting invitee is associated with a meeting series, the invitee will be removed from the entire meeting
        series. If the invitee is associated with a scheduled meeting, the invitee will be removed from only that
        scheduled meeting.

        :param meeting_invitee_id: Unique identifier for the invitee to be removed. This parameter only applies to an
            invitee to a meeting series or a scheduled meeting. It doesn't apply to an invitee to an ended or ongoing
            meeting instance.
        :type meeting_invitee_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will delete a meeting invitee that is hosted by that user.
        :type host_email: str
        :param send_email: If `true`, send an email to the invitee.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_invitee_id}')
        super().delete(url, params=params)


class MeetingMessagesApi(ApiChild, base='meeting/messages/{meetingMessageId}'):
    """
    Meeting Messages
    
    Meeting messages are how we communicate through text within an active `Webex Suite meeting
    <https://help.webex.com/en-us/article/m61d8eb/Webex-App-%7C-About-the-Webex-Suite-meeting-platform>`_ or space bound meeting.
    
    The meeting messages are stored in the `/events API
    <https://developer.webex.com/docs/api/v1/events/list-events>`_ with the associated resource type: `meetingMessages`
    
    By default direct messages between two participants in a meeting are treated as ephemeral. Public messages will be
    archived in the /events API, but `can be made ephemeral
    <https://help.webex.com/en-us/article/o1rrjk/Save-or-clear-your-organization's-in-meeting-chats-after-a-meeting>`_ as well.
    
    In a Webex meeting, each meeting message is displayed on its own line along with a timestamp and sender
    information.
    
    Message can contain plain text and `rich text
    <https://developer.webex.com/docs/basics#formatting-messages>`_
    """

    def delete_a_meeting_message(self, meeting_message_id: str):
        """
        Delete a Meeting Message

        Deletes a Meeting Message from the In Meeting Chat, using its ID.

        This ID can be retrieved by a Compliance Officer using the `events API
        <https://developer.webex.com/docs/api/v1/events/list-events>`_ filtering on the `meetingMessages`
        resource type.

        NOTE: When viewing the response from the events API, there are 2 `id` fields. The ID to be used here can be
        found under the `data` field in the response.

        Specify the `meetingMessage` ID in the `meetingMessageId` parameter in the URI.

        :param meeting_message_id: The unique identifier for the message.
        :type meeting_message_id: str
        :rtype: None
        """
        url = self.ep(f'')
        super().delete(url)


class MeetingParticipantsWithAdmissionFromLobbyToBreakoutSessionApi(ApiChild, base='meetingParticipants'):
    """
    Meeting Participants with Admission from Lobby to Breakout Session
    
    This API manages meeting participants.
    
    Refer to the `Meetings API Scopes
    <https://developer.webex.com/docs/meetings#meetings-api-scopes>`_ section of `Meetings Overview
    """

    def list_meeting_participants(self, meeting_id: str, meeting_start_time_from: Union[str, datetime] = None,
                                  meeting_start_time_to: Union[str, datetime] = None, host_email: str = None,
                                  join_time_from: Union[str, datetime] = None, join_time_to: Union[str,
                                  datetime] = None, **params) -> Generator[Participant, None, None]:
        """
        List Meeting Participants

        List all participants in an in-progress meeting or an ended meeting. The `meetingId` parameter is required,
        which is the unique identifier for the meeting.

        The authenticated user calling this API must either have an Administrator role with the
        `meeting:admin_participants_read` scope, or be the meeting host.

        * If the `meetingId` value specified is for a meeting series, the operation returns participants' details for
        the last instance in the meeting series. If the `meetingStartTimeFrom` value and the `meetingStartTimeTo`
        value are specified, the operation returns participants' details for the last instance in the meeting series
        in the time range.

        * If the `meetingId` value specified is for a scheduled meeting from a meeting series, the operation returns
        participants' details for that scheduled meeting. If the `meetingStartTimeFrom` value and the
        `meetingStartTimeTo` value are specified, the operation returns participants' details for the last instance in
        the scheduled meeting in the time range.

        * If the `meetingId` value specified is for a meeting instance which is in progress or ended, the operation
        returns participants' details for that meeting instance.

        * If the meeting is in progress, the operation returns all the real-time participants. If the meeting is ended,
        the operation returns all the participants that have joined the meeting.

        * The `meetingStartTimeFrom` and `meetingStartTimeTo` only apply when `meetingId` is a series ID or an
        occurrence ID.

        * If the webinar is in progress when the attendee has ever been unmuted to speak in the webinar, this attendee
        becomes a panelist. The operation returns include the people who have been designated as panelists when the
        webinar is created and have joined the webinar, and the attendees who have joined the webinar and are unmuted
        to speak in the webinar temporarily. If the webinar is ended, the operation returns all the participants,
        including all panelists and all attendees who are not panelists.

        #### Request Header

        * `timezone`: Time zone for time stamps in the response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_.

        :param meeting_id: The unique identifier for the meeting. Please note that currently meeting ID of a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param meeting_start_time_from: Meetings start from the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeFrom` is not specified, it equals `meetingStartTimeTo` minus 1
            month; if `meetingStartTimeTo` is also not specified, the default value for `meetingStartTimeFrom` is 1
            month before current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: Meetings start before the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeTo` is not specified, it equals the result of a comparison,
            `meetingStartTimeFrom` plus one month and the current time, and the result is the earlier of the two; if
            `meetingStartTimeFrom` is also not specified, the default value for `meetingStartTimeTo` is current date
            and time minus 1 month.
        :type meeting_start_time_to: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param join_time_from: The time participants join a meeting starts from the specified date and time (inclusive)
            in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeFrom` is not specified, it equals `joinTimeTo` minus 7 days.
        :type join_time_from: Union[str, datetime]
        :param join_time_to: The time participants join a meeting before the specified date and time (exclusive) in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeTo` is not specified, it equals `joinTimeFrom` plus 7 days. The
            interval between `joinTimeFrom` and `joinTimeTo` must be within 90 days.
        :type join_time_to: Union[str, datetime]
        :return: Generator yielding :class:`Participant` instances
        """
        params['meetingId'] = meeting_id
        if meeting_start_time_from is not None:
            if isinstance(meeting_start_time_from, str):
                meeting_start_time_from = isoparse(meeting_start_time_from)
            meeting_start_time_from = dt_iso_str(meeting_start_time_from)
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            if isinstance(meeting_start_time_to, str):
                meeting_start_time_to = isoparse(meeting_start_time_to)
            meeting_start_time_to = dt_iso_str(meeting_start_time_to)
            params['meetingStartTimeTo'] = meeting_start_time_to
        if host_email is not None:
            params['hostEmail'] = host_email
        if join_time_from is not None:
            if isinstance(join_time_from, str):
                join_time_from = isoparse(join_time_from)
            join_time_from = dt_iso_str(join_time_from)
            params['joinTimeFrom'] = join_time_from
        if join_time_to is not None:
            if isinstance(join_time_to, str):
                join_time_to = isoparse(join_time_to)
            join_time_to = dt_iso_str(join_time_to)
            params['joinTimeTo'] = join_time_to
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Participant, item_key='items', params=params)

    def query_meeting_participants_with_email(self, meeting_id: str, meeting_start_time_from: Union[str,
                                              datetime] = None, meeting_start_time_to: Union[str, datetime] = None,
                                              host_email: str = None, emails: list[str] = None,
                                              join_time_from: Union[str, datetime] = None, join_time_to: Union[str,
                                              datetime] = None) -> list[Participant]:
        """
        Query Meeting Participants with Email

        Query participants in a live meeting, or after the meeting, using participant's email. The `meetingId`
        parameter is the unique identifier for the meeting and is required.

        The authenticated user calling this API must either have an Administrator role with the
        `meeting:admin_participants_read` scope, or be the meeting host.

        * If the `meetingId` value specified is for a meeting series, the operation returns participants' details for
        the last instance in the meeting series. If the `meetingStartTimeFrom` value and the `meetingStartTimeTo`
        value are specified, the operation returns participants' details for the last instance in the meeting series
        in the time range.

        * If the `meetingId` value specified is for a scheduled meeting from a meeting series, the operation returns
        participants' details for that scheduled meeting. If the `meetingStartTimeFrom` value and the
        `meetingStartTimeTo` value are specified, the operation returns participants' details for the last instance in
        the scheduled meeting in the time range.

        * If the `meetingId` value specified is for a meeting instance which is in progress or ended, the operation
        returns participants' details for that meeting instance.

        * The `meetingStartTimeFrom` and `meetingStartTimeTo` only apply when `meetingId` is a series ID or an
        occurrence ID.

        #### Request Header

        * `timezone`: Time zone for time stamps in the response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_.

        :param meeting_id: The unique identifier for the meeting.
        :type meeting_id: str
        :param meeting_start_time_from: Meetings start from the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeFrom` is not specified, it equals `meetingStartTimeTo` minus 1
            month; if `meetingStartTimeTo` is also not specified, the default value for `meetingStartTimeFrom` is 1
            month before current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: Meetings start before the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeTo` is not specified, it equals the result of a comparison,
            `meetingStartTimeFrom` plus one month and the current time, and the result is the earlier of the two; if
            `meetingStartTimeFrom` is also not specified, the default value for `meetingStartTimeTo` is current date
            and time minus 1 month.
        :type meeting_start_time_to: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param emails: Participants email list
        :type emails: list[str]
        :param join_time_from: The time participants join a meeting starts from the specified date and time (inclusive)
            in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeFrom` is not specified, it equals `joinTimeTo` minus 7 days.
        :type join_time_from: Union[str, datetime]
        :param join_time_to: The time participants join a meeting before the specified date and time (exclusive) in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeTo` is not specified, it equals `joinTimeFrom` plus 7 days. The
            interval between `joinTimeFrom` and `joinTimeTo` must be within 90 days.
        :type join_time_to: Union[str, datetime]
        :rtype: list[Participant]
        """
        params = {}
        params['meetingId'] = meeting_id
        if meeting_start_time_from is not None:
            if isinstance(meeting_start_time_from, str):
                meeting_start_time_from = isoparse(meeting_start_time_from)
            meeting_start_time_from = dt_iso_str(meeting_start_time_from)
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            if isinstance(meeting_start_time_to, str):
                meeting_start_time_to = isoparse(meeting_start_time_to)
            meeting_start_time_to = dt_iso_str(meeting_start_time_to)
            params['meetingStartTimeTo'] = meeting_start_time_to
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['emails'] = emails
        body['joinTimeFrom'] = join_time_from
        body['joinTimeTo'] = join_time_to
        url = self.ep('query')
        data = super().post(url, params=params, json=body)
        r = TypeAdapter(list[Participant]).validate_python(data['items'])
        return r

    def get_meeting_participant_details(self, participant_id: str, host_email: str = None) -> Participant:
        """
        Get Meeting Participant Details

        Get a meeting participant details of a live or post meeting. The `participantId` is required to identify the
        meeting and the participant.

        The authenticated user calling this API must either have an Administrator role with the
        `meeting:admin_participants_read` scope, or be the meeting host.

        :param participant_id: The unique identifier for the meeting and the participant.
        :type participant_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :rtype: :class:`Participant`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{participant_id}')
        data = super().get(url, params=params)
        r = Participant.model_validate(data)
        return r

    def update_a_participant(self, participant_id: str, muted: str = None, admit: str = None,
                             expel: str = None) -> InProgressParticipant:
        """
        Update a Participant

        To mute, un-mute, expel, or admit a participant in a live meeting. The `participantId` is required to identify
        the meeting and the participant.

        Notes:

        * The owner of the OAuth token calling this API needs to be the meeting host or co-host.

        * The `expel` attribute always takes precedence over `admit` and `muted`. The request can have all `expel`,
        `admit` and `muted` or any of them.

        <div><Callout type="warning">There is an inconsistent behavior in Webex Meetings App when all active meeting
        participants join using Webex Meetings App and the host attempts to change meeting participant status using
        this API. Requests to mute, un-mute, admit, or expel a meeting participant return a successful response and
        update the state in the API, but the changes will not be applied to the Webex Meetings App participants. The
        inconsistent behavior in Webex Meetings App will be corrected in a future release.
        **Workaround**: `Enable closed captions
        <https://help.webex.com/en-us/article/WBX47352/How-Do-I-Enable-Closed-Captions?>`_ or enable the `Webex Assistant

        :param participant_id: The unique identifier for the meeting and the participant.
        :type participant_id: str
        :param muted: The value is true or false, and means to mute or unmute the audio of a participant.
        :type muted: str
        :param admit: The value can be true or false. The value of true is to admit a participant to the meeting if the
            participant is in the lobby, No-Op if the participant is not in the lobby or when the value is set to
            false.
        :type admit: str
        :param expel: The attribute is exclusive and its value can be true or false. The value of true means that the
            participant will be expelled from the meeting, the value of false means No-Op.
        :type expel: str
        :rtype: :class:`InProgressParticipant`
        """
        body = dict()
        body['muted'] = muted
        body['admit'] = admit
        body['expel'] = expel
        url = self.ep(f'{participant_id}')
        data = super().put(url, json=body)
        r = InProgressParticipant.model_validate(data)
        return r

    def admit_participants(self, items: list[AdmitParticipant]):
        """
        Admit Participants

        To admit participants into a live meeting or its breakout sessions in bulk. If `breakoutSessionId` is null for
        all the requested participants, they are admitted into the main session of the meeting. If `breakoutSessionId`
        is not null for all the requested participants, they are admitted into the breakout sessions specified by each
        `breakoutSessionId`. It's not allowed that some requested participants have `breakoutSessionId` and the others
        haven't.

        This API limits the maximum size of `items` in the request body to 100.

        Each `participantId` of `items` in the request body should have the same prefix of `meetingId`.

        :type items: list[AdmitParticipant]
        :rtype: None
        """
        body = dict()
        body['items'] = loads(TypeAdapter(list[AdmitParticipant]).dump_json(items))
        url = self.ep('admit')
        super().post(url, json=body)


class MeetingParticipantsApi(ApiChild, base='meetingParticipants'):
    """
    Meeting Participants
    
    This API manages meeting participants.
    
    Refer to the `Meetings API Scopes
    <https://developer.webex.com/docs/meetings#meetings-api-scopes>`_ section of `Meetings Overview
    """

    def list_meeting_participants(self, meeting_id: str, meeting_start_time_from: Union[str, datetime] = None,
                                  meeting_start_time_to: Union[str, datetime] = None, host_email: str = None,
                                  join_time_from: Union[str, datetime] = None, join_time_to: Union[str,
                                  datetime] = None, **params) -> Generator[Participant1, None, None]:
        """
        List Meeting Participants

        List all participants in an in-progress meeting or an ended meeting. The `meetingId` parameter is required,
        which is the unique identifier for the meeting.

        The authenticated user calling this API must either have an Administrator role with the
        `meeting:admin_participants_read` scope, or be the meeting host.

        * If the `meetingId` value specified is for a meeting series, the operation returns participants' details for
        the last instance in the meeting series. If the `meetingStartTimeFrom` value and the `meetingStartTimeTo`
        value are specified, the operation returns participants' details for the last instance in the meeting series
        in the time range.

        * If the `meetingId` value specified is for a scheduled meeting from a meeting series, the operation returns
        participants' details for that scheduled meeting. If the `meetingStartTimeFrom` value and the
        `meetingStartTimeTo` value are specified, the operation returns participants' details for the last instance in
        the scheduled meeting in the time range.

        * If the `meetingId` value specified is for a meeting instance which is in progress or ended, the operation
        returns participants' details for that meeting instance.

        * If the meeting is in progress, the operation returns all the real-time participants. If the meeting is ended,
        the operation returns all the participants that have joined the meeting.

        * The `meetingStartTimeFrom` and `meetingStartTimeTo` only apply when `meetingId` is a series ID or an
        occurrence ID.

        * If the webinar is in progress when the attendee has ever been unmuted to speak in the webinar, this attendee
        becomes a panelist. The operation returns include the people who have been designated as panelists when the
        webinar is created and have joined the webinar, and the attendees who have joined the webinar and are unmuted
        to speak in the webinar temporarily. If the webinar is ended, the operation returns all the participants,
        including all panelists and all attendees who are not panelists.

        #### Request Header

        * `timezone`: Time zone for time stamps in the response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_.

        :param meeting_id: The unique identifier for the meeting. Please note that currently meeting ID of a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param meeting_start_time_from: Meetings start from the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeFrom` is not specified, it equals `meetingStartTimeTo` minus 1
            month; if `meetingStartTimeTo` is also not specified, the default value for `meetingStartTimeFrom` is 1
            month before current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: Meetings start before the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeTo` is not specified, it equals the result of a comparison,
            `meetingStartTimeFrom` plus one month and the current time, and the result is the earlier of the two; if
            `meetingStartTimeFrom` is also not specified, the default value for `meetingStartTimeTo` is current date
            and time minus 1 month.
        :type meeting_start_time_to: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param join_time_from: The time participants join a meeting starts from the specified date and time (inclusive)
            in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeFrom` is not specified, it equals `joinTimeTo` minus 7 days.
        :type join_time_from: Union[str, datetime]
        :param join_time_to: The time participants join a meeting before the specified date and time (exclusive) in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeTo` is not specified, it equals `joinTimeFrom` plus 7 days. The
            interval between `joinTimeFrom` and `joinTimeTo` must be within 90 days.
        :type join_time_to: Union[str, datetime]
        :return: Generator yielding :class:`Participant1` instances
        """
        params['meetingId'] = meeting_id
        if meeting_start_time_from is not None:
            if isinstance(meeting_start_time_from, str):
                meeting_start_time_from = isoparse(meeting_start_time_from)
            meeting_start_time_from = dt_iso_str(meeting_start_time_from)
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            if isinstance(meeting_start_time_to, str):
                meeting_start_time_to = isoparse(meeting_start_time_to)
            meeting_start_time_to = dt_iso_str(meeting_start_time_to)
            params['meetingStartTimeTo'] = meeting_start_time_to
        if host_email is not None:
            params['hostEmail'] = host_email
        if join_time_from is not None:
            if isinstance(join_time_from, str):
                join_time_from = isoparse(join_time_from)
            join_time_from = dt_iso_str(join_time_from)
            params['joinTimeFrom'] = join_time_from
        if join_time_to is not None:
            if isinstance(join_time_to, str):
                join_time_to = isoparse(join_time_to)
            join_time_to = dt_iso_str(join_time_to)
            params['joinTimeTo'] = join_time_to
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Participant1, item_key='items', params=params)

    def query_meeting_participants_with_email(self, meeting_id: str, meeting_start_time_from: Union[str,
                                              datetime] = None, meeting_start_time_to: Union[str, datetime] = None,
                                              host_email: str = None, emails: list[str] = None,
                                              join_time_from: Union[str, datetime] = None, join_time_to: Union[str,
                                              datetime] = None) -> list[Participant1]:
        """
        Query Meeting Participants with Email

        Query participants in a live meeting, or after the meeting, using participant's email. The `meetingId`
        parameter is the unique identifier for the meeting and is required.

        The authenticated user calling this API must either have an Administrator role with the
        `meeting:admin_participants_read` scope, or be the meeting host.

        * If the `meetingId` value specified is for a meeting series, the operation returns participants' details for
        the last instance in the meeting series. If the `meetingStartTimeFrom` value and the `meetingStartTimeTo`
        value are specified, the operation returns participants' details for the last instance in the meeting series
        in the time range.

        * If the `meetingId` value specified is for a scheduled meeting from a meeting series, the operation returns
        participants' details for that scheduled meeting. If the `meetingStartTimeFrom` value and the
        `meetingStartTimeTo` value are specified, the operation returns participants' details for the last instance in
        the scheduled meeting in the time range.

        * If the `meetingId` value specified is for a meeting instance which is in progress or ended, the operation
        returns participants' details for that meeting instance.

        * The `meetingStartTimeFrom` and `meetingStartTimeTo` only apply when `meetingId` is a series ID or an
        occurrence ID.

        #### Request Header

        * `timezone`: Time zone for time stamps in the response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_.

        :param meeting_id: The unique identifier for the meeting.
        :type meeting_id: str
        :param meeting_start_time_from: Meetings start from the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeFrom` is not specified, it equals `meetingStartTimeTo` minus 1
            month; if `meetingStartTimeTo` is also not specified, the default value for `meetingStartTimeFrom` is 1
            month before current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: Meetings start before the specified date and time(exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. If `meetingStartTimeTo` is not specified, it equals the result of a comparison,
            `meetingStartTimeFrom` plus one month and the current time, and the result is the earlier of the two; if
            `meetingStartTimeFrom` is also not specified, the default value for `meetingStartTimeTo` is current date
            and time minus 1 month.
        :type meeting_start_time_to: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param emails: Participants email list
        :type emails: list[str]
        :param join_time_from: The time participants join a meeting starts from the specified date and time (inclusive)
            in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeFrom` is not specified, it equals `joinTimeTo` minus 7 days.
        :type join_time_from: Union[str, datetime]
        :param join_time_to: The time participants join a meeting before the specified date and time (exclusive) in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `joinTimeTo` is not specified, it equals `joinTimeFrom` plus 7 days. The
            interval between `joinTimeFrom` and `joinTimeTo` must be within 90 days.
        :type join_time_to: Union[str, datetime]
        :rtype: list[Participant1]
        """
        params = {}
        params['meetingId'] = meeting_id
        if meeting_start_time_from is not None:
            if isinstance(meeting_start_time_from, str):
                meeting_start_time_from = isoparse(meeting_start_time_from)
            meeting_start_time_from = dt_iso_str(meeting_start_time_from)
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            if isinstance(meeting_start_time_to, str):
                meeting_start_time_to = isoparse(meeting_start_time_to)
            meeting_start_time_to = dt_iso_str(meeting_start_time_to)
            params['meetingStartTimeTo'] = meeting_start_time_to
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['emails'] = emails
        body['joinTimeFrom'] = join_time_from
        body['joinTimeTo'] = join_time_to
        url = self.ep('query')
        data = super().post(url, params=params, json=body)
        r = TypeAdapter(list[Participant1]).validate_python(data['items'])
        return r

    def get_meeting_participant_details(self, participant_id: str, host_email: str = None) -> Participant1:
        """
        Get Meeting Participant Details

        Get a meeting participant details of a live or post meeting. The `participantId` is required to identify the
        meeting and the participant.

        The authenticated user calling this API must either have an Administrator role with the
        `meeting:admin_participants_read` scope, or be the meeting host.

        :param participant_id: The unique identifier for the meeting and the participant.
        :type participant_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes, the admin may specify the email of a user in a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :rtype: :class:`Participant1`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{participant_id}')
        data = super().get(url, params=params)
        r = Participant1.model_validate(data)
        return r

    def update_a_participant(self, participant_id: str, muted: str = None, admit: str = None,
                             expel: str = None) -> InProgressParticipant:
        """
        Update a Participant

        To mute, un-mute, expel, or admit a participant in a live meeting. The `participantId` is required to identify
        the meeting and the participant.

        Notes:

        * The owner of the OAuth token calling this API needs to be the meeting host or co-host.

        * The `expel` attribute always takes precedence over `admit` and `muted`. The request can have all `expel`,
        `admit` and `muted` or any of them.

        <div><Callout type="warning">There is an inconsistent behavior in Webex Meetings App when all active meeting
        participants join using Webex Meetings App and the host attempts to change meeting participant status using
        this API. Requests to mute, un-mute, admit, or expel a meeting participant return a successful response and
        update the state in the API, but the changes will not be applied to the Webex Meetings App participants. The
        inconsistent behavior in Webex Meetings App will be corrected in a future release.
        **Workaround**: `Enable closed captions
        <https://help.webex.com/en-us/article/WBX47352/How-Do-I-Enable-Closed-Captions?>`_ or enable the `Webex Assistant

        :param participant_id: The unique identifier for the meeting and the participant.
        :type participant_id: str
        :param muted: The value is true or false, and means to mute or unmute the audio of a participant.
        :type muted: str
        :param admit: The value can be true or false. The value of true is to admit a participant to the meeting if the
            participant is in the lobby, No-Op if the participant is not in the lobby or when the value is set to
            false.
        :type admit: str
        :param expel: The attribute is exclusive and its value can be true or false. The value of true means that the
            participant will be expelled from the meeting, the value of false means No-Op.
        :type expel: str
        :rtype: :class:`InProgressParticipant`
        """
        body = dict()
        body['muted'] = muted
        body['admit'] = admit
        body['expel'] = expel
        url = self.ep(f'{participant_id}')
        data = super().put(url, json=body)
        r = InProgressParticipant.model_validate(data)
        return r

    def admit_participants(self, items: list[ParticipantID]):
        """
        Admit Participants

        To admit participants into a live meeting in bulk.

        This API limits the maximum size of `items` in the request body to 100.

        Each `participantId` of `items` in the request body should have the same prefix of `meetingId`.

        :type items: list[ParticipantID]
        :rtype: None
        """
        body = dict()
        body['items'] = loads(TypeAdapter(list[ParticipantID]).dump_json(items))
        url = self.ep('admit')
        super().post(url, json=body)


class MeetingPollsApi(ApiChild, base='meetings'):
    """
    Meeting Polls
    
    As a presenter, you can use a poll to create and share questionnaires. Polls can be useful for gathering feedback,
    taking votes, or testing knowledge.
    
    You can use the Meeting Poll API to list meeting polls, the poll's questions, and answers.
    
    Currently, these APIs are available to users with one of the meeting host,
    admin or `Compliance Officer
    <https://developer.webex.com/docs/compliance#compliance>`_ roles. The polls,
    polls results, and the list of poll respondents are available within 15
    minutes following the meeting.
    
    
    
    The Webex meetings poll functionality and API endpoint described here is
    "upon-request" and not enabled by default. If you need it enabled for your
    org, or if you need help, please contact the Webex Developer Support team at
    devsupport@webex.com.
    
    """

    def list_meeting_polls(self, meeting_id: str) -> list[Poll]:
        """
        List Meeting Polls

        Lists all the polls and the poll questions in a meeting when ready.

        * Only `meeting instances
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ in state `ended` or `inProgress` are supported for `meetingId`.

        * No pagination for this API because we don't expect a large number of questions for each meeting.

        <div><Callout type="info">Polls are available within 15 minutes following the meeting.</Callout></div>

        :param meeting_id: A unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the polls belong.
        :type meeting_id: str
        :rtype: list[Poll]
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep('polls')
        data = super().get(url, params=params)
        r = TypeAdapter(list[Poll]).validate_python(data['items'])
        return r

    def get_meeting_poll_results(self, meeting_id: str, **params) -> Generator[PollResult, None, None]:
        """
        Get Meeting PollResults

        List the meeting polls, the poll's questions, and answers from the meeting when ready.

        * Only `meeting instances
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ in state `ended` or `inProgress` are supported for `meetingId`.

        * Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * This API is paginated by the sum of respondents from all questions in a meeting, these pagination links are
        returned in the response header.

        <div><Callout type="info">Polls results are available within 15 minutes following the meeting.</Callout></div>

        :param meeting_id: A unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the polls belong.
        :type meeting_id: str
        :return: Generator yielding :class:`PollResult` instances
        """
        params['meetingId'] = meeting_id
        url = self.ep('pollResults')
        return self.session.follow_pagination(url=url, model=PollResult, item_key='items', params=params)

    def list_respondents_of_a_question(self, poll_id: str, question_id: str, meeting_id: str,
                                       **params) -> Generator[Respondent, None, None]:
        """
        List Respondents of a Question

        Lists the respondents to a specific questions in a poll.

        * Only `meeting instances
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ in state `ended` or `inProgress` are supported for `meetingId`.

        * Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        <div><Callout type="info">The list of poll respondents are available within 15 minutes following the
        meeting.</Callout></div>

        :param poll_id: A unique identifier for the poll to which the respondents belong.
        :type poll_id: str
        :param question_id: A unique identifier for the question to which the respondents belong.
        :type question_id: str
        :param meeting_id: A unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the respondents belong.
        :type meeting_id: str
        :return: Generator yielding :class:`Respondent` instances
        """
        params['meetingId'] = meeting_id
        url = self.ep(f'polls/{poll_id}/questions/{question_id}/respondents')
        return self.session.follow_pagination(url=url, model=Respondent, item_key='items', params=params)


class MeetingPreferencesApi(ApiChild, base=''):
    """
    Meeting Preferences
    
    This API manages a user's meeting preferences, including Personal Meeting Room settings, video and audio settings,
    meeting scheduling options, and site settings.
    
    Refer to the `Meetings API Scopes
    <https://developer.webex.com/docs/meetings#user-level-authentication-and-scopes>`_ section of `Meetings Overview
    """

    def get_meeting_preference_details(self, user_email: str = None, site_url: str = None) -> MeetingPreferenceObject:
        """
        Get Meeting Preference Details

        Retrieves meeting preferences for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the required `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site
            they manage and the API will return details of the meeting preferences for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: :class:`MeetingPreferenceObject`
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('meetingPreferences')
        data = super().get(url, params=params)
        r = MeetingPreferenceObject.model_validate(data)
        return r

    def get_personal_meeting_room_options(self, user_email: str = None,
                                          site_url: str = None) -> MeetingPreferenceObjectPersonalMeetingRoom:
        """
        Get Personal Meeting Room Options

        Retrieves the Personal Meeting Room options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will return details of the Personal Meeting Room options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: :class:`MeetingPreferenceObjectPersonalMeetingRoom`
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('meetingPreferences/personalMeetingRoom')
        data = super().get(url, params=params)
        r = MeetingPreferenceObjectPersonalMeetingRoom.model_validate(data)
        return r

    def update_personal_meeting_room_options(self, topic: str, host_pin: Union[str, datetime], enabled_auto_lock: bool,
                                             auto_lock_minutes: int, enabled_notify_host: bool, support_co_host: bool,
                                             support_anyone_as_co_host: bool, allow_first_user_to_be_co_host: bool,
                                             allow_authenticated_devices: bool,
                                             co_hosts: list[MeetingPreferenceObjectPersonalMeetingRoomCoHosts],
                                             user_email: str = None,
                                             site_url: str = None) -> MeetingPreferenceObjectPersonalMeetingRoom:
        """
        Update Personal Meeting Room Options

        Updates Personal Meeting Room options for the authenticated user.

        :param topic: Personal Meeting Room topic to be updated.
        :type topic: str
        :param host_pin: Updated PIN for joining the room as host. The host PIN must be digits of a predefined length,
            e.g. 4 digits. It cannot contain sequential digits, such as 1234 or 4321, or repeated digits of the
            predefined length, such as 1111. The predefined length for host PIN can be viewed in user's `My Personal
            Room` page and it can only be changed by site administrator.
        :type host_pin: Union[str, datetime]
        :param enabled_auto_lock: Update for option to automatically lock the Personal Room a number of minutes after a
            meeting starts. When a room is locked, invitees cannot enter until the owner admits them. The period after
            which the meeting is locked is defined by `autoLockMinutes`.
        :type enabled_auto_lock: bool
        :param auto_lock_minutes: Updated number of minutes after which the Personal Room is locked if
            `enabledAutoLock` is enabled. Valid options are 0, 5, 10, 15 and 20.
        :type auto_lock_minutes: int
        :param enabled_notify_host: Update for flag to enable notifying the owner of a Personal Room when someone
            enters the Personal Room lobby while the owner is not in the room.
        :type enabled_notify_host: bool
        :param support_co_host: Update for flag allowing other invitees to host a meetingCoHost in the Personal Room
            without the owner.
        :type support_co_host: bool
        :param support_anyone_as_co_host: Whether or not to allow any attendee with a host account on the target site
            to become a cohost when joining the Personal Room. The target site is user's preferred site.
        :type support_anyone_as_co_host: bool
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee with a host account on the
            target site to become a cohost when joining the Personal Room. The target site is user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the user's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param co_hosts: Updated array defining cohosts for the room if both `supportAnyoneAsCoHost` and
            `allowFirstUserToBeCoHost` are `false`
        :type co_hosts: list[MeetingPreferenceObjectPersonalMeetingRoomCoHosts]
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will update Personal Meeting Room options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: :class:`MeetingPreferenceObjectPersonalMeetingRoom`
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = dict()
        body['topic'] = topic
        body['hostPin'] = host_pin
        body['enabledAutoLock'] = enabled_auto_lock
        body['autoLockMinutes'] = auto_lock_minutes
        body['enabledNotifyHost'] = enabled_notify_host
        body['supportCoHost'] = support_co_host
        body['supportAnyoneAsCoHost'] = support_anyone_as_co_host
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['coHosts'] = loads(TypeAdapter(list[MeetingPreferenceObjectPersonalMeetingRoomCoHosts]).dump_json(co_hosts))
        url = self.ep('meetingPreferences/personalMeetingRoom')
        data = super().put(url, params=params, json=body)
        r = MeetingPreferenceObjectPersonalMeetingRoom.model_validate(data)
        return r

    def get_audio_options(self, user_email: str = None, site_url: str = None) -> MeetingPreferenceObjectAudio:
        """
        Get Audio Options

        Retrieves audio options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will return details of the audio options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: :class:`MeetingPreferenceObjectAudio`
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('meetingPreferences/audio')
        data = super().get(url, params=params)
        r = MeetingPreferenceObjectAudio.model_validate(data)
        return r

    def update_audio_options(self, default_audio_type: MeetingPreferenceObjectAudioDefaultAudioType,
                             other_teleconference_description: str, enabled_global_call_in: bool,
                             enabled_toll_free: bool, enabled_auto_connection: bool, audio_pin: str,
                             office_number: MeetingPreferenceObjectAudioOfficeNumber,
                             mobile_number: MeetingPreferenceObjectAudioOfficeNumber, user_email: str = None,
                             site_url: str = None) -> MeetingPreferenceObjectAudio:
        """
        Update Audio Options

        Updates audio options for the authenticated user.

        :param default_audio_type: Default audio type. This attribute can be modified with the with the
            `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type default_audio_type: MeetingPreferenceObjectAudioDefaultAudioType
        :param other_teleconference_description: Phone number and other information for the teleconference provider to
            be used, along with instructions for invitees. This attribute can be modified with the with the
            `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type other_teleconference_description: str
        :param enabled_global_call_in: Flag to enable/disable global call ins. ***Note***: If the site does not support
            global call-ins, you cannot set this option. This attribute can be modified with the with the
            `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type enabled_global_call_in: bool
        :param enabled_toll_free: Flag to enable/disable call-ins from toll-free numbers.  ***Note***: If the site does
            not support calls from toll-free numbers, you cannot set this option. This attribute can be modified with
            the with the `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type enabled_toll_free: bool
        :param enabled_auto_connection: Flag to enable/disable automatically connecting to audio using a computer. The
            meeting host can enable/disable this option. When this option is set to `true`, the user is automatically
            connected to audio via a computer when they start or join a Webex Meetings meeting on a desktop. This
            attribute can be modified with the with the `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type enabled_auto_connection: bool
        :param audio_pin: PIN to provide a secondary level of authentication for calls where the host is using the
            phone and may need to invite additional invitees. It must be exactly 4 digits. It cannot contain
            sequential digits, such as 1234 or 4321, or repeat a digit 4 times, such as 1111. This attribute can be
            modified with the with the `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type audio_pin: str
        :param office_number: Office phone number. We recommend that phone numbers be specified to facilitate
            connecting via audio. This attribute can be modified with the with the `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type office_number: MeetingPreferenceObjectAudioOfficeNumber
        :param mobile_number: Mobile phone number. We recommend that phone numbers be specified to facilitate
            connecting via audio. This attribute can be modified with the with the `Update Audio Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-audio-options>`_ API.
        :type mobile_number: MeetingPreferenceObjectAudioOfficeNumber
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will update audio options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: :class:`MeetingPreferenceObjectAudio`
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = dict()
        body['defaultAudioType'] = enum_str(default_audio_type)
        body['otherTeleconferenceDescription'] = other_teleconference_description
        body['enabledGlobalCallIn'] = enabled_global_call_in
        body['enabledTollFree'] = enabled_toll_free
        body['enabledAutoConnection'] = enabled_auto_connection
        body['audioPin'] = audio_pin
        body['officeNumber'] = loads(office_number.model_dump_json())
        body['mobileNumber'] = loads(mobile_number.model_dump_json())
        url = self.ep('meetingPreferences/audio')
        data = super().put(url, params=params, json=body)
        r = MeetingPreferenceObjectAudio.model_validate(data)
        return r

    def get_video_options(self, user_email: str = None,
                          site_url: str = None) -> list[MeetingPreferenceObjectVideoVideoDevices]:
        """
        Get Video Options

        Retrieves video options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will return details of the video options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved using
            `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: list[MeetingPreferenceObjectVideoVideoDevices]
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('meetingPreferences/video')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MeetingPreferenceObjectVideoVideoDevices]).validate_python(data['videoDevices'])
        return r

    def update_video_options(self, video_devices: list[MeetingPreferenceObjectVideoVideoDevices],
                             user_email: str = None,
                             site_url: str = None) -> list[MeetingPreferenceObjectVideoVideoDevices]:
        """
        Update Video Options

        Updates video options for the authenticated user.

        :param video_devices: Array of video devices. If the array is not empty, one device and no more than one
            devices must be set as default device.
        :type video_devices: list[MeetingPreferenceObjectVideoVideoDevices]
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will update video options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: list[MeetingPreferenceObjectVideoVideoDevices]
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = dict()
        body['videoDevices'] = loads(TypeAdapter(list[MeetingPreferenceObjectVideoVideoDevices]).dump_json(video_devices))
        url = self.ep('meetingPreferences/video')
        data = super().put(url, params=params, json=body)
        r = TypeAdapter(list[MeetingPreferenceObjectVideoVideoDevices]).validate_python(data['videoDevices'])
        return r

    def get_scheduling_options(self, user_email: str = None, site_url: str = None) -> SchedulingOptionsObject:
        """
        Get Scheduling Options

        Retrieves scheduling options for the authenticated user.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will return details of the scheduling options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: :class:`SchedulingOptionsObject`
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('meetingPreferences/schedulingOptions')
        data = super().get(url, params=params)
        r = SchedulingOptionsObject.model_validate(data)
        return r

    def update_scheduling_options(self, enabled_join_before_host: bool, join_before_host_minutes: int,
                                  enabled_auto_share_recording: bool, enabled_webex_assistant_by_default: bool,
                                  user_email: str = None, site_url: str = None) -> SchedulingOptionsObject:
        """
        Update Scheduling Options

        Updates scheduling options for the authenticated user.

        :param enabled_join_before_host: Flag to enable/disable ***Join Before Host***. The period during which
            invitees can join before the start time is defined by `autoLockMinutes`. This attribute can be modified
            with the `Update Scheduling Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API. ***Note***: This feature is only effective if the site supports
            the ***Join Before Host*** feature. This attribute can be modified with the `Update Scheduling Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
        :type enabled_join_before_host: bool
        :param join_before_host_minutes: Number of minutes before the start time that an invitee can join a meeting if
            `enabledJoinBeforeHost` is true. Valid options are 0, 5, 10 and 15. This attribute can be modified with
            the `Update Scheduling Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
        :type join_before_host_minutes: int
        :param enabled_auto_share_recording: Flag to enable/disable the automatic sharing of the meeting recording with
            invitees when it is available. This attribute can be modified with the `Update Scheduling Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
        :type enabled_auto_share_recording: bool
        :param enabled_webex_assistant_by_default: Flag to automatically enable Webex Assistant whenever you start a
            meeting. This attribute can be modified with the `Update Scheduling Options
            <https://developer.webex.com/docs/api/v1/meeting-preferences/update-scheduling-options>`_ API.
        :type enabled_webex_assistant_by_default: bool
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will update scheduling options for that user.
        :type user_email: str
        :param site_url: URL of the Webex site to query. For individual use, if `siteUrl` is not specified, the query
            will use the default site of the user. For admin use, if `siteUrl` is not specified, the query will use
            the default site for the admin's authorization token used to make the call. In the case where the user
            belongs to a site different than the admins default site, the admin can set the site to query using the
            `siteUrl` parameter. All available Webex sites and default site of a user can be retrieved from
            `/meetingPreferences/sites
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_.
        :type site_url: str
        :rtype: :class:`SchedulingOptionsObject`
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        if site_url is not None:
            params['siteUrl'] = site_url
        body = dict()
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['enabledAutoShareRecording'] = enabled_auto_share_recording
        body['enabledWebexAssistantByDefault'] = enabled_webex_assistant_by_default
        url = self.ep('meetingPreferences/schedulingOptions')
        data = super().put(url, params=params, json=body)
        r = SchedulingOptionsObject.model_validate(data)
        return r

    def get_site_list(self, user_email: str = None) -> list[MeetingPreferenceObjectSites]:
        """
        Get Site List

        Retrieves the list of Webex sites that the authenticated user is set up to use.

        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user and the API will
            return the list of Webex sites for that user.
        :type user_email: str
        :rtype: list[MeetingPreferenceObjectSites]
        """
        params = {}
        if user_email is not None:
            params['userEmail'] = user_email
        url = self.ep('meetingPreferences/sites')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MeetingPreferenceObjectSites]).validate_python(data['sites'])
        return r

    def update_default_site(self, default_site: bool, site_url: str,
                            user_email: str = None) -> MeetingPreferenceObjectSites:
        """
        Update Default Site

        Updates the default site for the authenticated user.

        :param default_site: Whether or not to change user's default site. ***Note***: `defaultSite` should be set to
            true for the user's single default site
        :type default_site: bool
        :param site_url: Access URL for the site.
        :type site_url: str
        :param user_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the `admin-level scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will update default site for that user.
        :type user_email: str
        :rtype: :class:`MeetingPreferenceObjectSites`
        """
        params = {}
        params['defaultSite'] = str(default_site).lower()
        if user_email is not None:
            params['userEmail'] = user_email
        body = dict()
        body['siteUrl'] = site_url
        url = self.ep('meetingPreferences/sites')
        data = super().put(url, params=params, json=body)
        r = MeetingPreferenceObjectSites.model_validate(data)
        return r

    def batch_refresh_personal_meeting_room_id(self, site_url: str = None,
                                               personal_meeting_room_ids: list[PMRIDObject] = None) -> BatchRefreshPMRIDResponseObject:
        """
        Batch Refresh Personal Meeting Room ID

        Refreshes personal room IDs automatically according to the current personal room ID rule of the target site or
        by the values specified by the admin user.

        The new personal room IDs are generated by the site's settings automatically if `systemGenerated` is true;
        otherwise, replace the existing personal room IDs with the specified values if `systemGenerated` is false or
        not specified.

        It may take up to 30 minutes to see the updated personal room ID on the Webex meeting page after refreshing the
        personal room ID due to cache.

        Either all items in `personalMeetingRoomIds` have `personalMeetingRoomId`, or they all have `systemGenerated`
        which equals true. `personalMeetingRoomId` and `systemGenerated: true` cannot be specified at the same time.

        The items in `personalMeetingRoomIds` either all have `personId` or all have `email` in a single request.
        Partial `personId` and partial `email` is not allowed in the same request.

        :param site_url: Site URL to refresh the personal room IDs.
        :type site_url: str
        :param personal_meeting_room_ids: Information of whose personal room IDs are to be refreshed and how to
            refresh. The maximum size of `items` is 100.
        :type personal_meeting_room_ids: list[PMRIDObject]
        :rtype: :class:`BatchRefreshPMRIDResponseObject`
        """
        body = dict()
        body['siteUrl'] = site_url
        body['personalMeetingRoomIds'] = loads(TypeAdapter(list[PMRIDObject]).dump_json(personal_meeting_room_ids))
        url = self.ep('admin/meetingPreferences/personalMeetingRoom/refreshId')
        data = super().post(url, json=body)
        r = BatchRefreshPMRIDResponseObject.model_validate(data)
        return r


class MeetingQAndAApi(ApiChild, base='meetings/q_and_a'):
    """
    Meeting Q and A
    
    During a `Question and Answer
    <https://help.webex.com/en-us/article/nakt8px/Question-and-answer-(Q&A>`_-sessions-in-Webex-Meetings-and-Webex-Webinars) (Q&A) session, attendees can pose
    questions to hosts, co-hosts, and presenters, who can answer and moderate those questions. You use the Meeting Q&A
    API to retrieve the questions and the answers in a meeting.
    
    Currently, these APIs are available to users with one of the meeting host,
    admin or `Compliance Officer
    <https://developer.webex.com/docs/compliance#compliance>`_ roles.
    
    
    
    The features and APIs described here are available upon-request and is not
    enabled by default. If would like this feature enabled for your organization
    please contact the Webex Developer Support team at devsupport@webex.com.
    
    """

    def list_meeting_q_and_a(self, meeting_id: str, **params) -> Generator[QAObject, None, None]:
        """
        List Meeting Q and A

        Lists questions and answers from a meeting, when ready.

        Notes:

        * Only `meeting instances
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ in state `ended` or `inProgress` are supported for `meetingId`.

        * Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * This API is paginated by the sum of answers in a meeting, These pagination links are returned in the response
        header.

        :param meeting_id: A unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ which the Q&A belongs to.
        :type meeting_id: str
        :return: Generator yielding :class:`QAObject` instances
        """
        params['meetingId'] = meeting_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=QAObject, item_key='items', params=params)

    def list_answers_of_a_question(self, meeting_id: str, question_id: str,
                                   **params) -> Generator[AnswerObject, None, None]:
        """
        List Answers of a Question

        Lists the answers to a specific question asked in a meeting.

        * Only `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ in state `ended` or `inProgress` are supported for `meetingId`.

        * Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param meeting_id: A unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ which the Q&A belongs to.
        :type meeting_id: str
        :param question_id: The ID of a question.
        :type question_id: str
        :return: Generator yielding :class:`AnswerObject` instances
        """
        params['meetingId'] = meeting_id
        url = self.ep(f'{question_id}/answers')
        return self.session.follow_pagination(url=url, model=AnswerObject, item_key='items', params=params)


class MeetingQualitiesApi(ApiChild, base='meeting/qualities'):
    """
    Meeting Qualities
    
    To retrieve quality information, you must use an administrator token with the `analytics:read_all` `scope
    <https://developer.webex.com/docs/integrations#scopes>`_. The
    authenticated user must be a read-only or full administrator of the organization to which the meeting belongs and
    must not be an external administrator.
    
    To use this endpoint, the org needs to be licensed for the Webex Pro Pack.
    
    For CI-Native site, no additional settings are required.
    
    For CI-linked site, the admin must also be set as the Full/ReadOnly Site Admin of the site.
    
    A minimum Webex and Teams client version is required. For details, see `Troubleshooting Help Doc
    <https://help.webex.com/en-us/ni3wlvw/Advanced-Diagnostics-and-Troubleshooting-in-Control-Hub-xa>`_.
    
    Quality information is available 10 minutes after a meeting has started and may be retrieved for up to 7 days.
    
    A rate limit of 1 API call every 5 minutes for the same meeting instance ID applies.
    """

    def get_meeting_qualities(self, meeting_id: str, **params) -> Generator[MediaSessionQuality1, None, None]:
        """
        Get Meeting Qualities

        Get quality data for a meeting, by `meetingId`. Only organization administrators can retrieve meeting quality
        data.

        :param meeting_id: Unique identifier for the specific meeting instance. **Note:** The `meetingId` can be
            obtained via the Meeting List API when meetingType=meeting. The `id` attribute in the Meeting List
            Response is what is needed, for example, `e5dba9613a9d455aa49f6ffdafb6e7db_I_191395283063545470`.
        :type meeting_id: str
        :return: Generator yielding :class:`MediaSessionQuality1` instances
        """
        params['meetingId'] = meeting_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=MediaSessionQuality1, item_key='items', params=params)


class SessionTypesApi(ApiChild, base='admin/meeting'):
    """
    Session Types
    
    Session types define the features and options that are available to users for scheduled meetings.
    
    The API allows getting site-level session types and modifying user-level session types.
    
    Viewing the list of site session types and user session types requires an administrator auth token with
    `meeting:admin_schedule_read` or `meeting:admin_config_read`. Updating user session types requires an
    administrator auth token with the `meeting:admin_schedule_write` or `meeting:admin_config_write` scope.
    """

    def list_site_session_types(self, site_url: str = None) -> list[SiteSessionType]:
        """
        List Site Session Types

        List session types for a specific site.

        :param site_url: URL of the Webex site to query. If siteUrl is not specified, the query will use the default
            site for the admin's authorization token used to make the call.
        :type site_url: str
        :rtype: list[SiteSessionType]
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('config/sessionTypes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[SiteSessionType]).validate_python(data['items'])
        return r

    def list_user_session_type(self, site_url: str = None, person_id: str = None) -> list[UserSessionTypes]:
        """
        List User Session Type

        List session types for a specific user.

        :param site_url: URL of the Webex site to query.
        :type site_url: str
        :param person_id: A unique identifier for the user.
        :type person_id: str
        :rtype: list[UserSessionTypes]
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        if person_id is not None:
            params['personId'] = person_id
        url = self.ep('userconfig/sessionTypes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[UserSessionTypes]).validate_python(data['items'])
        return r

    def update_user_session_types(self, site_url: str, person_id: str, email: str,
                                  session_type_ids: list[str]) -> UserSessionTypes:
        """
        Update User Session Types

        Assign session types to specific users.

        * At least one of the following body parameters is required to update a specific user session type: `personId`,
        `email`.

        :param site_url: Site URL for the session type.
        :type site_url: str
        :param person_id: A unique identifier for the user.
        :type person_id: str
        :param email: The email of the user.
        :type email: str
        :param session_type_ids: An array of the session type ID.
        :type session_type_ids: list[str]
        :rtype: :class:`UserSessionTypes`
        """
        body = dict()
        body['siteUrl'] = site_url
        body['personId'] = person_id
        body['email'] = email
        body['sessionTypeIds'] = session_type_ids
        url = self.ep('userconfig/sessionTypes')
        data = super().put(url, json=body)
        r = UserSessionTypes.model_validate(data)
        return r


class MeetingTranscriptsApi(ApiChild, base=''):
    """
    Meeting Transcripts
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    A meeting transcript is the automatic transcription of a meeting's recordings by our industry-leading
    speech-to-text engine to capture of what was discussed and decided during the meeting, in text form.
    
    A transcript snippet is a short text snippet from a meeting transcript which was spoken by a particular participant
    in the meeting. A meeting transcript consists of many snippets.
    
    This API manages meeting transcripts and snippets. You can use the Transcript API to list meeting transcripts,
    list, get and update transcript snippets. Transcripts may be retrieved via download link defined by
    `vttDownloadLink` or `txtDownloadlink` in the response body.
    
    Refer to the `Meetings API Scopes` section of `Meetings Overview
    <https://developer.webex.com/docs/meetings>`_ for scopes required for each API.
    
    **NOTE:**
    1. Listing/Getting/Updating meeting transcript snippets function do not support Admin role.
    2. The meeting transcript can not be recorded until you turn on the meeting recording. Since August 1, 2023, you
    also need to turn on the `Webex Assistant
    <https://www.cisco.com/c/en/us/products/collateral/conferencing/webex-meetings/at-a-glance-c45-744053.html>`_ or the `Closed Captions
    """

    def list_meeting_transcripts(self, meeting_id: str = None, host_email: str = None, site_url: str = None,
                                 from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                                 **params) -> Generator[TranscriptObject, None, None]:
        """
        List Meeting Transcripts

        Lists available transcripts of an ended `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_.

        Use this operation to list transcripts of an ended `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ when they are ready. Please note that only
        **meeting instances** in state `ended` are supported for `meetingId`. **Meeting series**, **scheduled
        meetings** and `in-progress` **meeting instances** are not supported.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.

        :param meeting_id: Unique identifier for the `meeting instance
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ to which the transcript belongs. Please note that
            currently the meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API. If
            `meetingId` is not specified, the operation returns an array of transcripts for all meetings of the
            current user.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the `admin-level` scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user. If `meetingId` is
            not specified, it can not support `hostEmail`.
        :type host_email: str
        :param site_url: URL of the Webex site from which the API lists transcripts. If not specified, the API lists
            transcripts from user's preferred site. All available Webex sites and the preferred site of the user can
            be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param from_: Starting date and time (inclusive) for transcripts to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `from` cannot be after `to`.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time (exclusive) for List transcripts to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `to` cannot be before `from`.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`TranscriptObject` instances
        """
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('meetingTranscripts')
        return self.session.follow_pagination(url=url, model=TranscriptObject, item_key='items', params=params)

    def list_meeting_transcripts_for_compliance_officer(self, site_url: str, from_: Union[str, datetime] = None,
                                                        to_: Union[str, datetime] = None,
                                                        **params) -> Generator[TranscriptObject, None, None]:
        """
        List Meeting Transcripts For Compliance Officer

        Lists available or deleted transcripts of an ended `meeting instance
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for a specific site.

        The returned list is sorted in descending order by the date and time that the transcript was created.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.

        :param site_url: URL of the Webex site from which the API lists transcripts.
        :type site_url: str
        :param from_: Starting date and time (inclusive) for transcripts to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `from` cannot be after `to`.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time (exclusive) for List transcripts to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `to` cannot be before `from`.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`TranscriptObject` instances
        """
        params['siteUrl'] = site_url
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('admin/meetingTranscripts')
        return self.session.follow_pagination(url=url, model=TranscriptObject, item_key='items', params=params)

    def download_a_meeting_transcript(self, transcript_id: str,
                                      format: DownloadMeetingClosedCaptionSnippetsFormat = None,
                                      host_email: str = None):
        """
        Download a Meeting Transcript

        Download a meeting transcript from the meeting transcript specified by `transcriptId`.

        :param transcript_id: Unique identifier for the meeting transcript.
        :type transcript_id: str
        :param format: Format for the downloaded meeting transcript.
        :type format: DownloadMeetingClosedCaptionSnippetsFormat
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the `admin-level` scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: None
        """
        params = {}
        if format is not None:
            params['format'] = format
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'meetingTranscripts/{transcript_id}/download')
        super().get(url, params=params)

    def list_snippets_of_a_meeting_transcript(self, transcript_id: str,
                                              **params) -> Generator[SnippetObject1, None, None]:
        """
        List Snippets of a Meeting Transcript

        Lists snippets of a meeting transcript specified by `transcriptId`.

        Use this operation to list snippets of a meeting transcript when they are ready.

        :param transcript_id: Unique identifier for the meeting transcript to which the snippets belong.
        :type transcript_id: str
        :return: Generator yielding :class:`SnippetObject1` instances
        """
        url = self.ep(f'meetingTranscripts/{transcript_id}/snippets')
        return self.session.follow_pagination(url=url, model=SnippetObject1, item_key='items', params=params)

    def get_a_transcript_snippet(self, transcript_id: str, snippet_id: str) -> SnippetObject1:
        """
        Get a Transcript Snippet

        Retrieves details for a transcript snippet specified by `snippetId` from the meeting transcript specified by
        `transcriptId`.

        :param transcript_id: Unique identifier for the meeting transcript to which the requested snippet belongs.
        :type transcript_id: str
        :param snippet_id: Unique identifier for the snippet being requested.
        :type snippet_id: str
        :rtype: :class:`SnippetObject1`
        """
        url = self.ep(f'meetingTranscripts/{transcript_id}/snippets/{snippet_id}')
        data = super().get(url)
        r = SnippetObject1.model_validate(data)
        return r

    def update_a_transcript_snippet(self, transcript_id: str, snippet_id: str, reason: str,
                                    text: str) -> SnippetObject1:
        """
        Update a Transcript Snippet

        Updates details for a transcript snippet specified by `snippetId` from the meeting transcript specified by
        `transcriptId`.

        :param transcript_id: Unique identifier for the meeting transcript to which the snippet to be updated belongs.
        :type transcript_id: str
        :param snippet_id: Unique identifier for the snippet being updated.
        :type snippet_id: str
        :param reason: Reason for snippet update; only required for Compliance Officers.
        :type reason: str
        :param text: Text for the snippet.
        :type text: str
        :rtype: :class:`SnippetObject1`
        """
        body = dict()
        body['reason'] = reason
        body['text'] = text
        url = self.ep(f'meetingTranscripts/{transcript_id}/snippets/{snippet_id}')
        data = super().put(url, json=body)
        r = SnippetObject1.model_validate(data)
        return r

    def delete_a_transcript(self, transcript_id: str, reason: str, comment: str):
        """
        Delete a Transcript

        Removes a transcript with a specified transcript ID. The deleted transcript cannot be recovered. If a
        Compliance Officer deletes another user's transcript, the transcript will be inaccessible to regular users
        (host, attendees), but will be still available to the Compliance Officer.

        :param transcript_id: Unique identifier for the meeting transcript.
        :type transcript_id: str
        :param reason: Reason for deleting a transcript. Only required when a Compliance Officer is operating on
            another user's transcript.
        :type reason: str
        :param comment: Explanation for deleting a transcript. The comment can be a maximum of 255 characters long.
        :type comment: str
        :rtype: None
        """
        body = dict()
        body['reason'] = reason
        body['comment'] = comment
        url = self.ep(f'meetingTranscripts/{transcript_id}')
        super().delete(url, json=body)


class MeetingsSummaryReportApi(ApiChild, base='meetingReports'):
    """
    Meetings Summary Report
    
    The meeting usage report API is used to retrieve aggregated meeting usage information, like `totalCallInMinutes`,
    `totalParticipants`, etc. It also includes the meeting `trackingCodes`.
    
    The meeting attendee report API is used to retrieve aggregated meeting attendee information, like `joinedTime`,
    `leftTime`, `duration`, etc.
    
    The report data for a meeting should be available within 24 hours after the meeting ended.
    
    Refer to the `Meetings API Scopes` section of `Meetings Overview
    <https://developer.webex.com/docs/meetings>`_ for scopes required for each API.
    """

    def list_meeting_usage_reports(self, site_url: str, service_type: str = None, from_: Union[str, datetime] = None,
                                   to_: Union[str, datetime] = None,
                                   **params) -> Generator[MeetingUsageReportObject, None, None]:
        """
        List Meeting Usage Reports

        List meeting usage reports of all the users on the specified site by an admin. You can specify a date range and
        the maximum number of meeting usage reports to return.

        The list returned is sorted in descending order by the date and time the meetings were started.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * `siteUrl` is required, and the meeting usage reports of the specified site are listed. All available Webex
        sites can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        defined.

        :param site_url: URL of the Webex site which the API lists meeting usage reports from. All available Webex
            sites can be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param service_type: Meeting usage report's service-type. If `serviceType` is specified, the API filters
            meeting usage reports by service-type. If `serviceType` is not specified, the API returns meeting usage
            reports by `MeetingCenter` by default. Valid values:

        + `MeetingCenter`

        + `EventCenter`

        + `SupportCenter`

        + `TrainingCenter`
        :type service_type: str
        :param from_: Starting date and time for meeting usage reports to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `from` cannot be after `to`. The interval between `to` and `from` cannot exceed 30 days and `from` cannot
            be earlier than 90 days ago.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time for meeting usage reports to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `to`
            cannot be before `from`. The interval between `to` and `from` cannot exceed 30 days.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`MeetingUsageReportObject` instances
        """
        params['siteUrl'] = site_url
        if service_type is not None:
            params['serviceType'] = service_type
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('usage')
        return self.session.follow_pagination(url=url, model=MeetingUsageReportObject, item_key='items', params=params)

    def list_meeting_attendee_reports(self, site_url: str, meeting_id: str = None, meeting_number: str = None,
                                      meeting_title: str = None, from_: Union[str, datetime] = None, to_: Union[str,
                                      datetime] = None,
                                      **params) -> Generator[MeetingAttendeeReportObject, None, None]:
        """
        List Meeting Attendee Reports

        Lists of meeting attendee reports by a date range, the maximum number of meeting attendee reports, a meeting
        ID, a meeting number or a meeting title.

        If the requesting user is an admin, the API returns meeting attendee reports of the meetings hosted by all the
        users on the specified site filtered by meeting ID, meeting number or meeting title.

        If it's a normal meeting host, the API returns meeting attendee reports of the meetings hosted by the user
        himself on the specified site filtered by meeting ID, meeting number or meeting title.

        The list returned is grouped by meeting instances. Both the groups and items of each group are sorted in
        descending order of `joinedTime`. For example, if `meetingId` is specified and it's a meeting series ID, the
        returned list is grouped by meeting instances of that series. The groups are sorted in descending order of
        `joinedTime`, and within each group the items are also sorted in descending order of `joinedTime`. Please
        refer to `Meetings Overview
        <https://developer.webex.com/docs/meetings>`_ for details of meeting series, scheduled meeting and meeting instance.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * `siteUrl` is required, and the meeting attendee reports of the specified site are listed. All available Webex
        sites can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        * `meetingId`, `meetingNumber` and `meetingTitle` are optional parameters to query the meeting attendee
        reports, but at least one of them should be specified. If more than one parameter in the sequence of
        `meetingId`, `meetingNumber`, and `meetingTitle` are specified, the first one in the sequence is used.
        Currently, only ended meeting instance IDs and meeting series IDs are supported for `meetingId`. IDs of
        scheduled meetings or personal room meetings are not supported.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        defined.

        :param site_url: URL of the Webex site which the API lists meeting attendee reports from. All available Webex
            sites can be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param meeting_id: Meeting ID for the meeting attendee reports to return. If specified, return meeting attendee
            reports of the specified meeting; otherwise, return meeting attendee reports of all meetings. Currently,
            only ended meeting instance IDs are supported. IDs of meeting series, scheduled meetings or personal room
            meetings are not supported.
        :type meeting_id: str
        :param meeting_number: Meeting number for the meeting attendee reports to return. If specified, return meeting
            attendee reports of the specified meeting; otherwise, return meeting attendee reports of all meetings.
        :type meeting_number: str
        :param meeting_title: Meeting title for the meeting attendee reports to return. If specified, return meeting
            attendee reports of the specified meeting; otherwise, return meeting attendee reports of all meetings.
        :type meeting_title: str
        :param from_: Starting date and time for the meeting attendee reports to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant
            format. `from` cannot be after `to`. The interval between `to` and `from` cannot exceed 30 days and `from`
            cannot be earlier than 90 days ago.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time for the meeting attendee reports to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `to` cannot be before `from`. The interval between `to` and `from` cannot exceed 30 days.
        :type to_: Union[str, datetime]
        :return: Generator yielding :class:`MeetingAttendeeReportObject` instances
        """
        params['siteUrl'] = site_url
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if meeting_number is not None:
            params['meetingNumber'] = meeting_number
        if meeting_title is not None:
            params['meetingTitle'] = meeting_title
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('attendees')
        return self.session.follow_pagination(url=url, model=MeetingAttendeeReportObject, item_key='items', params=params)


class TrackingCodesApi(ApiChild, base='admin/meeting'):
    """
    Tracking Codes
    
    Tracking codes are alphanumeric codes that identify categories of users on a Webex site. With tracking codes, you
    can analyze usage by various groups within an organization.
    
    The authenticated user calling this API must have an Administrator role with the `meeting:admin_schedule_write` and
    `meeting:admin_schedule_read` scopes.
    """

    def list_tracking_codes(self, site_url: str = None) -> list[GetTrackingCodeObject]:
        """
        List Tracking Codes

        Lists tracking codes on a site by an admin user.

        * If `siteUrl` is specified, tracking codes of the specified site will be listed; otherwise, tracking codes of
        the user's preferred site will be listed. All available Webex sites and the preferred sites of a user can be
        retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        * Admins can switch any Control Hub managed site from using classic tracking codes to mapped tracking codes in
        Control Hub. This is a one-time irreversible operation. Once the tracking codes are mapped to custom or user
        profile attributes, the response returns the mapped tracking codes.

        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :rtype: list[GetTrackingCodeObject]
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('config/trackingCodes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[GetTrackingCodeObject]).validate_python(data['items'])
        return r

    def get_a_tracking_code(self, tracking_code_id: Union[str, datetime],
                            site_url: str = None) -> GetTrackingCodeObject:
        """
        Get a Tracking Code

        Retrieves details for a tracking code by an admin user.

        * If `siteUrl` is specified, the tracking code is retrieved from the specified site; otherwise, the tracking
        code is retrieved from the user's preferred site. All available Webex sites and the preferred sites of a user
        can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        * Admins can switch any Control Hub managed site from using classic tracking codes to mapped tracking codes in
        Control Hub, this is a one-time irreversible operation. Once the tracking codes are mapped to custom or user
        profile attributes, the response returns details for a mapped tracking code.

        :param tracking_code_id: Unique identifier for the tracking code whose details are being requested.
        :type tracking_code_id: Union[str, datetime]
        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and the
            preferred sites of a user can be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :rtype: :class:`GetTrackingCodeObject`
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep(f'config/trackingCodes/{tracking_code_id}')
        data = super().get(url, params=params)
        r = GetTrackingCodeObject.model_validate(data)
        return r

    def create_a_tracking_code(self, name: str, site_url: str, options: list[OptionsForTrackingCodeObject],
                               input_mode: GetTrackingCodeObjectInputMode,
                               host_profile_code: GetTrackingCodeObjectHostProfileCode,
                               schedule_start_codes: list[ScheduleStartCodeObject]) -> GetTrackingCodeObject:
        """
        Create a Tracking Code

        Create a new tracking code by an admin user.

        * The `siteUrl` is required. The operation creates a tracking code for the specified site. All or a user's
        available Webex sites can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        * The `inputMode` of `hostProfileSelect` is only available for a host profile and sign-up pages and does not
        apply to the meeting scheduler page or the meeting start page. The value for `scheduleStartCodes` must be
        `null` or the value for all services must be `notUsed` when the `inputMode` is `hostProfileSelect`.

        * The `hostProfileCode` of `required` is only allowed for a Site Admin managed site, and not for a Control Hub
        managed site.

        * When the `hostProfileCode` is `adminSet`, only `adminSet`, `notUsed`, and `notApplicable` are available for
        the types of `scheduleStartCodes`. When the `hostProfileCode` is not `adminSet`, only `optional`, `required`,
        `notUsed`, and `notApplicable` are available for `scheduleStartCodes`.

        * If the type of the `All` service has a value other than `notApplicable`, and another service, e.g.
        `EventCenter`, is missing from the `scheduleStartCodes`, then the type of this missing `EventCenter` service
        shares the same type as the `All` service. If the type of `All` service has a value other than
        `notApplicable`, and another service, e.g. `EventCenter`, has a type, then the type specified should be the
        same as the `All` service.

        * If the `All` service is missing from the `scheduleStartCodes`, any of the other four services, e.g.
        `EventCenter`, have a default type of `notUsed` if it is also missing from the `scheduleStartCodes`.

        * Admins can switch any Control Hub managed site from using classic tracking codes to mapped tracking codes in
        Control Hub, this is a one-time irreversible operation. Once the tracking codes are mapped to custom or user
        profile attributes, they cannot create tracking codes when the mapping process is in progress or the mapping
        process is completed.

        :param name: Name for tracking code. The name cannot be empty and the maximum size is 120 characters.
        :type name: str
        :param site_url: Site URL for the tracking code.
        :type site_url: str
        :param options: Tracking code option list. The maximum size of `options` is 500.
        :type options: list[OptionsForTrackingCodeObject]
        :param input_mode: Select an option for how users can provide a code value. Please note that if users set
            `inputMode` as `hostProfileSelect`, `scheduleStartCode` should be `null`, which means `hostProfileSelect`
            only applies to "Host Profile".
        :type input_mode: GetTrackingCodeObjectInputMode
        :param host_profile_code: Type for the host profile.
        :type host_profile_code: GetTrackingCodeObjectHostProfileCode
        :param schedule_start_codes: Specify how tracking codes are used for each service on the meeting scheduler or
            meeting start pages. The maximum size of `scheduleStartCodes` is 5.
        :type schedule_start_codes: list[ScheduleStartCodeObject]
        :rtype: :class:`GetTrackingCodeObject`
        """
        body = dict()
        body['name'] = name
        body['siteUrl'] = site_url
        body['options'] = loads(TypeAdapter(list[OptionsForTrackingCodeObject]).dump_json(options))
        body['inputMode'] = enum_str(input_mode)
        body['hostProfileCode'] = enum_str(host_profile_code)
        body['scheduleStartCodes'] = loads(TypeAdapter(list[ScheduleStartCodeObject]).dump_json(schedule_start_codes))
        url = self.ep('config/trackingCodes')
        data = super().post(url, json=body)
        r = GetTrackingCodeObject.model_validate(data)
        return r

    def update_a_tracking_code(self, name: str, site_url: str, options: list[OptionsForTrackingCodeObject],
                               input_mode: GetTrackingCodeObjectInputMode,
                               host_profile_code: GetTrackingCodeObjectHostProfileCode,
                               schedule_start_codes: list[ScheduleStartCodeObject]) -> GetTrackingCodeObject:
        """
        Update a Tracking Code

        Updates details for a tracking code by an admin user.

        * The `siteUrl` is required. The operation updates a tracking code for the specified site. All of a user's
        available Webex sites can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        * The `inputMode` of `hostProfileSelect` is only available for the host profile and sign-up pages and it
        doesn't apply to the meeting scheduler page or meeting start page. Therefore, `scheduleStartCodes` must be
        `null` or type of all services must be `notUsed` when the `inputMode` is `hostProfileSelect`.

        * Currently, the `hostProfileCode` of `required` is only allowed for a Site Admin managed site, and not allowed
        for a Control Hub managed site.

        * When the `hostProfileCode` is `adminSet`, only `adminSet`, `notUsed` and `notApplicable` are available for
        the types of `scheduleStartCodes`. When the `hostProfileCode` is not `adminSet`, only `optional`, `required`,
        `notUsed` and `notApplicable` are available for types of `scheduleStartCodes`.

        * If the type of the `All` service has a value other than `notApplicable`, and another service, e.g.
        `EventCenter`, is missing from the `scheduleStartCodes`, then the type of this missing `EventCenter` service
        shares the same type as the `All` service silently. If the type of `All` service has a value other than
        `notApplicable`, and another service, e.g. `EventCenter`, has a type, then the type specified should be the
        same as the `All` service.

        * If the `All` service is missing from the `scheduleStartCodes`, any of the other four services, e.g.
        `EventCenter`, has a default type of `notUsed` if that service is also missing from the `scheduleStartCodes`.

        * Admins can switch any Control Hub managed site from using classic tracking codes to mapped tracking codes in
        Control Hub, this is a one-time irreversible operation. Once the tracking codes are mapped to custom or user
        profile attributes, they cannot update tracking codes when the mapping process is in progress or the mapping
        process is completed.

        :param name: Name for tracking code. The name cannot be empty and the maximum size is 120 characters.
        :type name: str
        :param site_url: Site URL for the tracking code.
        :type site_url: str
        :param options: Tracking code option list. The maximum size of `options` is 500.
        :type options: list[OptionsForTrackingCodeObject]
        :param input_mode: Select an option for how users can provide a code value. Please note that if users set
            `inputMode` as `hostProfileSelect`, `scheduleStartCode` should be `null`, which means `hostProfileSelect`
            only applies to "Host Profile".
        :type input_mode: GetTrackingCodeObjectInputMode
        :param host_profile_code: Type for the host profile.
        :type host_profile_code: GetTrackingCodeObjectHostProfileCode
        :param schedule_start_codes: Specify how tracking codes are used for each service on the meeting scheduler or
            meeting start pages. The maximum size of `scheduleStartCodes` is 5.
        :type schedule_start_codes: list[ScheduleStartCodeObject]
        :rtype: :class:`GetTrackingCodeObject`
        """
        body = dict()
        body['name'] = name
        body['siteUrl'] = site_url
        body['options'] = loads(TypeAdapter(list[OptionsForTrackingCodeObject]).dump_json(options))
        body['inputMode'] = enum_str(input_mode)
        body['hostProfileCode'] = enum_str(host_profile_code)
        body['scheduleStartCodes'] = loads(TypeAdapter(list[ScheduleStartCodeObject]).dump_json(schedule_start_codes))
        url = self.ep('config/trackingCodes/{trackingCodeId}')
        data = super().put(url, json=body)
        r = GetTrackingCodeObject.model_validate(data)
        return r

    def delete_a_tracking_code(self, tracking_code_id: Union[str, datetime], site_url: str):
        """
        Delete a Tracking Code

        Deletes a tracking code by an admin user.

        * The `siteUrl` is required. The operation deletes a tracking code for the specified site. All of a user's
        available Webex sites can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        * Admins can switch any Control Hub managed site from using classic tracking codes to mapped tracking codes in
        Control Hub, this is a one-time irreversible operation. Once the tracking codes are mapped to custom or user
        profile attributes, they cannot delete tracking codes when the mapping process is in progress or the mapping
        process is completed.

        :param tracking_code_id: Unique identifier for the tracking code to be deleted.
        :type tracking_code_id: Union[str, datetime]
        :param site_url: URL of the Webex site from which the API deletes the tracking code. All available Webex sites
            and preferred sites of a user can be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :rtype: None
        """
        params = {}
        params['siteUrl'] = site_url
        url = self.ep(f'config/trackingCodes/{tracking_code_id}')
        super().delete(url, params=params)

    def get_user_tracking_codes(self, site_url: str = None, person_id: str = None) -> GetTrackingCodeForUserObject:
        """
        Get User Tracking Codes

        Lists user's tracking codes by an admin user.

        * At least one parameter, either `personId`, or `email` is required. `personId` must come before `email` if
        both are specified. Please note that `email` is specified in the request header.

        * If `siteUrl` is specified, the tracking codes of the specified site will be listed; otherwise, the tracking
        codes of a user's preferred site are listed. All available Webex sites and preferred sites of a user can be
        retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API. Please note that the user here is the admin user who invokes the API, not
        the user specified by `personId` or email.

        * Admins can switch any Control Hub managed site from using classic tracking codes to mapped tracking codes in
        Control Hub, this is a one-time irreversible operation. Once the tracking codes are mapped to custom or user
        profile attributes, the response returns the user's mapped tracking codes.

        #### Request Header

        * `email`: Email address for the user whose tracking codes are being retrieved. The admin users can specify the
        email of a user on a site they manage and the API returns details for the user's tracking codes. At least one
        parameter of `personId` or `email` is required.

        :param site_url: URL of the Webex site from which the API retrieves the tracking code. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param person_id: Unique identifier for the user whose tracking codes are being retrieved. The admin user can
            specify the `personId` of a user on a site they manage and the API returns details for the user's tracking
            codes. At least one parameter of `personId` or `email` is required.
        :type person_id: str
        :rtype: :class:`GetTrackingCodeForUserObject`
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        if person_id is not None:
            params['personId'] = person_id
        url = self.ep('userconfig/trackingCodes')
        data = super().get(url, params=params)
        r = GetTrackingCodeForUserObject.model_validate(data)
        return r

    def update_user_tracking_codes(self, site_url: str, person_id: str, email: str,
                                   tracking_codes: list[MeetingUsageReportTrackingCodeObject]) -> GetTrackingCodeForUserObject:
        """
        Update User Tracking Codes

        Updates tracking codes for a specified user by an admin user.

        * The `siteUrl` is required. The operation updates a user's tracking code on the specified site. All a user's
        available Webex sites can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API. Please note that the user here is the admin
        user who invokes the API, not the user specified by `personId` or `email`.

        * A name that is not found in the site-level tracking codes cannot be set for a user's tracking codes. All
        available site-level tracking codes for a site can be retrieved by the `List Tracking Codes
        <https://developer.webex.com/docs/api/v1/tracking-codes/list-tracking-codes>`_ API.

        * If the `inputMode` of a user's tracking code is `select` or `hostProfileSelect`, its value must be one of the
        site-level options of that tracking code. All available site-level tracking codes for a site can be retrieved
        by the `List Tracking Codes
        <https://developer.webex.com/docs/api/v1/tracking-codes/list-tracking-codes>`_ API.

        * Admins can switch any Control Hub managed site from using classic tracking codes to mapped tracking codes in
        Control Hub, this is a one-time irreversible operation. Once the tracking codes are mapped to custom or user
        profile attributes, they cannot update user's tracking codes when the mapping process is in progress or the
        mapping process is completed.

        :param site_url: Site URL for the tracking code.
        :type site_url: str
        :param person_id: Unique identifier for the user. At least one parameter of `personId` or `email` is required.
            `personId` must precede `email` if both are specified.
        :type person_id: str
        :param email: Email address for the user. At least one parameter of `personId` or `email` is required.
            `personId` must precede `email` if both are specified.
        :type email: str
        :param tracking_codes: Tracking code information for updates.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :rtype: :class:`GetTrackingCodeForUserObject`
        """
        body = dict()
        body['siteUrl'] = site_url
        body['personId'] = person_id
        body['email'] = email
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        url = self.ep('userconfig/trackingCodes')
        data = super().put(url, json=body)
        r = GetTrackingCodeForUserObject.model_validate(data)
        return r


class MeetingsWithAdmissionFromLobbyToBreakoutSessionApi(ApiChild, base='meetings'):
    """
    Meetings with Admission from Lobby to Breakout Session
    
    Meetings are virtual conferences where users can collaborate in real time using audio, video, content sharing,
    chat, online whiteboards, and to collaborate.
    
    This API focuses primarily on the scheduling and management of meetings. You can use the Meetings API to list,
    create, get, update, and delete meetings.
    
    Several types of meeting objects are supported by this API, such as meeting series, scheduled meeting, and ended or
    in-progress meeting instances. See the `Meetings Overview
    <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about the types of meetings.
    
    Refer to the `Meetings API Scopes` section of `Meetings Overview
    <https://developer.webex.com/docs/meetings>`_ for scopes required for each API.
    """

    def create_a_meeting(self, adhoc: bool, room_id: str, template_id: str, title: str, agenda: str, password: str,
                         start: Union[str, datetime], end: Union[str, datetime], timezone: str, recurrence: str,
                         enabled_auto_record_meeting: bool, allow_any_user_to_be_co_host: bool,
                         enabled_join_before_host: bool, enable_connect_audio_before_host: bool,
                         join_before_host_minutes: int, exclude_password: bool, public_meeting: bool,
                         reminder_time: int,
                         unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                         session_type_id: int, scheduled_type: MeetingSeriesObjectScheduledType,
                         enabled_webcast_view: bool, panelist_password: str, enable_automatic_lock: bool,
                         automatic_lock_minutes: int, allow_first_user_to_be_co_host: bool,
                         allow_authenticated_devices: bool, invitees: list[InviteeObjectForCreateMeeting],
                         send_email: bool, host_email: str, site_url: str,
                         meeting_options: MeetingSeriesObjectMeetingOptions,
                         attendee_privileges: MeetingSeriesObjectAttendeePrivileges,
                         registration: CreateMeetingObjectRegistration, integration_tags: list[str],
                         simultaneous_interpretation: CreateMeetingObjectSimultaneousInterpretation,
                         enabled_breakout_sessions: bool, breakout_sessions: list[BreakoutSessionObject],
                         tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                         audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                         require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObjectWithAdhoc:
        """
        Create a Meeting

        Creates a new meeting. Regular users can schedule up to 100 meetings in 24 hours and admin users up to 3000.
        Please note that the failed requests are also counted toward the limits.

        * If the parameter `adhoc` is `true` and `roomId` is specified, an ad-hoc meeting is created for the target
        room. An ad-hoc meeting is a non-recurring instant meeting for the target room which is supposed to be started
        immediately after being created for a quick collaboration. There's only one ad-hoc meeting for a room at the
        same time. So, if there's already an ongoing ad-hoc meeting for the room, the API returns this ongoing meeting
        instead of creating a new one. If it's a `direct
        <https://developer.webex.com/docs/api/v1/rooms/get-room-details>`_ room, both members of the room can create an ad-hoc meeting
        for the room. If it's a `group
        <https://developer.webex.com/docs/api/v1/rooms/get-room-details>`_ room, only room members that are in the same `organization
        an ad-hoc meeting for the room. Please note that an ad-hoc meeting is for the purpose of an instant
        collaboration with people in a room, user should not persist the `id` and `meetingNumber` of the ad-hoc
        meeting when it's been created since this meeting may become an inactive ad-hoc meeting for the room if it's
        not been started after being created for a while or it has been started and ended. Each time a user needs an
        ad-hoc meeting for a room, they should create one instead of reusing the previous persisted one. Moreover, for
        the same reason, no email will be sent when an ad-hoc meeting is created. Ad-hoc meetings cannot be updated by
        `Update a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ or deleted by `Delete a Meeting
        scheduled meetings of an ad-hoc meeting cannot be listed by `List Meetings of a Meeting Series
        <https://developer.webex.com/docs/api/v1/meetings/list-meetings-of-a-meeting-series>`_, but the ended
        and ongoing instances of ad-hoc meetings can be listed by `List Meetings
        <https://developer.webex.com/docs/api/v1/meetings/list-meetings>`_ and `List Meetings of a Meeting Series

        * If the parameter `adhoc` is `true`, `roomId` is required and the others are optional or ignored.

        * The default value of `title` for an ad-hoc meeting is the user's name if not specified. The following
        parameters for an ad-hoc meeting have default values and the user's input values will be ignored:
        `scheduledType` is always `meeting`; `start` and `end` are 5 minutes after the current time and 20 minutes
        after the current time respectively; `timezone` is `UTC`; `allowAnyUserToBeCoHost`,
        `allowAuthenticatedDevices`, `enabledJoinBeforeHost`, `enableConnectAudioBeforeHost` are always `true`;
        `allowFirstUserToBeCoHost`, `enableAutomaticLock`, `publicMeeting`, `sendEmail` are always `false`; `invitees`
        is the room members except "me"; `joinBeforeHostMinutes` is 5; `automaticLockMinutes` is null;
        `unlockedMeetingJoinSecurity` is `allowJoinWithLobby`. An ad-hoc meeting can be started immediately even if
        the `start` is 5 minutes after the current time.

        * The following parameters are not supported and will be ignored for an ad-hoc meeting: `templateId`,
        `recurrence`, `excludePassword`, `reminderTime`, `registration`, `integrationTags`, `enabledWebcastView`, and
        `panelistPassword`.

        * If the value of the parameter `recurrence` is null, a non-recurring meeting is created.

        * If the parameter `recurrence` has a value, a recurring meeting is created based on the rule defined by the
        value of `recurrence`. For a non-recurring meeting which has no `recurrence` value set, its `meetingType` is
        also `meetingSeries` which is a meeting series with only one occurrence in Webex meeting modeling.

        * If the parameter `templateId` has a value, the meeting is created based on the meeting template specified by
        `templateId`. The list of meeting templates that is available for the authenticated user can be retrieved from
        `List Meeting Templates
        <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_.

        * If the parameter `siteUrl` has a value, the meeting is created on the specified site. Otherwise, the meeting
        is created on the user's preferred site. All available Webex sites and preferred site of the user can be
        retrieved by `Get Site List` API.

        * If the parameter `scheduledType` equals "personalRoomMeeting", the meeting is created in the user's
        `personal room
        <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.

        * If the parameter `roomId` has a value, the meeting is created for the Webex space specified by `roomId`. If
        `roomId` is specified but the user calling the API is not a member of the Webex space specified by `roomId`,
        the API will fail even if the user has the admin-level scopes or he is calling the API on behalf of another
        user which is specified by `hostEmail` and is a member of the Webex space.

        :param adhoc: Whether or not to create an ad-hoc meeting for the room specified by `roomId`. When `true`,
            `roomId` is required.
        :type adhoc: bool
        :param room_id: Unique identifier for the Webex space which the meeting is to be associated with. It can be
            retrieved by `List Rooms
            <https://developer.webex.com/docs/api/v1/rooms/list-rooms>`_. `roomId` is required when `adhoc` is `true`. When `roomId` is specified, the
            parameter `hostEmail` will be ignored.
        :type room_id: str
        :param template_id: Unique identifier for meeting template. Please note that `start` and `end` are optional
            when `templateId` is specified. The list of meeting templates that is available for the authenticated user
            can be retrieved from `List Meeting Templates
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_. This parameter is ignored for an ad-hoc meeting.
        :type template_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long. The default value for an ad-hoc
            meeting is the user's name if not specified.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password
            rules will be generated automatically.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 24 hours. Please note that when a meeting is being scheduled, `start` of the meeting will
            be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is within the same minute as
            the current time, `start` will be adjusted to the upcoming minute; otherwise, `start` will be adjusted
            with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`. The default value for an
            ad-hoc meeting is 5 minutes after the current time and the user's input value will be ignored. An ad-hoc
            meeting can be started immediately even if the `start` is 5 minutes after the current time.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 24 hours. Please note that when a meeting is being scheduled, `end` of the meeting
            will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be adjusted with seconds
            and milliseconds stripped off. For instance, `end` of `2022-03-01T11:52:28.076+08:00` or
            `2022-03-01T11:52:41+08:00` will be adjusted to `2022-03-01T11:52:00+08:00`. The default value for an
            ad-hoc meeting is 20 minutes after the current time and the user's input value will be ignored.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_). The default value for an ad-hoc meeting is `UTC` and the user's input value will
            be ignored.
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_), applying only to meeting series.
            It doesn't apply to a scheduled meeting or an ended or ongoing meeting instance. This parameter is ignored
            for an ad-hoc meeting. Multiple days or dates for monthly or yearly `recurrence` rule are not supported,
            only the first day or date specified is taken. For example,
            "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported
            as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's the user's preferred site. The default value for an ad-hoc
            meeting is `true` and the user's input value will be ignored.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting. The default value for an ad-hoc meeting is `true` and the user's input value will be ignored.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true. The default value for an ad-hoc meeting is `true` and the user's input value
            will be ignored.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. This attribute is only applicable if the `enabledJoinBeforeHost` attribute is set
            to true. Valid options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are
            `0`, `15`, `30`, `45`, and `60`. The default value for an ad-hoc meeting is 0 and the user's input value
            will be ignored.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation. This
            parameter is ignored for an ad-hoc meeting.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar. The default
            value for an ad-hoc meeting is `false` and the user's input value will be ignored.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host. This parameter is ignored for an ad-hoc meeting.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting. The default value for an ad-hoc meeting is `allowJoinWithLobby` and the user's input value will
            be ignored.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            when scheduling a webinar meeting. All available meeting session types enabled for the user can be
            retrieved using the `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param scheduled_type: When set as an attribute in a POST request body, specifies whether it's a regular
            meeting, a webinar, or a meeting scheduled in the user's `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_. If not specified, it's a regular
            meeting by default. The default value for an ad-hoc meeting is `meeting` and the user's input value will
            be ignored.
        :type scheduled_type: MeetingSeriesObjectScheduledType
        :param enabled_webcast_view: Whether or not webcast view is enabled. This parameter is ignored for an ad-hoc
            meeting.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically. This parameter is ignored for an ad-hoc
            meeting.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts. The default
            value for an ad-hoc meeting is `false` and the user's input value will be ignored.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
            The default value for an ad-hoc meeting is null and the user's input value will be ignored.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site. The default value for an ad-hoc
            meeting is `false` and the user's input value will be ignored.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt. The default value for an ad-hoc meeting is
            `true` and the user's input value will be ignored.
        :type allow_authenticated_devices: bool
        :param invitees: Invitees for meeting. The maximum size of invitees is 1000. If `roomId` is specified and
            `invitees` is missing, all the members in the space are invited implicitly. If both `roomId` and
            `invitees` are specified, only those in the `invitees` list are invited. `coHost` for each invitee is
            `true` by default if `roomId` is specified when creating a meeting, and anyone in the invitee list that is
            not qualified to be a cohost will be invited as a non-cohost invitee. The user's input value will be
            ignored for an ad-hoc meeting and the the members of the room specified by `roomId` except "me" will be
            used by default.
        :type invitees: list[InviteeObjectForCreateMeeting]
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true. The default value for an ad-hoc meeting is `false` and the user's input value will be
            ignored.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is created on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param registration: Meeting registration. When this option is enabled, meeting invitees must register personal
            information to join the meeting. Meeting invitees will receive an email with a registration link for the
            registration. When the registration form has been submitted and approved, an email with a real meeting
            link will be received. By clicking that link the meeting invitee can join the meeting. Please note that
            meeting registration does not apply to a meeting when it's a recurring meeting with a recurrence field or
            no password, or the Join Before Host option is enabled for the meeting. See
            `Register for a Meeting in Cisco Webex Meetings
            <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details. This parameter is ignored for an ad-hoc
            meeting.
        :type registration: CreateMeetingObjectRegistration
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. This parameter is ignored for an ad-hoc meeting.
        :type integration_tags: list[str]
        :param simultaneous_interpretation: Simultaneous interpretation information for a meeting.
        :type simultaneous_interpretation: CreateMeetingObjectSimultaneousInterpretation
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled.
        :type enabled_breakout_sessions: bool
        :param breakout_sessions: Breakout sessions are smaller groups that are split off from the main meeting or
            webinar. They allow a subset of participants to collaborate and share ideas over audio and video. Use
            breakout sessions for workshops, classrooms, or for when you need a moment to talk privately with a few
            participants outside of the main session. Please note that maximum number of breakout sessions in a
            meeting or webinar is 100. In webinars, if hosts preassign attendees to breakout sessions, the role of
            `attendee` will be changed to `panelist`. Breakout session is not supported for a meeting with
            simultaneous interpretation.
        :type breakout_sessions: list[BreakoutSessionObject]
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObjectWithAdhoc`
        """
        body = dict()
        body['adhoc'] = adhoc
        body['roomId'] = room_id
        body['templateId'] = template_id
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['scheduledType'] = enum_str(scheduled_type)
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['invitees'] = loads(TypeAdapter(list[InviteeObjectForCreateMeeting]).dump_json(invitees))
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['registration'] = loads(registration.model_dump_json())
        body['integrationTags'] = integration_tags
        body['simultaneousInterpretation'] = loads(simultaneous_interpretation.model_dump_json())
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['breakoutSessions'] = loads(TypeAdapter(list[BreakoutSessionObject]).dump_json(breakout_sessions))
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep()
        data = super().post(url, json=body)
        r = MeetingSeriesObjectWithAdhoc.model_validate(data)
        return r

    def get_a_meeting(self, meeting_id: str, current: bool = None,
                      host_email: str = None) -> MeetingSeriesObjectWithAdhoc:
        """
        Get a Meeting

        Retrieves details for a meeting with a specified meeting ID.

        * If the `meetingId` value specified is for a meeting series and `current` is `true`, the operation returns
        details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or
        the upcoming scheduled meeting of the meeting series.

        * If the `meetingId` value specified is for a meeting series and `current` is `false` or `current` is not
        specified, the operation returns details for the entire meeting series.

        * If the `meetingId` value specified is for a scheduled meeting from a meeting series, the operation returns
        details for that scheduled meeting.

        * If the `meetingId` value specified is for a meeting instance which is happening or has happened, the
        operation returns details for that meeting instance.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_id: Unique identifier for the meeting being requested.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`MeetingSeriesObjectWithAdhoc`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}')
        data = super().get(url, params=params)
        r = MeetingSeriesObjectWithAdhoc.model_validate(data)
        return r

    def list_meetings(self, meeting_number: str = None, web_link: str = None, room_id: str = None,
                      meeting_type: MeetingSeriesObjectMeetingType = None, state: MeetingSeriesObjectState = None,
                      scheduled_type: MeetingSeriesObjectScheduledType = None, is_modified: bool = None,
                      has_chat: bool = None, has_recording: bool = None, has_transcription: bool = None,
                      has_closed_caption: bool = None, has_polls: bool = None, has_qa: bool = None,
                      current: bool = None, from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                      host_email: str = None, site_url: str = None, integration_tag: str = None,
                      **params) -> Generator[MeetingSeriesObjectForListMeeting, None, None]:
        """
        List Meetings

        Retrieves details for meetings with a specified meeting number, web link, meeting type, etc. Please note that
        there are various products in the `Webex Suite
        <https://www.webex.com/collaboration-suite.html>`_ such as `Meetings` and `Events`. Currently, only meetings of the
        `Meetings` product are supported by this API, meetings of others in the suite are not supported. Ad-hoc
        meetings created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` will not be listed, but the ended
        and ongoing ad-hoc meeting instances will be listed.

        * If `meetingNumber` is specified, the operation returns an array of meeting objects specified by the
        `meetingNumber`. Each object in the array can be a scheduled meeting or a meeting series depending on whether
        the `current` parameter is `true` or `false`, and each object contains the simultaneous interpretation object.
        When `meetingNumber` is specified, parameters of `from`, `to`, `meetingType`, `state`, `isModified` and
        `siteUrl` will be ignored. Please note that `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `webLink` is specified, the operation returns an array of meeting objects specified by the `webLink`. Each
        object in the array is a scheduled meeting, and each object contains the simultaneous interpretation object.
        When `webLink` is specified, parameters of `current`, `from`, `to`, `meetingType`, `state`, `isModified` and
        `siteUrl` will be ignored. Please note that `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `roomId` is specified, the operation returns an array of meeting objects of the Webex space specified by
        the `roomId`. When `roomId` is specified, parameters of `current`, `meetingType`, `state` and `isModified`
        will be ignored. The meeting objects are queried on the user's preferred site if no `siteUrl` is specified;
        otherwise, queried on the specified site. `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `state` parameter is specified, the returned array only has items in the specified state. If `state` is
        not specified, return items of all states.

        * If `meetingType` equals "meetingSeries", the `scheduledType` parameter can be "meeting", "webinar" or null.
        If `scheduledType` is specified, the returned array only has items of the specified scheduled type; otherwise,
        it has items of "meeting" and "webinar".

        * If `meetingType` equals "scheduledMeeting", the `scheduledType` parameter can be "meeting", "webinar",
        "personalRoomMeeting" or null. If `scheduledType` is specified, the returned array only has items of the
        specified scheduled type; otherwise, it has items of all scheduled types.

        * If `meetingType` equals "meeting", the `scheduledType` parameter can be "meeting", "webinar" or null. If
        `scheduledType` is specified, the returned array only has items of the specified scheduled type; otherwise, it
        has items of "meeting" and "webinar". Please note that ended or in-progress meeting instances of `personal room
        <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_
        also fall into the category of "meeting" `scheduledType`.

        * If `isModified` parameter is specified, the returned array only has items which have been modified to
        exceptional meetings. This parameter only applies to scheduled meeting.

        * If any of the `hasChat`, `hasRecording`, `hasTranscription`, `hasClosedCaption`, `hasPolls ` and `hasQA`
        parameters is specified, the `meetingType` must be "meeting" and `state` must be "ended". These parameters are
        null by default.

        * The `current` parameter only applies to meeting series. If it's `true`, the `start` and `end` attributes of
        each returned meeting series object are for the first scheduled meeting of that series. If it's `true` or not
        specified, the `start` and `end` attributes are for the scheduled meeting which is ready to start or join or
        the upcoming scheduled meeting of that series.

        * If `from` and `to` are specified, the operation returns an array of meeting objects in that specified time
        range.

        * If the parameter `siteUrl` has a value, the operation lists meetings on the specified site; otherwise, lists
        meetings on the user's all sites. All available Webex sites of the user can be retrieved by `Get Site List`
        API.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_number: Meeting number for the meeting objects being requested. `meetingNumber`, `webLink` and
            `roomId` are mutually exclusive. If it's an exceptional meeting from a meeting series, the exceptional
            meeting instead of the primary meeting series is returned.
        :type meeting_number: str
        :param web_link: URL encoded link to information page for the meeting objects being requested. `meetingNumber`,
            `webLink` and `roomId` are mutually exclusive.
        :type web_link: str
        :param room_id: Associated Webex space ID for the meeting objects being requested. `meetingNumber`, `webLink`
            and `roomId` are mutually exclusive.
        :type room_id: str
        :param meeting_type: Meeting type for the meeting objects being requested. This parameter will be ignored if
            `meetingNumber`, `webLink` or `roomId` is specified.
        :type meeting_type: MeetingSeriesObjectMeetingType
        :param state: Meeting state for the meeting objects being requested. If not specified, return meetings of all
            states. This parameter will be ignored if `meetingNumber`, `webLink` or `roomId` is specified. Details of
            an `ended` meeting will only be available 15 minutes after the meeting has ended. `inProgress` meetings
            are not fully supported. The API will try to return details of an `inProgress` meeting 15 minutes after
            the meeting starts. However, it may take longer depending on the traffic. See the `Webex Meetings
            <https://developer.webex.com/docs/meetings#meeting-states>`_ guide for
            more information about the states of meetings.
        :type state: MeetingSeriesObjectState
        :param scheduled_type: Scheduled type for the meeting objects being requested.
        :type scheduled_type: MeetingSeriesObjectScheduledType
        :param is_modified: Flag identifying whether a meeting has been modified. Only applies to scheduled meetings.
            If `true`, only return modified scheduled meetings; if `false`, only return unmodified scheduled meetings;
            if not specified, all scheduled meetings will be returned.
        :type is_modified: bool
        :param has_chat: Flag identifying whether a meeting has a chat log. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have chats; if `false`, only return meeting instances which
            have no chats; if not specified, all meeting instances will be returned.
        :type has_chat: bool
        :param has_recording: Flag identifying meetings with recordings. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have recordings; if `false`, only return meeting instances
            which have no recordings; if not specified, all meeting instances will be returned.
        :type has_recording: bool
        :param has_transcription: Flag identifying meetings with transcripts. Only applies to ended meeting instances.
            If `true`, only return meeting instances which have transcripts; if `false`, only return meeting instances
            which have no transcripts; if not specified, all meeting instances will be returned.
        :type has_transcription: bool
        :param has_closed_caption: Flag identifying meetings with closed captions. Only applies to ended meeting
            instances. If `true`, only return meeting instances which have closed captions; if `false`, only return
            meeting instances which have no closed captions; if not specified, all meeting instances will be returned.
        :type has_closed_caption: bool
        :param has_polls: Flag identifying meetings with polls. Only applies to ended meeting instances. If `true`,
            only return meeting instances which have polls; if `false`, only return meeting instances which have no
            polls; if not specified, all meeting instances will be returned.
        :type has_polls: bool
        :param has_qa: Flag identifying meetings with Q&A. Only applies to ended meeting instances. If `true`, only
            return meeting instances which have Q&A; if `false`, only return meeting instances which have no Q&A; if
            not specified, all meeting instances will be returned.
        :type has_qa: bool
        :param current: Flag identifying to retrieve the current scheduled meeting of the meeting series or the entire
            meeting series. This parameter only applies to scenarios where `meetingNumber` is specified and the
            meeting is not an exceptional meeting from a meeting series. If it's `true`, return the scheduled meeting
            of the meeting series which is ready to join or start or the upcoming scheduled meeting of the meeting
            series; if it's `false`, return the entire meeting series.
        :type current: bool
        :param from_: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being
            requested. `from` cannot be after `to`. This parameter will be ignored if `meetingNumber`, `webLink` or
            `roomId` is specified.
        :type from_: Union[str, datetime]
        :param to_: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being
            requested. `to` cannot be before `from`. This parameter will be ignored if `meetingNumber`, `webLink` or
            `roomId` is specified.
        :type to_: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for meetings that are hosted by that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meetings from. If not specified, the API lists
            meetings from user's all sites. All available Webex sites of the user can be retrieved by `Get Site List`
            API.
        :type site_url: str
        :param integration_tag: External key created by an integration application. This parameter is used by the
            integration application to query meetings by a key in its own domain such as a Zendesk ticket ID, a Jira
            ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str
        :return: Generator yielding :class:`MeetingSeriesObjectForListMeeting` instances
        """
        if meeting_number is not None:
            params['meetingNumber'] = meeting_number
        if web_link is not None:
            params['webLink'] = web_link
        if room_id is not None:
            params['roomId'] = room_id
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if scheduled_type is not None:
            params['scheduledType'] = scheduled_type
        if is_modified is not None:
            params['isModified'] = str(is_modified).lower()
        if has_chat is not None:
            params['hasChat'] = str(has_chat).lower()
        if has_recording is not None:
            params['hasRecording'] = str(has_recording).lower()
        if has_transcription is not None:
            params['hasTranscription'] = str(has_transcription).lower()
        if has_closed_caption is not None:
            params['hasClosedCaption'] = str(has_closed_caption).lower()
        if has_polls is not None:
            params['hasPolls'] = str(has_polls).lower()
        if has_qa is not None:
            params['hasQA'] = str(has_qa).lower()
        if current is not None:
            params['current'] = str(current).lower()
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        url = self.ep()
        return self.session.follow_pagination(url=url, model=MeetingSeriesObjectForListMeeting, item_key='items', params=params)

    def list_meetings_of_a_meeting_series(self, meeting_series_id: str, from_: Union[str, datetime] = None,
                                          to_: Union[str, datetime] = None,
                                          meeting_type: ListMeetingsOfAMeetingSeriesMeetingType = None,
                                          state: ListMeetingsOfAMeetingSeriesState = None, is_modified: bool = None,
                                          has_chat: bool = None, has_recording: bool = None,
                                          has_transcription: bool = None, has_closed_caption: bool = None,
                                          has_polls: bool = None, has_qa: bool = None, host_email: str = None,
                                          **params) -> Generator[ScheduledMeetingObject, None, None]:
        """
        List Meetings of a Meeting Series

        Lists scheduled meeting and meeting instances of a meeting series identified by `meetingSeriesId`. Scheduled
        meetings of an ad-hoc meeting created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` will not be
        listed, but the ended and ongoing meeting instances of it will be listed.

        Each _scheduled meeting_ or _meeting_ instance of a _meeting series_ has its own `start`, `end`, etc. Thus, for
        example, when a daily meeting has been scheduled from `2019-04-01` to `2019-04-10`, there are 10 scheduled
        meeting instances in this series, one instance for each day, and each one has its own attributes. When a
        scheduled meeting has been started and ended or is happening, there are even more ended or in-progress meeting
        instances.

        Use this operation to list scheduled meeting and meeting instances of a meeting series within a specific date
        range.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * If any of the `hasChat`, `hasRecording`, `hasTranscription`, `hasClosedCaption`, `hasPolls ` and `hasQA`
        parameters is specified, the `meetingType` must be "meeting" and `state` must be "ended". These parameters are
        null by default.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_series_id: Unique identifier for the meeting series. Please note that currently meeting ID of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_series_id: str
        :param from_: Start date and time (inclusive) for the range for which meetings are to be returned in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot be after `to`.
        :type from_: Union[str, datetime]
        :param to_: End date and time (exclusive) for the range for which meetings are to be returned in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. `to` cannot be before `from`.
        :type to_: Union[str, datetime]
        :param meeting_type: Meeting type for the meeting objects being requested. If not specified, return meetings of
            all types.
        :type meeting_type: ListMeetingsOfAMeetingSeriesMeetingType
        :param state: Meeting state for the meetings being requested. If not specified, return meetings of all states.
            Details of an `ended` meeting will only be available 15 minutes after the meeting has ended. `inProgress`
            meetings are not fully supported. The API will try to return details of an `inProgress` meeting 15 minutes
            after the meeting starts. However, it may take longer depending on the traffic. See the `Webex Meetings
            <https://developer.webex.com/docs/meetings#meeting-states>`_
            guide for more information about the states of meetings.
        :type state: ListMeetingsOfAMeetingSeriesState
        :param is_modified: Flag identifying whether a meeting has been modified. Only applies to scheduled meetings.
            If `true`, only return modified scheduled meetings; if `false`, only return unmodified scheduled meetings;
            if not specified, all scheduled meetings will be returned.
        :type is_modified: bool
        :param has_chat: Flag identifying whether a meeting has a chat log. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have chats; if `false`, only return meeting instances which
            have no chats; if not specified, all meeting instances will be returned.
        :type has_chat: bool
        :param has_recording: Flag identifying meetings with recordings. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have recordings; if `false`, only return meeting instances
            which have no recordings; if not specified, all meeting instances will be returned.
        :type has_recording: bool
        :param has_transcription: Flag identifying meetings with transcripts. Only applies to ended meeting instances.
            If `true`, only return meeting instances which have transcripts; if `false`, only return meeting instances
            which have no transcripts; if not specified, all meeting instances will be returned.
        :type has_transcription: bool
        :param has_closed_caption: Flag identifying meetings with closed captions. Only applies to ended meeting
            instances. If `true`, only return meeting instances which have closed captions; if `false`, only return
            meeting instances which have no closed captions; if not specified, all meeting instances will be returned.
        :type has_closed_caption: bool
        :param has_polls: Flag identifying meetings with polls. Only applies to ended meeting instances. If `true`,
            only return meeting instances which have polls; if `false`, only return meeting instances which have no
            polls; if not specified, all meeting instances will be returned.
        :type has_polls: bool
        :param has_qa: Flag identifying meetings with Q&A. Only applies to ended meeting instances. If `true`, only
            return meeting instances which have Q&A; if `false`, only return meeting instances which have no Q&A; if
            not specified, all meeting instances will be returned.
        :type has_qa: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meetings that are hosted by that user.
        :type host_email: str
        :return: Generator yielding :class:`ScheduledMeetingObject` instances
        """
        params['meetingSeriesId'] = meeting_series_id
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if is_modified is not None:
            params['isModified'] = str(is_modified).lower()
        if has_chat is not None:
            params['hasChat'] = str(has_chat).lower()
        if has_recording is not None:
            params['hasRecording'] = str(has_recording).lower()
        if has_transcription is not None:
            params['hasTranscription'] = str(has_transcription).lower()
        if has_closed_caption is not None:
            params['hasClosedCaption'] = str(has_closed_caption).lower()
        if has_polls is not None:
            params['hasPolls'] = str(has_polls).lower()
        if has_qa is not None:
            params['hasQA'] = str(has_qa).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ScheduledMeetingObject, item_key='items', params=params)

    def patch_a_meeting(self, meeting_id: str, title: str, agenda: str, password: str, start: Union[str, datetime],
                        end: Union[str, datetime], timezone: str, recurrence: str, enabled_auto_record_meeting: bool,
                        allow_any_user_to_be_co_host: bool, enabled_join_before_host: bool,
                        enable_connect_audio_before_host: bool, join_before_host_minutes: int, exclude_password: bool,
                        public_meeting: bool, reminder_time: int,
                        unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                        session_type_id: int, enabled_webcast_view: bool, panelist_password: str,
                        enable_automatic_lock: bool, automatic_lock_minutes: int,
                        allow_first_user_to_be_co_host: bool, allow_authenticated_devices: bool, send_email: bool,
                        host_email: str, site_url: str, meeting_options: MeetingSeriesObjectMeetingOptions,
                        attendee_privileges: MeetingSeriesObjectAttendeePrivileges, integration_tags: list[str],
                        enabled_breakout_sessions: bool, tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                        audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                        require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObject:
        """
        Patch a Meeting

        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be updated.

        * If the `meetingId` value specified is for a scheduled meeting, the operation updates that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation updates the entire meeting series.
        **Note**: If the value of `start`, `end`, or `recurrence` for the meeting series is changed, any exceptional
        scheduled meeting in this series is cancelled when the meeting series is updated.

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on
            updating date and time for a meeting. Please note that when a meeting is being updated, `start` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is within the same
            minute as the current time, `start` will be adjusted to the upcoming minute; otherwise, `start` will be
            adjusted with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions
            on updating date and time for a meeting. Please note that when a meeting is being updated, `end` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be adjusted with
            seconds and milliseconds stripped off. For instance, `end` of `2022-03-01T11:52:28.076+08:00` or
            `2022-03-01T11:52:41+08:00` will be adjusted to `2022-03-01T11:52:00+08:00`.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for
            monthly or yearly `recurrence` rule are not supported, only the first day or date specified is taken. For
            example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially
            supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. Only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid
            options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`,
            `45`, and `60`. The default is `0` if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be
            retrieved by `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. Please note that an empty or null
            `integrationTags` will delete all existing integration tags for the meeting implicitly. Developer can
            update integration tags for a `meetingSeries` but he cannot update it for a `scheduledMeeting` or a
            `meeting` instance.
        :type integration_tags: list[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            `enabledBreakoutSessions` is false, users can not set breakout sessions. If the value of
            `enabledBreakoutSessions` is true, users can update breakout sessions using the `Update Breakout Sessions
            <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_
            API. Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObject`
        """
        body = dict()
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['integrationTags'] = integration_tags
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep(f'{meeting_id}')
        data = super().patch(url, json=body)
        r = MeetingSeriesObject.model_validate(data)
        return r

    def update_a_meeting(self, meeting_id: str, title: str, agenda: str, password: str, start: Union[str, datetime],
                         end: Union[str, datetime], timezone: str, recurrence: str, enabled_auto_record_meeting: bool,
                         allow_any_user_to_be_co_host: bool, enabled_join_before_host: bool,
                         enable_connect_audio_before_host: bool, join_before_host_minutes: int,
                         exclude_password: bool, public_meeting: bool, reminder_time: int,
                         unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                         session_type_id: int, enabled_webcast_view: bool, panelist_password: str,
                         enable_automatic_lock: bool, automatic_lock_minutes: int,
                         allow_first_user_to_be_co_host: bool, allow_authenticated_devices: bool, send_email: bool,
                         host_email: str, site_url: str, meeting_options: MeetingSeriesObjectMeetingOptions,
                         attendee_privileges: MeetingSeriesObjectAttendeePrivileges, integration_tags: list[str],
                         enabled_breakout_sessions: bool, tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                         audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                         require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObject:
        """
        Update a Meeting

        <div>
        <Callout type="warning">The PUT method is still supported and behaves the same as before, will be deprecated in
        the future. Use the PATCH method instead.</Callout>
        </div>

        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be updated.

        * If the `meetingId` value specified is for a scheduled meeting, the operation updates that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation updates the entire meeting series.
        **Note**: If the value of `start`, `end`, or `recurrence` for the meeting series is changed, any exceptional
        scheduled meeting in this series is cancelled when the meeting series is updated.

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on
            updating date and time for a meeting. Please note that when a meeting is being updated, `start` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is within the same
            minute as the current time, `start` will be adjusted to the upcoming minute; otherwise, `start` will be
            adjusted with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions
            on updating date and time for a meeting. Please note that when a meeting is being updated, `end` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be adjusted with
            seconds and milliseconds stripped off. For instance, `end` of `2022-03-01T11:52:28.076+08:00` or
            `2022-03-01T11:52:41+08:00` will be adjusted to `2022-03-01T11:52:00+08:00`.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for
            monthly or yearly `recurrence` rule are not supported, only the first day or date specified is taken. For
            example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially
            supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. Only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid
            options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`,
            `45`, and `60`. The default is `0` if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be
            retrieved by `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. Please note that an empty or null
            `integrationTags` will delete all existing integration tags for the meeting implicitly. Developer can
            update integration tags for a `meetingSeries` but he cannot update it for a `scheduledMeeting` or a
            `meeting` instance.
        :type integration_tags: list[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            `enabledBreakoutSessions` is false, users can not set breakout sessions. If the value of
            `enabledBreakoutSessions` is true, users can update breakout sessions using the `Update Breakout Sessions
            <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_
            API. Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObject`
        """
        body = dict()
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['integrationTags'] = integration_tags
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep(f'{meeting_id}')
        data = super().put(url, json=body)
        r = MeetingSeriesObject.model_validate(data)
        return r

    def delete_a_meeting(self, meeting_id: str, host_email: str = None, send_email: bool = None):
        """
        Delete a Meeting

        Deletes a meeting with a specified meeting ID. The deleted meeting cannot be recovered. This operation applies
        to meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc
        meetings created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be deleted.

        * If the `meetingId` value specified is for a scheduled meeting, the operation deletes that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation deletes the entire meeting series.

        :param meeting_id: Unique identifier for the meeting to be deleted. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will delete a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}')
        super().delete(url, params=params)

    def join_a_meeting(self, meeting_id: str, meeting_number: str, web_link: str, join_directly: bool, email: str,
                       display_name: str, password: str, expiration_minutes: int) -> JoinMeetingLinkObject:
        """
        Join a Meeting

        Retrieves links for a meeting with a specified `meetingId`, `meetingNumber`, or `webLink` that allow users to
        start or join the meeting directly without logging in and entering a password.

        * Please note that `meetingId`, `meetingNumber` and `webLink` are mutually exclusive and they cannot be
        specified simultaneously.

        * If `joinDirectly` is true or not specified, the response will have HTTP response code 302 and the request
        will be redirected to `joinLink`; otherwise, the response will have HTTP response code 200 and `joinLink` will
        be returned in response body.

        * Only the meeting host or cohost can generate the `startLink`.

        * Generating a join link or a start link before the time specified by `joinBeforeHostMinutes` for a webinar is
        not supported.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances. Please note that currently meeting
            ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is also supported for this API.
        :type meeting_id: str
        :param meeting_number: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but
            not to meeting instances which have ended.
        :type meeting_number: str
        :param web_link: Link to a meeting information page where the meeting client is launched if the meeting is
            ready to start or join.
        :type web_link: str
        :param join_directly: Whether or not to redirect to `joinLink`. It is an optional field and default value is
            true.
        :type join_directly: bool
        :param email: Email address of meeting participant. If `email` is specified, the link is generated for the user
            of `email`; otherwise, it's generated for the user calling the API. `email` is required for a
            `guest issuer
            <https://developer.webex.com/docs/guest-issuer>`_.
        :type email: str
        :param display_name: Display name of meeting participant. If `email` is specified and `displayName` is empty,
            the display name is the same as `email`. The maximum length of `displayName` is 128 characters.
            `displayName` is required for a `guest issuer
            <https://developer.webex.com/docs/guest-issuer>`_.
        :type display_name: str
        :param password: It's required when the meeting is protected by a password and the current user is not
            privileged to view it if they are not a host, cohost or invitee of the meeting.
        :type password: str
        :param expiration_minutes: Expiration duration of `joinLink` in minutes. Must be between 1 and 60.
        :type expiration_minutes: int
        :rtype: :class:`JoinMeetingLinkObject`
        """
        body = dict()
        body['meetingId'] = meeting_id
        body['meetingNumber'] = meeting_number
        body['webLink'] = web_link
        body['joinDirectly'] = join_directly
        body['email'] = email
        body['displayName'] = display_name
        body['password'] = password
        body['expirationMinutes'] = expiration_minutes
        url = self.ep('join')
        data = super().post(url, json=body)
        r = JoinMeetingLinkObject.model_validate(data)
        return r

    def list_meeting_templates(self, template_type: MeetingUsageReportObjectScheduledType = None, locale: str = None,
                               is_default: bool = None, is_standard: bool = None, host_email: str = None,
                               site_url: str = None) -> list[TemplateObject]:
        """
        List Meeting Templates

        Retrieves the list of meeting templates that is available for the authenticated user.

        There are separate lists of meeting templates for different `templateType`, `locale` and `siteUrl`.

        * If `templateType` is specified, the operation returns an array of meeting template objects specified by the
        `templateType`; otherwise, returns an array of meeting template objects of all template types.

        * If `locale` is specified, the operation returns an array of meeting template objects specified by the
        `locale`; otherwise, returns an array of meeting template objects of the default `en_US` locale. Refer to
        `Meeting Template Locales
        <https://developer.webex.com/docs/meetings#meeting-template-locales>`_ for all the locales supported by Webex.

        * If the parameter `siteUrl` has a value, the operation lists meeting templates on the specified site;
        otherwise, lists meeting templates on the user's preferred site. All available Webex sites and preferred site
        of the user can be retrieved by `Get Site List` API.

        :param template_type: Meeting template type for the meeting template objects being requested. If not specified,
            return meeting templates of all types.
        :type template_type: MeetingUsageReportObjectScheduledType
        :param locale: Locale for the meeting template objects being requested. If not specified, return meeting
            templates of the default `en_US` locale. Refer to `Meeting Template Locales
            <https://developer.webex.com/docs/meetings#meeting-template-locales>`_ for all the locales supported
            by Webex.
        :type locale: str
        :param is_default: The value is `true` or `false`. If it's `true`, return the default meeting templates; if
            it's `false`, return the non-default meeting templates. If it's not specified, return both default and
            non-default meeting templates.
        :type is_default: bool
        :param is_standard: The value is `true` or `false`. If it's `true`, return the standard meeting templates; if
            it's `false`, return the non-standard meeting templates. If it's not specified, return both standard and
            non-standard meeting templates.
        :type is_standard: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meeting templates that are available for that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meeting templates from. If not specified, the API
            lists meeting templates from user's preferred site. All available Webex sites and preferred site of the
            user can be retrieved by `Get Site List` API.
        :type site_url: str
        :rtype: list[TemplateObject]
        """
        params = {}
        if template_type is not None:
            params['templateType'] = template_type
        if locale is not None:
            params['locale'] = locale
        if is_default is not None:
            params['isDefault'] = str(is_default).lower()
        if is_standard is not None:
            params['isStandard'] = str(is_standard).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('templates')
        data = super().get(url, params=params)
        r = TypeAdapter(list[TemplateObject]).validate_python(data['items'])
        return r

    def get_a_meeting_template(self, template_id: str, host_email: str = None) -> DetailedTemplateObject:
        """
        Get a Meeting Template

        Retrieves details for a meeting template with a specified meeting template ID.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param template_id: Unique identifier for the meeting template being requested.
        :type template_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return the meeting template that is available for that user.
        :type host_email: str
        :rtype: :class:`DetailedTemplateObject`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'templates/{template_id}')
        data = super().get(url, params=params)
        r = DetailedTemplateObject.model_validate(data)
        return r

    def get_meeting_control_status(self, meeting_id: str) -> Control:
        """
        Get Meeting Control Status

        Get the meeting control of a live meeting, which is consisted of meeting control status on "locked" and
        "recording" to reflect whether the meeting is currently locked and there is recording in progress.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :rtype: :class:`Control`
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep('controls')
        data = super().get(url, params=params)
        r = Control.model_validate(data)
        return r

    def update_meeting_control_status(self, meeting_id: str, recording_started: str = None,
                                      recording_paused: str = None, locked: str = None) -> Control:
        """
        Update Meeting Control Status

        To start, pause, resume, or stop a meeting recording; To lock or unlock an on-going meeting.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param recording_started: The value can be true or false. true means to start the recording, false to end the
            recording.
        :type recording_started: str
        :param recording_paused: The value can be true or false, will be ignored if 'recordingStarted' sets to false,
            and true to resume the recording only if the recording is paused vise versa.
        :type recording_paused: str
        :param locked: The value is true or false.
        :type locked: str
        :rtype: :class:`Control`
        """
        params = {}
        params['meetingId'] = meeting_id
        body = dict()
        body['recordingStarted'] = recording_started
        body['recordingPaused'] = recording_paused
        body['locked'] = locked
        url = self.ep('controls')
        data = super().put(url, params=params, json=body)
        r = Control.model_validate(data)
        return r

    def list_meeting_session_types(self, host_email: str = None,
                                   site_url: str = None) -> list[MeetingSessionTypeObject]:
        """
        List Meeting Session Types

        List all the meeting session types enabled for a given user.

        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will list all the meeting session types enabled for the user.
        :type host_email: str
        :param site_url: Webex site URL to query. If `siteUrl` is not specified, the users' preferred site will be
            used. If the authorization token has the admin-level scopes, the admin can set the Webex site URL on
            behalf of the user specified in the `hostEmail` parameter.
        :type site_url: str
        :rtype: list[MeetingSessionTypeObject]
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('sessionTypes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MeetingSessionTypeObject]).validate_python(data['items'])
        return r

    def get_a_meeting_session_type(self, session_type_id: int, host_email: str = None,
                                   site_url: str = None) -> MeetingSessionTypeObject:
        """
        Get a Meeting Session Type

        Retrieves details for a meeting session type with a specified session type ID.

        :param session_type_id: A unique identifier for the sessionType.
        :type session_type_id: int
        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will get a meeting session type with the specified session type ID enabled for the
            user.
        :type host_email: str
        :param site_url: Webex site URL to query. If `siteUrl` is not specified, the users' preferred site will be
            used. If the authorization token has the admin-level scopes, the admin can set the Webex site URL on
            behalf of the user specified in the `hostEmail` parameter.
        :type site_url: str
        :rtype: :class:`MeetingSessionTypeObject`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep(f'sessionTypes/{session_type_id}')
        data = super().get(url, params=params)
        r = MeetingSessionTypeObject.model_validate(data)
        return r

    def get_registration_form_for_a_meeting(self, meeting_id: str, current: bool = None,
                                            host_email: str = None) -> Registration:
        """
        Get registration form for a meeting

        Get a meeting's registration form to understand which fields are required.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`Registration`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registration')
        data = super().get(url, params=params)
        r = Registration.model_validate(data)
        return r

    def update_meeting_registration_form(self, meeting_id: str, host_email: str, require_first_name: bool,
                                         require_last_name: bool, require_email: bool, require_job_title: bool,
                                         require_company_name: bool, require_address1: bool, require_address2: bool,
                                         require_city: bool, require_state: bool, require_zip_code: bool,
                                         require_country_region: bool, require_work_phone: bool, require_fax: bool,
                                         max_register_num: int,
                                         customized_questions: list[CustomizedQuestionForCreateMeeting],
                                         rules: list[StandardRegistrationApproveRule]) -> Registration:
        """
        Update Meeting Registration Form

        Enable or update a registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param host_email: - Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return an update for a meeting that is hosted by that user.
        :type host_email: str
        :param require_first_name: Whether or not a registrant's first name is required for meeting registration. This
            option must always be `true`.
        :type require_first_name: bool
        :param require_last_name: Whether or not a registrant's last name is required for meeting registration. This
            option must always be `true`.
        :type require_last_name: bool
        :param require_email: Whether or not a registrant's email is required for meeting registration. This option
            must always be `true`.
        :type require_email: bool
        :param require_job_title: Whether or not a registrant's job title is shown or required for meeting
            registration.
        :type require_job_title: bool
        :param require_company_name: Whether or not a registrant's company name is shown or required for meeting
            registration.
        :type require_company_name: bool
        :param require_address1: Whether or not a registrant's first address field is shown or required for meeting
            registration.
        :type require_address1: bool
        :param require_address2: Whether or not a registrant's second address field is shown or required for meeting
            registration.
        :type require_address2: bool
        :param require_city: Whether or not a registrant's city is shown or required for meeting registration.
        :type require_city: bool
        :param require_state: Whether or not a registrant's state is shown or required for meeting registration.
        :type require_state: bool
        :param require_zip_code: Whether or not a registrant's postal code is shown or required for meeting
            registration.
        :type require_zip_code: bool
        :param require_country_region: Whether or not a registrant's country or region is shown or required for meeting
            registration.
        :type require_country_region: bool
        :param require_work_phone: Whether or not a registrant's work phone number is shown or required for meeting
            registration.
        :type require_work_phone: bool
        :param require_fax: Whether or not a registrant's fax number is shown or required for meeting registration.
        :type require_fax: bool
        :param max_register_num: Maximum number of meeting registrations. This only applies to meetings. The maximum
            number of participants for meetings and webinars, with the limit based on the user capacity and controlled
            by a toggle at the site level. The default maximum number of participants for webinars is 10000, but the
            actual maximum number of participants is limited by the user capacity.
        :type max_register_num: int
        :param customized_questions: Customized questions for meeting registration.
        :type customized_questions: list[CustomizedQuestionForCreateMeeting]
        :param rules: The approval rule for standard questions.
        :type rules: list[StandardRegistrationApproveRule]
        :rtype: :class:`Registration`
        """
        body = dict()
        body['hostEmail'] = host_email
        body['requireFirstName'] = require_first_name
        body['requireLastName'] = require_last_name
        body['requireEmail'] = require_email
        body['requireJobTitle'] = require_job_title
        body['requireCompanyName'] = require_company_name
        body['requireAddress1'] = require_address1
        body['requireAddress2'] = require_address2
        body['requireCity'] = require_city
        body['requireState'] = require_state
        body['requireZipCode'] = require_zip_code
        body['requireCountryRegion'] = require_country_region
        body['requireWorkPhone'] = require_work_phone
        body['requireFax'] = require_fax
        body['maxRegisterNum'] = max_register_num
        body['customizedQuestions'] = loads(TypeAdapter(list[CustomizedQuestionForCreateMeeting]).dump_json(customized_questions))
        body['rules'] = loads(TypeAdapter(list[StandardRegistrationApproveRule]).dump_json(rules))
        url = self.ep(f'{meeting_id}/registration')
        data = super().put(url, json=body)
        r = Registration.model_validate(data)
        return r

    def delete_meeting_registration_form(self, meeting_id: str):
        """
        Delete Meeting Registration Form

        Disable the registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :rtype: None
        """
        url = self.ep(f'{meeting_id}/registration')
        super().delete(url)

    def register_a_meeting_registrant(self, meeting_id: str, first_name: str, last_name: str, email: str,
                                      send_email: bool, job_title: str, company_name: str, address1: str,
                                      address2: str, city: str, state: str, zip_code: int, country_region: str,
                                      work_phone: str, fax: str, customized_questions: list[CustomizedRegistrant],
                                      current: bool = None, host_email: str = None) -> RegistrantCreateResponse:
        """
        Register a Meeting Registrant

        Register a new registrant for a meeting. When a meeting or webinar is created, this API can only be used if
        Registration is checked on the page or the registration attribute is specified through the `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_
        API.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param first_name: The registrant's first name.
        :type first_name: str
        :param last_name: The registrant's last name. (Required)
        :type last_name: str
        :param email: The registrant's email.
        :type email: str
        :param send_email: If `true` send email to the registrant. Default: `true`.
        :type send_email: bool
        :param job_title: The registrant's job title. Registration options define whether or not this is required.
        :type job_title: str
        :param company_name: The registrant's company. Registration options define whether or not this is required.
        :type company_name: str
        :param address1: The registrant's first address line. Registration options define whether or not this is
            required.
        :type address1: str
        :param address2: The registrant's second address line. Registration options define whether or not this is
            required.
        :type address2: str
        :param city: The registrant's city name. Registration options define whether or not this is required.
        :type city: str
        :param state: The registrant's state. Registration options define whether or not this is required.
        :type state: str
        :param zip_code: The registrant's postal code. Registration options define whether or not this is required.
        :type zip_code: int
        :param country_region: The America is not a country or a specific region. Registration options define whether
            or not this is required.
        :type country_region: str
        :param work_phone: The registrant's work phone number. Registration options define whether or not this is
            required.
        :type work_phone: str
        :param fax: The registrant's FAX number. Registration options define whether or not this is required.
        :type fax: str
        :param customized_questions: The registrant's answers for customized questions. Registration options define
            whether or not this is required.
        :type customized_questions: list[CustomizedRegistrant]
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`RegistrantCreateResponse`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['email'] = email
        body['sendEmail'] = send_email
        body['jobTitle'] = job_title
        body['companyName'] = company_name
        body['address1'] = address1
        body['address2'] = address2
        body['city'] = city
        body['state'] = state
        body['zipCode'] = zip_code
        body['countryRegion'] = country_region
        body['workPhone'] = work_phone
        body['fax'] = fax
        body['customizedQuestions'] = loads(TypeAdapter(list[CustomizedRegistrant]).dump_json(customized_questions))
        url = self.ep(f'{meeting_id}/registrants')
        data = super().post(url, params=params, json=body)
        r = RegistrantCreateResponse.model_validate(data)
        return r

    def batch_register_meeting_registrants(self, meeting_id: str, current: bool = None, host_email: str = None,
                                           items: list[RegistrantFormObject] = None) -> list[RegistrantCreateResponse]:
        """
        Batch register Meeting Registrants

        Bulk register new registrants for a meeting. When a meeting or webinar is created, this API can only be used if
        Registration is checked on the page or the registration attribute is specified through the `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_
        API.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param items: Registrants array.
        :type items: list[RegistrantFormObject]
        :rtype: list[RegistrantCreateResponse]
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['items'] = loads(TypeAdapter(list[RegistrantFormObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/registrants/bulkInsert')
        data = super().post(url, params=params, json=body)
        r = TypeAdapter(list[RegistrantCreateResponse]).validate_python(data['items'])
        return r

    def get_detailed_information_for_a_meeting_registrant(self, meeting_id: str, registrant_id: str,
                                                          current: bool = None, host_email: str = None) -> Registrant:
        """
        Get Detailed Information for a Meeting Registrant

        Retrieves details for a meeting registrant with a specified registrant Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`Registrant`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        data = super().get(url, params=params)
        r = Registrant.model_validate(data)
        return r

    def list_meeting_registrants(self, meeting_id: str, host_email: str = None, current: bool = None,
                                 email: str = None, registration_time_from: Union[str, datetime] = None,
                                 registration_time_to: Union[str, datetime] = None,
                                 **params) -> Generator[Registrant, None, None]:
        """
        List Meeting Registrants

        Meeting's host and cohost can retrieve the list of registrants for a meeting with a specified meeting Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param email: Registrant's email to filter registrants.
        :type email: str
        :param registration_time_from: The time registrants register a meeting starts from the specified date and time
            (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `registrationTimeFrom` is not specified, it equals
            `registrationTimeTo` minus 7 days.
        :type registration_time_from: Union[str, datetime]
        :param registration_time_to: The time registrants register a meeting before the specified date and time
            (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `registrationTimeTo` is not specified, it equals
            `registrationTimeFrom` plus 7 days. The interval between `registrationTimeFrom` and `registrationTimeTo`
            must be within 90 days.
        :type registration_time_to: Union[str, datetime]
        :return: Generator yielding :class:`Registrant` instances
        """
        if host_email is not None:
            params['hostEmail'] = host_email
        if current is not None:
            params['current'] = str(current).lower()
        if email is not None:
            params['email'] = email
        if registration_time_from is not None:
            if isinstance(registration_time_from, str):
                registration_time_from = isoparse(registration_time_from)
            registration_time_from = dt_iso_str(registration_time_from)
            params['registrationTimeFrom'] = registration_time_from
        if registration_time_to is not None:
            if isinstance(registration_time_to, str):
                registration_time_to = isoparse(registration_time_to)
            registration_time_to = dt_iso_str(registration_time_to)
            params['registrationTimeTo'] = registration_time_to
        url = self.ep(f'{meeting_id}/registrants')
        return self.session.follow_pagination(url=url, model=Registrant, item_key='items', params=params)

    def query_meeting_registrants(self, meeting_id: str, status: RegistrantStatus,
                                  order_type: QueryRegistrantsOrderType, order_by: QueryRegistrantsOrderBy,
                                  emails: list[str], current: bool = None, host_email: str = None,
                                  **params) -> Generator[Registrant, None, None]:
        """
        Query Meeting Registrants

        Meeting's host and cohost can query the list of registrants for a meeting with a specified meeting ID and
        registrants email.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param status: Registrant's status.
        :type status: RegistrantStatus
        :param order_type: Sort order for the registrants.
        :type order_type: QueryRegistrantsOrderType
        :param order_by: Registrant ordering field. Ordered by `registrationTime` by default.
        :type order_by: QueryRegistrantsOrderBy
        :param emails: List of registrant email addresses.
        :type emails: list[str]
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :return: Generator yielding :class:`Registrant` instances
        """
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['status'] = enum_str(status)
        body['orderType'] = enum_str(order_type)
        body['orderBy'] = enum_str(order_by)
        body['emails'] = emails
        url = self.ep(f'{meeting_id}/registrants/query')
        return self.session.follow_pagination(url=url, model=Registrant, item_key='items', params=params, json=body)

    def batch_update_meeting_registrants_status(self, meeting_id: str,
                                                status_op_type: BatchUpdateMeetingRegistrantsStatusStatusOpType,
                                                current: bool = None, host_email: str = None, send_email: str = None,
                                                registrants: list[DepartmentResponseWithId] = None):
        """
        Batch Update Meeting Registrants status

        Meeting's host or cohost can update the set of registrants for a meeting. `cancel` means the registrant(s) will
        be moved back to the registration list. `bulkDelete` means the registrant(s) will be deleted.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param status_op_type: Update registrant's status.
        :type status_op_type: BatchUpdateMeetingRegistrantsStatusStatusOpType
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        + Default: `false`
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If `true` send email to registrants. Default: `true`.
        :type send_email: str
        :param registrants: Registrants array.
        :type registrants: list[DepartmentResponseWithId]
        :rtype: None
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['sendEmail'] = send_email
        body['registrants'] = loads(TypeAdapter(list[DepartmentResponseWithId]).dump_json(registrants))
        url = self.ep(f'{meeting_id}/registrants/{status_op_type}')
        super().post(url, params=params, json=body)

    def delete_a_meeting_registrant(self, meeting_id: str, registrant_id: str, current: bool = None,
                                    host_email: str = None):
        """
        Delete a Meeting Registrant

        Meeting's host or cohost can delete a registrant with a specified registrant ID.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant.
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: None
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        super().delete(url, params=params)

    def update_meeting_simultaneous_interpretation(self, meeting_id: str, enabled: bool,
                                                   interpreters: list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]) -> MeetingSeriesObjectSimultaneousInterpretation:
        """
        Update Meeting Simultaneous interpretation

        Updates simultaneous interpretation options of a meeting with a specified meeting ID. This operation applies to
        meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param enabled: Whether or not simultaneous interpretation is enabled.
        :type enabled: bool
        :param interpreters: Interpreters for meeting.
        :type interpreters: list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]
        :rtype: :class:`MeetingSeriesObjectSimultaneousInterpretation`
        """
        body = dict()
        body['enabled'] = enabled
        body['interpreters'] = loads(TypeAdapter(list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]).dump_json(interpreters))
        url = self.ep(f'{meeting_id}/simultaneousInterpretation')
        data = super().put(url, json=body)
        r = MeetingSeriesObjectSimultaneousInterpretation.model_validate(data)
        return r

    def create_a_meeting_interpreter(self, meeting_id: str, language_code1: str, language_code2: str, email: str,
                                     display_name: str, host_email: str,
                                     send_email: bool) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Create a Meeting Interpreter

        Assign an interpreter to a bi-directional simultaneous interpretation language channel for a meeting.

        :param meeting_id: Unique identifier for the meeting to which the interpreter is to be assigned.
        :type meeting_id: str
        :param language_code1: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code1: str
        :param language_code2: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code2: str
        :param email: Email address of meeting interpreter. If not specified, an empty interpreter will be created for
            this bi-directional language channel, and a specific email can be assigned to this empty interpreter by
            `Update a Meeting Interpreter` API later. Please note that multiple interpreters with different emails can
            be assigned to the same bi-directional language channel, but the same email cannot be assigned to more
            than one interpreter.
        :type email: str
        :param display_name: Display name of meeting interpreter. If the interpreter is already an invitee of the
            meeting and it has a different display name, that invitee's display name will be overwritten by this
            attribute.
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        body = dict()
        body['languageCode1'] = language_code1
        body['languageCode2'] = language_code2
        body['email'] = email
        body['displayName'] = display_name
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().post(url, json=body)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def get_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str,
                                  host_email: str = None) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Get a Meeting Interpreter

        Retrieves details for a meeting interpreter identified by `meetingId` and `interpreterId` in the URI.

        :param meeting_id: Unique identifier for the meeting to which the interpreter has been assigned.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return details for an interpreter of the meeting that is hosted by that
            user.
        :type host_email: str
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().get(url, params=params)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def list_meeting_interpreters(self, meeting_id: str,
                                  host_email: str = None) -> list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]:
        """
        List Meeting Interpreters

        Lists meeting interpreters for a meeting with a specified `meetingId`.

        This operation can be used for meeting series, scheduled meeting and ended or ongoing meeting instance objects.
        If the specified `meetingId` is for a meeting series, the interpreters for the series will be listed; if the
        `meetingId` is for a scheduled meeting, the interpreters for the particular scheduled meeting will be listed;
        if the `meetingId` is for an ended or ongoing meeting instance, the interpreters for the particular meeting
        instance will be listed. See the `Webex Meetings
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ guide for more information about the types of meetings.

        The list returned is sorted in descending order by when interpreters were created.

        :param meeting_id: Unique identifier for the meeting for which interpreters are being requested. The meeting
            can be meeting series, scheduled meeting or meeting instance which has ended or is ongoing. Please note
            that currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return interpreters of the meeting that is hosted by that user.
        :type host_email: str
        :rtype: list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]).validate_python(data['items'])
        return r

    def update_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str, language_code1: str,
                                     language_code2: str, email: str, display_name: str, host_email: str,
                                     send_email: bool) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Update a Meeting Interpreter

        Updates details for a meeting interpreter identified by `meetingId` and `interpreterId` in the URI.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param language_code1: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code1: str
        :param language_code2: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code2: str
        :param email: Email address of meeting interpreter. If not specified, it'll be an empty interpreter for the
            bi-directional language channel. Please note that multiple interpreters with different emails can be
            assigned to the same bi-directional language channel, but the same email cannot be assigned to more than
            one interpreter.
        :type email: str
        :param display_name: Display name of meeting interpreter. If the interpreter is already an invitee of the
            meeting and it has a different display name, that invitee's display name will be overwritten by this
            attribute.
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        body = dict()
        body['languageCode1'] = language_code1
        body['languageCode2'] = language_code2
        body['email'] = email
        body['displayName'] = display_name
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().put(url, json=body)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def delete_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str, host_email: str = None,
                                     send_email: bool = None):
        """
        Delete a Meeting Interpreter

        Removes a meeting interpreter identified by `meetingId` and `interpreterId` in the URI. The deleted meeting
        interpreter cannot be recovered.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter to be removed.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will delete an interpreter of the meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        super().delete(url, params=params)

    def update_meeting_breakout_sessions(self, meeting_id: str, host_email: str, send_email: bool,
                                         items: list[BreakoutSessionObject]) -> list[GetBreakoutSessionObject]:
        """
        Update Meeting Breakout Sessions

        Updates breakout sessions of a meeting with a specified meeting ID in the pre-meeting state. Only applies to
        meeting series and scheduled meetings. Doesn't apply to ongoing or ended meeting instances.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param items: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They
            allow a subset of participants to collaborate and share ideas over audio and video. Use breakout sessions
            for workshops, classrooms, or for when you need a moment to talk privately with a few participants outside
            of the main session. Please note that maximum number of breakout sessions in a meeting or webinar is 100.
            In webinars, if hosts preassign attendees to breakout sessions, the role of `attendee` will be changed to
            `panelist`. Breakout session is not supported for a meeting with simultaneous interpretation.
        :type items: list[BreakoutSessionObject]
        :rtype: list[GetBreakoutSessionObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        body['items'] = loads(TypeAdapter(list[BreakoutSessionObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().put(url, json=body)
        r = TypeAdapter(list[GetBreakoutSessionObject]).validate_python(data['items'])
        return r

    def list_meeting_breakout_sessions(self, meeting_id: str) -> list[GetBreakoutSessionObject]:
        """
        List Meeting Breakout Sessions

        Lists meeting breakout sessions for a meeting with a specified `meetingId`.

        Applies to meeting series, scheduled meetings, ongoing and ended meeting instances. It lists the breakout
        sessions in the pre-meeting state when `meetingId` is a meeting series, scheduled meeting, or an ended meeting
        instance. It lists the real-time in-meeting breakout sessions when `meetingId` is an ongoing meeting instance.
        The breakout session ID listed in the response cannot be used in the `Admit Participants
        <https://developer.webex.com/docs/api/v1/meeting-participants/admit-participants>`_ API if the `meetingId`
        is not an ongoing meeting instance. See the `Webex Meetings
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ guide for more information about the types of
        meetings.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series, scheduled
            meeting and ended or ongoing meeting instance objects. Please note that currently meeting ID of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :rtype: list[GetBreakoutSessionObject]
        """
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().get(url)
        r = TypeAdapter(list[GetBreakoutSessionObject]).validate_python(data['items'])
        return r

    def delete_meeting_breakout_sessions(self, meeting_id: str, send_email: bool = None):
        """
        Delete Meeting Breakout Sessions

        Deletes breakout sessions with a specified meeting ID. The deleted breakout sessions cannot be recovered. The
        value of `enabledBreakoutSessions` attribute is set to `false` automatically.
        Only applies to meeting series and scheduled meetings. Doesn't apply to ongoing or ended meeting instances.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/breakoutSessions')
        super().delete(url, params=params)

    def get_a_meeting_survey(self, meeting_id: str) -> SurveyObject:
        """
        Get a Meeting Survey

        Retrieves details for a meeting survey identified by `meetingId`.

        #### Request Header

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return recording details of that user.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str
        :rtype: :class:`SurveyObject`
        """
        url = self.ep(f'{meeting_id}/survey')
        data = super().get(url)
        r = SurveyObject.model_validate(data)
        return r

    def list_meeting_survey_results(self, meeting_id: str, meeting_start_time_from: Union[str, datetime] = None,
                                    meeting_start_time_to: Union[str, datetime] = None,
                                    **params) -> Generator[SurveyResultObject, None, None]:
        """
        List Meeting Survey Results

        Retrieves results for a meeting survey identified by `meetingId`.

        #### Request Header

        * `timezone`: Time zone for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return recording details of that user.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str
        :param meeting_start_time_from: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the
            meeting objects being requested. `meetingStartTimeFrom` cannot be after `meetingStartTimeTo`. This
            parameter will be ignored if `meetingId` is the unique identifier for the specific meeting instance.
        When `meetingId` is not the unique identifier for the specific meeting instance, the `meetingStartTimeFrom`, if
        not specified, equals `meetingStartTimeTo` minus `1` month; if `meetingStartTimeTo` is also not specified, the
        default value for `meetingStartTimeFrom` is `1` month before the current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting
            objects being requested. `meetingStartTimeTo` cannot be prior to `meetingStartTimeFrom`. This parameter
            will be ignored if `meetingId` is the unique identifier for the specific meeting instance.
        When `meetingId` is not the unique identifier for the specific meeting instance, if `meetingStartTimeFrom` is
        also not specified, the default value for `meetingStartTimeTo` is the current date and time;For example,if
        `meetingStartTimeFrom` is a month ago, the default value for `meetingStartTimeTo` is `1` month after
        `meetingStartTimeFrom`.Otherwise it is the current date and time.
        :type meeting_start_time_to: Union[str, datetime]
        :return: Generator yielding :class:`SurveyResultObject` instances
        """
        if meeting_start_time_from is not None:
            if isinstance(meeting_start_time_from, str):
                meeting_start_time_from = isoparse(meeting_start_time_from)
            meeting_start_time_from = dt_iso_str(meeting_start_time_from)
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            if isinstance(meeting_start_time_to, str):
                meeting_start_time_to = isoparse(meeting_start_time_to)
            meeting_start_time_to = dt_iso_str(meeting_start_time_to)
            params['meetingStartTimeTo'] = meeting_start_time_to
        url = self.ep(f'{meeting_id}/surveyResults')
        return self.session.follow_pagination(url=url, model=SurveyResultObject, item_key='items', params=params)

    def create_invitation_sources(self, meeting_id: str, host_email: str = None, person_id: str = None,
                                  items: list[InvitationSourceCreateObject] = None) -> list[InvitationSourceObject]:
        """
        Create Invitation Sources

        Creates one or more invitation sources for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param person_id: Unique identifier for the meeting host. Should only be set if the user or application calling
            the API has the admin-level scopes. When used, the admin may specify the email of a user in a site they
            manage to be the meeting host.
        :type person_id: str
        :type items: list[InvitationSourceCreateObject]
        :rtype: list[InvitationSourceObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['personId'] = person_id
        body['items'] = loads(TypeAdapter(list[InvitationSourceCreateObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().post(url, json=body)
        r = TypeAdapter(list[InvitationSourceObject]).validate_python(data['items'])
        return r

    def list_invitation_sources(self, meeting_id: str) -> list[InvitationSourceObject]:
        """
        List Invitation Sources

        Lists invitation sources for a meeting.

        #### Request Header

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return recording details of that user.

        * `personId`:  Unique identifier for the meeting host. This attribute should only be set if the user or
        application calling the API has the admin-level scopes. When used, the admin may specify the email of a user
        in a site they manage to be the meeting host.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str
        :rtype: list[InvitationSourceObject]
        """
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().get(url)
        r = TypeAdapter(list[InvitationSourceObject]).validate_python(data['items'])
        return r

    def list_meeting_tracking_codes(self, service: str, site_url: str = None,
                                    host_email: str = None) -> MeetingTrackingCodesObject:
        """
        List Meeting Tracking Codes

        Lists tracking codes on a site by a meeting host. The result indicates which tracking codes and what options
        can be used to create or update a meeting on the specified site.

        * The `options` here differ from those in the `site-level tracking codes
        <https://developer.webex.com/docs/api/v1/tracking-codes/get-a-tracking-code>`_ and the `user-level tracking codes
        is the result of a selective combination of the two.

        * For a tracking code, if there is no user-level tracking code, the API returns the site-level options, and the
        `defaultValue` of the site-level default option is `true`. If there is a user-level tracking code, it is
        merged into the `options`. Meanwhile, the `defaultValue` of this user-level option is `true` and the
        site-level default option becomes non default.

        * If `siteUrl` is specified, tracking codes of the specified site will be listed; otherwise, tracking codes of
        the user's preferred site will be listed. All available Webex sites and the preferred sites of a user can be
        retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        :param service: Service for schedule or sign-up pages.
        :type service: str
        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :rtype: :class:`MeetingTrackingCodesObject`
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        params['service'] = service
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep('trackingCodes')
        data = super().get(url, params=params)
        r = MeetingTrackingCodesObject.model_validate(data)
        return r

    def reassign_meetings_to_a_new_host(self, host_email: str = None,
                                        meeting_ids: list[str] = None) -> list[ReassignMeetingResponseObject]:
        """
        Reassign Meetings to a New Host

        Reassigns a list of meetings to a new host by an admin user.

        All the meetings of `meetingIds` should belong to the same site, which is the `siteUrl` in the request header,
        if specified, or the admin user's preferred site, if not specified. All available Webex sites and the
        preferred sites of a user can be retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        If the user of `hostEmail` is not qualified to be a host of the target site, the API returns an error with the
        HTTP status code `403`. If all the meetings referenced by `meetingIds` have been reassigned the new host
        successfully, the API returns an empty response with the HTTP status code `204`. Otherwise, if all the
        meetings of `meetingIds` fail or some of them fail, the API returns a "Multi-Status" response with status code
        of `207`, and individual errors for each meeting in the response body.

        Only IDs of meeting series are supported for the `meetingIds`. IDs of scheduled meetings, meeting instances, or
        scheduled personal room meetings are not supported. See the `Meetings Overview
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about the
        types of meetings.

        There are several limitations when reassigning meetings:

        * Users cannot assign an in-progress meeting.

        * Users cannot assign a meeting to a user who is not a Webex user, or an attendee who does not have host
        privilege.

        * Users cannot assign a meeting with calling/callback to a host user who does not have calling/callback
        privileges

        * Users cannot assign a meeting with session type A to a host user who does not have session type A privileges.

        * Users cannot assign an MC or Webinar to a new host who does not have an MC license or a Webinar license.

        * Users cannot assign a TC/EC1.0/SC meeting, or a meeting that is created by on-behalf to a new host.

        * Users cannot assign meetings from third-party integrations, such as meetings integrated with Outlook or
        Google.

        #### Request Header

        * `siteUrl`: Optional request header parameter. All the meetings of `meetingIds` should belong to the site
        referenced by siteUrl if specified. Otherwise, the meetings should belong to the admin user's preferred sites.
        All available Webex sites and the preferred sites of a user can be retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        :param host_email: Email address of the new meeting host.
        :type host_email: str
        :param meeting_ids: List of meeting series IDs to be reassigned the new host. The size is between 1 and 100.
            All the meetings of `meetingIds` should belong to the same site, which is the `siteUrl` in the request
            header, if specified, or the admin user's preferred site, if not specified. All available Webex sites and
            the preferred sites of a user can be retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type meeting_ids: list[str]
        :rtype: list[ReassignMeetingResponseObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['meetingIds'] = meeting_ids
        url = self.ep('reassignHost')
        data = super().post(url, json=body)
        r = TypeAdapter(list[ReassignMeetingResponseObject]).validate_python(data['items'])
        return r

    def end_a_meeting(self):
        """
        End a Meeting

        Ends a meeting with a specified meeting ID. This operation applies to meeting series, scheduled meetings, and
        in-progress meetings on a non-converged site, but does not apply to meetings on a converged site. Only the
        meeting host, cohost, or compliance officer can end a meeting with this API.

        * If the `meetingId` value specified is for a scheduled meeting, the operation ends that meeting without
        impacting other scheduled meetings of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation ends the current meeting
        occurrence.

        :rtype: None
        """
        url = self.ep('{meetingId}/end')
        super().post(url)


class MeetingsWithAudioWatermarkApi(ApiChild, base='meetings'):
    """
    Meetings with audio watermark
    
    Meetings are virtual conferences where users can collaborate in real time using audio, video, content sharing,
    chat, online whiteboards, and to collaborate.
    
    This API focuses primarily on the scheduling and management of meetings. You can use the Meetings API to list,
    create, get, update, and delete meetings.
    
    Several types of meeting objects are supported by this API, such as meeting series, scheduled meeting, and ended or
    in-progress meeting instances. See the `Meetings Overview
    <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about the types of meetings.
    
    Refer to the `Meetings API Scopes` section of `Meetings Overview
    <https://developer.webex.com/docs/meetings>`_ for scopes required for each API.
    """

    def create_a_meeting(self, adhoc: bool, room_id: str, template_id: str, title: str, agenda: str, password: str,
                         start: Union[str, datetime], end: Union[str, datetime], timezone: str, recurrence: str,
                         enabled_auto_record_meeting: bool, allow_any_user_to_be_co_host: bool,
                         enabled_join_before_host: bool, enable_connect_audio_before_host: bool,
                         join_before_host_minutes: int, exclude_password: bool, public_meeting: bool,
                         reminder_time: int,
                         unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                         session_type_id: int, scheduled_type: MeetingSeriesObjectScheduledType,
                         enabled_webcast_view: bool, panelist_password: str, enable_automatic_lock: bool,
                         automatic_lock_minutes: int, allow_first_user_to_be_co_host: bool,
                         allow_authenticated_devices: bool, invitees: list[InviteeObjectForCreateMeeting],
                         send_email: bool, host_email: str, site_url: str,
                         meeting_options: MeetingSeriesObjectMeetingOptions,
                         attendee_privileges: MeetingSeriesObjectAttendeePrivileges,
                         registration: CreateMeetingObjectRegistration, integration_tags: list[str],
                         simultaneous_interpretation: CreateMeetingObjectSimultaneousInterpretation,
                         enabled_breakout_sessions: bool, breakout_sessions: list[BreakoutSessionObject],
                         enabled_audio_watermark: bool, tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                         audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                         require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObjectWithAdhoc1:
        """
        Create a Meeting

        Creates a new meeting. Regular users can schedule up to 100 meetings in 24 hours and admin users up to 3000.
        Please note that the failed requests are also counted toward the limits.

        * If the parameter `adhoc` is `true` and `roomId` is specified, an ad-hoc meeting is created for the target
        room. An ad-hoc meeting is a non-recurring instant meeting for the target room which is supposed to be started
        immediately after being created for a quick collaboration. There's only one ad-hoc meeting for a room at the
        same time. So, if there's already an ongoing ad-hoc meeting for the room, the API returns this ongoing meeting
        instead of creating a new one. If it's a `direct
        <https://developer.webex.com/docs/api/v1/rooms/get-room-details>`_ room, both members of the room can create an ad-hoc meeting
        for the room. If it's a `group
        <https://developer.webex.com/docs/api/v1/rooms/get-room-details>`_ room, only room members that are in the same `organization
        an ad-hoc meeting for the room. Please note that an ad-hoc meeting is for the purpose of an instant
        collaboration with people in a room, user should not persist the `id` and `meetingNumber` of the ad-hoc
        meeting when it's been created since this meeting may become an inactive ad-hoc meeting for the room if it's
        not been started after being created for a while or it has been started and ended. Each time a user needs an
        ad-hoc meeting for a room, they should create one instead of reusing the previous persisted one. Moreover, for
        the same reason, no email will be sent when an ad-hoc meeting is created. Ad-hoc meetings cannot be updated by
        `Update a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ or deleted by `Delete a Meeting
        scheduled meetings of an ad-hoc meeting cannot be listed by `List Meetings of a Meeting Series
        <https://developer.webex.com/docs/api/v1/meetings/list-meetings-of-a-meeting-series>`_, but the ended
        and ongoing instances of ad-hoc meetings can be listed by `List Meetings
        <https://developer.webex.com/docs/api/v1/meetings/list-meetings>`_ and `List Meetings of a Meeting Series

        * If the parameter `adhoc` is `true`, `roomId` is required and the others are optional or ignored.

        * The default value of `title` for an ad-hoc meeting is the user's name if not specified. The following
        parameters for an ad-hoc meeting have default values and the user's input values will be ignored:
        `scheduledType` is always `meeting`; `start` and `end` are 5 minutes after the current time and 20 minutes
        after the current time respectively; `timezone` is `UTC`; `allowAnyUserToBeCoHost`,
        `allowAuthenticatedDevices`, `enabledJoinBeforeHost`, `enableConnectAudioBeforeHost` are always `true`;
        `allowFirstUserToBeCoHost`, `enableAutomaticLock`, `publicMeeting`, `sendEmail` are always `false`; `invitees`
        is the room members except "me"; `joinBeforeHostMinutes` is 5; `automaticLockMinutes` is null;
        `unlockedMeetingJoinSecurity` is `allowJoinWithLobby`. An ad-hoc meeting can be started immediately even if
        the `start` is 5 minutes after the current time.

        * The following parameters are not supported and will be ignored for an ad-hoc meeting: `templateId`,
        `recurrence`, `excludePassword`, `reminderTime`, `registration`, `integrationTags`, `enabledWebcastView`, and
        `panelistPassword`.

        * If the value of the parameter `recurrence` is null, a non-recurring meeting is created.

        * If the parameter `recurrence` has a value, a recurring meeting is created based on the rule defined by the
        value of `recurrence`. For a non-recurring meeting which has no `recurrence` value set, its `meetingType` is
        also `meetingSeries` which is a meeting series with only one occurrence in Webex meeting modeling.

        * If the parameter `templateId` has a value, the meeting is created based on the meeting template specified by
        `templateId`. The list of meeting templates that is available for the authenticated user can be retrieved from
        `List Meeting Templates
        <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_.

        * If the parameter `siteUrl` has a value, the meeting is created on the specified site. Otherwise, the meeting
        is created on the user's preferred site. All available Webex sites and preferred site of the user can be
        retrieved by `Get Site List` API.

        * If the parameter `scheduledType` equals "personalRoomMeeting", the meeting is created in the user's
        `personal room
        <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.

        * If the parameter `roomId` has a value, the meeting is created for the Webex space specified by `roomId`. If
        `roomId` is specified but the user calling the API is not a member of the Webex space specified by `roomId`,
        the API will fail even if the user has the admin-level scopes or he is calling the API on behalf of another
        user which is specified by `hostEmail` and is a member of the Webex space.

        * If the parameter `enabledAudioWatermark` is `true`, `scheduledType` equals "meeting" and
        `audioConnectionOptions.audioConnectionType` equals "VoIP", The audio for this meeting will have a watermark,
        in this case a unique identifier is embedded into the audio that plays out of each Webex app and device. An
        administrator can use this watermark when analyzing an unauthorized recording to identify which Webex app or
        device was the source of the recording.

        :param adhoc: Whether or not to create an ad-hoc meeting for the room specified by `roomId`. When `true`,
            `roomId` is required.
        :type adhoc: bool
        :param room_id: Unique identifier for the Webex space which the meeting is to be associated with. It can be
            retrieved by `List Rooms
            <https://developer.webex.com/docs/api/v1/rooms/list-rooms>`_. `roomId` is required when `adhoc` is `true`. When `roomId` is specified, the
            parameter `hostEmail` will be ignored.
        :type room_id: str
        :param template_id: Unique identifier for meeting template. Please note that `start` and `end` are optional
            when `templateId` is specified. The list of meeting templates that is available for the authenticated user
            can be retrieved from `List Meeting Templates
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_. This parameter is ignored for an ad-hoc meeting.
        :type template_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long. The default value for an ad-hoc
            meeting is the user's name if not specified.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password
            rules will be generated automatically.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 24 hours. Please note that when a meeting is being scheduled, `start` of the meeting will
            be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is within the same minute as
            the current time, `start` will be adjusted to the upcoming minute; otherwise, `start` will be adjusted
            with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`. The default value for an
            ad-hoc meeting is 5 minutes after the current time and the user's input value will be ignored. An ad-hoc
            meeting can be started immediately even if the `start` is 5 minutes after the current time.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 24 hours. Please note that when a meeting is being scheduled, `end` of the meeting
            will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be adjusted with seconds
            and milliseconds stripped off. For instance, `end` of `2022-03-01T11:52:28.076+08:00` or
            `2022-03-01T11:52:41+08:00` will be adjusted to `2022-03-01T11:52:00+08:00`. The default value for an
            ad-hoc meeting is 20 minutes after the current time and the user's input value will be ignored.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_). The default value for an ad-hoc meeting is `UTC` and the user's input value will
            be ignored.
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_), applying only to meeting series.
            It doesn't apply to a scheduled meeting or an ended or ongoing meeting instance. This parameter is ignored
            for an ad-hoc meeting. Multiple days or dates for monthly or yearly `recurrence` rule are not supported,
            only the first day or date specified is taken. For example,
            "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported
            as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's the user's preferred site. The default value for an ad-hoc
            meeting is `true` and the user's input value will be ignored.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting. The default value for an ad-hoc meeting is `true` and the user's input value will be ignored.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true. The default value for an ad-hoc meeting is `true` and the user's input value
            will be ignored.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. This attribute is only applicable if the `enabledJoinBeforeHost` attribute is set
            to true. Valid options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are
            `0`, `15`, `30`, `45`, and `60`. The default value for an ad-hoc meeting is 0 and the user's input value
            will be ignored.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation. This
            parameter is ignored for an ad-hoc meeting.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar. The default
            value for an ad-hoc meeting is `false` and the user's input value will be ignored.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host. This parameter is ignored for an ad-hoc meeting.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting. The default value for an ad-hoc meeting is `allowJoinWithLobby` and the user's input value will
            be ignored.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            when scheduling a webinar meeting. All available meeting session types enabled for the user can be
            retrieved using the `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param scheduled_type: When set as an attribute in a POST request body, specifies whether it's a regular
            meeting, a webinar, or a meeting scheduled in the user's `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_. If not specified, it's a regular
            meeting by default. The default value for an ad-hoc meeting is `meeting` and the user's input value will
            be ignored.
        :type scheduled_type: MeetingSeriesObjectScheduledType
        :param enabled_webcast_view: Whether or not webcast view is enabled. This parameter is ignored for an ad-hoc
            meeting.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically. This parameter is ignored for an ad-hoc
            meeting.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts. The default
            value for an ad-hoc meeting is `false` and the user's input value will be ignored.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
            The default value for an ad-hoc meeting is null and the user's input value will be ignored.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site. The default value for an ad-hoc
            meeting is `false` and the user's input value will be ignored.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt. The default value for an ad-hoc meeting is
            `true` and the user's input value will be ignored.
        :type allow_authenticated_devices: bool
        :param invitees: Invitees for meeting. The maximum size of invitees is 1000. If `roomId` is specified and
            `invitees` is missing, all the members in the space are invited implicitly. If both `roomId` and
            `invitees` are specified, only those in the `invitees` list are invited. `coHost` for each invitee is
            `true` by default if `roomId` is specified when creating a meeting, and anyone in the invitee list that is
            not qualified to be a cohost will be invited as a non-cohost invitee. The user's input value will be
            ignored for an ad-hoc meeting and the the members of the room specified by `roomId` except "me" will be
            used by default.
        :type invitees: list[InviteeObjectForCreateMeeting]
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true. The default value for an ad-hoc meeting is `false` and the user's input value will be
            ignored.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is created on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param registration: Meeting registration. When this option is enabled, meeting invitees must register personal
            information to join the meeting. Meeting invitees will receive an email with a registration link for the
            registration. When the registration form has been submitted and approved, an email with a real meeting
            link will be received. By clicking that link the meeting invitee can join the meeting. Please note that
            meeting registration does not apply to a meeting when it's a recurring meeting with a recurrence field or
            no password, or the Join Before Host option is enabled for the meeting. See
            `Register for a Meeting in Cisco Webex Meetings
            <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for details. This parameter is ignored for an ad-hoc
            meeting.
        :type registration: CreateMeetingObjectRegistration
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. This parameter is ignored for an ad-hoc meeting.
        :type integration_tags: list[str]
        :param simultaneous_interpretation: Simultaneous interpretation information for a meeting.
        :type simultaneous_interpretation: CreateMeetingObjectSimultaneousInterpretation
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled.
        :type enabled_breakout_sessions: bool
        :param breakout_sessions: Breakout sessions are smaller groups that are split off from the main meeting or
            webinar. They allow a subset of participants to collaborate and share ideas over audio and video. Use
            breakout sessions for workshops, classrooms, or for when you need a moment to talk privately with a few
            participants outside of the main session. Please note that maximum number of breakout sessions in a
            meeting or webinar is 100. In webinars, if hosts preassign attendees to breakout sessions, the role of
            `attendee` will be changed to `panelist`. Breakout session is not supported for a meeting with
            simultaneous interpretation.
        :type breakout_sessions: list[BreakoutSessionObject]
        :param enabled_audio_watermark: Whether or not audio watermark is enabled.
        :type enabled_audio_watermark: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObjectWithAdhoc1`
        """
        body = dict()
        body['adhoc'] = adhoc
        body['roomId'] = room_id
        body['templateId'] = template_id
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['scheduledType'] = enum_str(scheduled_type)
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['invitees'] = loads(TypeAdapter(list[InviteeObjectForCreateMeeting]).dump_json(invitees))
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['registration'] = loads(registration.model_dump_json())
        body['integrationTags'] = integration_tags
        body['simultaneousInterpretation'] = loads(simultaneous_interpretation.model_dump_json())
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['breakoutSessions'] = loads(TypeAdapter(list[BreakoutSessionObject]).dump_json(breakout_sessions))
        body['enabledAudioWatermark'] = enabled_audio_watermark
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep()
        data = super().post(url, json=body)
        r = MeetingSeriesObjectWithAdhoc1.model_validate(data)
        return r

    def get_a_meeting(self, meeting_id: str, current: bool = None,
                      host_email: str = None) -> MeetingSeriesObjectWithAdhoc1:
        """
        Get a Meeting

        Retrieves details for a meeting with a specified meeting ID.

        * If the `meetingId` value specified is for a meeting series and `current` is `true`, the operation returns
        details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or
        the upcoming scheduled meeting of the meeting series.

        * If the `meetingId` value specified is for a meeting series and `current` is `false` or `current` is not
        specified, the operation returns details for the entire meeting series.

        * If the `meetingId` value specified is for a scheduled meeting from a meeting series, the operation returns
        details for that scheduled meeting.

        * If the `meetingId` value specified is for a meeting instance which is happening or has happened, the
        operation returns details for that meeting instance.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_id: Unique identifier for the meeting being requested.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`MeetingSeriesObjectWithAdhoc1`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}')
        data = super().get(url, params=params)
        r = MeetingSeriesObjectWithAdhoc1.model_validate(data)
        return r

    def list_meetings(self, meeting_number: str = None, web_link: str = None, room_id: str = None,
                      meeting_type: MeetingSeriesObjectMeetingType = None, state: MeetingSeriesObjectState = None,
                      scheduled_type: MeetingSeriesObjectScheduledType = None, is_modified: bool = None,
                      has_chat: bool = None, has_recording: bool = None, has_transcription: bool = None,
                      has_closed_caption: bool = None, has_polls: bool = None, has_qa: bool = None,
                      current: bool = None, from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                      host_email: str = None, site_url: str = None, integration_tag: str = None,
                      **params) -> Generator[MeetingSeriesObjectForListMeeting1, None, None]:
        """
        List Meetings

        Retrieves details for meetings with a specified meeting number, web link, meeting type, etc. Please note that
        there are various products in the `Webex Suite
        <https://www.webex.com/collaboration-suite.html>`_ such as `Meetings` and `Events`. Currently, only meetings of the
        `Meetings` product are supported by this API, meetings of others in the suite are not supported. Ad-hoc
        meetings created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` will not be listed, but the ended
        and ongoing ad-hoc meeting instances will be listed.

        * If `meetingNumber` is specified, the operation returns an array of meeting objects specified by the
        `meetingNumber`. Each object in the array can be a scheduled meeting or a meeting series depending on whether
        the `current` parameter is `true` or `false`, and each object contains the simultaneous interpretation object.
        When `meetingNumber` is specified, parameters of `from`, `to`, `meetingType`, `state`, `isModified` and
        `siteUrl` will be ignored. Please note that `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `webLink` is specified, the operation returns an array of meeting objects specified by the `webLink`. Each
        object in the array is a scheduled meeting, and each object contains the simultaneous interpretation object.
        When `webLink` is specified, parameters of `current`, `from`, `to`, `meetingType`, `state`, `isModified` and
        `siteUrl` will be ignored. Please note that `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `roomId` is specified, the operation returns an array of meeting objects of the Webex space specified by
        the `roomId`. When `roomId` is specified, parameters of `current`, `meetingType`, `state` and `isModified`
        will be ignored. The meeting objects are queried on the user's preferred site if no `siteUrl` is specified;
        otherwise, queried on the specified site. `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `state` parameter is specified, the returned array only has items in the specified state. If `state` is
        not specified, return items of all states.

        * If `meetingType` equals "meetingSeries", the `scheduledType` parameter can be "meeting", "webinar" or null.
        If `scheduledType` is specified, the returned array only has items of the specified scheduled type; otherwise,
        it has items of "meeting" and "webinar".

        * If `meetingType` equals "scheduledMeeting", the `scheduledType` parameter can be "meeting", "webinar",
        "personalRoomMeeting" or null. If `scheduledType` is specified, the returned array only has items of the
        specified scheduled type; otherwise, it has items of all scheduled types.

        * If `meetingType` equals "meeting", the `scheduledType` parameter can be "meeting", "webinar" or null. If
        `scheduledType` is specified, the returned array only has items of the specified scheduled type; otherwise, it
        has items of "meeting" and "webinar". Please note that ended or in-progress meeting instances of `personal room
        <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_
        also fall into the category of "meeting" `scheduledType`.

        * If `isModified` parameter is specified, the returned array only has items which have been modified to
        exceptional meetings. This parameter only applies to scheduled meeting.

        * If any of the `hasChat`, `hasRecording`, `hasTranscription`, `hasClosedCaption`, `hasPolls ` and `hasQA`
        parameters is specified, the `meetingType` must be "meeting" and `state` must be "ended". These parameters are
        null by default.

        * The `current` parameter only applies to meeting series. If it's `true`, the `start` and `end` attributes of
        each returned meeting series object are for the first scheduled meeting of that series. If it's `true` or not
        specified, the `start` and `end` attributes are for the scheduled meeting which is ready to start or join or
        the upcoming scheduled meeting of that series.

        * If `from` and `to` are specified, the operation returns an array of meeting objects in that specified time
        range.

        * If the parameter `siteUrl` has a value, the operation lists meetings on the specified site; otherwise, lists
        meetings on the user's all sites. All available Webex sites of the user can be retrieved by `Get Site List`
        API.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_number: Meeting number for the meeting objects being requested. `meetingNumber`, `webLink` and
            `roomId` are mutually exclusive. If it's an exceptional meeting from a meeting series, the exceptional
            meeting instead of the primary meeting series is returned.
        :type meeting_number: str
        :param web_link: URL encoded link to information page for the meeting objects being requested. `meetingNumber`,
            `webLink` and `roomId` are mutually exclusive.
        :type web_link: str
        :param room_id: Associated Webex space ID for the meeting objects being requested. `meetingNumber`, `webLink`
            and `roomId` are mutually exclusive.
        :type room_id: str
        :param meeting_type: Meeting type for the meeting objects being requested. This parameter will be ignored if
            `meetingNumber`, `webLink` or `roomId` is specified.
        :type meeting_type: MeetingSeriesObjectMeetingType
        :param state: Meeting state for the meeting objects being requested. If not specified, return meetings of all
            states. This parameter will be ignored if `meetingNumber`, `webLink` or `roomId` is specified. Details of
            an `ended` meeting will only be available 15 minutes after the meeting has ended. `inProgress` meetings
            are not fully supported. The API will try to return details of an `inProgress` meeting 15 minutes after
            the meeting starts. However, it may take longer depending on the traffic. See the `Webex Meetings
            <https://developer.webex.com/docs/meetings#meeting-states>`_ guide for
            more information about the states of meetings.
        :type state: MeetingSeriesObjectState
        :param scheduled_type: Scheduled type for the meeting objects being requested.
        :type scheduled_type: MeetingSeriesObjectScheduledType
        :param is_modified: Flag identifying whether a meeting has been modified. Only applies to scheduled meetings.
            If `true`, only return modified scheduled meetings; if `false`, only return unmodified scheduled meetings;
            if not specified, all scheduled meetings will be returned.
        :type is_modified: bool
        :param has_chat: Flag identifying whether a meeting has a chat log. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have chats; if `false`, only return meeting instances which
            have no chats; if not specified, all meeting instances will be returned.
        :type has_chat: bool
        :param has_recording: Flag identifying meetings with recordings. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have recordings; if `false`, only return meeting instances
            which have no recordings; if not specified, all meeting instances will be returned.
        :type has_recording: bool
        :param has_transcription: Flag identifying meetings with transcripts. Only applies to ended meeting instances.
            If `true`, only return meeting instances which have transcripts; if `false`, only return meeting instances
            which have no transcripts; if not specified, all meeting instances will be returned.
        :type has_transcription: bool
        :param has_closed_caption: Flag identifying meetings with closed captions. Only applies to ended meeting
            instances. If `true`, only return meeting instances which have closed captions; if `false`, only return
            meeting instances which have no closed captions; if not specified, all meeting instances will be returned.
        :type has_closed_caption: bool
        :param has_polls: Flag identifying meetings with polls. Only applies to ended meeting instances. If `true`,
            only return meeting instances which have polls; if `false`, only return meeting instances which have no
            polls; if not specified, all meeting instances will be returned.
        :type has_polls: bool
        :param has_qa: Flag identifying meetings with Q&A. Only applies to ended meeting instances. If `true`, only
            return meeting instances which have Q&A; if `false`, only return meeting instances which have no Q&A; if
            not specified, all meeting instances will be returned.
        :type has_qa: bool
        :param current: Flag identifying to retrieve the current scheduled meeting of the meeting series or the entire
            meeting series. This parameter only applies to scenarios where `meetingNumber` is specified and the
            meeting is not an exceptional meeting from a meeting series. If it's `true`, return the scheduled meeting
            of the meeting series which is ready to join or start or the upcoming scheduled meeting of the meeting
            series; if it's `false`, return the entire meeting series.
        :type current: bool
        :param from_: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being
            requested. `from` cannot be after `to`. This parameter will be ignored if `meetingNumber`, `webLink` or
            `roomId` is specified.
        :type from_: Union[str, datetime]
        :param to_: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being
            requested. `to` cannot be before `from`. This parameter will be ignored if `meetingNumber`, `webLink` or
            `roomId` is specified.
        :type to_: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for meetings that are hosted by that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meetings from. If not specified, the API lists
            meetings from user's all sites. All available Webex sites of the user can be retrieved by `Get Site List`
            API.
        :type site_url: str
        :param integration_tag: External key created by an integration application. This parameter is used by the
            integration application to query meetings by a key in its own domain such as a Zendesk ticket ID, a Jira
            ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str
        :return: Generator yielding :class:`MeetingSeriesObjectForListMeeting1` instances
        """
        if meeting_number is not None:
            params['meetingNumber'] = meeting_number
        if web_link is not None:
            params['webLink'] = web_link
        if room_id is not None:
            params['roomId'] = room_id
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if scheduled_type is not None:
            params['scheduledType'] = scheduled_type
        if is_modified is not None:
            params['isModified'] = str(is_modified).lower()
        if has_chat is not None:
            params['hasChat'] = str(has_chat).lower()
        if has_recording is not None:
            params['hasRecording'] = str(has_recording).lower()
        if has_transcription is not None:
            params['hasTranscription'] = str(has_transcription).lower()
        if has_closed_caption is not None:
            params['hasClosedCaption'] = str(has_closed_caption).lower()
        if has_polls is not None:
            params['hasPolls'] = str(has_polls).lower()
        if has_qa is not None:
            params['hasQA'] = str(has_qa).lower()
        if current is not None:
            params['current'] = str(current).lower()
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        url = self.ep()
        return self.session.follow_pagination(url=url, model=MeetingSeriesObjectForListMeeting1, item_key='items', params=params)

    def list_meetings_of_a_meeting_series(self, meeting_series_id: str, from_: Union[str, datetime] = None,
                                          to_: Union[str, datetime] = None,
                                          meeting_type: ListMeetingsOfAMeetingSeriesMeetingType = None,
                                          state: ListMeetingsOfAMeetingSeriesState = None, is_modified: bool = None,
                                          has_chat: bool = None, has_recording: bool = None,
                                          has_transcription: bool = None, has_closed_caption: bool = None,
                                          has_polls: bool = None, has_qa: bool = None, host_email: str = None,
                                          **params) -> Generator[ScheduledMeetingObject1, None, None]:
        """
        List Meetings of a Meeting Series

        Lists scheduled meeting and meeting instances of a meeting series identified by `meetingSeriesId`. Scheduled
        meetings of an ad-hoc meeting created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` will not be
        listed, but the ended and ongoing meeting instances of it will be listed.

        Each _scheduled meeting_ or _meeting_ instance of a _meeting series_ has its own `start`, `end`, etc. Thus, for
        example, when a daily meeting has been scheduled from `2019-04-01` to `2019-04-10`, there are 10 scheduled
        meeting instances in this series, one instance for each day, and each one has its own attributes. When a
        scheduled meeting has been started and ended or is happening, there are even more ended or in-progress meeting
        instances.

        Use this operation to list scheduled meeting and meeting instances of a meeting series within a specific date
        range.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * If any of the `hasChat`, `hasRecording`, `hasTranscription`, `hasClosedCaption`, `hasPolls ` and `hasQA`
        parameters is specified, the `meetingType` must be "meeting" and `state` must be "ended". These parameters are
        null by default.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_series_id: Unique identifier for the meeting series. Please note that currently meeting ID of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_series_id: str
        :param from_: Start date and time (inclusive) for the range for which meetings are to be returned in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot be after `to`.
        :type from_: Union[str, datetime]
        :param to_: End date and time (exclusive) for the range for which meetings are to be returned in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. `to` cannot be before `from`.
        :type to_: Union[str, datetime]
        :param meeting_type: Meeting type for the meeting objects being requested. If not specified, return meetings of
            all types.
        :type meeting_type: ListMeetingsOfAMeetingSeriesMeetingType
        :param state: Meeting state for the meetings being requested. If not specified, return meetings of all states.
            Details of an `ended` meeting will only be available 15 minutes after the meeting has ended. `inProgress`
            meetings are not fully supported. The API will try to return details of an `inProgress` meeting 15 minutes
            after the meeting starts. However, it may take longer depending on the traffic. See the `Webex Meetings
            <https://developer.webex.com/docs/meetings#meeting-states>`_
            guide for more information about the states of meetings.
        :type state: ListMeetingsOfAMeetingSeriesState
        :param is_modified: Flag identifying whether a meeting has been modified. Only applies to scheduled meetings.
            If `true`, only return modified scheduled meetings; if `false`, only return unmodified scheduled meetings;
            if not specified, all scheduled meetings will be returned.
        :type is_modified: bool
        :param has_chat: Flag identifying whether a meeting has a chat log. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have chats; if `false`, only return meeting instances which
            have no chats; if not specified, all meeting instances will be returned.
        :type has_chat: bool
        :param has_recording: Flag identifying meetings with recordings. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have recordings; if `false`, only return meeting instances
            which have no recordings; if not specified, all meeting instances will be returned.
        :type has_recording: bool
        :param has_transcription: Flag identifying meetings with transcripts. Only applies to ended meeting instances.
            If `true`, only return meeting instances which have transcripts; if `false`, only return meeting instances
            which have no transcripts; if not specified, all meeting instances will be returned.
        :type has_transcription: bool
        :param has_closed_caption: Flag identifying meetings with closed captions. Only applies to ended meeting
            instances. If `true`, only return meeting instances which have closed captions; if `false`, only return
            meeting instances which have no closed captions; if not specified, all meeting instances will be returned.
        :type has_closed_caption: bool
        :param has_polls: Flag identifying meetings with polls. Only applies to ended meeting instances. If `true`,
            only return meeting instances which have polls; if `false`, only return meeting instances which have no
            polls; if not specified, all meeting instances will be returned.
        :type has_polls: bool
        :param has_qa: Flag identifying meetings with Q&A. Only applies to ended meeting instances. If `true`, only
            return meeting instances which have Q&A; if `false`, only return meeting instances which have no Q&A; if
            not specified, all meeting instances will be returned.
        :type has_qa: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meetings that are hosted by that user.
        :type host_email: str
        :return: Generator yielding :class:`ScheduledMeetingObject1` instances
        """
        params['meetingSeriesId'] = meeting_series_id
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if is_modified is not None:
            params['isModified'] = str(is_modified).lower()
        if has_chat is not None:
            params['hasChat'] = str(has_chat).lower()
        if has_recording is not None:
            params['hasRecording'] = str(has_recording).lower()
        if has_transcription is not None:
            params['hasTranscription'] = str(has_transcription).lower()
        if has_closed_caption is not None:
            params['hasClosedCaption'] = str(has_closed_caption).lower()
        if has_polls is not None:
            params['hasPolls'] = str(has_polls).lower()
        if has_qa is not None:
            params['hasQA'] = str(has_qa).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ScheduledMeetingObject1, item_key='items', params=params)

    def patch_a_meeting(self, meeting_id: str, title: str, agenda: str, password: str, start: Union[str, datetime],
                        end: Union[str, datetime], timezone: str, recurrence: str, enabled_auto_record_meeting: bool,
                        allow_any_user_to_be_co_host: bool, enabled_join_before_host: bool,
                        enable_connect_audio_before_host: bool, join_before_host_minutes: int, exclude_password: bool,
                        public_meeting: bool, reminder_time: int,
                        unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                        session_type_id: int, enabled_webcast_view: bool, panelist_password: str,
                        enable_automatic_lock: bool, automatic_lock_minutes: int,
                        allow_first_user_to_be_co_host: bool, allow_authenticated_devices: bool, send_email: bool,
                        host_email: str, site_url: str, meeting_options: MeetingSeriesObjectMeetingOptions,
                        attendee_privileges: MeetingSeriesObjectAttendeePrivileges, integration_tags: list[str],
                        enabled_breakout_sessions: bool, tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                        enabled_audio_watermark: bool,
                        audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                        require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObject1:
        """
        Patch a Meeting

        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be updated.

        * If the `meetingId` value specified is for a scheduled meeting, the operation updates that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation updates the entire meeting series.
        **Note**: If the value of `start`, `end`, or `recurrence` for the meeting series is changed, any exceptional
        scheduled meeting in this series is cancelled when the meeting series is updated.

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on
            updating date and time for a meeting. Please note that when a meeting is being updated, `start` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is within the same
            minute as the current time, `start` will be adjusted to the upcoming minute; otherwise, `start` will be
            adjusted with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions
            on updating date and time for a meeting. Please note that when a meeting is being updated, `end` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be adjusted with
            seconds and milliseconds stripped off. For instance, `end` of `2022-03-01T11:52:28.076+08:00` or
            `2022-03-01T11:52:41+08:00` will be adjusted to `2022-03-01T11:52:00+08:00`.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for
            monthly or yearly `recurrence` rule are not supported, only the first day or date specified is taken. For
            example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially
            supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. Only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid
            options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`,
            `45`, and `60`. The default is `0` if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be
            retrieved by `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. Please note that an empty or null
            `integrationTags` will delete all existing integration tags for the meeting implicitly. Developer can
            update integration tags for a `meetingSeries` but he cannot update it for a `scheduledMeeting` or a
            `meeting` instance.
        :type integration_tags: list[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            `enabledBreakoutSessions` is false, users can not set breakout sessions. If the value of
            `enabledBreakoutSessions` is true, users can update breakout sessions using the `Update Breakout Sessions
            <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_
            API. Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param enabled_audio_watermark: Whether or not audio watermark is enabled.
        :type enabled_audio_watermark: bool
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObject1`
        """
        body = dict()
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['integrationTags'] = integration_tags
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['enabledAudioWatermark'] = enabled_audio_watermark
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep(f'{meeting_id}')
        data = super().patch(url, json=body)
        r = MeetingSeriesObject1.model_validate(data)
        return r

    def update_a_meeting(self, meeting_id: str, title: str, agenda: str, password: str, start: Union[str, datetime],
                         end: Union[str, datetime], timezone: str, recurrence: str, enabled_auto_record_meeting: bool,
                         allow_any_user_to_be_co_host: bool, enabled_join_before_host: bool,
                         enable_connect_audio_before_host: bool, join_before_host_minutes: int,
                         exclude_password: bool, public_meeting: bool, reminder_time: int,
                         unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                         session_type_id: int, enabled_webcast_view: bool, panelist_password: str,
                         enable_automatic_lock: bool, automatic_lock_minutes: int,
                         allow_first_user_to_be_co_host: bool, allow_authenticated_devices: bool, send_email: bool,
                         host_email: str, site_url: str, meeting_options: MeetingSeriesObjectMeetingOptions,
                         attendee_privileges: MeetingSeriesObjectAttendeePrivileges, integration_tags: list[str],
                         enabled_breakout_sessions: bool, tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                         enabled_audio_watermark: bool,
                         audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                         require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObject1:
        """
        Update a Meeting

        <div>
        <Callout type="warning">The PUT method is still supported and behaves the same as before, will be deprecated in
        the future. Use the PATCH method instead.</Callout>
        </div>

        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be updated.

        * If the `meetingId` value specified is for a scheduled meeting, the operation updates that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation updates the entire meeting series.
        **Note**: If the value of `start`, `end`, or `recurrence` for the meeting series is changed, any exceptional
        scheduled meeting in this series is cancelled when the meeting series is updated.

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions on
            updating date and time for a meeting. Please note that when a meeting is being updated, `start` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is within the same
            minute as the current time, `start` will be adjusted to the upcoming minute; otherwise, `start` will be
            adjusted with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 24 hours. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about restrictions
            on updating date and time for a meeting. Please note that when a meeting is being updated, `end` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be adjusted with
            seconds and milliseconds stripped off. For instance, `end` of `2022-03-01T11:52:28.076+08:00` or
            `2022-03-01T11:52:41+08:00` will be adjusted to `2022-03-01T11:52:00+08:00`.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for
            monthly or yearly `recurrence` rule are not supported, only the first day or date specified is taken. For
            example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially
            supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. Only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid
            options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`,
            `45`, and `60`. The default is `0` if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be
            retrieved by `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. Please note that an empty or null
            `integrationTags` will delete all existing integration tags for the meeting implicitly. Developer can
            update integration tags for a `meetingSeries` but he cannot update it for a `scheduledMeeting` or a
            `meeting` instance.
        :type integration_tags: list[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            `enabledBreakoutSessions` is false, users can not set breakout sessions. If the value of
            `enabledBreakoutSessions` is true, users can update breakout sessions using the `Update Breakout Sessions
            <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_
            API. Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param enabled_audio_watermark: Whether or not audio watermark is enabled.
        :type enabled_audio_watermark: bool
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObject1`
        """
        body = dict()
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['integrationTags'] = integration_tags
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['enabledAudioWatermark'] = enabled_audio_watermark
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep(f'{meeting_id}')
        data = super().put(url, json=body)
        r = MeetingSeriesObject1.model_validate(data)
        return r

    def delete_a_meeting(self, meeting_id: str, host_email: str = None, send_email: bool = None):
        """
        Delete a Meeting

        Deletes a meeting with a specified meeting ID. The deleted meeting cannot be recovered. This operation applies
        to meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc
        meetings created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be deleted.

        * If the `meetingId` value specified is for a scheduled meeting, the operation deletes that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation deletes the entire meeting series.

        :param meeting_id: Unique identifier for the meeting to be deleted. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will delete a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}')
        super().delete(url, params=params)

    def join_a_meeting(self, meeting_id: str, meeting_number: str, web_link: str, join_directly: bool, email: str,
                       display_name: str, password: str, expiration_minutes: int, registration_id: Union[str,
                       datetime]) -> JoinMeetingLinkObject:
        """
        Join a Meeting

        Retrieves links for a meeting with a specified `meetingId`, `meetingNumber`, or `webLink` that allow users to
        start or join the meeting directly without logging in and entering a password.

        * Please note that `meetingId`, `meetingNumber` and `webLink` are mutually exclusive and they cannot be
        specified simultaneously.

        * If `joinDirectly` is true or not specified, the response will have HTTP response code 302 and the request
        will be redirected to `joinLink`; otherwise, the response will have HTTP response code 200 and `joinLink` will
        be returned in response body.

        * Only the meeting host or cohost can generate the `startLink`.

        * Generating a join link or a start link before the time specified by `joinBeforeHostMinutes` for a webinar is
        not supported.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances. Please note that currently meeting
            ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is also supported for this API.
        :type meeting_id: str
        :param meeting_number: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but
            not to meeting instances which have ended.
        :type meeting_number: str
        :param web_link: Link to a meeting information page where the meeting client is launched if the meeting is
            ready to start or join.
        :type web_link: str
        :param join_directly: Whether or not to redirect to `joinLink`. It is an optional field and default value is
            true.
        :type join_directly: bool
        :param email: Email address of meeting participant. If `email` is specified, the link is generated for the user
            of `email`; otherwise, the API returns the link for the user calling the API. `email` is required for a
            `guest issuer
            <https://developer.webex.com/docs/guest-issuer>`_.
        :type email: str
        :param display_name: Display name of meeting participant. If `displayName` is specified, `email` must be
            specified as well. If `email` is specified and `displayName` is not, display name is the same as `email`.
            If neither `displayName` nor `email` is specified, the API returns the link for the user calling the API.
            The maximum length of `displayName` is 128 characters. `displayName` is required for a `guest issuer
            <https://developer.webex.com/docs/guest-issuer>`_.
        :type display_name: str
        :param password: Required when the meeting is protected by a password and the current user is not privileged to
            view it if they are not a host, cohost, or invitee.
        :type password: str
        :param expiration_minutes: Expiration duration of `joinLink` in minutes. Must be between 1 and 60.
        :type expiration_minutes: int
        :param registration_id: Required when the meeting is webinar-enabled and enabled registration ID.
        :type registration_id: Union[str, datetime]
        :rtype: :class:`JoinMeetingLinkObject`
        """
        body = dict()
        body['meetingId'] = meeting_id
        body['meetingNumber'] = meeting_number
        body['webLink'] = web_link
        body['joinDirectly'] = join_directly
        body['email'] = email
        body['displayName'] = display_name
        body['password'] = password
        body['expirationMinutes'] = expiration_minutes
        body['registrationId'] = registration_id
        url = self.ep('join')
        data = super().post(url, json=body)
        r = JoinMeetingLinkObject.model_validate(data)
        return r

    def list_meeting_templates(self, template_type: MeetingUsageReportObjectScheduledType = None, locale: str = None,
                               is_default: bool = None, is_standard: bool = None, host_email: str = None,
                               site_url: str = None) -> list[TemplateObject]:
        """
        List Meeting Templates

        Retrieves the list of meeting templates that is available for the authenticated user.

        There are separate lists of meeting templates for different `templateType`, `locale` and `siteUrl`.

        * If `templateType` is specified, the operation returns an array of meeting template objects specified by the
        `templateType`; otherwise, returns an array of meeting template objects of all template types.

        * If `locale` is specified, the operation returns an array of meeting template objects specified by the
        `locale`; otherwise, returns an array of meeting template objects of the default `en_US` locale. Refer to
        `Meeting Template Locales
        <https://developer.webex.com/docs/meetings#meeting-template-locales>`_ for all the locales supported by Webex.

        * If the parameter `siteUrl` has a value, the operation lists meeting templates on the specified site;
        otherwise, lists meeting templates on the user's preferred site. All available Webex sites and preferred site
        of the user can be retrieved by `Get Site List` API.

        :param template_type: Meeting template type for the meeting template objects being requested. If not specified,
            return meeting templates of all types.
        :type template_type: MeetingUsageReportObjectScheduledType
        :param locale: Locale for the meeting template objects being requested. If not specified, return meeting
            templates of the default `en_US` locale. Refer to `Meeting Template Locales
            <https://developer.webex.com/docs/meetings#meeting-template-locales>`_ for all the locales supported
            by Webex.
        :type locale: str
        :param is_default: The value is `true` or `false`. If it's `true`, return the default meeting templates; if
            it's `false`, return the non-default meeting templates. If it's not specified, return both default and
            non-default meeting templates.
        :type is_default: bool
        :param is_standard: The value is `true` or `false`. If it's `true`, return the standard meeting templates; if
            it's `false`, return the non-standard meeting templates. If it's not specified, return both standard and
            non-standard meeting templates.
        :type is_standard: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meeting templates that are available for that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meeting templates from. If not specified, the API
            lists meeting templates from user's preferred site. All available Webex sites and preferred site of the
            user can be retrieved by `Get Site List` API.
        :type site_url: str
        :rtype: list[TemplateObject]
        """
        params = {}
        if template_type is not None:
            params['templateType'] = template_type
        if locale is not None:
            params['locale'] = locale
        if is_default is not None:
            params['isDefault'] = str(is_default).lower()
        if is_standard is not None:
            params['isStandard'] = str(is_standard).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('templates')
        data = super().get(url, params=params)
        r = TypeAdapter(list[TemplateObject]).validate_python(data['items'])
        return r

    def get_a_meeting_template(self, template_id: str, host_email: str = None) -> DetailedTemplateObject1:
        """
        Get a Meeting Template

        Retrieves details for a meeting template with a specified meeting template ID.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param template_id: Unique identifier for the meeting template being requested.
        :type template_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return the meeting template that is available for that user.
        :type host_email: str
        :rtype: :class:`DetailedTemplateObject1`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'templates/{template_id}')
        data = super().get(url, params=params)
        r = DetailedTemplateObject1.model_validate(data)
        return r

    def get_meeting_control_status(self, meeting_id: str) -> Control:
        """
        Get Meeting Control Status

        Get the meeting control of a live meeting, which is consisted of meeting control status on "locked" and
        "recording" to reflect whether the meeting is currently locked and there is recording in progress.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :rtype: :class:`Control`
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep('controls')
        data = super().get(url, params=params)
        r = Control.model_validate(data)
        return r

    def update_meeting_control_status(self, meeting_id: str, recording_started: str = None,
                                      recording_paused: str = None, locked: str = None) -> Control:
        """
        Update Meeting Control Status

        To start, pause, resume, or stop a meeting recording; To lock or unlock an on-going meeting.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param recording_started: The value can be true or false. true means to start the recording, false to end the
            recording.
        :type recording_started: str
        :param recording_paused: The value can be true or false, will be ignored if 'recordingStarted' sets to false,
            and true to resume the recording only if the recording is paused vise versa.
        :type recording_paused: str
        :param locked: The value is true or false.
        :type locked: str
        :rtype: :class:`Control`
        """
        params = {}
        params['meetingId'] = meeting_id
        body = dict()
        body['recordingStarted'] = recording_started
        body['recordingPaused'] = recording_paused
        body['locked'] = locked
        url = self.ep('controls')
        data = super().put(url, params=params, json=body)
        r = Control.model_validate(data)
        return r

    def list_meeting_session_types(self, host_email: str = None,
                                   site_url: str = None) -> list[MeetingSessionTypeObject]:
        """
        List Meeting Session Types

        List all the meeting session types enabled for a given user.

        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will list all the meeting session types enabled for the user.
        :type host_email: str
        :param site_url: Webex site URL to query. If `siteUrl` is not specified, the users' preferred site will be
            used. If the authorization token has the admin-level scopes, the admin can set the Webex site URL on
            behalf of the user specified in the `hostEmail` parameter.
        :type site_url: str
        :rtype: list[MeetingSessionTypeObject]
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('sessionTypes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MeetingSessionTypeObject]).validate_python(data['items'])
        return r

    def get_a_meeting_session_type(self, session_type_id: int, host_email: str = None,
                                   site_url: str = None) -> MeetingSessionTypeObject:
        """
        Get a Meeting Session Type

        Retrieves details for a meeting session type with a specified session type ID.

        :param session_type_id: A unique identifier for the sessionType.
        :type session_type_id: int
        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will get a meeting session type with the specified session type ID enabled for the
            user.
        :type host_email: str
        :param site_url: Webex site URL to query. If `siteUrl` is not specified, the users' preferred site will be
            used. If the authorization token has the admin-level scopes, the admin can set the Webex site URL on
            behalf of the user specified in the `hostEmail` parameter.
        :type site_url: str
        :rtype: :class:`MeetingSessionTypeObject`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep(f'sessionTypes/{session_type_id}')
        data = super().get(url, params=params)
        r = MeetingSessionTypeObject.model_validate(data)
        return r

    def get_registration_form_for_a_meeting(self, meeting_id: str, current: bool = None,
                                            host_email: str = None) -> Registration:
        """
        Get registration form for a meeting

        Get a meeting's registration form to understand which fields are required.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`Registration`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registration')
        data = super().get(url, params=params)
        r = Registration.model_validate(data)
        return r

    def update_meeting_registration_form(self, meeting_id: str, host_email: str, require_first_name: bool,
                                         require_last_name: bool, require_email: bool, require_job_title: bool,
                                         require_company_name: bool, require_address1: bool, require_address2: bool,
                                         require_city: bool, require_state: bool, require_zip_code: bool,
                                         require_country_region: bool, require_work_phone: bool, require_fax: bool,
                                         max_register_num: int,
                                         customized_questions: list[CustomizedQuestionForCreateMeeting],
                                         rules: list[StandardRegistrationApproveRule]) -> Registration:
        """
        Update Meeting Registration Form

        Enable or update a registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param host_email: - Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return an update for a meeting that is hosted by that user.
        :type host_email: str
        :param require_first_name: Whether or not a registrant's first name is required for meeting registration. This
            option must always be `true`.
        :type require_first_name: bool
        :param require_last_name: Whether or not a registrant's last name is required for meeting registration. This
            option must always be `true`.
        :type require_last_name: bool
        :param require_email: Whether or not a registrant's email is required for meeting registration. This option
            must always be `true`.
        :type require_email: bool
        :param require_job_title: Whether or not a registrant's job title is shown or required for meeting
            registration.
        :type require_job_title: bool
        :param require_company_name: Whether or not a registrant's company name is shown or required for meeting
            registration.
        :type require_company_name: bool
        :param require_address1: Whether or not a registrant's first address field is shown or required for meeting
            registration.
        :type require_address1: bool
        :param require_address2: Whether or not a registrant's second address field is shown or required for meeting
            registration.
        :type require_address2: bool
        :param require_city: Whether or not a registrant's city is shown or required for meeting registration.
        :type require_city: bool
        :param require_state: Whether or not a registrant's state is shown or required for meeting registration.
        :type require_state: bool
        :param require_zip_code: Whether or not a registrant's postal code is shown or required for meeting
            registration.
        :type require_zip_code: bool
        :param require_country_region: Whether or not a registrant's country or region is shown or required for meeting
            registration.
        :type require_country_region: bool
        :param require_work_phone: Whether or not a registrant's work phone number is shown or required for meeting
            registration.
        :type require_work_phone: bool
        :param require_fax: Whether or not a registrant's fax number is shown or required for meeting registration.
        :type require_fax: bool
        :param max_register_num: Maximum number of meeting registrations. This only applies to meetings. The maximum
            number of participants for meetings and webinars, with the limit based on the user capacity and controlled
            by a toggle at the site level. The default maximum number of participants for webinars is 10000, but the
            actual maximum number of participants is limited by the user capacity.
        :type max_register_num: int
        :param customized_questions: Customized questions for meeting registration.
        :type customized_questions: list[CustomizedQuestionForCreateMeeting]
        :param rules: The approval rule for standard questions.
        :type rules: list[StandardRegistrationApproveRule]
        :rtype: :class:`Registration`
        """
        body = dict()
        body['hostEmail'] = host_email
        body['requireFirstName'] = require_first_name
        body['requireLastName'] = require_last_name
        body['requireEmail'] = require_email
        body['requireJobTitle'] = require_job_title
        body['requireCompanyName'] = require_company_name
        body['requireAddress1'] = require_address1
        body['requireAddress2'] = require_address2
        body['requireCity'] = require_city
        body['requireState'] = require_state
        body['requireZipCode'] = require_zip_code
        body['requireCountryRegion'] = require_country_region
        body['requireWorkPhone'] = require_work_phone
        body['requireFax'] = require_fax
        body['maxRegisterNum'] = max_register_num
        body['customizedQuestions'] = loads(TypeAdapter(list[CustomizedQuestionForCreateMeeting]).dump_json(customized_questions))
        body['rules'] = loads(TypeAdapter(list[StandardRegistrationApproveRule]).dump_json(rules))
        url = self.ep(f'{meeting_id}/registration')
        data = super().put(url, json=body)
        r = Registration.model_validate(data)
        return r

    def delete_meeting_registration_form(self, meeting_id: str):
        """
        Delete Meeting Registration Form

        Disable the registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :rtype: None
        """
        url = self.ep(f'{meeting_id}/registration')
        super().delete(url)

    def register_a_meeting_registrant(self, meeting_id: str, first_name: str, last_name: str, email: str,
                                      send_email: bool, job_title: str, company_name: str, address1: str,
                                      address2: str, city: str, state: str, zip_code: int, country_region: str,
                                      work_phone: str, fax: str, customized_questions: list[CustomizedRegistrant],
                                      current: bool = None, host_email: str = None) -> RegistrantCreateResponse:
        """
        Register a Meeting Registrant

        Register a new registrant for a meeting. When a meeting or webinar is created, this API can only be used if
        Registration is checked on the page or the registration attribute is specified through the `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_
        API.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param first_name: The registrant's first name.
        :type first_name: str
        :param last_name: The registrant's last name. (Required)
        :type last_name: str
        :param email: The registrant's email.
        :type email: str
        :param send_email: If `true` send email to the registrant. Default: `true`.
        :type send_email: bool
        :param job_title: The registrant's job title. Registration options define whether or not this is required.
        :type job_title: str
        :param company_name: The registrant's company. Registration options define whether or not this is required.
        :type company_name: str
        :param address1: The registrant's first address line. Registration options define whether or not this is
            required.
        :type address1: str
        :param address2: The registrant's second address line. Registration options define whether or not this is
            required.
        :type address2: str
        :param city: The registrant's city name. Registration options define whether or not this is required.
        :type city: str
        :param state: The registrant's state. Registration options define whether or not this is required.
        :type state: str
        :param zip_code: The registrant's postal code. Registration options define whether or not this is required.
        :type zip_code: int
        :param country_region: The America is not a country or a specific region. Registration options define whether
            or not this is required.
        :type country_region: str
        :param work_phone: The registrant's work phone number. Registration options define whether or not this is
            required.
        :type work_phone: str
        :param fax: The registrant's FAX number. Registration options define whether or not this is required.
        :type fax: str
        :param customized_questions: The registrant's answers for customized questions. Registration options define
            whether or not this is required.
        :type customized_questions: list[CustomizedRegistrant]
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`RegistrantCreateResponse`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['email'] = email
        body['sendEmail'] = send_email
        body['jobTitle'] = job_title
        body['companyName'] = company_name
        body['address1'] = address1
        body['address2'] = address2
        body['city'] = city
        body['state'] = state
        body['zipCode'] = zip_code
        body['countryRegion'] = country_region
        body['workPhone'] = work_phone
        body['fax'] = fax
        body['customizedQuestions'] = loads(TypeAdapter(list[CustomizedRegistrant]).dump_json(customized_questions))
        url = self.ep(f'{meeting_id}/registrants')
        data = super().post(url, params=params, json=body)
        r = RegistrantCreateResponse.model_validate(data)
        return r

    def batch_register_meeting_registrants(self, meeting_id: str, current: bool = None, host_email: str = None,
                                           items: list[RegistrantFormObject] = None) -> list[RegistrantCreateResponse]:
        """
        Batch register Meeting Registrants

        Bulk register new registrants for a meeting. When a meeting or webinar is created, this API can only be used if
        Registration is checked on the page or the registration attribute is specified through the `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_
        API.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param items: Registrants array.
        :type items: list[RegistrantFormObject]
        :rtype: list[RegistrantCreateResponse]
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['items'] = loads(TypeAdapter(list[RegistrantFormObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/registrants/bulkInsert')
        data = super().post(url, params=params, json=body)
        r = TypeAdapter(list[RegistrantCreateResponse]).validate_python(data['items'])
        return r

    def get_detailed_information_for_a_meeting_registrant(self, meeting_id: str, registrant_id: str,
                                                          current: bool = None,
                                                          host_email: str = None) -> Registrant1:
        """
        Get Detailed Information for a Meeting Registrant

        Retrieves details for a meeting registrant with a specified registrant Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`Registrant1`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        data = super().get(url, params=params)
        r = Registrant1.model_validate(data)
        return r

    def list_meeting_registrants(self, meeting_id: str, host_email: str = None, current: bool = None,
                                 email: str = None, registration_time_from: Union[str, datetime] = None,
                                 registration_time_to: Union[str, datetime] = None,
                                 **params) -> Generator[Registrant1, None, None]:
        """
        List Meeting Registrants

        Meeting's host and cohost can retrieve the list of registrants for a meeting with a specified meeting Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param email: Registrant's email to filter registrants.
        :type email: str
        :param registration_time_from: The time registrants register a meeting starts from the specified date and time
            (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `registrationTimeFrom` is not specified, it equals
            `registrationTimeTo` minus 7 days.
        :type registration_time_from: Union[str, datetime]
        :param registration_time_to: The time registrants register a meeting before the specified date and time
            (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `registrationTimeTo` is not specified, it equals
            `registrationTimeFrom` plus 7 days. The interval between `registrationTimeFrom` and `registrationTimeTo`
            must be within 90 days.
        :type registration_time_to: Union[str, datetime]
        :return: Generator yielding :class:`Registrant1` instances
        """
        if host_email is not None:
            params['hostEmail'] = host_email
        if current is not None:
            params['current'] = str(current).lower()
        if email is not None:
            params['email'] = email
        if registration_time_from is not None:
            if isinstance(registration_time_from, str):
                registration_time_from = isoparse(registration_time_from)
            registration_time_from = dt_iso_str(registration_time_from)
            params['registrationTimeFrom'] = registration_time_from
        if registration_time_to is not None:
            if isinstance(registration_time_to, str):
                registration_time_to = isoparse(registration_time_to)
            registration_time_to = dt_iso_str(registration_time_to)
            params['registrationTimeTo'] = registration_time_to
        url = self.ep(f'{meeting_id}/registrants')
        return self.session.follow_pagination(url=url, model=Registrant1, item_key='items', params=params)

    def query_meeting_registrants(self, meeting_id: str, status: RegistrantStatus,
                                  order_type: QueryRegistrantsOrderType, order_by: QueryRegistrantsOrderBy,
                                  emails: list[str], current: bool = None, host_email: str = None,
                                  **params) -> Generator[Registrant1, None, None]:
        """
        Query Meeting Registrants

        Meeting's host and cohost can query the list of registrants for a meeting with a specified meeting ID and
        registrants email.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param status: Registrant's status.
        :type status: RegistrantStatus
        :param order_type: Sort order for the registrants.
        :type order_type: QueryRegistrantsOrderType
        :param order_by: Registrant ordering field. Ordered by `registrationTime` by default.
        :type order_by: QueryRegistrantsOrderBy
        :param emails: List of registrant email addresses.
        :type emails: list[str]
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :return: Generator yielding :class:`Registrant1` instances
        """
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['status'] = enum_str(status)
        body['orderType'] = enum_str(order_type)
        body['orderBy'] = enum_str(order_by)
        body['emails'] = emails
        url = self.ep(f'{meeting_id}/registrants/query')
        return self.session.follow_pagination(url=url, model=Registrant1, item_key='items', params=params, json=body)

    def batch_update_meeting_registrants_status(self, meeting_id: str,
                                                status_op_type: BatchUpdateMeetingRegistrantsStatusStatusOpType,
                                                current: bool = None, host_email: str = None, send_email: str = None,
                                                registrants: list[DepartmentResponseWithId] = None):
        """
        Batch Update Meeting Registrants status

        Meeting's host or cohost can update the set of registrants for a meeting. `cancel` means the registrant(s) will
        be moved back to the registration list. `bulkDelete` means the registrant(s) will be deleted.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param status_op_type: Update registrant's status.
        :type status_op_type: BatchUpdateMeetingRegistrantsStatusStatusOpType
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        + Default: `false`
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If `true` send email to registrants. Default: `true`.
        :type send_email: str
        :param registrants: Registrants array.
        :type registrants: list[DepartmentResponseWithId]
        :rtype: None
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['sendEmail'] = send_email
        body['registrants'] = loads(TypeAdapter(list[DepartmentResponseWithId]).dump_json(registrants))
        url = self.ep(f'{meeting_id}/registrants/{status_op_type}')
        super().post(url, params=params, json=body)

    def delete_a_meeting_registrant(self, meeting_id: str, registrant_id: str, current: bool = None,
                                    host_email: str = None):
        """
        Delete a Meeting Registrant

        Meeting's host or cohost can delete a registrant with a specified registrant ID.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant.
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: None
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        super().delete(url, params=params)

    def update_meeting_simultaneous_interpretation(self, meeting_id: str, enabled: bool,
                                                   interpreters: list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]) -> MeetingSeriesObjectSimultaneousInterpretation:
        """
        Update Meeting Simultaneous interpretation

        Updates simultaneous interpretation options of a meeting with a specified meeting ID. This operation applies to
        meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param enabled: Whether or not simultaneous interpretation is enabled.
        :type enabled: bool
        :param interpreters: Interpreters for meeting.
        :type interpreters: list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]
        :rtype: :class:`MeetingSeriesObjectSimultaneousInterpretation`
        """
        body = dict()
        body['enabled'] = enabled
        body['interpreters'] = loads(TypeAdapter(list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]).dump_json(interpreters))
        url = self.ep(f'{meeting_id}/simultaneousInterpretation')
        data = super().put(url, json=body)
        r = MeetingSeriesObjectSimultaneousInterpretation.model_validate(data)
        return r

    def create_a_meeting_interpreter(self, meeting_id: str, language_code1: str, language_code2: str, email: str,
                                     display_name: str, host_email: str,
                                     send_email: bool) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Create a Meeting Interpreter

        Assign an interpreter to a bi-directional simultaneous interpretation language channel for a meeting.

        :param meeting_id: Unique identifier for the meeting to which the interpreter is to be assigned.
        :type meeting_id: str
        :param language_code1: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code1: str
        :param language_code2: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code2: str
        :param email: Email address of meeting interpreter. If not specified, an empty interpreter will be created for
            this bi-directional language channel, and a specific email can be assigned to this empty interpreter by
            `Update a Meeting Interpreter` API later. Please note that multiple interpreters with different emails can
            be assigned to the same bi-directional language channel, but the same email cannot be assigned to more
            than one interpreter.
        :type email: str
        :param display_name: Display name of meeting interpreter. If the interpreter is already an invitee of the
            meeting and it has a different display name, that invitee's display name will be overwritten by this
            attribute.
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        body = dict()
        body['languageCode1'] = language_code1
        body['languageCode2'] = language_code2
        body['email'] = email
        body['displayName'] = display_name
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().post(url, json=body)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def get_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str,
                                  host_email: str = None) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Get a Meeting Interpreter

        Retrieves details for a meeting interpreter identified by `meetingId` and `interpreterId` in the URI.

        :param meeting_id: Unique identifier for the meeting to which the interpreter has been assigned.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return details for an interpreter of the meeting that is hosted by that
            user.
        :type host_email: str
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().get(url, params=params)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def list_meeting_interpreters(self, meeting_id: str,
                                  host_email: str = None) -> list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]:
        """
        List Meeting Interpreters

        Lists meeting interpreters for a meeting with a specified `meetingId`.

        This operation can be used for meeting series, scheduled meeting and ended or ongoing meeting instance objects.
        If the specified `meetingId` is for a meeting series, the interpreters for the series will be listed; if the
        `meetingId` is for a scheduled meeting, the interpreters for the particular scheduled meeting will be listed;
        if the `meetingId` is for an ended or ongoing meeting instance, the interpreters for the particular meeting
        instance will be listed. See the `Webex Meetings
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ guide for more information about the types of meetings.

        The list returned is sorted in descending order by when interpreters were created.

        :param meeting_id: Unique identifier for the meeting for which interpreters are being requested. The meeting
            can be meeting series, scheduled meeting or meeting instance which has ended or is ongoing. Please note
            that currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return interpreters of the meeting that is hosted by that user.
        :type host_email: str
        :rtype: list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]).validate_python(data['items'])
        return r

    def update_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str, language_code1: str,
                                     language_code2: str, email: str, display_name: str, host_email: str,
                                     send_email: bool) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Update a Meeting Interpreter

        Updates details for a meeting interpreter identified by `meetingId` and `interpreterId` in the URI.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param language_code1: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code1: str
        :param language_code2: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code2: str
        :param email: Email address of meeting interpreter. If not specified, it'll be an empty interpreter for the
            bi-directional language channel. Please note that multiple interpreters with different emails can be
            assigned to the same bi-directional language channel, but the same email cannot be assigned to more than
            one interpreter.
        :type email: str
        :param display_name: Display name of meeting interpreter. If the interpreter is already an invitee of the
            meeting and it has a different display name, that invitee's display name will be overwritten by this
            attribute.
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        body = dict()
        body['languageCode1'] = language_code1
        body['languageCode2'] = language_code2
        body['email'] = email
        body['displayName'] = display_name
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().put(url, json=body)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def delete_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str, host_email: str = None,
                                     send_email: bool = None):
        """
        Delete a Meeting Interpreter

        Removes a meeting interpreter identified by `meetingId` and `interpreterId` in the URI. The deleted meeting
        interpreter cannot be recovered.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter to be removed.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will delete an interpreter of the meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        super().delete(url, params=params)

    def update_meeting_breakout_sessions(self, meeting_id: str, host_email: str, send_email: bool,
                                         items: list[BreakoutSessionObject]) -> list[GetBreakoutSessionObject]:
        """
        Update Meeting Breakout Sessions

        Updates breakout sessions of a meeting with a specified meeting ID in the pre-meeting state. This operation
        applies to meeting series and scheduled meetings.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param items: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They
            allow a subset of participants to collaborate and share ideas over audio and video. Use breakout sessions
            for workshops, classrooms, or for when you need a moment to talk privately with a few participants outside
            of the main session. Please note that maximum number of breakout sessions in a meeting or webinar is 100.
            In webinars, if hosts preassign attendees to breakout sessions, the role of `attendee` will be changed to
            `panelist`. Breakout session is not supported for a meeting with simultaneous interpretation.
        :type items: list[BreakoutSessionObject]
        :rtype: list[GetBreakoutSessionObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        body['items'] = loads(TypeAdapter(list[BreakoutSessionObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().put(url, json=body)
        r = TypeAdapter(list[GetBreakoutSessionObject]).validate_python(data['items'])
        return r

    def list_meeting_breakout_sessions(self, meeting_id: str) -> list[GetBreakoutSessionObject]:
        """
        List Meeting Breakout Sessions

        Lists meeting breakout sessions for a meeting with a specified `meetingId`.

        This operation can be used for meeting series, scheduled meeting and ended or ongoing meeting instance objects.
        See the `Webex Meetings
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ guide for more information about the types of meetings.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series, scheduled
            meeting and ended or ongoing meeting instance objects. Please note that currently meeting ID of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :rtype: list[GetBreakoutSessionObject]
        """
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().get(url)
        r = TypeAdapter(list[GetBreakoutSessionObject]).validate_python(data['items'])
        return r

    def delete_meeting_breakout_sessions(self, meeting_id: str, send_email: bool = None):
        """
        Delete Meeting Breakout Sessions

        Deletes breakout sessions with a specified meeting ID. The deleted breakout sessions cannot be recovered. The
        value of `enabledBreakoutSessions` attribute is set to `false` automatically.
        This operation applies to meeting series and scheduled meetings. It doesn't apply to ended or in-progress
        meeting instances.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/breakoutSessions')
        super().delete(url, params=params)

    def get_a_meeting_survey(self, meeting_id: str) -> SurveyObject:
        """
        Get a Meeting Survey

        Retrieves details for a meeting survey identified by `meetingId`.

        #### Request Header

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return survey details of that user.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str
        :rtype: :class:`SurveyObject`
        """
        url = self.ep(f'{meeting_id}/survey')
        data = super().get(url)
        r = SurveyObject.model_validate(data)
        return r

    def list_meeting_survey_results(self, meeting_id: str, meeting_start_time_from: Union[str, datetime] = None,
                                    meeting_start_time_to: Union[str, datetime] = None,
                                    **params) -> Generator[SurveyResultObject, None, None]:
        """
        List Meeting Survey Results

        Retrieves results for a meeting survey identified by `meetingId`.

        #### Request Header

        * `timezone`: Time zone for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return the survey results of that user.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str
        :param meeting_start_time_from: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the
            meeting objects being requested. `meetingStartTimeFrom` cannot be after `meetingStartTimeTo`. This
            parameter will be ignored if `meetingId` is the unique identifier for the specific meeting instance.
        When `meetingId` is not the unique identifier for the specific meeting instance, the `meetingStartTimeFrom`, if
        not specified, equals `meetingStartTimeTo` minus `1` month; if `meetingStartTimeTo` is also not specified, the
        default value for `meetingStartTimeFrom` is `1` month before the current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting
            objects being requested. `meetingStartTimeTo` cannot be prior to `meetingStartTimeFrom`. This parameter
            will be ignored if `meetingId` is the unique identifier for the specific meeting instance.
        When `meetingId` is not the unique identifier for the specific meeting instance, if `meetingStartTimeFrom` is
        also not specified, the default value for `meetingStartTimeTo` is the current date and time;For example,if
        `meetingStartTimeFrom` is a month ago, the default value for `meetingStartTimeTo` is `1` month after
        `meetingStartTimeFrom`.Otherwise it is the current date and time.
        :type meeting_start_time_to: Union[str, datetime]
        :return: Generator yielding :class:`SurveyResultObject` instances
        """
        if meeting_start_time_from is not None:
            if isinstance(meeting_start_time_from, str):
                meeting_start_time_from = isoparse(meeting_start_time_from)
            meeting_start_time_from = dt_iso_str(meeting_start_time_from)
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            if isinstance(meeting_start_time_to, str):
                meeting_start_time_to = isoparse(meeting_start_time_to)
            meeting_start_time_to = dt_iso_str(meeting_start_time_to)
            params['meetingStartTimeTo'] = meeting_start_time_to
        url = self.ep(f'{meeting_id}/surveyResults')
        return self.session.follow_pagination(url=url, model=SurveyResultObject, item_key='items', params=params)

    def get_meeting_survey_links(self, meeting_id: str, host_email: str, meeting_start_time_from: Union[str, datetime],
                                 meeting_start_time_to: Union[str, datetime],
                                 emails: list[str]) -> list[SurveyLinkObject]:
        """
        Get Meeting Survey Links

        Get survey links of a meeting for different users.

        #### Request Header

        * `timezone`: Time zone for the `meetingStartTimeFrom` and `meetingStartTimeTo` parameters and defined in
        conformance with the `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_id: Unique identifier for the meeting. Only applies to webinars. Meetings and personal room
            meetings are not supported.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. An admin can specify the email of the meeting host who
            is in a site he manages and the API returns post survey links on behalf of the meeting host.
        :type host_email: str
        :param meeting_start_time_from: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the
            meeting objects being requested and conforms with the `timezone` in the request header if specified.
            `meetingStartTimeFrom` cannot be after `meetingStartTimeTo`. Only applies when `meetingId` is not an
            instance ID. The API generates survey links for the last instance of `meetingId` in the time range
            specified by `meetingStartTimeFrom` and `meetingStartTimeTo`. If not specified, `meetingStartTimeFrom`
            equals `meetingStartTimeTo` minus `1` month; if `meetingStartTimeTo` is also not specified, the default
            value for `meetingStartTimeFrom` is `1` month before the current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting
            objects being requested and conforms with the `timezone` in the request header if specified.
            `meetingStartTimeTo` cannot be prior to `meetingStartTimeFrom`. Only applies when `meetingId` is not an
            instance ID. The API generates survey links for the last instance of `meetingId` in the time range
            specified by `meetingStartTimeFrom` and `meetingStartTimeTo`. If not specified, `meetingStartTimeTo`
            equals `meetingStartTimeFrom` plus `1` month; if `meetingStartTimeFrom` is also not specified, the default
            value for `meetingStartTimeTo` is the current date and time.
        :type meeting_start_time_to: Union[str, datetime]
        :param emails: Participants' email list. The maximum size of `emails` is 100.
        :type emails: list[str]
        :rtype: list[SurveyLinkObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['meetingStartTimeFrom'] = meeting_start_time_from
        body['meetingStartTimeTo'] = meeting_start_time_to
        body['emails'] = emails
        url = self.ep(f'{meeting_id}/surveyLinks')
        data = super().post(url, json=body)
        r = TypeAdapter(list[SurveyLinkObject]).validate_python(data['items'])
        return r

    def create_invitation_sources(self, meeting_id: str, host_email: str = None, person_id: str = None,
                                  items: list[InvitationSourceCreateObject] = None) -> list[InvitationSourceObject]:
        """
        Create Invitation Sources

        Creates one or more invitation sources for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param person_id: Unique identifier for the meeting host. Should only be set if the user or application calling
            the API has the admin-level scopes. When used, the admin may specify the email of a user in a site they
            manage to be the meeting host.
        :type person_id: str
        :type items: list[InvitationSourceCreateObject]
        :rtype: list[InvitationSourceObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['personId'] = person_id
        body['items'] = loads(TypeAdapter(list[InvitationSourceCreateObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().post(url, json=body)
        r = TypeAdapter(list[InvitationSourceObject]).validate_python(data['items'])
        return r

    def list_invitation_sources(self, meeting_id: str) -> list[InvitationSourceObject]:
        """
        List Invitation Sources

        Lists invitation sources for a meeting.

        #### Request Header

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return recording details of that user.

        * `personId`:  Unique identifier for the meeting host. This attribute should only be set if the user or
        application calling the API has the admin-level scopes. When used, the admin may specify the email of a user
        in a site they manage to be the meeting host.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str
        :rtype: list[InvitationSourceObject]
        """
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().get(url)
        r = TypeAdapter(list[InvitationSourceObject]).validate_python(data['items'])
        return r

    def list_meeting_tracking_codes(self, service: str, site_url: str = None,
                                    host_email: str = None) -> MeetingTrackingCodesObject:
        """
        List Meeting Tracking Codes

        Lists tracking codes on a site by a meeting host. The result indicates which tracking codes and what options
        can be used to create or update a meeting on the specified site.

        * The `options` here differ from those in the `site-level tracking codes
        <https://developer.webex.com/docs/api/v1/tracking-codes/get-a-tracking-code>`_ and the `user-level tracking codes
        is the result of a selective combination of the two.

        * For a tracking code, if there is no user-level tracking code, the API returns the site-level options, and the
        `defaultValue` of the site-level default option is `true`. If there is a user-level tracking code, it is
        merged into the `options`. Meanwhile, the `defaultValue` of this user-level option is `true` and the
        site-level default option becomes non default.

        * If `siteUrl` is specified, tracking codes of the specified site will be listed; otherwise, tracking codes of
        the user's preferred site will be listed. All available Webex sites and the preferred sites of a user can be
        retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        :param service: Service for schedule or sign-up pages.
        :type service: str
        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :rtype: :class:`MeetingTrackingCodesObject`
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        params['service'] = service
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep('trackingCodes')
        data = super().get(url, params=params)
        r = MeetingTrackingCodesObject.model_validate(data)
        return r

    def reassign_meetings_to_a_new_host(self, host_email: str = None,
                                        meeting_ids: list[str] = None) -> list[ReassignMeetingResponseObject]:
        """
        Reassign Meetings to a New Host

        Reassigns a list of meetings to a new host by an admin user.

        All the meetings of `meetingIds` should belong to the same site, which is the `siteUrl` in the request header,
        if specified, or the admin user's preferred site, if not specified. All available Webex sites and the
        preferred sites of a user can be retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        If the user of `hostEmail` is not qualified to be a host of the target site, the API returns an error with the
        HTTP status code `403`. If all the meetings referenced by `meetingIds` have been reassigned the new host
        successfully, the API returns an empty response with the HTTP status code `204`. Otherwise, if all the
        meetings of `meetingIds` fail or some of them fail, the API returns a "Multi-Status" response with status code
        of `207`, and individual errors for each meeting in the response body.

        Only IDs of meeting series are supported for the `meetingIds`. IDs of scheduled meetings, meeting instances, or
        scheduled personal room meetings are not supported. See the `Meetings Overview
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about the
        types of meetings.

        There are several limitations when reassigning meetings:

        * Users cannot assign an in-progress meeting.

        * Users cannot assign a meeting to a user who is not a Webex user, or an attendee who does not have host
        privilege.

        * Users cannot assign a meeting with calling/callback to a host user who does not have calling/callback
        privileges

        * Users cannot assign a meeting with session type A to a host user who does not have session type A privileges.

        * Users cannot assign an MC or Webinar to a new host who does not have an MC license or a Webinar license.

        * Users cannot assign a TC/EC1.0/SC meeting, or a meeting that is created by on-behalf to a new host.

        * Users cannot assign meetings from third-party integrations, such as meetings integrated with Outlook or
        Google.

        #### Request Header

        * `siteUrl`: Optional request header parameter. All the meetings of `meetingIds` should belong to the site
        referenced by siteUrl if specified. Otherwise, the meetings should belong to the admin user's preferred sites.
        All available Webex sites and the preferred sites of a user can be retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        :param host_email: Email address of the new meeting host.
        :type host_email: str
        :param meeting_ids: List of meeting series IDs to be reassigned the new host. The size is between 1 and 100.
            All the meetings of `meetingIds` should belong to the same site, which is the `siteUrl` in the request
            header, if specified, or the admin user's preferred site, if not specified. All available Webex sites and
            the preferred sites of a user can be retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type meeting_ids: list[str]
        :rtype: list[ReassignMeetingResponseObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['meetingIds'] = meeting_ids
        url = self.ep('reassignHost')
        data = super().post(url, json=body)
        r = TypeAdapter(list[ReassignMeetingResponseObject]).validate_python(data['items'])
        return r


class MeetingsApi(ApiChild, base='meetings'):
    """
    Meetings
    
    Meetings are virtual conferences where users can collaborate in real time using audio, video, content sharing,
    chat, online whiteboards, and to collaborate.
    
    This API focuses primarily on the scheduling and management of meetings. You can use the Meetings API to list,
    create, get, update, and delete meetings.
    
    Several types of meeting objects are supported by this API, such as meeting series, scheduled meeting, and ended or
    in-progress meeting instances. See the `Meetings Overview
    <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about the types of meetings.
    
    Refer to the `Meetings API Scopes` section of `Meetings Overview
    <https://developer.webex.com/docs/meetings>`_ for scopes required for each API.
    """

    def create_a_meeting(self, adhoc: bool, room_id: str, template_id: str, title: str, agenda: str, password: str,
                         start: Union[str, datetime], end: Union[str, datetime], timezone: str, recurrence: str,
                         enabled_auto_record_meeting: bool, allow_any_user_to_be_co_host: bool,
                         enabled_join_before_host: bool, enable_connect_audio_before_host: bool,
                         join_before_host_minutes: int, exclude_password: bool, public_meeting: bool,
                         reminder_time: int,
                         unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                         session_type_id: int, scheduled_type: MeetingSeriesObjectScheduledType,
                         enabled_webcast_view: bool, panelist_password: str, enable_automatic_lock: bool,
                         automatic_lock_minutes: int, allow_first_user_to_be_co_host: bool,
                         allow_authenticated_devices: bool, invitees: list[InviteeObjectForCreateMeeting],
                         send_email: bool, host_email: str, site_url: str,
                         meeting_options: MeetingSeriesObjectMeetingOptions,
                         attendee_privileges: MeetingSeriesObjectAttendeePrivileges,
                         registration: CreateMeetingObjectRegistration, integration_tags: list[str],
                         simultaneous_interpretation: CreateMeetingObjectSimultaneousInterpretation,
                         enabled_breakout_sessions: bool, breakout_sessions: list[BreakoutSessionObject],
                         tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                         audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                         require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObjectWithAdhoc:
        """
        Create a Meeting

        Creates a new meeting. Regular users can schedule up to 100 meetings in 24 hours and admin users up to 3000
        overall or 800 for a single user. Please note that the failed requests are also counted toward the limits.

        * If the parameter `adhoc` is `true` and `roomId` is specified, an ad-hoc meeting is created for the target
        room. An ad-hoc meeting is a non-recurring instant meeting for the target room which is supposed to be started
        immediately after being created for a quick collaboration. There's only one ad-hoc meeting for a room at the
        same time. So, if there's already an ongoing ad-hoc meeting for the room, the API returns this ongoing meeting
        instead of creating a new one. If it's a `direct
        <https://developer.webex.com/docs/api/v1/rooms/get-room-details>`_ room, both members of the room can create an ad-hoc meeting
        for the room. If it's a `group
        <https://developer.webex.com/docs/api/v1/rooms/get-room-details>`_ room, only room members that are in the same `organization
        an ad-hoc meeting for the room. Please note that an ad-hoc meeting is for the purpose of an instant
        collaboration with people in a room, user should not persist the `id` and `meetingNumber` of the ad-hoc
        meeting when it's been created since this meeting may become an inactive ad-hoc meeting for the room if it's
        not been started after being created for a while or it has been started and ended. Each time a user needs an
        ad-hoc meeting for a room, they should create one instead of reusing the previous persisted one. Moreover, for
        the same reason, no email will be sent when an ad-hoc meeting is created. Ad-hoc meetings cannot be updated by
        `Update a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/update-a-meeting>`_ or deleted by `Delete a Meeting
        scheduled meetings of an ad-hoc meeting cannot be listed by `List Meetings of a Meeting Series
        <https://developer.webex.com/docs/api/v1/meetings/list-meetings-of-a-meeting-series>`_, but the ended
        and ongoing instances of ad-hoc meetings can be listed by `List Meetings
        <https://developer.webex.com/docs/api/v1/meetings/list-meetings>`_ and `List Meetings of a Meeting Series

        * If the parameter `adhoc` is `true`, `roomId` is required and the others are optional or ignored.

        * The default value of `title` for an ad-hoc meeting is the user's name if not specified. The following
        parameters for an ad-hoc meeting have default values and the user's input values will be ignored:
        `scheduledType` is always `meeting`; `start` and `end` are 5 minutes after the current time and 20 minutes
        after the current time respectively; `timezone` is `UTC`; `allowAnyUserToBeCoHost`,
        `allowAuthenticatedDevices`, `enabledJoinBeforeHost`, `enableConnectAudioBeforeHost` are always `true`;
        `allowFirstUserToBeCoHost`, `enableAutomaticLock`, `publicMeeting`, `sendEmail` are always `false`; `invitees`
        is the room members except "me"; `joinBeforeHostMinutes` is 5; `automaticLockMinutes` is null;
        `unlockedMeetingJoinSecurity` is `allowJoinWithLobby`. An ad-hoc meeting can be started immediately even if
        the `start` is 5 minutes after the current time.

        * The following parameters are not supported and will be ignored for an ad-hoc meeting: `templateId`,
        `recurrence`, `excludePassword`, `reminderTime`, `registration`, `integrationTags`, `enabledWebcastView`, and
        `panelistPassword`.

        * If the value of the parameter `recurrence` is null, a non-recurring meeting is created.

        * If the parameter `recurrence` has a value, a recurring meeting is created based on the rule defined by the
        value of `recurrence`. For a non-recurring meeting which has no `recurrence` value set, its `meetingType` is
        also `meetingSeries` which is a meeting series with only one occurrence in Webex meeting modeling.

        * If the parameter `templateId` has a value, the meeting is created based on the meeting template specified by
        `templateId`. The list of meeting templates that is available for the authenticated user can be retrieved from
        `List Meeting Templates
        <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_.

        * If the parameter `siteUrl` has a value, the meeting is created on the specified site. Otherwise, the meeting
        is created on the user's preferred site. All available Webex sites and preferred site of the user can be
        retrieved by `Get Site List` API.

        * If the parameter `scheduledType` equals "personalRoomMeeting", the meeting is created in the user's
        `personal room
        <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_.

        * If the parameter `roomId` has a value, the meeting is created for the Webex space specified by `roomId`. If
        `roomId` is specified but the user calling the API is not a member of the Webex space specified by `roomId`,
        the API will fail even if the user has the admin-level scopes or he is calling the API on behalf of another
        user which is specified by `hostEmail` and is a member of the Webex space.

        :param adhoc: Whether or not to create an ad-hoc meeting for the room specified by `roomId`. When `true`,
            `roomId` is required.
        :type adhoc: bool
        :param room_id: Unique identifier for the Webex space which the meeting is to be associated with. It can be
            retrieved by `List Rooms
            <https://developer.webex.com/docs/api/v1/rooms/list-rooms>`_. `roomId` is required when `adhoc` is `true`. When `roomId` is specified, the
            parameter `hostEmail` will be ignored.
        :type room_id: str
        :param template_id: Unique identifier for meeting template. Please note that `start` and `end` are optional
            when `templateId` is specified. The list of meeting templates that is available for the authenticated user
            can be retrieved from `List Meeting Templates
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-templates>`_. This parameter is ignored for an ad-hoc meeting.
        :type template_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long. The default value for an ad-hoc
            meeting is the user's name if not specified.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming to the site's password
            rules will be generated automatically.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 23 hours 59 minutes. Please note that when a meeting is being scheduled, `start` of the
            meeting will be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is within the same
            minute as the current time, `start` will be adjusted to the upcoming minute; otherwise, `start` will be
            adjusted with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`. The default value for an
            ad-hoc meeting is 5 minutes after the current time and the user's input value will be ignored. An ad-hoc
            meeting can be started immediately even if the `start` is 5 minutes after the current time.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 23 hours 59 minutes. Please note that when a meeting is being scheduled, `end` of
            the meeting will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be adjusted
            with seconds and milliseconds stripped off. For instance, `end` of `2022-03-01T11:52:28.076+08:00` or
            `2022-03-01T11:52:41+08:00` will be adjusted to `2022-03-01T11:52:00+08:00`. The default value for an
            ad-hoc meeting is 20 minutes after the current time and the user's input value will be ignored.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_). The default value for an ad-hoc meeting is `UTC` and the user's input value will
            be ignored.
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_), applying only to meeting series.
            It doesn't apply to a scheduled meeting or an ended or ongoing meeting instance. This parameter is ignored
            for an ad-hoc meeting. Multiple days or dates for monthly or yearly `recurrence` rule are not supported,
            only the first day or date specified is taken. For example,
            "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially supported
            as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's the user's preferred site. The default value for an ad-hoc
            meeting is `true` and the user's input value will be ignored.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting. The default value for an ad-hoc meeting is `true` and the user's input value will be ignored.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true. The default value for an ad-hoc meeting is `true` and the user's input value
            will be ignored.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. This attribute is only applicable if the `enabledJoinBeforeHost` attribute is set
            to true. Valid options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are
            `0`, `15`, `30`, `45`, and `60`. The default value for an ad-hoc meeting is 0 and the user's input value
            will be ignored.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation. This
            parameter is ignored for an ad-hoc meeting.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar. The default
            value for an ad-hoc meeting is `false` and the user's input value will be ignored.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host. This parameter is ignored for an ad-hoc meeting.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting. The default value for an ad-hoc meeting is `allowJoinWithLobby` and the user's input value will
            be ignored.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            when scheduling a webinar meeting. All available meeting session types enabled for the user can be
            retrieved using the `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param scheduled_type: When set as an attribute in a POST request body, specifies whether it's a regular
            meeting, a webinar, or a meeting scheduled in the user's `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_. If not specified, it's a regular
            meeting by default. The default value for an ad-hoc meeting is `meeting` and the user's input value will
            be ignored.
        :type scheduled_type: MeetingSeriesObjectScheduledType
        :param enabled_webcast_view: Whether or not webcast view is enabled. This parameter is ignored for an ad-hoc
            meeting.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically. This parameter is ignored for an ad-hoc
            meeting.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts. The default
            value for an ad-hoc meeting is `false` and the user's input value will be ignored.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
            The default value for an ad-hoc meeting is null and the user's input value will be ignored.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site. The default value for an ad-hoc
            meeting is `false` and the user's input value will be ignored.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt. The default value for an ad-hoc meeting is
            `true` and the user's input value will be ignored.
        :type allow_authenticated_devices: bool
        :param invitees: Invitees for meeting. The maximum size of invitees is 1000. If `roomId` is specified and
            `invitees` is missing, all the members in the space are invited implicitly. If both `roomId` and
            `invitees` are specified, only those in the `invitees` list are invited. `coHost` for each invitee is
            `true` by default if `roomId` is specified when creating a meeting, and anyone in the invitee list that is
            not qualified to be a cohost will be invited as a non-cohost invitee. The user's input value will be
            ignored for an ad-hoc meeting and the the members of the room specified by `roomId` except "me" will be
            used by default.
        :type invitees: list[InviteeObjectForCreateMeeting]
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true. The default value for an ad-hoc meeting is `false` and the user's input value will be
            ignored.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is created on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param registration: Meeting registration. When this option is enabled, meeting invitees must register personal
            information in order to join the meeting. Meeting invitees will receive an email with a registration link
            for the registration. When the registration form has been submitted and approved, an email with a real
            meeting link will be received. By clicking that link the meeting invitee can join the meeting. Please note
            that meeting registration does not apply to a meeting when it's a recurring meeting with a `recurrence`
            field or no `password` or when the feature toggle `DecoupleJBHWithRegistration` is disabled the `Join
            Before Host` option is enabled for the meeting, See `Register for a Meeting in Cisco Webex Meetings
            <https://help.webex.com/en-us/nmgmeff/Register-for-a-Meeting-in-Cisco-Webex-Meetings>`_ for
            details.
        :type registration: CreateMeetingObjectRegistration
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. This parameter is ignored for an ad-hoc meeting.
        :type integration_tags: list[str]
        :param simultaneous_interpretation: Simultaneous interpretation information for a meeting.
        :type simultaneous_interpretation: CreateMeetingObjectSimultaneousInterpretation
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled.
        :type enabled_breakout_sessions: bool
        :param breakout_sessions: Breakout sessions are smaller groups that are split off from the main meeting or
            webinar. They allow a subset of participants to collaborate and share ideas over audio and video. Use
            breakout sessions for workshops, classrooms, or for when you need a moment to talk privately with a few
            participants outside of the main session. Please note that maximum number of breakout sessions in a
            meeting or webinar is 100. In webinars, if hosts preassign attendees to breakout sessions, the role of
            `attendee` will be changed to `panelist`. Breakout session is not supported for a meeting with
            simultaneous interpretation.
        :type breakout_sessions: list[BreakoutSessionObject]
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObjectWithAdhoc`
        """
        body = dict()
        body['adhoc'] = adhoc
        body['roomId'] = room_id
        body['templateId'] = template_id
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['scheduledType'] = enum_str(scheduled_type)
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['invitees'] = loads(TypeAdapter(list[InviteeObjectForCreateMeeting]).dump_json(invitees))
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['registration'] = loads(registration.model_dump_json())
        body['integrationTags'] = integration_tags
        body['simultaneousInterpretation'] = loads(simultaneous_interpretation.model_dump_json())
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['breakoutSessions'] = loads(TypeAdapter(list[BreakoutSessionObject]).dump_json(breakout_sessions))
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep()
        data = super().post(url, json=body)
        r = MeetingSeriesObjectWithAdhoc.model_validate(data)
        return r

    def get_a_meeting(self, meeting_id: str, current: bool = None,
                      host_email: str = None) -> MeetingSeriesObjectWithAdhoc:
        """
        Get a Meeting

        Retrieves details for a meeting with a specified meeting ID.

        * If the `meetingId` value specified is for a meeting series and `current` is `true`, the operation returns
        details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start or
        the upcoming scheduled meeting of the meeting series.

        * If the `meetingId` value specified is for a meeting series and `current` is `false` or `current` is not
        specified, the operation returns details for the entire meeting series.

        * If the `meetingId` value specified is for a scheduled meeting from a meeting series, the operation returns
        details for that scheduled meeting.

        * If the `meetingId` value specified is for a meeting instance which is happening or has happened, the
        operation returns details for that meeting instance.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_id: Unique identifier for the meeting being requested.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`MeetingSeriesObjectWithAdhoc`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}')
        data = super().get(url, params=params)
        r = MeetingSeriesObjectWithAdhoc.model_validate(data)
        return r

    def list_meetings(self, meeting_number: str = None, web_link: str = None, room_id: str = None,
                      meeting_type: MeetingSeriesObjectMeetingType = None, state: MeetingSeriesObjectState = None,
                      scheduled_type: MeetingSeriesObjectScheduledType = None, is_modified: bool = None,
                      has_chat: bool = None, has_recording: bool = None, has_transcription: bool = None,
                      has_closed_caption: bool = None, has_polls: bool = None, has_qa: bool = None,
                      current: bool = None, from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                      host_email: str = None, site_url: str = None, integration_tag: str = None,
                      **params) -> Generator[MeetingSeriesObjectForListMeeting, None, None]:
        """
        List Meetings

        Retrieves details for meetings with a specified meeting number, web link, meeting type, etc. Please note that
        there are various products in the `Webex Suite
        <https://www.webex.com/collaboration-suite.html>`_ such as `Meetings` and `Events`. Currently, only meetings of the
        `Meetings` product are supported by this API, meetings of others in the suite are not supported. Ad-hoc
        meetings created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` will not be listed, but the ended
        and ongoing ad-hoc meeting instances will be listed.

        * If `meetingNumber` is specified, the operation returns an array of meeting objects specified by the
        `meetingNumber`. Each object in the array can be a scheduled meeting or a meeting series depending on whether
        the `current` parameter is `true` or `false`, and each object contains the simultaneous interpretation object.
        When `meetingNumber` is specified, parameters of `from`, `to`, `meetingType`, `state`, `isModified` and
        `siteUrl` will be ignored. Please note that `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `webLink` is specified, the operation returns an array of meeting objects specified by the `webLink`. Each
        object in the array is a scheduled meeting, and each object contains the simultaneous interpretation object.
        When `webLink` is specified, parameters of `current`, `from`, `to`, `meetingType`, `state`, `isModified` and
        `siteUrl` will be ignored. Please note that `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `roomId` is specified, the operation returns an array of meeting objects of the Webex space specified by
        the `roomId`. When `roomId` is specified, parameters of `current`, `meetingType`, `state` and `isModified`
        will be ignored. The meeting objects are queried on the user's preferred site if no `siteUrl` is specified;
        otherwise, queried on the specified site. `meetingNumber`, `webLink` and `roomId` are mutually exclusive and
        they cannot be specified simultaneously.

        * If `state` parameter is specified, the returned array only has items in the specified state. If `state` is
        not specified, return items of all states.

        * If `meetingType` equals "meetingSeries", the `scheduledType` parameter can be "meeting", "webinar" or null.
        If `scheduledType` is specified, the returned array only has items of the specified scheduled type; otherwise,
        it has items of "meeting" and "webinar".

        * If `meetingType` equals "scheduledMeeting", the `scheduledType` parameter can be "meeting", "webinar",
        "personalRoomMeeting" or null. If `scheduledType` is specified, the returned array only has items of the
        specified scheduled type; otherwise, it has items of all scheduled types.

        * If `meetingType` equals "meeting", the `scheduledType` parameter can be "meeting", "webinar" or null. If
        `scheduledType` is specified, the returned array only has items of the specified scheduled type; otherwise, it
        has items of "meeting" and "webinar". Please note that ended or in-progress meeting instances of `personal room
        <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_
        also fall into the category of "meeting" `scheduledType`.

        * If `isModified` parameter is specified, the returned array only has items which have been modified to
        exceptional meetings. This parameter only applies to scheduled meeting.

        * If any of the `hasChat`, `hasRecording`, `hasTranscription`, `hasClosedCaption`, `hasPolls ` and `hasQA`
        parameters is specified, the `meetingType` must be "meeting" and `state` must be "ended". These parameters are
        null by default.

        * The `current` parameter only applies to meeting series. If it's `true`, the `start` and `end` attributes of
        each returned meeting series object are for the first scheduled meeting of that series. If it's `true` or not
        specified, the `start` and `end` attributes are for the scheduled meeting which is ready to start or join or
        the upcoming scheduled meeting of that series.

        * If `from` and `to` are specified, the operation returns an array of meeting objects in that specified time
        range.

        * If the parameter `siteUrl` has a value, the operation lists meetings on the specified site; otherwise, lists
        meetings on the user's all sites. All available Webex sites of the user can be retrieved by `Get Site List`
        API.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_number: Meeting number for the meeting objects being requested. `meetingNumber`, `webLink` and
            `roomId` are mutually exclusive. If it's an exceptional meeting from a meeting series, the exceptional
            meeting instead of the primary meeting series is returned.
        :type meeting_number: str
        :param web_link: URL encoded link to information page for the meeting objects being requested. `meetingNumber`,
            `webLink` and `roomId` are mutually exclusive.
        :type web_link: str
        :param room_id: Associated Webex space ID for the meeting objects being requested. `meetingNumber`, `webLink`
            and `roomId` are mutually exclusive.
        :type room_id: str
        :param meeting_type: Meeting type for the meeting objects being requested. This parameter will be ignored if
            `meetingNumber`, `webLink` or `roomId` is specified.
        :type meeting_type: MeetingSeriesObjectMeetingType
        :param state: Meeting state for the meeting objects being requested. If not specified, return meetings of all
            states. This parameter will be ignored if `meetingNumber`, `webLink` or `roomId` is specified. Details of
            an `ended` meeting will only be available 15 minutes after the meeting has ended. `inProgress` meetings
            are not fully supported. The API will try to return details of an `inProgress` meeting 15 minutes after
            the meeting starts. However, it may take longer depending on the traffic. See the `Webex Meetings
            <https://developer.webex.com/docs/meetings#meeting-states>`_ guide for
            more information about the states of meetings.
        :type state: MeetingSeriesObjectState
        :param scheduled_type: Scheduled type for the meeting objects being requested.
        :type scheduled_type: MeetingSeriesObjectScheduledType
        :param is_modified: Flag identifying whether a meeting has been modified. Only applies to scheduled meetings.
            If `true`, only return modified scheduled meetings; if `false`, only return unmodified scheduled meetings;
            if not specified, all scheduled meetings will be returned.
        :type is_modified: bool
        :param has_chat: Flag identifying whether a meeting has a chat log. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have chats; if `false`, only return meeting instances which
            have no chats; if not specified, all meeting instances will be returned.
        :type has_chat: bool
        :param has_recording: Flag identifying meetings with recordings. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have recordings; if `false`, only return meeting instances
            which have no recordings; if not specified, all meeting instances will be returned.
        :type has_recording: bool
        :param has_transcription: Flag identifying meetings with transcripts. Only applies to ended meeting instances.
            If `true`, only return meeting instances which have transcripts; if `false`, only return meeting instances
            which have no transcripts; if not specified, all meeting instances will be returned.
        :type has_transcription: bool
        :param has_closed_caption: Flag identifying meetings with closed captions. Only applies to ended meeting
            instances. If `true`, only return meeting instances which have closed captions; if `false`, only return
            meeting instances which have no closed captions; if not specified, all meeting instances will be returned.
        :type has_closed_caption: bool
        :param has_polls: Flag identifying meetings with polls. Only applies to ended meeting instances. If `true`,
            only return meeting instances which have polls; if `false`, only return meeting instances which have no
            polls; if not specified, all meeting instances will be returned.
        :type has_polls: bool
        :param has_qa: Flag identifying meetings with Q&A. Only applies to ended meeting instances. If `true`, only
            return meeting instances which have Q&A; if `false`, only return meeting instances which have no Q&A; if
            not specified, all meeting instances will be returned.
        :type has_qa: bool
        :param current: Flag identifying to retrieve the current scheduled meeting of the meeting series or the entire
            meeting series. This parameter only applies to scenarios where `meetingNumber` is specified and the
            meeting is not an exceptional meeting from a meeting series. If it's `true`, return the scheduled meeting
            of the meeting series which is ready to join or start or the upcoming scheduled meeting of the meeting
            series; if it's `false`, return the entire meeting series.
        :type current: bool
        :param from_: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being
            requested. `from` cannot be after `to`. This parameter will be ignored if `meetingNumber`, `webLink` or
            `roomId` is specified.
        :type from_: Union[str, datetime]
        :param to_: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting objects being
            requested. `to` cannot be before `from`. This parameter will be ignored if `meetingNumber`, `webLink` or
            `roomId` is specified.
        :type to_: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for meetings that are hosted by that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meetings from. If not specified, the API lists
            meetings from user's all sites. All available Webex sites of the user can be retrieved by `Get Site List`
            API.
        :type site_url: str
        :param integration_tag: External key created by an integration application. This parameter is used by the
            integration application to query meetings by a key in its own domain such as a Zendesk ticket ID, a Jira
            ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str
        :return: Generator yielding :class:`MeetingSeriesObjectForListMeeting` instances
        """
        if meeting_number is not None:
            params['meetingNumber'] = meeting_number
        if web_link is not None:
            params['webLink'] = web_link
        if room_id is not None:
            params['roomId'] = room_id
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if scheduled_type is not None:
            params['scheduledType'] = scheduled_type
        if is_modified is not None:
            params['isModified'] = str(is_modified).lower()
        if has_chat is not None:
            params['hasChat'] = str(has_chat).lower()
        if has_recording is not None:
            params['hasRecording'] = str(has_recording).lower()
        if has_transcription is not None:
            params['hasTranscription'] = str(has_transcription).lower()
        if has_closed_caption is not None:
            params['hasClosedCaption'] = str(has_closed_caption).lower()
        if has_polls is not None:
            params['hasPolls'] = str(has_polls).lower()
        if has_qa is not None:
            params['hasQA'] = str(has_qa).lower()
        if current is not None:
            params['current'] = str(current).lower()
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        url = self.ep()
        return self.session.follow_pagination(url=url, model=MeetingSeriesObjectForListMeeting, item_key='items', params=params)

    def list_meetings_of_a_meeting_series(self, meeting_series_id: str, from_: Union[str, datetime] = None,
                                          to_: Union[str, datetime] = None,
                                          meeting_type: ListMeetingsOfAMeetingSeriesMeetingType = None,
                                          state: ListMeetingsOfAMeetingSeriesState = None, is_modified: bool = None,
                                          has_chat: bool = None, has_recording: bool = None,
                                          has_transcription: bool = None, has_closed_caption: bool = None,
                                          has_polls: bool = None, has_qa: bool = None, host_email: str = None,
                                          **params) -> Generator[ScheduledMeetingObject, None, None]:
        """
        List Meetings of a Meeting Series

        Lists scheduled meeting and meeting instances of a meeting series identified by `meetingSeriesId`. Scheduled
        meetings of an ad-hoc meeting created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` will not be
        listed, but the ended and ongoing meeting instances of it will be listed.

        Each _scheduled meeting_ or _meeting_ instance of a _meeting series_ has its own `start`, `end`, etc. Thus, for
        example, when a daily meeting has been scheduled from `2019-04-01` to `2019-04-10`, there are 10 scheduled
        meeting instances in this series, one instance for each day, and each one has its own attributes. When a
        scheduled meeting has been started and ended or is happening, there are even more ended or in-progress meeting
        instances.

        Use this operation to list scheduled meeting and meeting instances of a meeting series within a specific date
        range.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * If any of the `hasChat`, `hasRecording`, `hasTranscription`, `hasClosedCaption`, `hasPolls ` and `hasQA`
        parameters is specified, the `meetingType` must be "meeting" and `state` must be "ended". These parameters are
        null by default.

        * `trackingCodes` is not supported for ended meeting instances.

        #### Request Header

        * `password`: Meeting password. Required when the meeting is protected by a password and the current user is
        not privileged to view it if they are not a host, cohost or invitee of the meeting.

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_series_id: Unique identifier for the meeting series. Please note that currently meeting ID of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_series_id: str
        :param from_: Start date and time (inclusive) for the range for which meetings are to be returned in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot be after `to`.
        :type from_: Union[str, datetime]
        :param to_: End date and time (exclusive) for the range for which meetings are to be returned in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. `to` cannot be before `from`.
        :type to_: Union[str, datetime]
        :param meeting_type: Meeting type for the meeting objects being requested. If not specified, return meetings of
            all types.
        :type meeting_type: ListMeetingsOfAMeetingSeriesMeetingType
        :param state: Meeting state for the meetings being requested. If not specified, return meetings of all states.
            Details of an `ended` meeting will only be available 15 minutes after the meeting has ended. `inProgress`
            meetings are not fully supported. The API will try to return details of an `inProgress` meeting 15 minutes
            after the meeting starts. However, it may take longer depending on the traffic. See the `Webex Meetings
            <https://developer.webex.com/docs/meetings#meeting-states>`_
            guide for more information about the states of meetings.
        :type state: ListMeetingsOfAMeetingSeriesState
        :param is_modified: Flag identifying whether a meeting has been modified. Only applies to scheduled meetings.
            If `true`, only return modified scheduled meetings; if `false`, only return unmodified scheduled meetings;
            if not specified, all scheduled meetings will be returned.
        :type is_modified: bool
        :param has_chat: Flag identifying whether a meeting has a chat log. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have chats; if `false`, only return meeting instances which
            have no chats; if not specified, all meeting instances will be returned.
        :type has_chat: bool
        :param has_recording: Flag identifying meetings with recordings. Only applies to ended meeting instances. If
            `true`, only return meeting instances which have recordings; if `false`, only return meeting instances
            which have no recordings; if not specified, all meeting instances will be returned.
        :type has_recording: bool
        :param has_transcription: Flag identifying meetings with transcripts. Only applies to ended meeting instances.
            If `true`, only return meeting instances which have transcripts; if `false`, only return meeting instances
            which have no transcripts; if not specified, all meeting instances will be returned.
        :type has_transcription: bool
        :param has_closed_caption: Flag identifying meetings with closed captions. Only applies to ended meeting
            instances. If `true`, only return meeting instances which have closed captions; if `false`, only return
            meeting instances which have no closed captions; if not specified, all meeting instances will be returned.
        :type has_closed_caption: bool
        :param has_polls: Flag identifying meetings with polls. Only applies to ended meeting instances. If `true`,
            only return meeting instances which have polls; if `false`, only return meeting instances which have no
            polls; if not specified, all meeting instances will be returned.
        :type has_polls: bool
        :param has_qa: Flag identifying meetings with Q&A. Only applies to ended meeting instances. If `true`, only
            return meeting instances which have Q&A; if `false`, only return meeting instances which have no Q&A; if
            not specified, all meeting instances will be returned.
        :type has_qa: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meetings that are hosted by that user.
        :type host_email: str
        :return: Generator yielding :class:`ScheduledMeetingObject` instances
        """
        params['meetingSeriesId'] = meeting_series_id
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if meeting_type is not None:
            params['meetingType'] = meeting_type
        if state is not None:
            params['state'] = state
        if is_modified is not None:
            params['isModified'] = str(is_modified).lower()
        if has_chat is not None:
            params['hasChat'] = str(has_chat).lower()
        if has_recording is not None:
            params['hasRecording'] = str(has_recording).lower()
        if has_transcription is not None:
            params['hasTranscription'] = str(has_transcription).lower()
        if has_closed_caption is not None:
            params['hasClosedCaption'] = str(has_closed_caption).lower()
        if has_polls is not None:
            params['hasPolls'] = str(has_polls).lower()
        if has_qa is not None:
            params['hasQA'] = str(has_qa).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ScheduledMeetingObject, item_key='items', params=params)

    def patch_a_meeting(self, meeting_id: str, title: str, agenda: str, password: str, start: Union[str, datetime],
                        end: Union[str, datetime], timezone: str, recurrence: str, enabled_auto_record_meeting: bool,
                        allow_any_user_to_be_co_host: bool, enabled_join_before_host: bool,
                        enable_connect_audio_before_host: bool, join_before_host_minutes: int, exclude_password: bool,
                        public_meeting: bool, reminder_time: int,
                        unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                        session_type_id: int, enabled_webcast_view: bool, panelist_password: str,
                        enable_automatic_lock: bool, automatic_lock_minutes: int,
                        allow_first_user_to_be_co_host: bool, allow_authenticated_devices: bool, send_email: bool,
                        host_email: str, site_url: str, meeting_options: MeetingSeriesObjectMeetingOptions,
                        attendee_privileges: MeetingSeriesObjectAttendeePrivileges, integration_tags: list[str],
                        enabled_breakout_sessions: bool, tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                        audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                        require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObject:
        """
        Patch a Meeting

        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be updated.

        * If the `meetingId` value specified is for a scheduled meeting, the operation updates that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation updates the entire meeting series.
        **Note**: If the value of `start`, `end`, or `recurrence` for the meeting series is changed, any exceptional
        scheduled meeting in this series is cancelled when the meeting series is updated.

        * The `agenda`, `recurrence`, and `trackingCodes` attributes can be specified as `null` so that these
        attributes become null and hidden from the response after the patch. Note that it's the keyword `null` not the
        string "null".

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long. It can be specified `null`
            so that it becomes null and hidden from the response after the patch.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 23 hours 59 minutes. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about
            restrictions on updating date and time for a meeting. Please note that when a meeting is being updated,
            `start` of the meeting will be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is
            within the same minute as the current time, `start` will be adjusted to the upcoming minute; otherwise,
            `start` will be adjusted with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 23 hours 59 minutes. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about
            restrictions on updating date and time for a meeting. Please note that when a meeting is being updated,
            `end` of the meeting will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be
            adjusted with seconds and milliseconds stripped off. For instance, `end` of
            `2022-03-01T11:52:28.076+08:00` or `2022-03-01T11:52:41+08:00` will be adjusted to
            `2022-03-01T11:52:00+08:00`.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for
            monthly or yearly `recurrence` rule are not supported, only the first day or date specified is taken. For
            example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially
            supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10". It can be specified `null` so that the
            meeting becomes non-recurring and the `recurrence` attribute becomes null and hidden from the response
            after the patch.
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. Only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid
            options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`,
            `45`, and `60`. The default is `0` if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be
            retrieved by `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. Please note that an empty or null
            `integrationTags` will delete all existing integration tags for the meeting implicitly. Developer can
            update integration tags for a `meetingSeries` but he cannot update it for a `scheduledMeeting` or a
            `meeting` instance.
        :type integration_tags: list[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            `enabledBreakoutSessions` is false, users can not set breakout sessions. If the value of
            `enabledBreakoutSessions` is true, users can update breakout sessions using the `Update Breakout Sessions
            <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_
            API. Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting. It can be specified `null` so that it becomes null and hidden from the
            response after the patch.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObject`
        """
        body = dict()
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['integrationTags'] = integration_tags
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep(f'{meeting_id}')
        data = super().patch(url, json=body)
        r = MeetingSeriesObject.model_validate(data)
        return r

    def update_a_meeting(self, meeting_id: str, title: str, agenda: str, password: str, start: Union[str, datetime],
                         end: Union[str, datetime], timezone: str, recurrence: str, enabled_auto_record_meeting: bool,
                         allow_any_user_to_be_co_host: bool, enabled_join_before_host: bool,
                         enable_connect_audio_before_host: bool, join_before_host_minutes: int,
                         exclude_password: bool, public_meeting: bool, reminder_time: int,
                         unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity,
                         session_type_id: int, enabled_webcast_view: bool, panelist_password: str,
                         enable_automatic_lock: bool, automatic_lock_minutes: int,
                         allow_first_user_to_be_co_host: bool, allow_authenticated_devices: bool, send_email: bool,
                         host_email: str, site_url: str, meeting_options: MeetingSeriesObjectMeetingOptions,
                         attendee_privileges: MeetingSeriesObjectAttendeePrivileges, integration_tags: list[str],
                         enabled_breakout_sessions: bool, tracking_codes: list[MeetingUsageReportTrackingCodeObject],
                         audio_connection_options: MeetingSeriesObjectAudioConnectionOptions,
                         require_attendee_login: bool, restrict_to_invitees: bool) -> MeetingSeriesObject:
        """
        Update a Meeting

        <div>
        <Callout type="warning">The PUT method is still supported and behaves the same as before, will be deprecated in
        the future. Use the PATCH method instead.</Callout>
        </div>

        Updates details for a meeting with a specified meeting ID. This operation applies to meeting series and
        scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc meetings created by
        `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be updated.

        * If the `meetingId` value specified is for a scheduled meeting, the operation updates that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation updates the entire meeting series.
        **Note**: If the value of `start`, `end`, or `recurrence` for the meeting series is changed, any exceptional
        scheduled meeting in this series is cancelled when the meeting series is updated.

        :param meeting_id: Unique identifier for the meeting to be updated. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Please note that
            currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param title: Meeting title. The title can be a maximum of 128 characters long.
        :type title: str
        :param agenda: Meeting agenda. The agenda can be a maximum of 1300 characters long.
        :type agenda: str
        :param password: Meeting password. Must conform to the site's password complexity settings. Read
            `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details.
        :type password: str
        :param start: Date and time for the start of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `start` cannot be before
            current date and time or after `end`. Duration between `start` and `end` cannot be shorter than 10 minutes
            or longer than 23 hours 59 minutes. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about
            restrictions on updating date and time for a meeting. Please note that when a meeting is being updated,
            `start` of the meeting will be accurate to minutes, not seconds or milliseconds. Therefore, if `start` is
            within the same minute as the current time, `start` will be adjusted to the upcoming minute; otherwise,
            `start` will be adjusted with seconds and milliseconds stripped off. For instance, if the current time is
            `2022-03-01T10:32:16.657+08:00`, `start` of `2022-03-01T10:32:28.076+08:00` or `2022-03-01T10:32:41+08:00`
            will be adjusted to `2022-03-01T10:33:00+08:00`, and `start` of `2022-03-01T11:32:28.076+08:00` or
            `2022-03-01T11:32:41+08:00` will be adjusted to `2022-03-01T11:32:00+08:00`.
        :type start: Union[str, datetime]
        :param end: Date and time for the end of meeting in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `end` cannot be before
            current date and time or before `start`. Duration between `start` and `end` cannot be shorter than 10
            minutes or longer than 23 hours 59 minutes. Refer to the `Webex Meetings
            <https://developer.webex.com/docs/meetings#restrictions-on-updating-a-meeting>`_ guide for more information about
            restrictions on updating date and time for a meeting. Please note that when a meeting is being updated,
            `end` of the meeting will be accurate to minutes, not seconds or milliseconds. Therefore, `end` will be
            adjusted with seconds and milliseconds stripped off. For instance, `end` of
            `2022-03-01T11:52:28.076+08:00` or `2022-03-01T11:52:41+08:00` will be adjusted to
            `2022-03-01T11:52:00+08:00`.
        :type end: Union[str, datetime]
        :param timezone: `Time zone
            <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in which the meeting was originally scheduled (conforming with the
            `IANA time zone database
            <https://www.iana.org/time-zones>`_).
        :type timezone: str
        :param recurrence: Meeting series recurrence rule (conforming with `RFC 2445
            <https://www.ietf.org/rfc/rfc2445.txt>`_). Applies only to a recurring
            meeting series, not to a meeting series with only one scheduled meeting. Multiple days or dates for
            monthly or yearly `recurrence` rule are not supported, only the first day or date specified is taken. For
            example, "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10,11,12" is not supported and it will be partially
            supported as "FREQ=MONTHLY;INTERVAL=1;COUNT=10;BYMONTHDAY=10".
        :type recurrence: str
        :param enabled_auto_record_meeting: Whether or not meeting is recorded automatically.
        :type enabled_auto_record_meeting: bool
        :param allow_any_user_to_be_co_host: Whether or not to allow any attendee with a host account on the target
            site to become a cohost when joining the meeting. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_any_user_to_be_co_host: bool
        :param enabled_join_before_host: Whether or not to allow any attendee to join the meeting before the host joins
            the meeting.
        :type enabled_join_before_host: bool
        :param enable_connect_audio_before_host: Whether or not to allow any attendee to connect audio in the meeting
            before the host joins the meeting. This attribute is only applicable if the `enabledJoinBeforeHost`
            attribute is set to true.
        :type enable_connect_audio_before_host: bool
        :param join_before_host_minutes: Number of minutes an attendee can join the meeting before the meeting start
            time and the host joins. Only applicable if the `enabledJoinBeforeHost` attribute is set to true. Valid
            options for a meeting are `0`, `5`, `10`, and `15`, and valid options for a webinar are `0`, `15`, `30`,
            `45`, and `60`. The default is `0` if not specified.
        :type join_before_host_minutes: int
        :param exclude_password: Whether or not to exclude the meeting password from the email invitation.
        :type exclude_password: bool
        :param public_meeting: Whether or not to allow the meeting to be listed on the public calendar.
        :type public_meeting: bool
        :param reminder_time: The number of minutes before the meeting begins, that an email reminder is sent to the
            host.
        :type reminder_time: int
        :param unlocked_meeting_join_security: Specifies how the people who aren't on the invite can join the unlocked
            meeting.
        :type unlocked_meeting_join_security: MeetingSeriesObjectUnlockedMeetingJoinSecurity
        :param session_type_id: Unique identifier for a meeting session type for the user. This attribute is required
            while scheduling webinar meeting. All available meeting session types enabled for the user can be
            retrieved by `List Meeting Session Types
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-session-types>`_ API.
        :type session_type_id: int
        :param enabled_webcast_view: Whether or not webcast view is enabled.
        :type enabled_webcast_view: bool
        :param panelist_password: Password for panelists of a webinar meeting. Must conform to the site's password
            complexity settings. Read `password management
            <https://help.webex.com/en-us/zrupm6/Manage-Security-Options-for-Your-Site-in-Webex-Site-Administration>`_ for details. If not specified, a random password conforming
            to the site's password rules will be generated automatically.
        :type panelist_password: str
        :param enable_automatic_lock: Whether or not to automatically lock the meeting after it starts.
        :type enable_automatic_lock: bool
        :param automatic_lock_minutes: The number of minutes after the meeting begins, for automatically locking it.
        :type automatic_lock_minutes: int
        :param allow_first_user_to_be_co_host: Whether or not to allow the first attendee of the meeting with a host
            account on the target site to become a cohost. The target site is specified by `siteUrl` parameter when
            creating the meeting; if not specified, it's user's preferred site.
        :type allow_first_user_to_be_co_host: bool
        :param allow_authenticated_devices: Whether or not to allow authenticated video devices in the meeting's
            organization to start or join the meeting without a prompt.
        :type allow_authenticated_devices: bool
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin-level scopes. When used, the admin may specify the email of a
            user in a site they manage to be the meeting host.
        :type host_email: str
        :param site_url: URL of the Webex site which the meeting is updated on. If not specified, the meeting is
            created on user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List` API.
        :type site_url: str
        :param meeting_options: Meeting Options.
        :type meeting_options: MeetingSeriesObjectMeetingOptions
        :param attendee_privileges: Attendee Privileges. This attribute is not supported for a webinar.
        :type attendee_privileges: MeetingSeriesObjectAttendeePrivileges
        :param integration_tags: External keys created by an integration application in its own domain, for example
            Zendesk ticket IDs, Jira IDs, Salesforce Opportunity IDs, etc. The integration application queries
            meetings by a key in its own domain. The maximum size of `integrationTags` is 3 and each item of
            `integrationTags` can be a maximum of 64 characters long. Please note that an empty or null
            `integrationTags` will delete all existing integration tags for the meeting implicitly. Developer can
            update integration tags for a `meetingSeries` but he cannot update it for a `scheduledMeeting` or a
            `meeting` instance.
        :type integration_tags: list[str]
        :param enabled_breakout_sessions: Whether or not breakout sessions are enabled. If the value of
            `enabledBreakoutSessions` is false, users can not set breakout sessions. If the value of
            `enabledBreakoutSessions` is true, users can update breakout sessions using the `Update Breakout Sessions
            <https://developer.webex.com/docs/api/v1/meetings/{meetingId}/breakoutSessions>`_
            API. Updating breakout sessions are not supported by this API.
        :type enabled_breakout_sessions: bool
        :param tracking_codes: Tracking codes information. All available tracking codes and their options for the
            specified site can be retrieved by `List Meeting Tracking Codes
            <https://developer.webex.com/docs/api/v1/meetings/list-meeting-tracking-codes>`_ API. If an optional tracking code is
            missing from the `trackingCodes` array and there's a default option for this tracking code, the default
            option is assigned automatically. If the `inputMode` of a tracking code is `select`, its value must be one
            of the site-level options or the user-level value. Tracking code is not supported for a personal room
            meeting or an ad-hoc space meeting.
        :type tracking_codes: list[MeetingUsageReportTrackingCodeObject]
        :param audio_connection_options: Audio connection options.
        :type audio_connection_options: MeetingSeriesObjectAudioConnectionOptions
        :param require_attendee_login: Require attendees to sign in before joining the webinar. This option works when
            the value of `scheduledType` attribute is `webinar`. Please note that `requireAttendeeLogin` cannot be set
            if someone has already registered for the webinar.
        :type require_attendee_login: bool
        :param restrict_to_invitees: Restrict webinar to invited attendees only. This option works when the
            registration option is disabled and the value of `scheduledType` attribute is `webinar`. Please note that
            `restrictToInvitees` cannot be set to `true` if `requireAttendeeLogin` is `false`.
        :type restrict_to_invitees: bool
        :rtype: :class:`MeetingSeriesObject`
        """
        body = dict()
        body['title'] = title
        body['agenda'] = agenda
        body['password'] = password
        body['start'] = start
        body['end'] = end
        body['timezone'] = timezone
        body['recurrence'] = recurrence
        body['enabledAutoRecordMeeting'] = enabled_auto_record_meeting
        body['allowAnyUserToBeCoHost'] = allow_any_user_to_be_co_host
        body['enabledJoinBeforeHost'] = enabled_join_before_host
        body['enableConnectAudioBeforeHost'] = enable_connect_audio_before_host
        body['joinBeforeHostMinutes'] = join_before_host_minutes
        body['excludePassword'] = exclude_password
        body['publicMeeting'] = public_meeting
        body['reminderTime'] = reminder_time
        body['unlockedMeetingJoinSecurity'] = enum_str(unlocked_meeting_join_security)
        body['sessionTypeId'] = session_type_id
        body['enabledWebcastView'] = enabled_webcast_view
        body['panelistPassword'] = panelist_password
        body['enableAutomaticLock'] = enable_automatic_lock
        body['automaticLockMinutes'] = automatic_lock_minutes
        body['allowFirstUserToBeCoHost'] = allow_first_user_to_be_co_host
        body['allowAuthenticatedDevices'] = allow_authenticated_devices
        body['sendEmail'] = send_email
        body['hostEmail'] = host_email
        body['siteUrl'] = site_url
        body['meetingOptions'] = loads(meeting_options.model_dump_json())
        body['attendeePrivileges'] = loads(attendee_privileges.model_dump_json())
        body['integrationTags'] = integration_tags
        body['enabledBreakoutSessions'] = enabled_breakout_sessions
        body['trackingCodes'] = loads(TypeAdapter(list[MeetingUsageReportTrackingCodeObject]).dump_json(tracking_codes))
        body['audioConnectionOptions'] = loads(audio_connection_options.model_dump_json())
        body['requireAttendeeLogin'] = require_attendee_login
        body['restrictToInvitees'] = restrict_to_invitees
        url = self.ep(f'{meeting_id}')
        data = super().put(url, json=body)
        r = MeetingSeriesObject.model_validate(data)
        return r

    def delete_a_meeting(self, meeting_id: str, host_email: str = None, send_email: bool = None):
        """
        Delete a Meeting

        Deletes a meeting with a specified meeting ID. The deleted meeting cannot be recovered. This operation applies
        to meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances. Ad-hoc
        meetings created by `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_ with `adhoc` of `true` and a `roomId` cannot be deleted.

        * If the `meetingId` value specified is for a scheduled meeting, the operation deletes that scheduled meeting
        without impact on other scheduled meeting of the parent meeting series.

        * If the `meetingId` value specified is for a meeting series, the operation deletes the entire meeting series.

        :param meeting_id: Unique identifier for the meeting to be deleted. This parameter applies to meeting series
            and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will delete a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}')
        super().delete(url, params=params)

    def join_a_meeting(self, meeting_id: str, meeting_number: str, web_link: str, join_directly: bool, email: str,
                       display_name: str, password: str, expiration_minutes: int, registration_id: Union[str,
                       datetime], host_email: str) -> JoinMeetingLinkObject:
        """
        Join a Meeting

        Retrieves links for a meeting with a specified `meetingId`, `meetingNumber`, or `webLink` that allow users to
        start or join the meeting directly without logging in and entering a password.

        * Please note that `meetingId`, `meetingNumber` and `webLink` are mutually exclusive and they cannot be
        specified simultaneously.

        * If `joinDirectly` is true or not specified, the response will have HTTP response code 302 and the request
        will be redirected to `joinLink`; otherwise, the response will have HTTP response code 200 and `joinLink` will
        be returned in response body.

        * Only the meeting host or cohost can generate the `startLink`.

        * An admin user or a `Service App
        <https://developer.webex.com/docs/service-apps>`_ can generate the `startLink` and `joinLink` on behalf of another meeting host
        using the `hostEmail` parameter. When a `Service App
        <https://developer.webex.com/docs/service-apps>`_ generates the `startLink` and `joinLink`, the `hostEmail`
        parameter is required. The `hostEmail` parameter only applies to meetings, not webinars.

        * For Service Apps, `hostEmail` must be provided in the request.

        * Generating a join link or a start link before the time specified by `joinBeforeHostMinutes` for a webinar is
        not supported.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances. Please note that currently meeting
            ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is also supported for this API.
        :type meeting_id: str
        :param meeting_number: Meeting number. Applies to meeting series, scheduled meeting, and meeting instances, but
            not to meeting instances which have ended.
        :type meeting_number: str
        :param web_link: Link to a meeting information page where the meeting client is launched if the meeting is
            ready to start or join.
        :type web_link: str
        :param join_directly: Whether or not to redirect to `joinLink`. It is an optional field and default value is
            true.
        :type join_directly: bool
        :param email: Email address of meeting participant. If `email` is specified, the link is generated for the user
            of `email`; otherwise, the API returns the link for the user calling the API. `email` is required for a
            `guest issuer
            <https://developer.webex.com/docs/guest-issuer>`_.
        :type email: str
        :param display_name: Display name of meeting participant. If `displayName` is specified, `email` must be
            specified as well. If `email` is specified and `displayName` is not, display name is the same as `email`.
            If neither `displayName` nor `email` is specified, the API returns the link for the user calling the API.
            The maximum length of `displayName` is 128 characters. `displayName` is required for a `guest issuer
            <https://developer.webex.com/docs/guest-issuer>`_.
        :type display_name: str
        :param password: Required when the meeting is protected by a password and the current user is not privileged to
            view it if they are not a host, cohost, or invitee.
        :type password: str
        :param expiration_minutes: Expiration duration of `joinLink` in minutes. Must be between 1 and 60.
        :type expiration_minutes: int
        :param registration_id: Required when the meeting is webinar-enabled and enabled registration ID.
        :type registration_id: Union[str, datetime]
        :param host_email: Email address for the meeting host. This attribute should be set if the user or application
            calling the API has the admin on-behalf-of scopes. This parameter is required for a `Service App
            <https://developer.webex.com/docs/service-apps>`_. It only
            applies to meetings, not webinars.
        :type host_email: str
        :rtype: :class:`JoinMeetingLinkObject`
        """
        body = dict()
        body['meetingId'] = meeting_id
        body['meetingNumber'] = meeting_number
        body['webLink'] = web_link
        body['joinDirectly'] = join_directly
        body['email'] = email
        body['displayName'] = display_name
        body['password'] = password
        body['expirationMinutes'] = expiration_minutes
        body['registrationId'] = registration_id
        body['hostEmail'] = host_email
        url = self.ep('join')
        data = super().post(url, json=body)
        r = JoinMeetingLinkObject.model_validate(data)
        return r

    def list_meeting_templates(self, template_type: MeetingUsageReportObjectScheduledType = None, locale: str = None,
                               is_default: bool = None, is_standard: bool = None, host_email: str = None,
                               site_url: str = None) -> list[TemplateObject]:
        """
        List Meeting Templates

        Retrieves the list of meeting templates that is available for the authenticated user.

        There are separate lists of meeting templates for different `templateType`, `locale` and `siteUrl`.

        * If `templateType` is specified, the operation returns an array of meeting template objects specified by the
        `templateType`; otherwise, returns an array of meeting template objects of all template types.

        * If `locale` is specified, the operation returns an array of meeting template objects specified by the
        `locale`; otherwise, returns an array of meeting template objects of the default `en_US` locale. Refer to
        `Meeting Template Locales
        <https://developer.webex.com/docs/meetings#meeting-template-locales>`_ for all the locales supported by Webex.

        * If the parameter `siteUrl` has a value, the operation lists meeting templates on the specified site;
        otherwise, lists meeting templates on the user's preferred site. All available Webex sites and preferred site
        of the user can be retrieved by `Get Site List` API.

        :param template_type: Meeting template type for the meeting template objects being requested. If not specified,
            return meeting templates of all types.
        :type template_type: MeetingUsageReportObjectScheduledType
        :param locale: Locale for the meeting template objects being requested. If not specified, return meeting
            templates of the default `en_US` locale. Refer to `Meeting Template Locales
            <https://developer.webex.com/docs/meetings#meeting-template-locales>`_ for all the locales supported
            by Webex.
        :type locale: str
        :param is_default: The value is `true` or `false`. If it's `true`, return the default meeting templates; if
            it's `false`, return the non-default meeting templates. If it's not specified, return both default and
            non-default meeting templates.
        :type is_default: bool
        :param is_standard: The value is `true` or `false`. If it's `true`, return the standard meeting templates; if
            it's `false`, return the non-standard meeting templates. If it's not specified, return both standard and
            non-standard meeting templates.
        :type is_standard: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return meeting templates that are available for that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists meeting templates from. If not specified, the API
            lists meeting templates from user's preferred site. All available Webex sites and preferred site of the
            user can be retrieved by `Get Site List` API.
        :type site_url: str
        :rtype: list[TemplateObject]
        """
        params = {}
        if template_type is not None:
            params['templateType'] = template_type
        if locale is not None:
            params['locale'] = locale
        if is_default is not None:
            params['isDefault'] = str(is_default).lower()
        if is_standard is not None:
            params['isStandard'] = str(is_standard).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('templates')
        data = super().get(url, params=params)
        r = TypeAdapter(list[TemplateObject]).validate_python(data['items'])
        return r

    def get_a_meeting_template(self, template_id: str, host_email: str = None) -> DetailedTemplateObject:
        """
        Get a Meeting Template

        Retrieves details for a meeting template with a specified meeting template ID.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param template_id: Unique identifier for the meeting template being requested.
        :type template_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return the meeting template that is available for that user.
        :type host_email: str
        :rtype: :class:`DetailedTemplateObject`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'templates/{template_id}')
        data = super().get(url, params=params)
        r = DetailedTemplateObject.model_validate(data)
        return r

    def get_meeting_control_status(self, meeting_id: str) -> Control:
        """
        Get Meeting Control Status

        Get the meeting control of a live meeting, which is consisted of meeting control status on "locked" and
        "recording" to reflect whether the meeting is currently locked and there is recording in progress.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :rtype: :class:`Control`
        """
        params = {}
        params['meetingId'] = meeting_id
        url = self.ep('controls')
        data = super().get(url, params=params)
        r = Control.model_validate(data)
        return r

    def update_meeting_control_status(self, meeting_id: str, recording_started: str = None,
                                      recording_paused: str = None, locked: str = None) -> Control:
        """
        Update Meeting Control Status

        To start, pause, resume, or stop a meeting recording; To lock or unlock an on-going meeting.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param recording_started: The value can be true or false. true means to start the recording, false to end the
            recording.
        :type recording_started: str
        :param recording_paused: The value can be true or false, will be ignored if 'recordingStarted' sets to false,
            and true to resume the recording only if the recording is paused vise versa.
        :type recording_paused: str
        :param locked: The value is true or false.
        :type locked: str
        :rtype: :class:`Control`
        """
        params = {}
        params['meetingId'] = meeting_id
        body = dict()
        body['recordingStarted'] = recording_started
        body['recordingPaused'] = recording_paused
        body['locked'] = locked
        url = self.ep('controls')
        data = super().put(url, params=params, json=body)
        r = Control.model_validate(data)
        return r

    def list_meeting_session_types(self, host_email: str = None,
                                   site_url: str = None) -> list[MeetingSessionTypeObject]:
        """
        List Meeting Session Types

        List all the meeting session types enabled for a given user.

        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will list all the meeting session types enabled for the user.
        :type host_email: str
        :param site_url: Webex site URL to query. If `siteUrl` is not specified, the users' preferred site will be
            used. If the authorization token has the admin-level scopes, the admin can set the Webex site URL on
            behalf of the user specified in the `hostEmail` parameter.
        :type site_url: str
        :rtype: list[MeetingSessionTypeObject]
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('sessionTypes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MeetingSessionTypeObject]).validate_python(data['items'])
        return r

    def get_a_meeting_session_type(self, session_type_id: int, host_email: str = None,
                                   site_url: str = None) -> MeetingSessionTypeObject:
        """
        Get a Meeting Session Type

        Retrieves details for a meeting session type with a specified session type ID.

        :param session_type_id: A unique identifier for the sessionType.
        :type session_type_id: int
        :param host_email: Email address for the user. This parameter is only used if the user or application calling
            the API has the admin-level scopes. If set, the admin may specify the email of a user in a site they
            manage and the API will get a meeting session type with the specified session type ID enabled for the
            user.
        :type host_email: str
        :param site_url: Webex site URL to query. If `siteUrl` is not specified, the users' preferred site will be
            used. If the authorization token has the admin-level scopes, the admin can set the Webex site URL on
            behalf of the user specified in the `hostEmail` parameter.
        :type site_url: str
        :rtype: :class:`MeetingSessionTypeObject`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep(f'sessionTypes/{session_type_id}')
        data = super().get(url, params=params)
        r = MeetingSessionTypeObject.model_validate(data)
        return r

    def get_registration_form_for_a_meeting(self, meeting_id: str, current: bool = None,
                                            host_email: str = None) -> Registration2:
        """
        Get registration form for a meeting

        Get a meeting's registration form to understand which fields are required.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`Registration2`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registration')
        data = super().get(url, params=params)
        r = Registration2.model_validate(data)
        return r

    def update_meeting_registration_form(self, meeting_id: str, host_email: str, auto_accept_request: bool,
                                         require_first_name: bool, require_last_name: bool, require_email: bool,
                                         require_job_title: bool, require_company_name: bool, require_address1: bool,
                                         require_address2: bool, require_city: bool, require_state: bool,
                                         require_zip_code: bool, require_country_region: bool,
                                         require_work_phone: bool, require_fax: bool, max_register_num: int,
                                         customized_questions: list[CustomizedQuestionForCreateMeeting],
                                         rules: list[StandardRegistrationApproveRule]) -> Registration2:
        """
        Update Meeting Registration Form

        Enable or update a registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param host_email: - Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return an update for a meeting that is hosted by that user.
        :type host_email: str
        :param auto_accept_request: Whether or not meeting registration requests are accepted automatically.
        :type auto_accept_request: bool
        :param require_first_name: Whether or not a registrant's first name is required for meeting registration. This
            option must always be `true`.
        :type require_first_name: bool
        :param require_last_name: Whether or not a registrant's last name is required for meeting registration. This
            option must always be `true`.
        :type require_last_name: bool
        :param require_email: Whether or not a registrant's email is required for meeting registration. This option
            must always be `true`.
        :type require_email: bool
        :param require_job_title: Whether or not a registrant's job title is shown or required for meeting
            registration.
        :type require_job_title: bool
        :param require_company_name: Whether or not a registrant's company name is shown or required for meeting
            registration.
        :type require_company_name: bool
        :param require_address1: Whether or not a registrant's first address field is shown or required for meeting
            registration.
        :type require_address1: bool
        :param require_address2: Whether or not a registrant's second address field is shown or required for meeting
            registration.
        :type require_address2: bool
        :param require_city: Whether or not a registrant's city is shown or required for meeting registration.
        :type require_city: bool
        :param require_state: Whether or not a registrant's state is shown or required for meeting registration.
        :type require_state: bool
        :param require_zip_code: Whether or not a registrant's postal code is shown or required for meeting
            registration.
        :type require_zip_code: bool
        :param require_country_region: Whether or not a registrant's country or region is shown or required for meeting
            registration.
        :type require_country_region: bool
        :param require_work_phone: Whether or not a registrant's work phone number is shown or required for meeting
            registration.
        :type require_work_phone: bool
        :param require_fax: Whether or not a registrant's fax number is shown or required for meeting registration.
        :type require_fax: bool
        :param max_register_num: Maximum number of meeting registrations. This only applies to meetings. The maximum
            number of participants for meetings and webinars, with the limit based on the user capacity and controlled
            by a toggle at the site level. The default maximum number of participants for webinars is 10000, but the
            actual maximum number of participants is limited by the user capacity.
        :type max_register_num: int
        :param customized_questions: Customized questions for meeting registration.
        :type customized_questions: list[CustomizedQuestionForCreateMeeting]
        :param rules: The approval rule for standard questions.
        :type rules: list[StandardRegistrationApproveRule]
        :rtype: :class:`Registration2`
        """
        body = dict()
        body['hostEmail'] = host_email
        body['autoAcceptRequest'] = auto_accept_request
        body['requireFirstName'] = require_first_name
        body['requireLastName'] = require_last_name
        body['requireEmail'] = require_email
        body['requireJobTitle'] = require_job_title
        body['requireCompanyName'] = require_company_name
        body['requireAddress1'] = require_address1
        body['requireAddress2'] = require_address2
        body['requireCity'] = require_city
        body['requireState'] = require_state
        body['requireZipCode'] = require_zip_code
        body['requireCountryRegion'] = require_country_region
        body['requireWorkPhone'] = require_work_phone
        body['requireFax'] = require_fax
        body['maxRegisterNum'] = max_register_num
        body['customizedQuestions'] = loads(TypeAdapter(list[CustomizedQuestionForCreateMeeting]).dump_json(customized_questions))
        body['rules'] = loads(TypeAdapter(list[StandardRegistrationApproveRule]).dump_json(rules))
        url = self.ep(f'{meeting_id}/registration')
        data = super().put(url, json=body)
        r = Registration2.model_validate(data)
        return r

    def delete_meeting_registration_form(self, meeting_id: str):
        """
        Delete Meeting Registration Form

        Disable the registration form for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :rtype: None
        """
        url = self.ep(f'{meeting_id}/registration')
        super().delete(url)

    def register_a_meeting_registrant(self, meeting_id: str, first_name: str, last_name: str, email: str,
                                      send_email: bool, job_title: str, company_name: str, address1: str,
                                      address2: str, city: str, state: str, zip_code: int, country_region: str,
                                      work_phone: str, fax: str, customized_questions: list[CustomizedRegistrant],
                                      current: bool = None, host_email: str = None) -> RegistrantCreateResponse:
        """
        Register a Meeting Registrant

        Register a new registrant for a meeting. When a meeting or webinar is created, this API can only be used if
        Registration is checked on the page or the registration attribute is specified through the `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_
        API.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param first_name: The registrant's first name.
        :type first_name: str
        :param last_name: The registrant's last name. (Required)
        :type last_name: str
        :param email: The registrant's email.
        :type email: str
        :param send_email: If `true` send email to the registrant. Default: `true`.
        :type send_email: bool
        :param job_title: The registrant's job title. Registration options define whether or not this is required.
        :type job_title: str
        :param company_name: The registrant's company. Registration options define whether or not this is required.
        :type company_name: str
        :param address1: The registrant's first address line. Registration options define whether or not this is
            required.
        :type address1: str
        :param address2: The registrant's second address line. Registration options define whether or not this is
            required.
        :type address2: str
        :param city: The registrant's city name. Registration options define whether or not this is required.
        :type city: str
        :param state: The registrant's state. Registration options define whether or not this is required.
        :type state: str
        :param zip_code: The registrant's postal code. Registration options define whether or not this is required.
        :type zip_code: int
        :param country_region: The America is not a country or a specific region. Registration options define whether
            or not this is required.
        :type country_region: str
        :param work_phone: The registrant's work phone number. Registration options define whether or not this is
            required.
        :type work_phone: str
        :param fax: The registrant's FAX number. Registration options define whether or not this is required.
        :type fax: str
        :param customized_questions: The registrant's answers for customized questions. Registration options define
            whether or not this is required.
        :type customized_questions: list[CustomizedRegistrant]
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`RegistrantCreateResponse`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['email'] = email
        body['sendEmail'] = send_email
        body['jobTitle'] = job_title
        body['companyName'] = company_name
        body['address1'] = address1
        body['address2'] = address2
        body['city'] = city
        body['state'] = state
        body['zipCode'] = zip_code
        body['countryRegion'] = country_region
        body['workPhone'] = work_phone
        body['fax'] = fax
        body['customizedQuestions'] = loads(TypeAdapter(list[CustomizedRegistrant]).dump_json(customized_questions))
        url = self.ep(f'{meeting_id}/registrants')
        data = super().post(url, params=params, json=body)
        r = RegistrantCreateResponse.model_validate(data)
        return r

    def batch_register_meeting_registrants(self, meeting_id: str, current: bool = None, host_email: str = None,
                                           items: list[RegistrantFormObject] = None) -> list[RegistrantCreateResponse]:
        """
        Batch register Meeting Registrants

        Bulk register new registrants for a meeting. When a meeting or webinar is created, this API can only be used if
        Registration is checked on the page or the registration attribute is specified through the `Create a Meeting
        <https://developer.webex.com/docs/api/v1/meetings/create-a-meeting>`_
        API.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param items: Registrants array.
        :type items: list[RegistrantFormObject]
        :rtype: list[RegistrantCreateResponse]
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['items'] = loads(TypeAdapter(list[RegistrantFormObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/registrants/bulkInsert')
        data = super().post(url, params=params, json=body)
        r = TypeAdapter(list[RegistrantCreateResponse]).validate_python(data['items'])
        return r

    def get_detailed_information_for_a_meeting_registrant(self, meeting_id: str, registrant_id: str,
                                                          current: bool = None,
                                                          host_email: str = None) -> Registrant1:
        """
        Get Detailed Information for a Meeting Registrant

        Retrieves details for a meeting registrant with a specified registrant Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: :class:`Registrant1`
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        data = super().get(url, params=params)
        r = Registrant1.model_validate(data)
        return r

    def list_meeting_registrants(self, meeting_id: str, host_email: str = None, current: bool = None,
                                 email: str = None, registration_time_from: Union[str, datetime] = None,
                                 registration_time_to: Union[str, datetime] = None,
                                 **params) -> Generator[Registrant1, None, None]:
        """
        List Meeting Registrants

        Meeting's host and cohost can retrieve the list of registrants for a meeting with a specified meeting Id.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param email: Registrant's email to filter registrants.
        :type email: str
        :param registration_time_from: The time registrants register a meeting starts from the specified date and time
            (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `registrationTimeFrom` is not specified, it equals
            `registrationTimeTo` minus 7 days.
        :type registration_time_from: Union[str, datetime]
        :param registration_time_to: The time registrants register a meeting before the specified date and time
            (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. If `registrationTimeTo` is not specified, it equals
            `registrationTimeFrom` plus 7 days. The interval between `registrationTimeFrom` and `registrationTimeTo`
            must be within 90 days.
        :type registration_time_to: Union[str, datetime]
        :return: Generator yielding :class:`Registrant1` instances
        """
        if host_email is not None:
            params['hostEmail'] = host_email
        if current is not None:
            params['current'] = str(current).lower()
        if email is not None:
            params['email'] = email
        if registration_time_from is not None:
            if isinstance(registration_time_from, str):
                registration_time_from = isoparse(registration_time_from)
            registration_time_from = dt_iso_str(registration_time_from)
            params['registrationTimeFrom'] = registration_time_from
        if registration_time_to is not None:
            if isinstance(registration_time_to, str):
                registration_time_to = isoparse(registration_time_to)
            registration_time_to = dt_iso_str(registration_time_to)
            params['registrationTimeTo'] = registration_time_to
        url = self.ep(f'{meeting_id}/registrants')
        return self.session.follow_pagination(url=url, model=Registrant1, item_key='items', params=params)

    def query_meeting_registrants(self, meeting_id: str, status: RegistrantStatus,
                                  order_type: QueryRegistrantsOrderType, order_by: QueryRegistrantsOrderBy,
                                  emails: list[str], current: bool = None, host_email: str = None,
                                  **params) -> Generator[Registrant1, None, None]:
        """
        Query Meeting Registrants

        Meeting's host and cohost can query the list of registrants for a meeting with a specified meeting ID and
        registrants email.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param status: Registrant's status.
        :type status: RegistrantStatus
        :param order_type: Sort order for the registrants.
        :type order_type: QueryRegistrantsOrderType
        :param order_by: Registrant ordering field. Ordered by `registrationTime` by default.
        :type order_by: QueryRegistrantsOrderBy
        :param emails: List of registrant email addresses.
        :type emails: list[str]
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :return: Generator yielding :class:`Registrant1` instances
        """
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['status'] = enum_str(status)
        body['orderType'] = enum_str(order_type)
        body['orderBy'] = enum_str(order_by)
        body['emails'] = emails
        url = self.ep(f'{meeting_id}/registrants/query')
        return self.session.follow_pagination(url=url, model=Registrant1, item_key='items', params=params, json=body)

    def batch_update_meeting_registrants_status(self, meeting_id: str,
                                                status_op_type: BatchUpdateMeetingRegistrantsStatusStatusOpType,
                                                current: bool = None, host_email: str = None, send_email: str = None,
                                                registrants: list[DepartmentResponseWithId] = None):
        """
        Batch Update Meeting Registrants status

        Meeting's host or cohost can update the set of registrants for a meeting. `cancel` means the registrant(s) will
        be moved back to the registration list. `bulkDelete` means the registrant(s) will be deleted.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param status_op_type: Update registrant's status.
        :type status_op_type: BatchUpdateMeetingRegistrantsStatusStatusOpType
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        + Default: `false`
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If `true` send email to registrants. Default: `true`.
        :type send_email: str
        :param registrants: Registrants array.
        :type registrants: list[DepartmentResponseWithId]
        :rtype: None
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['sendEmail'] = send_email
        body['registrants'] = loads(TypeAdapter(list[DepartmentResponseWithId]).dump_json(registrants))
        url = self.ep(f'{meeting_id}/registrants/{status_op_type}')
        super().post(url, params=params, json=body)

    def delete_a_meeting_registrant(self, meeting_id: str, registrant_id: str, current: bool = None,
                                    host_email: str = None):
        """
        Delete a Meeting Registrant

        Meeting's host or cohost can delete a registrant with a specified registrant ID.

        :param meeting_id: Unique identifier for the meeting. Only the ID of the meeting series is supported for
            meetingId. IDs of scheduled meetings, meeting instances, or scheduled personal room meetings are not
            supported. See the `Meetings Overview
            <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about meeting types.
        :type meeting_id: str
        :param registrant_id: Unique identifier for the registrant.
        :type registrant_id: str
        :param current: Whether or not to retrieve only the current scheduled meeting of the meeting series, i.e. the
            meeting ready to join or start or the upcoming meeting of the meeting series. If it's `true`, return
            details for the current scheduled meeting of the series, i.e. the scheduled meeting ready to join or start
            or the upcoming scheduled meeting of the meeting series. If it's `false` or not specified, return details
            for the entire meeting series. This parameter only applies to meeting series.
        :type current: bool
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :rtype: None
        """
        params = {}
        if current is not None:
            params['current'] = str(current).lower()
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/registrants/{registrant_id}')
        super().delete(url, params=params)

    def update_meeting_simultaneous_interpretation(self, meeting_id: str, enabled: bool,
                                                   interpreters: list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]) -> MeetingSeriesObjectSimultaneousInterpretation:
        """
        Update Meeting Simultaneous interpretation

        Updates simultaneous interpretation options of a meeting with a specified meeting ID. This operation applies to
        meeting series and scheduled meetings. It doesn't apply to ended or in-progress meeting instances.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param enabled: Whether or not simultaneous interpretation is enabled.
        :type enabled: bool
        :param interpreters: Interpreters for meeting.
        :type interpreters: list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]
        :rtype: :class:`MeetingSeriesObjectSimultaneousInterpretation`
        """
        body = dict()
        body['enabled'] = enabled
        body['interpreters'] = loads(TypeAdapter(list[InterpreterObjectForSimultaneousInterpretationOfCreateOrUpdateMeeting]).dump_json(interpreters))
        url = self.ep(f'{meeting_id}/simultaneousInterpretation')
        data = super().put(url, json=body)
        r = MeetingSeriesObjectSimultaneousInterpretation.model_validate(data)
        return r

    def create_a_meeting_interpreter(self, meeting_id: str, language_code1: str, language_code2: str, email: str,
                                     display_name: str, host_email: str,
                                     send_email: bool) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Create a Meeting Interpreter

        Assign an interpreter to a bi-directional simultaneous interpretation language channel for a meeting.

        :param meeting_id: Unique identifier for the meeting to which the interpreter is to be assigned.
        :type meeting_id: str
        :param language_code1: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code1: str
        :param language_code2: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code2: str
        :param email: Email address of meeting interpreter. If not specified, an empty interpreter will be created for
            this bi-directional language channel, and a specific email can be assigned to this empty interpreter by
            `Update a Meeting Interpreter` API later. Please note that multiple interpreters with different emails can
            be assigned to the same bi-directional language channel, but the same email cannot be assigned to more
            than one interpreter.
        :type email: str
        :param display_name: Display name of meeting interpreter. If the interpreter is already an invitee of the
            meeting and it has a different display name, that invitee's display name will be overwritten by this
            attribute.
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        body = dict()
        body['languageCode1'] = language_code1
        body['languageCode2'] = language_code2
        body['email'] = email
        body['displayName'] = display_name
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().post(url, json=body)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def get_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str,
                                  host_email: str = None) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Get a Meeting Interpreter

        Retrieves details for a meeting interpreter identified by `meetingId` and `interpreterId` in the URI.

        :param meeting_id: Unique identifier for the meeting to which the interpreter has been assigned.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return details for an interpreter of the meeting that is hosted by that
            user.
        :type host_email: str
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().get(url, params=params)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def list_meeting_interpreters(self, meeting_id: str,
                                  host_email: str = None) -> list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]:
        """
        List Meeting Interpreters

        Lists meeting interpreters for a meeting with a specified `meetingId`.

        This operation can be used for meeting series, scheduled meeting and ended or ongoing meeting instance objects.
        If the specified `meetingId` is for a meeting series, the interpreters for the series will be listed; if the
        `meetingId` is for a scheduled meeting, the interpreters for the particular scheduled meeting will be listed;
        if the `meetingId` is for an ended or ongoing meeting instance, the interpreters for the particular meeting
        instance will be listed. See the `Webex Meetings
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ guide for more information about the types of meetings.

        The list returned is sorted in descending order by when interpreters were created.

        :param meeting_id: Unique identifier for the meeting for which interpreters are being requested. The meeting
            can be meeting series, scheduled meeting or meeting instance which has ended or is ongoing. Please note
            that currently meeting ID of a scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return interpreters of the meeting that is hosted by that user.
        :type host_email: str
        :rtype: list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'{meeting_id}/interpreters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting]).validate_python(data['items'])
        return r

    def update_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str, language_code1: str,
                                     language_code2: str, email: str, display_name: str, host_email: str,
                                     send_email: bool) -> InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting:
        """
        Update a Meeting Interpreter

        Updates details for a meeting interpreter identified by `meetingId` and `interpreterId` in the URI.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter whose details are being requested.
        :type interpreter_id: str
        :param language_code1: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code1: str
        :param language_code2: The pair of `languageCode1` and `languageCode2` form a bi-directional simultaneous
            interpretation language channel. The language codes conform with `ISO 639-1
            <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_.
        :type language_code2: str
        :param email: Email address of meeting interpreter. If not specified, it'll be an empty interpreter for the
            bi-directional language channel. Please note that multiple interpreters with different emails can be
            assigned to the same bi-directional language channel, but the same email cannot be assigned to more than
            one interpreter.
        :type email: str
        :param display_name: Display name of meeting interpreter. If the interpreter is already an invitee of the
            meeting and it has a different display name, that invitee's display name will be overwritten by this
            attribute.
        :type display_name: str
        :param host_email: Email address for the meeting host. This attribute should only be set if the user or
            application calling the API has the admin on-behalf-of scopes. When used, the admin may specify the email
            of a user in a site they manage to be the meeting host.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: :class:`InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting`
        """
        body = dict()
        body['languageCode1'] = language_code1
        body['languageCode2'] = language_code2
        body['email'] = email
        body['displayName'] = display_name
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        data = super().put(url, json=body)
        r = InterpreterObjectForSimultaneousInterpretationOfGetOrListMeeting.model_validate(data)
        return r

    def delete_a_meeting_interpreter(self, meeting_id: str, interpreter_id: str, host_email: str = None,
                                     send_email: bool = None):
        """
        Delete a Meeting Interpreter

        Removes a meeting interpreter identified by `meetingId` and `interpreterId` in the URI. The deleted meeting
        interpreter cannot be recovered.

        :param meeting_id: Unique identifier for the meeting whose interpreters were belong to.
        :type meeting_id: str
        :param interpreter_id: Unique identifier for the interpreter to be removed.
        :type interpreter_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will delete an interpreter of the meeting that is hosted by that user.
        :type host_email: str
        :param send_email: If `true`, send email to the interpreter.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/interpreters/{interpreter_id}')
        super().delete(url, params=params)

    def update_meeting_breakout_sessions(self, meeting_id: str, host_email: str, send_email: bool,
                                         items: list[BreakoutSessionObject]) -> list[GetBreakoutSessionObject]:
        """
        Update Meeting Breakout Sessions

        Updates breakout sessions of a meeting with a specified meeting ID in the pre-meeting state. This operation
        applies to meeting series and scheduled meetings.

        :param meeting_id: Unique identifier for the meeting. Does not support meeting IDs for a scheduled
            `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin-level scopes. If set, the admin may specify the email of a user in a site
            they manage and the API will return details for a meeting that is hosted by that user.
        :type host_email: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :param items: Breakout sessions are smaller groups that are split off from the main meeting or webinar. They
            allow a subset of participants to collaborate and share ideas over audio and video. Use breakout sessions
            for workshops, classrooms, or for when you need a moment to talk privately with a few participants outside
            of the main session. Please note that maximum number of breakout sessions in a meeting or webinar is 100.
            In webinars, if hosts preassign attendees to breakout sessions, the role of `attendee` will be changed to
            `panelist`. Breakout session is not supported for a meeting with simultaneous interpretation.
        :type items: list[BreakoutSessionObject]
        :rtype: list[GetBreakoutSessionObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['sendEmail'] = send_email
        body['items'] = loads(TypeAdapter(list[BreakoutSessionObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().put(url, json=body)
        r = TypeAdapter(list[GetBreakoutSessionObject]).validate_python(data['items'])
        return r

    def list_meeting_breakout_sessions(self, meeting_id: str) -> list[GetBreakoutSessionObject]:
        """
        List Meeting Breakout Sessions

        Lists meeting breakout sessions for a meeting with a specified `meetingId`.

        This operation can be used for meeting series, scheduled meeting and ended or ongoing meeting instance objects.
        See the `Webex Meetings
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ guide for more information about the types of meetings.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series, scheduled
            meeting and ended or ongoing meeting instance objects. Please note that currently meeting ID of a
            scheduled `personal room
            <https://help.webex.com/en-us/article/nul0wut/Webex-Personal-Rooms-in-Webex-Meetings>`_ meeting is not supported for this API.
        :type meeting_id: str
        :rtype: list[GetBreakoutSessionObject]
        """
        url = self.ep(f'{meeting_id}/breakoutSessions')
        data = super().get(url)
        r = TypeAdapter(list[GetBreakoutSessionObject]).validate_python(data['items'])
        return r

    def delete_meeting_breakout_sessions(self, meeting_id: str, send_email: bool = None):
        """
        Delete Meeting Breakout Sessions

        Deletes breakout sessions with a specified meeting ID. The deleted breakout sessions cannot be recovered. The
        value of `enabledBreakoutSessions` attribute is set to `false` automatically.
        This operation applies to meeting series and scheduled meetings. It doesn't apply to ended or in-progress
        meeting instances.

        :param meeting_id: Unique identifier for the meeting. This parameter applies to meeting series and scheduled
            meetings. It doesn't apply to ended or in-progress meeting instances.
        :type meeting_id: str
        :param send_email: Whether or not to send emails to host and invitees. It is an optional field and default
            value is true.
        :type send_email: bool
        :rtype: None
        """
        params = {}
        if send_email is not None:
            params['sendEmail'] = str(send_email).lower()
        url = self.ep(f'{meeting_id}/breakoutSessions')
        super().delete(url, params=params)

    def get_a_meeting_survey(self, meeting_id: str) -> SurveyObject:
        """
        Get a Meeting Survey

        Retrieves details for a meeting survey identified by `meetingId`.

        #### Request Header

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return survey details of that user.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str
        :rtype: :class:`SurveyObject`
        """
        url = self.ep(f'{meeting_id}/survey')
        data = super().get(url)
        r = SurveyObject.model_validate(data)
        return r

    def list_meeting_survey_results(self, meeting_id: str, meeting_start_time_from: Union[str, datetime] = None,
                                    meeting_start_time_to: Union[str, datetime] = None,
                                    **params) -> Generator[SurveyResultObject, None, None]:
        """
        List Meeting Survey Results

        Retrieves results for a meeting survey identified by `meetingId`.

        #### Request Header

        * `timezone`: Time zone for time stamps in response body, defined in conformance with the
        `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return the survey results of that user.

        :param meeting_id: Unique identifier for the meeting. Please note that only the meeting ID of a scheduled
            webinar is supported for this API.
        :type meeting_id: str
        :param meeting_start_time_from: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the
            meeting objects being requested. `meetingStartTimeFrom` cannot be after `meetingStartTimeTo`. This
            parameter will be ignored if `meetingId` is the unique identifier for the specific meeting instance.
        When `meetingId` is not the unique identifier for the specific meeting instance, the `meetingStartTimeFrom`, if
        not specified, equals `meetingStartTimeTo` minus `1` month; if `meetingStartTimeTo` is also not specified, the
        default value for `meetingStartTimeFrom` is `1` month before the current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting
            objects being requested. `meetingStartTimeTo` cannot be prior to `meetingStartTimeFrom`. This parameter
            will be ignored if `meetingId` is the unique identifier for the specific meeting instance.
        When `meetingId` is not the unique identifier for the specific meeting instance, if `meetingStartTimeFrom` is
        also not specified, the default value for `meetingStartTimeTo` is the current date and time;For example,if
        `meetingStartTimeFrom` is a month ago, the default value for `meetingStartTimeTo` is `1` month after
        `meetingStartTimeFrom`.Otherwise it is the current date and time.
        :type meeting_start_time_to: Union[str, datetime]
        :return: Generator yielding :class:`SurveyResultObject` instances
        """
        if meeting_start_time_from is not None:
            if isinstance(meeting_start_time_from, str):
                meeting_start_time_from = isoparse(meeting_start_time_from)
            meeting_start_time_from = dt_iso_str(meeting_start_time_from)
            params['meetingStartTimeFrom'] = meeting_start_time_from
        if meeting_start_time_to is not None:
            if isinstance(meeting_start_time_to, str):
                meeting_start_time_to = isoparse(meeting_start_time_to)
            meeting_start_time_to = dt_iso_str(meeting_start_time_to)
            params['meetingStartTimeTo'] = meeting_start_time_to
        url = self.ep(f'{meeting_id}/surveyResults')
        return self.session.follow_pagination(url=url, model=SurveyResultObject, item_key='items', params=params)

    def get_meeting_survey_links(self, meeting_id: str, host_email: str, meeting_start_time_from: Union[str, datetime],
                                 meeting_start_time_to: Union[str, datetime],
                                 emails: list[str]) -> list[SurveyLinkObject]:
        """
        Get Meeting Survey Links

        Get survey links of a meeting for different users.

        #### Request Header

        * `timezone`: Time zone for the `meetingStartTimeFrom` and `meetingStartTimeTo` parameters and defined in
        conformance with the `IANA time zone database
        <https://www.iana.org/time-zones>`_. The default value is `UTC` if not specified.

        :param meeting_id: Unique identifier for the meeting. Only applies to webinars. Meetings and personal room
            meetings are not supported.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. An admin can specify the email of the meeting host who
            is in a site he manages and the API returns post survey links on behalf of the meeting host.
        :type host_email: str
        :param meeting_start_time_from: Start date and time (inclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the
            meeting objects being requested and conforms with the `timezone` in the request header if specified.
            `meetingStartTimeFrom` cannot be after `meetingStartTimeTo`. Only applies when `meetingId` is not an
            instance ID. The API generates survey links for the last instance of `meetingId` in the time range
            specified by `meetingStartTimeFrom` and `meetingStartTimeTo`. If not specified, `meetingStartTimeFrom`
            equals `meetingStartTimeTo` minus `1` month; if `meetingStartTimeTo` is also not specified, the default
            value for `meetingStartTimeFrom` is `1` month before the current date and time.
        :type meeting_start_time_from: Union[str, datetime]
        :param meeting_start_time_to: End date and time (exclusive) in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format for the meeting
            objects being requested and conforms with the `timezone` in the request header if specified.
            `meetingStartTimeTo` cannot be prior to `meetingStartTimeFrom`. Only applies when `meetingId` is not an
            instance ID. The API generates survey links for the last instance of `meetingId` in the time range
            specified by `meetingStartTimeFrom` and `meetingStartTimeTo`. If not specified, `meetingStartTimeTo`
            equals `meetingStartTimeFrom` plus `1` month; if `meetingStartTimeFrom` is also not specified, the default
            value for `meetingStartTimeTo` is the current date and time.
        :type meeting_start_time_to: Union[str, datetime]
        :param emails: Participants' email list. The maximum size of `emails` is 100.
        :type emails: list[str]
        :rtype: list[SurveyLinkObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['meetingStartTimeFrom'] = meeting_start_time_from
        body['meetingStartTimeTo'] = meeting_start_time_to
        body['emails'] = emails
        url = self.ep(f'{meeting_id}/surveyLinks')
        data = super().post(url, json=body)
        r = TypeAdapter(list[SurveyLinkObject]).validate_python(data['items'])
        return r

    def create_invitation_sources(self, meeting_id: str, host_email: str = None, person_id: str = None,
                                  items: list[InvitationSourceCreateObject] = None) -> list[InvitationSourceObject]:
        """
        Create Invitation Sources

        Creates one or more invitation sources for a meeting.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :param person_id: Unique identifier for the meeting host. Should only be set if the user or application calling
            the API has the admin-level scopes. When used, the admin may specify the email of a user in a site they
            manage to be the meeting host.
        :type person_id: str
        :type items: list[InvitationSourceCreateObject]
        :rtype: list[InvitationSourceObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['personId'] = person_id
        body['items'] = loads(TypeAdapter(list[InvitationSourceCreateObject]).dump_json(items))
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().post(url, json=body)
        r = TypeAdapter(list[InvitationSourceObject]).validate_python(data['items'])
        return r

    def list_invitation_sources(self, meeting_id: str) -> list[InvitationSourceObject]:
        """
        List Invitation Sources

        Lists invitation sources for a meeting.

        #### Request Header

        * `hostEmail`: Email address for the meeting host. This parameter is only used if the user or application
        calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a site
        they manage and the API will return recording details of that user.

        * `personId`:  Unique identifier for the meeting host. This attribute should only be set if the user or
        application calling the API has the admin-level scopes. When used, the admin may specify the email of a user
        in a site they manage to be the meeting host.

        :param meeting_id: Unique identifier for the meeting. Only the meeting ID of a scheduled webinar is supported
            for this API.
        :type meeting_id: str
        :rtype: list[InvitationSourceObject]
        """
        url = self.ep(f'{meeting_id}/invitationSources')
        data = super().get(url)
        r = TypeAdapter(list[InvitationSourceObject]).validate_python(data['items'])
        return r

    def list_meeting_tracking_codes(self, service: str, site_url: str = None,
                                    host_email: str = None) -> MeetingTrackingCodesObject:
        """
        List Meeting Tracking Codes

        Lists tracking codes on a site by a meeting host. The result indicates which tracking codes and what options
        can be used to create or update a meeting on the specified site.

        * The `options` here differ from those in the `site-level tracking codes
        <https://developer.webex.com/docs/api/v1/tracking-codes/get-a-tracking-code>`_ and the `user-level tracking codes
        is the result of a selective combination of the two.

        * For a tracking code, if there is no user-level tracking code, the API returns the site-level options, and the
        `defaultValue` of the site-level default option is `true`. If there is a user-level tracking code, it is
        merged into the `options`. Meanwhile, the `defaultValue` of this user-level option is `true` and the
        site-level default option becomes non default.

        * If `siteUrl` is specified, tracking codes of the specified site will be listed; otherwise, tracking codes of
        the user's preferred site will be listed. All available Webex sites and the preferred sites of a user can be
        retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        :param service: Service for schedule or sign-up pages.
        :type service: str
        :param site_url: URL of the Webex site which the API retrieves the tracking code from. If not specified, the
            API retrieves the tracking code from the user's preferred site. All available Webex sites and preferred
            sites of a user can be retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param host_email: Email address for the meeting host. This parameter is only used if a user or application
            calling the API has the admin-level scopes. The admin may specify the email of a user on a site they
            manage and the API will return meeting participants of the meetings that are hosted by that user.
        :type host_email: str
        :rtype: :class:`MeetingTrackingCodesObject`
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        params['service'] = service
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep('trackingCodes')
        data = super().get(url, params=params)
        r = MeetingTrackingCodesObject.model_validate(data)
        return r

    def reassign_meetings_to_a_new_host(self, host_email: str = None,
                                        meeting_ids: list[str] = None) -> list[ReassignMeetingResponseObject]:
        """
        Reassign Meetings to a New Host

        Reassigns a list of meetings to a new host by an admin user.

        All the meetings of `meetingIds` should belong to the same site, which is the `siteUrl` in the request header,
        if specified, or the admin user's preferred site, if not specified. All available Webex sites and the
        preferred sites of a user can be retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        If the user of `hostEmail` is not qualified to be a host of the target site, the API returns an error with the
        HTTP status code `403`. If all the meetings referenced by `meetingIds` have been reassigned the new host
        successfully, the API returns an empty response with the HTTP status code `204`. Otherwise, if all the
        meetings of `meetingIds` fail or some of them fail, the API returns a "Multi-Status" response with status code
        of `207`, and individual errors for each meeting in the response body.

        Only IDs of meeting series are supported for the `meetingIds`. IDs of scheduled meetings, meeting instances, or
        scheduled personal room meetings are not supported. See the `Meetings Overview
        <https://developer.webex.com/docs/meetings#meeting-series-scheduled-meetings-and-meeting-instances>`_ for more information about the
        types of meetings.

        There are several limitations when reassigning meetings:

        * Users cannot assign an in-progress meeting.

        * Users cannot assign a meeting to a user who is not a Webex user, or an attendee who does not have host
        privilege.

        * Users cannot assign a meeting with calling/callback to a host user who does not have calling/callback
        privileges

        * Users cannot assign a meeting with session type A to a host user who does not have session type A privileges.

        * Users cannot assign an MC or Webinar to a new host who does not have an MC license or a Webinar license.

        * Users cannot assign a TC/EC1.0/SC meeting, or a meeting that is created by on-behalf to a new host.

        * Users cannot assign meetings from third-party integrations, such as meetings integrated with Outlook or
        Google.

        #### Request Header

        * `siteUrl`: Optional request header parameter. All the meetings of `meetingIds` should belong to the site
        referenced by siteUrl if specified. Otherwise, the meetings should belong to the admin user's preferred sites.
        All available Webex sites and the preferred sites of a user can be retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        :param host_email: Email address of the new meeting host.
        :type host_email: str
        :param meeting_ids: List of meeting series IDs to be reassigned the new host. The size is between 1 and 100.
            All the meetings of `meetingIds` should belong to the same site, which is the `siteUrl` in the request
            header, if specified, or the admin user's preferred site, if not specified. All available Webex sites and
            the preferred sites of a user can be retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type meeting_ids: list[str]
        :rtype: list[ReassignMeetingResponseObject]
        """
        body = dict()
        body['hostEmail'] = host_email
        body['meetingIds'] = meeting_ids
        url = self.ep('reassignHost')
        data = super().post(url, json=body)
        r = TypeAdapter(list[ReassignMeetingResponseObject]).validate_python(data['items'])
        return r


class MembershipsApi(ApiChild, base='memberships'):
    """
    Memberships
    
    Memberships represent a person's relationship to a room. Use this API to list members of any room that you're in or
    create memberships to invite someone to a room. Compliance Officers can now also list memberships for
    `personEmails` where the CO is not part of the room.
    Memberships can also be updated to make someone a moderator, or deleted, to remove someone from the room.
    
    Just like in the Webex client, you must be a member of the room in order to list its memberships or invite people.
    """

    def list_memberships(self, room_id: str = None, person_id: str = None, person_email: str = None,
                         **params) -> Generator[Membership, None, None]:
        """
        List Memberships

        Lists all room memberships. By default, lists memberships for rooms to which the authenticated user belongs.

        Use query parameters to filter the response.

        Use `roomId` to list memberships for a room, by ID.

        **NOTE**: For moderated team spaces, the list of memberships will include only the space moderators if the user
        is a team member but not a direct participant of the space.

        Use either `personId` or `personEmail` to filter the results. The `roomId` parameter is required when using
        these parameters.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param room_id: List memberships associated with a room, by ID.
        :type room_id: str
        :param person_id: List memberships associated with a person, by ID. The `roomId` parameter is required when
            using this parameter.
        :type person_id: str
        :param person_email: List memberships associated with a person, by email address. The `roomId` parameter is
            required when using this parameter.
        :type person_email: str
        :return: Generator yielding :class:`Membership` instances
        """
        if room_id is not None:
            params['roomId'] = room_id
        if person_id is not None:
            params['personId'] = person_id
        if person_email is not None:
            params['personEmail'] = person_email
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Membership, item_key='items', params=params)

    def create_a_membership(self, room_id: str, person_id: str = None, person_email: str = None,
                            is_moderator: str = None) -> Membership:
        """
        Create a Membership

        Add someone to a room by Person ID or email address, optionally making them a moderator. Compliance Officers
        cannot add people to empty (team) spaces.

        :param room_id: The room ID.
        :type room_id: str
        :param person_id: The person ID.
        :type person_id: str
        :param person_email: The email address of the person.
        :type person_email: str
        :param is_moderator: Whether or not the participant is a room moderator.
        :type is_moderator: str
        :rtype: :class:`Membership`
        """
        body = dict()
        body['roomId'] = room_id
        body['personId'] = person_id
        body['personEmail'] = person_email
        body['isModerator'] = is_moderator
        url = self.ep()
        data = super().post(url, json=body)
        r = Membership.model_validate(data)
        return r

    def get_membership_details(self, membership_id: str) -> Membership:
        """
        Get Membership Details

        Get details for a membership by ID.

        Specify the membership ID in the `membershipId` URI parameter.

        :param membership_id: The unique identifier for the membership.
        :type membership_id: str
        :rtype: :class:`Membership`
        """
        url = self.ep(f'{membership_id}')
        data = super().get(url)
        r = Membership.model_validate(data)
        return r

    def update_a_membership(self, membership_id: str, is_moderator: str, is_room_hidden: str) -> Membership:
        """
        Update a Membership

        Updates properties for a membership by ID.

        Specify the membership ID in the `membershipId` URI parameter.

        :param membership_id: The unique identifier for the membership.
        :type membership_id: str
        :param is_moderator: Whether or not the participant is a room moderator.
        :type is_moderator: str
        :param is_room_hidden: When set to true, hides direct spaces in the teams client. Any new message will make the
            room visible again.
        :type is_room_hidden: str
        :rtype: :class:`Membership`
        """
        body = dict()
        body['isModerator'] = is_moderator
        body['isRoomHidden'] = is_room_hidden
        url = self.ep(f'{membership_id}')
        data = super().put(url, json=body)
        r = Membership.model_validate(data)
        return r

    def delete_a_membership(self, membership_id: str):
        """
        Delete a Membership

        Deletes a membership by ID.

        Specify the membership ID in the `membershipId` URI parameter.

        The membership for the last moderator of a `Team
        <https://developer.webex.com/docs/api/v1/teams>`_'s General space may not be deleted; `promote another user
        team moderator first.

        :param membership_id: The unique identifier for the membership.
        :type membership_id: str
        :rtype: None
        """
        url = self.ep(f'{membership_id}')
        super().delete(url)


class MessagesWithECMApi(ApiChild, base='messages'):
    """
    Messages with ECM
    
    The Enterprise Content Management functionality and API endpoint changes
    described here are currently pre-release features which are not available to
    all Webex users. If you have any questions, or if you need help, please
    contact the Webex Developer Support team at devsupport@webex.com.
    
    
    
    Messages are how we communicate in a room. In Webex, each message is displayed on its own line along with a
    timestamp and sender information. Use this API to list, create, and delete messages.
    
    Message can contain plain text, `rich text
    <https://developer.webex.com/docs/api/basics#formatting-messages>`_, and a `file attachment
    
    Just like in the Webex app, you must be a member of the room in order to target it with this API.
    """

    def list_messages(self, room_id: str, mentioned_people: list[str] = None, before: Union[str, datetime] = None,
                      before_message: str = None, **params) -> Generator[Message, None, None]:
        """
        List Messages

        Lists all messages in a room.

        Each message includes content attachments if present.

        The list sorts the messages in descending order by creation date.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param room_id: List messages in a room, by ID.
        :type room_id: str
        :param mentioned_people: List messages with these people mentioned, by ID. Use `me` as a shorthand for the
            current API user.
        :type mentioned_people: list[str]
        :param before: List messages sent before a date and time.
        :type before: Union[str, datetime]
        :param before_message: List messages sent before a message, by ID.
        :type before_message: str
        :return: Generator yielding :class:`Message` instances
        """
        params['roomId'] = room_id
        if mentioned_people is not None:
            params['mentionedPeople'] = ','.join(mentioned_people)
        if before is not None:
            if isinstance(before, str):
                before = isoparse(before)
            before = dt_iso_str(before)
            params['before'] = before
        if before_message is not None:
            params['beforeMessage'] = before_message
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Message, item_key='items', params=params)

    def list_direct_messages(self, person_id: str = None, person_email: str = None) -> list[DirectMessage]:
        """
        List Direct Messages

        Lists all messages in a 1:1 (direct) room.

        Use the `personId` or `personEmail` query parameter to specify the room. Each message includes content
        attachments if present.

        The list sorts the messages in descending order by creation date.

        :param person_id: List messages in a 1:1 room, by person ID.
        :type person_id: str
        :param person_email: List messages in a 1:1 room, by person email.
        :type person_email: str
        :rtype: list[DirectMessage]
        """
        params = {}
        if person_id is not None:
            params['personId'] = person_id
        if person_email is not None:
            params['personEmail'] = person_email
        url = self.ep('direct')
        data = super().get(url, params=params)
        r = TypeAdapter(list[DirectMessage]).validate_python(data['items'])
        return r

    def create_a_message(self, room_id: str = None, to_person_id: str = None, to_person_email: str = None,
                         text: str = None, markdown: str = None, files: list[str] = None,
                         attachments: list[Attachment] = None) -> Message:
        """
        Create a Message

        Create a plain text or `rich text
        <https://developer.webex.com/docs/api/basics#formatting-messages>`_ message, and optionally, a `file attachment

        The `files` parameter is an array, which accepts multiple values to allow for future expansion, but currently
        only one file may be included with the message.

        :param room_id: The room ID of the message.
        :type room_id: str
        :param to_person_id: The person ID of the recipient when sending a private 1:1 message.
        :type to_person_id: str
        :param to_person_email: The email address of the recipient when sending a private 1:1 message.
        :type to_person_email: str
        :param text: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to
            provide alternate text for UI clients that do not support rich text. The maximum message length is 7439
            bytes.
        :type text: str
        :param markdown: The message, in Markdown format. The maximum message length is 7439 bytes.
        :type markdown: str
        :param files: The public URL to a binary file to be posted into the room. Only one file is allowed per message.
            Uploaded files are automatically converted into a format that all Webex clients can render. For the
            supported media types and the behavior of uploads, see the `Message Attachments Guide
            <https://developer.webex.com/docs/api/basics#message-attachments>`_.
        :type files: list[str]
        :param attachments: Content attachments to attach to the message.
        :type attachments: list[Attachment]
        :rtype: :class:`Message`
        """
        body = dict()
        body['roomId'] = room_id
        body['toPersonId'] = to_person_id
        body['toPersonEmail'] = to_person_email
        body['text'] = text
        body['markdown'] = markdown
        body['files'] = files
        body['attachments'] = loads(TypeAdapter(list[Attachment]).dump_json(attachments))
        url = self.ep()
        data = super().post(url, json=body)
        r = Message.model_validate(data)
        return r

    def get_message_details(self, message_id: str) -> Message:
        """
        Get Message Details

        Shows details for a message, by message ID.

        Specify the message ID in the `messageId` parameter in the URI.

        :param message_id: The unique identifier for the message.
        :type message_id: str
        :rtype: :class:`Message`
        """
        url = self.ep(f'{message_id}')
        data = super().get(url)
        r = Message.model_validate(data)
        return r

    def delete_a_message(self, message_id: str):
        """
        Delete a Message

        Deletes a message, by message ID.

        Specify the message ID in the `messageId` parameter in the URI.

        :param message_id: The unique identifier for the message.
        :type message_id: str
        :rtype: None
        """
        url = self.ep(f'{message_id}')
        super().delete(url)


class MessagesApi(ApiChild, base='messages'):
    """
    Messages
    
    Messages are how you communicate in a room. In Webex, each message is displayed on its own line along with a
    timestamp and sender information. Use this API to list, create, update, and delete messages.
    
    Message can contain plain text, `rich text
    <https://developer.webex.com/docs/basics#formatting-messages>`_, and a `file attachment
    
    Just like in the Webex app, you must be a member of the room in order to target it with this API.
    """

    def list_messages(self, room_id: str, parent_id: str = None, mentioned_people: list[str] = None, before: Union[str,
                      datetime] = None, before_message: str = None, **params) -> Generator[ListMessage, None, None]:
        """
        List Messages

        Lists all messages in a room.  Each message will include content attachments if present.

        The list sorts the messages in descending order by creation date.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param room_id: List messages in a room, by ID.
        :type room_id: str
        :param parent_id: List messages with a parent, by ID.
        :type parent_id: str
        :param mentioned_people: List messages with these people mentioned, by ID. Use `me` as a shorthand for the
            current API user. Only `me` or the person ID of the current user may be specified. Bots must include this
            parameter to list messages in group rooms (spaces).
        :type mentioned_people: list[str]
        :param before: List messages sent before a date and time.
        :type before: Union[str, datetime]
        :param before_message: List messages sent before a message, by ID.
        :type before_message: str
        :return: Generator yielding :class:`ListMessage` instances
        """
        params['roomId'] = room_id
        if parent_id is not None:
            params['parentId'] = parent_id
        if mentioned_people is not None:
            params['mentionedPeople'] = ','.join(mentioned_people)
        if before is not None:
            if isinstance(before, str):
                before = isoparse(before)
            before = dt_iso_str(before)
            params['before'] = before
        if before_message is not None:
            params['beforeMessage'] = before_message
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ListMessage, item_key='items', params=params)

    def list_direct_messages(self, parent_id: str = None, person_id: str = None,
                             person_email: str = None) -> list[DirectMessage1]:
        """
        List Direct Messages

        List all messages in a 1:1 (direct) room. Use the `personId` or `personEmail` query parameter to specify the
        room. Each message will include content attachments if present.

        The list sorts the messages in descending order by creation date.

        :param parent_id: List messages with a parent, by ID.
        :type parent_id: str
        :param person_id: List messages in a 1:1 room, by person ID.
        :type person_id: str
        :param person_email: List messages in a 1:1 room, by person email.
        :type person_email: str
        :rtype: list[DirectMessage1]
        """
        params = {}
        if parent_id is not None:
            params['parentId'] = parent_id
        if person_id is not None:
            params['personId'] = person_id
        if person_email is not None:
            params['personEmail'] = person_email
        url = self.ep('direct')
        data = super().get(url, params=params)
        r = TypeAdapter(list[DirectMessage1]).validate_python(data['items'])
        return r

    def create_a_message(self, room_id: str = None, parent_id: str = None, to_person_id: str = None,
                         to_person_email: str = None, text: str = None, markdown: str = None, files: list[str] = None,
                         attachments: list[Attachment1] = None) -> Message1:
        """
        Create a Message

        Post a plain text or `rich text
        <https://developer.webex.com/docs/basics#formatting-messages>`_ message, and optionally, a `file attachment

        The `files` parameter is an array, which accepts multiple values to allow for future expansion, but currently
        only one file may be included with the message. File previews are only rendered for attachments of 1MB or
        less.

        :param room_id: The room ID of the message.
        :type room_id: str
        :param parent_id: The parent message to reply to.
        :type parent_id: str
        :param to_person_id: The person ID of the recipient when sending a private 1:1 message.
        :type to_person_id: str
        :param to_person_email: The email address of the recipient when sending a private 1:1 message.
        :type to_person_email: str
        :param text: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to
            provide alternate text for UI clients that do not support rich text. The maximum message length is 7439
            bytes.
        :type text: str
        :param markdown: The message, in Markdown format. The maximum message length is 7439 bytes.
        :type markdown: str
        :param files: The public URL to a binary file to be posted into the room. Only one file is allowed per message.
            Uploaded files are automatically converted into a format that all Webex clients can render. For the
            supported media types and the behavior of uploads, see the `Message Attachments Guide
            <https://developer.webex.com/docs/basics#message-attachments>`_.
        :type files: list[str]
        :param attachments: Content attachments to attach to the message. Only one card per message is supported. See
            the `Cards Guide
            <https://developer.webex.com/docs/api/guides/cards>`_ for more information.
        :type attachments: list[Attachment1]
        :rtype: :class:`Message1`
        """
        body = dict()
        body['roomId'] = room_id
        body['parentId'] = parent_id
        body['toPersonId'] = to_person_id
        body['toPersonEmail'] = to_person_email
        body['text'] = text
        body['markdown'] = markdown
        body['files'] = files
        body['attachments'] = loads(TypeAdapter(list[Attachment1]).dump_json(attachments))
        url = self.ep()
        data = super().post(url, json=body)
        r = Message1.model_validate(data)
        return r

    def edit_a_message(self, message_id: str, room_id: str, text: str = None, markdown: str = None) -> ListMessage:
        """
        Edit a Message

        Update a message you have posted not more than 10 times.

        Specify the `messageId` of the message you want to edit.

        Edits of messages containing files or attachments are not currently supported.
        If a user attempts to edit a message containing files or attachments a `400 Bad Request` will be returned by
        the API with a message stating that the feature is currently unsupported.

        There is also a maximum number of times a user can edit a message. The maximum currently supported is 10 edits
        per message.
        If a user attempts to edit a message greater that the maximum times allowed the API will return 400 Bad Request
        with a message stating the edit limit has been reached.

        While only the `roomId` and `text` or `markdown` attributes are *required* in the request body, a common
        pattern for editing message is to first call `GET /messages/{id}` for the message you wish to edit and to then
        update the `text` or `markdown` attribute accordingly, passing the updated message object in the request body
        of the `PUT /messages/{id}` request.
        When this pattern is used on a message that included markdown, the `html` attribute must be deleted prior to
        making the `PUT` request.

        :param message_id: The unique identifier for the message.
        :type message_id: str
        :param room_id: The room ID of the message.
        :type room_id: str
        :param text: The message, in plain text. If `markdown` is specified this parameter may be *optionally* used to
            provide alternate text for UI clients that do not support rich text. The maximum message length is 7439
            bytes.
        :type text: str
        :param markdown: The message, in Markdown format. If this attribute is set ensure that the request does NOT
            contain an `html` attribute.
        :type markdown: str
        :rtype: :class:`ListMessage`
        """
        body = dict()
        body['roomId'] = room_id
        body['text'] = text
        body['markdown'] = markdown
        url = self.ep(f'{message_id}')
        data = super().put(url, json=body)
        r = ListMessage.model_validate(data)
        return r

    def get_message_details(self, message_id: str) -> ListMessage:
        """
        Get Message Details

        Show details for a message, by message ID.

        Specify the message ID in the `messageId` parameter in the URI.

        :param message_id: The unique identifier for the message.
        :type message_id: str
        :rtype: :class:`ListMessage`
        """
        url = self.ep(f'{message_id}')
        data = super().get(url)
        r = ListMessage.model_validate(data)
        return r

    def delete_a_message(self, message_id: str):
        """
        Delete a Message

        Delete a message, by message ID.

        Specify the message ID in the `messageId` parameter in the URI.

        :param message_id: The unique identifier for the message.
        :type message_id: str
        :rtype: None
        """
        url = self.ep(f'{message_id}')
        super().delete(url)


class NumbersApi(ApiChild, base='telephony/config'):
    """
    Numbers
    
    Numbers supports reading and writing of Webex Calling phone numbers for a
    specific organization.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def add_phone_numbers_to_a_location(self, location_id: str, phone_numbers: list[str], state: State,
                                        org_id: str = None):
        """
        Add Phone Numbers to a location

        Adds a specified set of phone numbers to a location for an organization.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.

        Adding a phone number to a location requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        <br/>

        <div><Callout type="warning">This API is only supported for Local Gateway (LGW) connected locations. It is not
        supported and should not be used for non-LGW connected locations because backend data issues may
        occur.</Callout></div>

        :param location_id: LocationId to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers that need to be added.
        :type phone_numbers: list[str]
        :param state: State of the phone numbers.
        :type state: State
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['phoneNumbers'] = phone_numbers
        body['state'] = enum_str(state)
        url = self.ep(f'locations/{location_id}/numbers')
        super().post(url, params=params, json=body)

    def activate_phone_numbers_in_a_location(self, location_id: str, phone_numbers: list[str], org_id: str = None):
        """
        Activate Phone Numbers in a location

        Activate the specified set of phone numbers in a location for an organization.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.

        Activating a phone number in a location requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        <br/>

        <div><Callout type="warning">This API is only supported for Local Gateway (LGW) connected locations. It is not
        supported and should not be used for non-LGW connected locations because backend data issues may
        occur.</Callout></div>

        :param location_id: `LocationId` to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers that need to be added.
        :type phone_numbers: list[str]
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['phoneNumbers'] = phone_numbers
        url = self.ep(f'locations/{location_id}/numbers')
        super().put(url, params=params, json=body)

    def remove_phone_numbers_from_a_location(self, location_id: str, phone_numbers: list[str], org_id: str = None):
        """
        Remove phone numbers from a location

        Remove the specified set of phone numbers from a location for an organization.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.

        Removing a phone number from a location requires a full administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        <br/>

        <div><Callout type="warning">This API is only supported for Local Gateway (LGW) connected locations. It is not
        supported and should not be used for non-LGW connected locations because backend data issues may
        occur.</Callout></div>

        :param location_id: `LocationId` to which numbers should be added.
        :type location_id: str
        :param phone_numbers: List of phone numbers that need to be deleted.
        :type phone_numbers: list[str]
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['phoneNumbers'] = phone_numbers
        url = self.ep(f'locations/{location_id}/numbers')
        super().delete(url, params=params, json=body)

    def validate_phone_numbers_(self, phone_numbers: list[str], org_id: str = None) -> ValidateNumbersResponse:
        """
        Validate phone numbers.

        Validate the list of phone numbers in an organization. Each phone number's availability is indicated in the
        response.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow E.164 format for all countries, except for the United States, which can also follow the National
        format. Active phone numbers are in service.

        Validating a phone number in an organization requires a full administrator or location administrator auth token
        with a scope of `spark-admin:telephony_config_write`.

        :param phone_numbers: List of phone numbers that need to be added.
        :type phone_numbers: list[str]
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: :class:`ValidateNumbersResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['phoneNumbers'] = phone_numbers
        url = self.ep('actions/validateNumbers/invoke')
        data = super().post(url, params=params, json=body)
        r = ValidateNumbersResponse.model_validate(data)
        return r

    def get_phone_numbers_for_an_organization_with_given_criterias(self, org_id: str = None, location_id: str = None,
                                                                   start: int = None, phone_number: str = None,
                                                                   available: bool = None, order: str = None,
                                                                   owner_name: str = None, owner_id: str = None,
                                                                   owner_type: GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType = None,
                                                                   extension: str = None, number_type: str = None,
                                                                   phone_number_type: str = None, state: str = None,
                                                                   details: bool = None,
                                                                   toll_free_numbers: bool = None,
                                                                   restricted_non_geo_numbers: bool = None,
                                                                   **params) -> Generator[NumberObject3, None, None]:
        """
        Get Phone Numbers for an Organization with Given Criterias

        List all the phone numbers for the given organization along with the status and owner (if any).

        PSTN phone numbers are associated with a specific location and can be active/inactive and assigned/unassigned.
        The owner is the person, workspace, or feature to which the number is assigned.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param org_id: List numbers for this organization.
        :type org_id: str
        :param location_id: Return the list of phone numbers for this location within the given organization. The
            maximum length is 36.
        :type location_id: str
        :param start: Start at the zero-based offset in the list of matching phone numbers. Default is 0.
        :type start: int
        :param phone_number: Search for this `phoneNumber`.
        :type phone_number: str
        :param available: Search among the available phone numbers. This parameter cannot be used along with
            `ownerType` parameter when set to `true`.
        :type available: bool
        :param order: Sort the list of phone numbers based on the following:`lastName`,`dn`,`extension`. Default sort
            will be based on number and extension in an ascending order
        :type order: str
        :param owner_name: Return the list of phone numbers that is owned by given `ownerName`. Maximum length is 255.
        :type owner_name: str
        :param owner_id: Returns only the matched number/extension entries assigned to the feature with specified
            uuid/broadsoftId.
        :type owner_id: str
        :param owner_type: Returns the list of phone numbers that are of given `ownerType`. Possible input values
        :type owner_type: GetPhoneNumbersForAnOrganizationWithGivenCriteriasOwnerType
        :param extension: Returns the list of PSTN phone numbers with the given extension.
        :type extension: str
        :param number_type: Returns the filtered list of PSTN phone numbers that contains given type of numbers. This
            parameter cannot be used along with `available` or `state`.
        :type number_type: str
        :param phone_number_type: Returns the filtered list of PSTN phone numbers that are of given `phoneNumberType`.
        :type phone_number_type: str
        :param state: Returns the list of PSTN phone numbers with matching state.
        :type state: str
        :param details: Returns the overall count of the PSTN phone numbers along with other details for given
            organization.
        :type details: bool
        :param toll_free_numbers: Returns the list of toll free phone numbers.
        :type toll_free_numbers: bool
        :param restricted_non_geo_numbers: Returns the list of restricted non geographical numbers.
        :type restricted_non_geo_numbers: bool
        :return: Generator yielding :class:`NumberObject3` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = location_id
        if start is not None:
            params['start'] = start
        if phone_number is not None:
            params['phoneNumber'] = phone_number
        if available is not None:
            params['available'] = str(available).lower()
        if order is not None:
            params['order'] = order
        if owner_name is not None:
            params['ownerName'] = owner_name
        if owner_id is not None:
            params['ownerId'] = owner_id
        if owner_type is not None:
            params['ownerType'] = owner_type
        if extension is not None:
            params['extension'] = extension
        if number_type is not None:
            params['numberType'] = number_type
        if phone_number_type is not None:
            params['phoneNumberType'] = phone_number_type
        if state is not None:
            params['state'] = state
        if details is not None:
            params['details'] = str(details).lower()
        if toll_free_numbers is not None:
            params['tollFreeNumbers'] = str(toll_free_numbers).lower()
        if restricted_non_geo_numbers is not None:
            params['restrictedNonGeoNumbers'] = str(restricted_non_geo_numbers).lower()
        url = self.ep('numbers')
        return self.session.follow_pagination(url=url, model=NumberObject3, item_key='phoneNumbers', params=params)

    def list_manage_numbers_jobs(self, org_id: str = None, start: int = None,
                                 **params) -> Generator[StartJobResponse, None, None]:
        """
        List Manage Numbers Jobs

        Lists all Manage Numbers jobs for the given organization in order of most recent one to oldest one irrespective
        of its status.

        The public API only supports initiating jobs which move numbers between locations.

        Via Control Hub they can initiate both the move and delete, so this listing can show both.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Retrieve list of Manage Number jobs for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of jobs. Default is 0.
        :type start: int
        :return: Generator yielding :class:`StartJobResponse` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        url = self.ep('jobs/numbers/manageNumbers')
        return self.session.follow_pagination(url=url, model=StartJobResponse, item_key='items', params=params)

    def initiate_move_number_jobs(self, operation: str, target_location_id: str,
                                  number_list: list[NumberItem]) -> StartJobResponse:
        """
        Initiate Move Number Jobs

        Starts the numbers move from one location to another location. Although jobs can do both MOVE and DELETE
        actions internally, only MOVE is supported publicly.

        <br/>

        In order to move a number,

        <br/>

        * The number must be unassigned.

        * Both locations must have the same PSTN Connection Type.

        * Both locations must have the same PSTN Provider.

        * Both locations have to be in the same country.

        <br/>

        For example, you can move from Cisco PSTN to Cisco PSTN, but you cannot move from Cisco PSTN to a location with
        Cloud Connected PSTN.

        <br/>

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param operation: Indicates the kind of operation to be carried out.
        :type operation: str
        :param target_location_id: The target location within organization where the unassigned numbers will be moved
            from the source location.
        :type target_location_id: str
        :param number_list: Indicates the numbers to be moved from source to target locations.
        :type number_list: list[NumberItem]
        :rtype: :class:`StartJobResponse`
        """
        body = dict()
        body['operation'] = operation
        body['targetLocationId'] = target_location_id
        body['numberList'] = loads(TypeAdapter(list[NumberItem]).dump_json(number_list))
        url = self.ep('jobs/numbers/manageNumbers')
        data = super().post(url, json=body)
        r = StartJobResponse.model_validate(data)
        return r

    def get_manage_numbers_job_status(self, job_id: str = None) -> JobIdResponseObject:
        """
        Get Manage Numbers Job Status

        Returns the status and other details of the job.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job details for this `jobId`.
        :type job_id: str
        :rtype: :class:`JobIdResponseObject`
        """
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}')
        data = super().get(url)
        r = JobIdResponseObject.model_validate(data)
        return r

    def pause_the_manage_numbers_job(self, job_id: str = None, org_id: str = None):
        """
        Pause the Manage Numbers Job

        Pause the running Manage Numbers Job. A paused job can be resumed or abandoned.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param job_id: Pause the Manage Numbers job for this `jobId`.
        :type job_id: str
        :param org_id: Pause the Manage Numbers job for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/actions/pause/invoke')
        super().post(url, params=params)

    def resume_the_manage_numbers_job(self, job_id: str = None, org_id: str = None):
        """
        Resume the Manage Numbers Job

        Resume the paused Manage Numbers Job. A paused job can be resumed or abandoned.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param job_id: Resume the Manage Numbers job for this `jobId`.
        :type job_id: str
        :param org_id: Resume the Manage Numbers job for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/actions/resume/invoke')
        super().post(url, params=params)

    def abandon_the_manage_numbers_job(self, job_id: str = None, org_id: str = None):
        """
        Abandon the Manage Numbers Job

        Abandon the Manage Numbers Job.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param job_id: Abandon the Manage Numbers job for this `jobId`.
        :type job_id: str
        :param org_id: Abandon the Manage Numbers job for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/actions/abandon/invoke')
        super().post(url, params=params)

    def list_manage_numbers_job_errors(self, job_id: str = None, org_id: str = None, start: int = None,
                                       **params) -> Generator[ItemObject, None, None]:
        """
        List Manage Numbers Job errors

        Lists all error details of Manage Numbers job. This will not list any errors if `exitCode` is `COMPLETED`. If
        the status is `COMPLETED_WITH_ERRORS` then this lists the cause of failures.

        List of possible Errors:

        + BATCH-1017021 - Failed to move because it is an inactive number.

        + BATCH-1017022 - Failed to move because the source location and target location have different CCP providers.

        + BATCH-1017023 - Failed because it is not an unassigned number.

        + BATCH-1017024 - Failed because it is a main number.

        + BATCH-1017027 - Manage Numbers Move Operation is not supported.

        + BATCH-1017031 - Hydra request is supported only for single number move job.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param job_id: Retrieve the error details for this `jobId`.
        :type job_id: str
        :param org_id: Retrieve list of jobs for this organization.
        :type org_id: str
        :param start: Specifies the error offset from the first result that you want to fetch.
        :type start: int
        :return: Generator yielding :class:`ItemObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        url = self.ep(f'jobs/numbers/manageNumbers/{job_id}/errors')
        return self.session.follow_pagination(url=url, model=ItemObject, item_key='items', params=params)


class OrganizationContactsApi(ApiChild, base='contacts/organizations/{orgId}/contacts'):
    """
    Organization Contacts
    
    Organizational contacts are entities that can be created, imported, or synchronized with Webex. Searching and
    viewing contacts require an auth token with a `scope
    <https://developer.webex.com/docs/integrations#scopes>`_ of `Identity:contact` or `Identity:SCIM`, while adding,
    updating, and removing contacts in your Organization requires an administrator auth token with the
    `Identity:contact` or `Identity:SCIM` scope. An admin can only operate on the contacts list for his org or a
    managed org.
    
    Note: `broadworks-connector` entitled callers are limited to org contacts with either source=`CH` or
    source=`Webex4Broadworks`, while non-entitled callers are limited to source=`CH`.
    """

    def create_a_contact(self, org_id: str, schemas: str, display_name: str, first_name: str, last_name: str,
                         company_name: str, title: str, address: str, avatar_url: str,
                         primary_contact_method: ContactPrimaryContactMethod, source: ContactSource,
                         emails: list[ContactEmails], phone_numbers: list[ContactPhoneNumbers],
                         sip_addresses: list[ContactSipAddresses], ims: list[ContactIms]):
        """
        Create a Contact

        Creating a new contact for a given organization requires an org admin role.

        At least one of the following body parameters: `phoneNumbers`, `emails`, `sipAddresses` is required to create a
        new contact for source "CH",
        `displayName` is required to create a new contact for source "Webex4Broadworks".

        :param org_id: Webex Identity assigned organization identifier for the user's organization or the organization
            he manages.
        :type org_id: str
        :param schemas: "urn:cisco:codev:identity:contact:core:1.0".
        :type schemas: str
        :param display_name: The full name of the contact.
        :type display_name: str
        :param first_name: The first name of the contact.
        :type first_name: str
        :param last_name: The last name of the contact.
        :type last_name: str
        :param company_name: The company the contact is working for.
        :type company_name: str
        :param title: The contact's title.
        :type title: str
        :param address: Contact's address.
        :type address: str
        :param avatar_url: The URL to the person's avatar in PNG format.
        :type avatar_url: str
        :param primary_contact_method: The contact's primary contact method.
        :type primary_contact_method: ContactPrimaryContactMethod
        :param source: Where the data come from.
        :type source: ContactSource
        :param emails: A list of the user's email addresses with an indicator of the user's primary email address.
        :type emails: list[ContactEmails]
        :param phone_numbers: A list of user's phone numbers with an indicator of primary to specify the user's main
            number.
        :type phone_numbers: list[ContactPhoneNumbers]
        :param sip_addresses: The sipAddress values for the user.
        :type sip_addresses: list[ContactSipAddresses]
        :param ims: Instant messaging addresses for the user.
        :type ims: list[ContactIms]
        :rtype: None
        """
        body = dict()
        body['schemas'] = schemas
        body['displayName'] = display_name
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['companyName'] = company_name
        body['title'] = title
        body['address'] = address
        body['avatarURL'] = avatar_url
        body['primaryContactMethod'] = enum_str(primary_contact_method)
        body['source'] = enum_str(source)
        body['emails'] = loads(TypeAdapter(list[ContactEmails]).dump_json(emails))
        body['phoneNumbers'] = loads(TypeAdapter(list[ContactPhoneNumbers]).dump_json(phone_numbers))
        body['sipAddresses'] = loads(TypeAdapter(list[ContactSipAddresses]).dump_json(sip_addresses))
        body['ims'] = loads(TypeAdapter(list[ContactIms]).dump_json(ims))
        url = self.ep(f'')
        super().post(url, json=body)

    def get_a_contact(self, org_id: str, contact_id: str) -> ContactResponse:
        """
        Get a Contact

        Shows details for an organization contact by ID.
        Specify the organization ID in the `orgId` parameter in the URI, and specify the contact ID in the `contactId`
        parameter in the URI.

        :param org_id: Webex Identity assigned organization identifier for the user's organization or the organization
            he manages.
        :type org_id: str
        :param contact_id: The contact ID.
        :type contact_id: str
        :rtype: :class:`ContactResponse`
        """
        url = self.ep(f'{contact_id}')
        data = super().get(url)
        r = ContactResponse.model_validate(data)
        return r

    def update_a_contact(self, org_id: str, contact_id: str, schemas: str, display_name: str, first_name: str,
                         last_name: str, company_name: str, title: str, address: str, avatar_url: str,
                         primary_contact_method: ContactPrimaryContactMethod, source: ContactSource,
                         emails: list[ContactEmails], phone_numbers: list[ContactPhoneNumbers],
                         sip_addresses: list[ContactSipAddresses], ims: list[ContactIms]):
        """
        Update a Contact

        Update details for contact by ID. Only an admin can update a contact.
        Specify the organization ID in the `orgId` parameter in the URI, and specify the contact ID in the `contactId`
        parameter in the URI.

        :param org_id: Webex Identity assigned organization identifier for the user's organization or the organization
            he manages.
        :type org_id: str
        :param contact_id: The contact ID.
        :type contact_id: str
        :param schemas: "urn:cisco:codev:identity:contact:core:1.0".
        :type schemas: str
        :param display_name: The full name of the contact.
        :type display_name: str
        :param first_name: The first name of the contact.
        :type first_name: str
        :param last_name: The last name of the contact.
        :type last_name: str
        :param company_name: The company the contact is working for.
        :type company_name: str
        :param title: The contact's title.
        :type title: str
        :param address: Contact's address.
        :type address: str
        :param avatar_url: The URL to the person's avatar in PNG format.
        :type avatar_url: str
        :param primary_contact_method: The contact's primary contact method.
        :type primary_contact_method: ContactPrimaryContactMethod
        :param source: Where the data come from.
        :type source: ContactSource
        :param emails: A list of the user's email addresses with an indicator of the user's primary email address.
        :type emails: list[ContactEmails]
        :param phone_numbers: A list of user's phone numbers with an indicator of primary to specify the user's main
            number.
        :type phone_numbers: list[ContactPhoneNumbers]
        :param sip_addresses: The sipAddress values for the user.
        :type sip_addresses: list[ContactSipAddresses]
        :param ims: Instant messaging addresses for the user.
        :type ims: list[ContactIms]
        :rtype: None
        """
        body = dict()
        body['schemas'] = schemas
        body['displayName'] = display_name
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['companyName'] = company_name
        body['title'] = title
        body['address'] = address
        body['avatarURL'] = avatar_url
        body['primaryContactMethod'] = enum_str(primary_contact_method)
        body['source'] = enum_str(source)
        body['emails'] = loads(TypeAdapter(list[ContactEmails]).dump_json(emails))
        body['phoneNumbers'] = loads(TypeAdapter(list[ContactPhoneNumbers]).dump_json(phone_numbers))
        body['sipAddresses'] = loads(TypeAdapter(list[ContactSipAddresses]).dump_json(sip_addresses))
        body['ims'] = loads(TypeAdapter(list[ContactIms]).dump_json(ims))
        url = self.ep(f'{contact_id}')
        super().patch(url, json=body)

    def delete_a_contact(self, org_id: str, contact_id: str):
        """
        Delete a Contact

        Remove a contact from the organization. Only an admin can remove a contact.

        Specify the organization ID in the `orgId` parameter in the URI, and specify the contact ID in the `contactId`
        parameter in the URI.

        :param org_id: Webex Identity assigned organization identifier for the user's organization or the organization
            he manages.
        :type org_id: str
        :param contact_id: The contact ID.
        :type contact_id: str
        :rtype: None
        """
        url = self.ep(f'{contact_id}')
        super().delete(url)

    def list_contacts(self, org_id: str, keyword: str = None, limit: int = None, source: str = None) -> SearchResponse:
        """
        List Contacts

        List contacts in the organization. The default limit is `1000`.

        `keyword` can be the value of "displayName", "firstName", "lastName", "email". An empty string of `keyword`
        means get all contacts.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param org_id: The organization ID.
        :type org_id: str
        :param keyword: List contacts with a keyword.
        :type keyword: str
        :param limit: Limit the maximum number of contact in the response.
        + Default: 1000
        :type limit: int
        :param source: List contacts with source.
        :type source: str
        :rtype: :class:`SearchResponse`
        """
        params = {}
        if keyword is not None:
            params['keyword'] = keyword
        if limit is not None:
            params['limit'] = limit
        if source is not None:
            params['source'] = source
        url = self.ep(f'search')
        data = super().get(url, params=params)
        r = SearchResponse.model_validate(data)
        return r

    def bulk_create_or_update_contacts(self, org_id: str, schemas: str, contacts: list[BulkCreateContacts]):
        """
        Bulk Create or Update Contacts

        Create or update contacts in bulk.

        :param org_id: Webex Identity assigned organization identifier for the user's organization or the organization
            he manages.
        :type org_id: str
        :param schemas: "urn:cisco:codev:identity:contact:core:1.0".
        :type schemas: str
        :param contacts: Contains a list of contacts to be created/updated.
        :type contacts: list[BulkCreateContacts]
        :rtype: None
        """
        body = dict()
        body['schemas'] = schemas
        body['contacts'] = loads(TypeAdapter(list[BulkCreateContacts]).dump_json(contacts))
        url = self.ep(f'bulk')
        super().post(url, json=body)

    def bulk_delete_contacts(self, org_id: str, schemas: str, object_ids: list[str]):
        """
        Bulk Delete Contacts

        Delete contacts in bulk.

        :param org_id: Webex Identity assigned organization identifier for the user's organization or the organization
            he manages.
        :type org_id: str
        :param schemas: "urn:cisco:codev:identity:contact:core:1.0".
        :type schemas: str
        :param object_ids: List of UUIDs for the contacts.
        :type object_ids: list[str]
        :rtype: None
        """
        body = dict()
        body['schemas'] = schemas
        body['objectIds'] = object_ids
        url = self.ep(f'bulk/delete')
        super().post(url, json=body)


class OrganizationGroupsApi(ApiChild, base='organization/groups?orgId={orgId}&displayName={displayName}'):
    """
    Organization Groups
    
    """

    def list_organization_groups(self, org_id: str) -> list[Person]:
        """
        List Organization Groups

        List the policy groups at an organization level based on a display name pattern.

        Specify the organization's ID in the `orgId` URI parameter and the group's display name pattern in the
        `displayName` URI parameter.

        :param org_id: A unique identifier for an org
        :type org_id: str
        :rtype: list[Person]
        """
        url = self.ep(f'')
        data = super().get(url)
        r = TypeAdapter(list[Person]).validate_python(data['items'])
        return r


class OrganizationLicenseTemplatesApi(ApiChild, base='organization'):
    """
    Organization License Templates
    
    These APIs allow a Webex organization administrator to list, create, update, and delete license templates for their
    groups. Admins can create org- and group-level templates. If a user is part of a group, they are assigned the
    group-level templates. Users who are not part of a group will default to org-level templates.
    
    To list templates at the organization level you need an admin auth token with a scope of
    `spark-admin:licenses_read` to view templates at the org level. Adding, updating, and removing templates requires
    an admin auth token with the `spark-admin:licenses_write` scope.
    """

    def list_organization_license_templates(self, org_id: str) -> list[Template]:
        """
        List Organization License Templates

        Get org level license templates

        :param org_id: A unique identifier for an org
        :type org_id: str
        :rtype: list[Template]
        """
        url = self.ep(f'licenseTemplates?orgId={org_id}')
        data = super().get(url)
        r = TypeAdapter(list[Template]).validate_python(data['items'])
        return r

    def create_an_organization_license_template(self, org_id: str, template_name: str = None,
                                                licenses: list[str] = None, groups: list[str] = None,
                                                template_type: TemplateTemplateType = None) -> Template:
        """
        Create an Organization License Template

        Create an org/group level license template which could be assigned to users as part of user onboarding.
        Only group level templates can be associated with groups

        :param org_id: A unique identifier for an org
        :type org_id: str
        :param template_name: Name of the org level template
        :type template_name: str
        :param licenses: An array of license strings
        :type licenses: list[str]
        :param groups: An array of groups
        :type groups: list[str]
        :param template_type: Specify the template type to be created
        :type template_type: TemplateTemplateType
        :rtype: :class:`Template`
        """
        body = dict()
        body['templateName'] = template_name
        body['licenses'] = licenses
        body['groups'] = groups
        body['templateType'] = enum_str(template_type)
        body['orgId'] = org_id
        url = self.ep('licenseTemplates')
        data = super().post(url, json=body)
        r = Template.model_validate(data)
        return r

    def update_an_organization_license_template(self, license_template_id: str, org_id: str, template_name: str = None,
                                                licenses: list[str] = None, groups: list[str] = None) -> Template:
        """
        Update an Organization License Template

        Update org/group license template

        Specify the templateId in the `licenseTemplateId` parameter in the URI

        :param license_template_id: A unique identifier of a template
        :type license_template_id: str
        :param org_id: A unique identifier for an org
        :type org_id: str
        :param template_name: Name of the org level template
        :type template_name: str
        :param licenses: An array of license strings
        :type licenses: list[str]
        :param groups: An array of groups
        :type groups: list[str]
        :rtype: :class:`Template`
        """
        body = dict()
        body['templateName'] = template_name
        body['licenses'] = licenses
        body['groups'] = groups
        body['orgId'] = org_id
        url = self.ep(f'licenseTemplates/{license_template_id}')
        data = super().put(url, json=body)
        r = Template.model_validate(data)
        return r

    def delete_an_organization_license_template(self, license_template_id: str):
        """
        Delete an Organization License Template

        Delete an org/group level template

        Specify the templateId in the `licenseTemplateId` parameter in the URI

        :param license_template_id: A unique identifier of a template
        :type license_template_id: str
        :rtype: None
        """
        url = self.ep(f'licenseTemplates/{license_template_id}')
        super().delete(url)


class OrganizationsWithECMApi(ApiChild, base='organizations'):
    """
    Organizations with ECM
    
    A set of people in Webex. Organizations may manage other organizations or be managed themselves. Organizations
    resources can be accessed only by an admin.
    """

    def list_organizations(self) -> list[Organization3]:
        """
        List Organizations

        List all organizations visible by your account. The results will not be `paginated
        <https://developer.webex.com/docs/basics#pagination>`_.

        :rtype: list[Organization3]
        """
        url = self.ep()
        data = super().get(url)
        r = TypeAdapter(list[Organization3]).validate_python(data['items'])
        return r

    def get_organization_details(self, org_id: str) -> Organization3:
        """
        Get Organization Details

        Shows details for an organization, by ID.

        Specify the org ID in the `orgId` parameter in the URI.

        :param org_id: The unique identifier for the organization.
        :type org_id: str
        :rtype: :class:`Organization3`
        """
        url = self.ep(f'{org_id}')
        data = super().get(url)
        r = Organization3.model_validate(data)
        return r


class OrganizationsWithXsiApi(ApiChild, base='organizations'):
    """
    Organizations with Xsi
    
    A set of people in Webex. Organizations may manage other organizations or be managed themselves. This organizations
    resource can be accessed only by an admin.
    """

    def list_organizations(self, calling_data: bool = None) -> list[Organization4]:
        """
        List Organizations

        List all organizations visible by your account.

        If the `callingData` parameter is set to `true` and the base domain (region where the organization is
        provisioned) is non-null, then the XSI endpoint values will be included in the organization details.

        :param calling_data: Include XSI endpoint values in the response (if applicable) for the organization.
        :type calling_data: bool
        :rtype: list[Organization4]
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[Organization4]).validate_python(data['items'])
        return r

    def get_organization_details(self, org_id: str, calling_data: bool = None) -> Organization4:
        """
        Get Organization Details

        Shows details for an organization, by ID.

        Specify the org ID in the `orgId` parameter in the URI.

        If the `callingData` parameter is set to `true` and the base domain (region where the organization is
        provisioned) is non-null, then the XSI endpoint values will be included in the organization details.

        :param org_id: The unique identifier for the organization.
        :type org_id: str
        :param calling_data: Include XSI endpoint values in the response (if applicable) for the organization.
        :type calling_data: bool
        :rtype: :class:`Organization4`
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        url = self.ep(f'{org_id}')
        data = super().get(url, params=params)
        r = Organization4.model_validate(data)
        return r


class OrganizationsApi(ApiChild, base='organizations'):
    """
    Organizations
    
    A set of people in Webex. Organizations may manage other organizations or be managed themselves. This organizations
    resource can be accessed only by an admin.
    
    Applications can delete an Organization only after they have been authorized by a user with the
    `Full Administrator Role
    <https://help.webex.com/en-us/fs78p5/Assign-Organization-Account-Roles-in-Cisco-Webex-Control-Hub#id_117864>`_ which may be a user in the customer org or a user in a managing partner organization to
    which the role has been granted. The authorizing admin must grant the `spark-admin:organizations-write` scope.
    """

    def list_organizations(self) -> list[Organization5]:
        """
        List Organizations

        List all organizations visible by your account. The results will not be `paginated
        <https://developer.webex.com/docs/basics#pagination>`_.

        :rtype: list[Organization5]
        """
        url = self.ep()
        data = super().get(url)
        r = TypeAdapter(list[Organization5]).validate_python(data['items'])
        return r

    def get_organization_details(self, org_id: str) -> Organization5:
        """
        Get Organization Details

        Shows details for an organization, by ID.

        Specify the org ID in the `orgId` parameter in the URI.

        :param org_id: The unique identifier for the organization.
        :type org_id: str
        :rtype: :class:`Organization5`
        """
        url = self.ep(f'{org_id}')
        data = super().get(url)
        r = Organization5.model_validate(data)
        return r

    def delete_organization(self, org_id: str):
        """
        Delete Organization

        Deletes an organization, by ID. It may take up to 10 minutes for the organization to be deleted after the
        response is returned.
        <br/><br/>
        Specify the org ID in the `orgId` parameter in the URI.

        <div><Callout type="warning">Deleting your organization permanently deletes all of the information associated
        with your organization and is irreversible.</Callout></div>

        Deleting an Organization may fail with a HTTP 409 Conflict response and encounter one or more of the errors
        described below. Resolve these conditions to allow the delete to succeed.
        <br/><br/>

        + Org cannot be deleted as it has Linked sites.

        + Org cannot be deleted as it has active subscriptions or licenses.

        + Org cannot be deleted as `Directory Synchronization
        <https://developer.webex.com/docs/api/v1/broadworks-enterprises/get-directory-sync-status-for-an-enterprise>`_ is enabled.

        + Org cannot be deleted as it has more than 1 user.

        + Org cannot be deleted as it has more than 1 managed by relationship.

        + Org cannot be deleted as it has managed orgs.

        <div>
        <Callout type='info'>When deleting a Webex for BroadWorks Organization with BroadWorks Directory
        Synchronization enabled, a prerequisite is to disable BroadWorks Directory Synchronization for the given
        Organization. Refer to the `Organization Deletion
        <https://developer.webex.com/docs/api/guides/webex-for-broadworks-developers-guide#organization-deletion>`_ section of the `Webex for BroadWorks
        information.</Callout>
        </div>

        :param org_id: The unique identifier for the organization.
        :type org_id: str
        :rtype: None
        """
        url = self.ep(f'{org_id}')
        super().delete(url)


class PartnerAdministratorsApi(ApiChild, base='partner/organizations'):
    """
    Partner Administrators
    
    Partner organizations that manage their customers through Webex Partner Hub can leverage this API to assign or
    unassign partner administrator roles to their users, as well as assign or unassign customer organizations to
    specific partner administrators.
    Managing other partner administrators in an organization requires the partner full administrator role. The users
    being acted upon also exist in the partners own organization. To create a user, see `People API
    <https://developer.webex.com/docs/api/v1/people>`_. The authorizing
    admin must grant the spark-admin:organizations-read scope for read operations and spark-admin:organizations-write
    scope for write operations.
    """

    def get_all_customers_managed_by_a_partner_admin(self, managed_by: str) -> list[IdentityManagedOrg]:
        """
        Get all customers managed by a partner admin

        Get all customers managed by given partner admin, in the `managedBy` request parameter.

        This API can be used by partner full admin and partner readonly admin.

        Specify the `personId` in the `managedBy` parameter in the URI.

        :param managed_by: List customer orgs associated with this person ID.
        :type managed_by: str
        :rtype: list[IdentityManagedOrg]
        """
        params = {}
        params['managedBy'] = managed_by
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[IdentityManagedOrg]).validate_python(data['items'])
        return r

    def get_all_partner_admins_assigned_to_a_customer(self, org_id: str) -> list[PartnerAdminUser]:
        """
        Get all partner admins assigned to a customer

        For a given customer, get all the partner admins with their role details.

        This API can be used by partner full admin.

        Specify the `orgId` in the path parameter.

        :param org_id: List partner admins associated with this customer org ID.
        :type org_id: str
        :rtype: list[PartnerAdminUser]
        """
        url = self.ep(f'{org_id}/partnerAdmins')
        data = super().get(url)
        r = TypeAdapter(list[PartnerAdminUser]).validate_python(data['items'])
        return r

    def assign_partner_admin_to_a_customer(self, org_id: str, person_id: str):
        """
        Assign partner admin to a customer

        Assign a specific partner admin to a customer organization. The partner admin is a user that has the partner
        administrator role.
        Other partner roles, such as partner full administrator are not applicable for this API, since this role
        manages all customer organizations.

        This API can be used by partner full admin.

        Specify the `orgId` and the `personId` in the path param.

        :param org_id: The ID of the customer organization.
        :type org_id: str
        :param person_id: User ID of the partner admin in the partners org.
        :type person_id: str
        :rtype: None
        """
        url = self.ep(f'{org_id}/partnerAdmin/{person_id}/assign')
        super().post(url)

    def unassign_partner_admin_from_a_customer(self, org_id: str, person_id: str):
        """
        Unassign partner admin from a customer

        Unassign a specific partner admin from a customer organization. The partner admin is a user that has the
        partner administrator role.
        Unassigning a customer organization from a partner admin does not remove the role from the user.

        This API can be used by partner full admin.

        Specify the `orgId` and the `personId` in the path param.

        :param org_id: The ID of the customer organization.
        :type org_id: str
        :param person_id: User ID of the partner admin in the partners org.
        :type person_id: str
        :rtype: None
        """
        url = self.ep(f'{org_id}/partnerAdmin/{person_id}/unassign')
        super().delete(url)

    def revoke_all_partner_admin_roles_for_a_given_person_id(self, person_id: str):
        """
        Revoke all partner admin roles for a given person ID

        Revoke all partner administrator roles from a user, thereby revoking access to Partner Hub and all managed
        customer organizations.
        This action does not grant or revoke Control Hub administrator roles (e.g. full administrator, user and device
        administrator, etc.).

        This API can be used by partner full admin.

        Specify the `personId` in the path param.

        :param person_id: ID of the user whose partner roles needs to be revoked.
        :type person_id: str
        :rtype: None
        """
        url = self.ep(f'partnerAdmin/{person_id}')
        super().delete(url)


class PeopleApi(ApiChild, base='people'):
    """
    People
    
    People are registered users of Webex. Searching and viewing People requires an auth token with a `scope
    <https://developer.webex.com/docs/integrations#scopes>`_ of
    `spark:people_read`. Viewing the list of all People in your Organization requires an administrator auth token with
    `spark-admin:people_read` scope. Adding, updating, and removing People requires an administrator auth token with
    the `spark-admin:people_write` and `spark-admin:people_read` scope.
    
    A person's call settings are for `Webex Calling` and necessitate Webex Calling licenses.
    
    To learn more about managing people in a room see the `Memberships API
    <https://developer.webex.com/docs/api/v1/memberships>`_. For information about how to allocate Hybrid
    Services licenses to people, see the `Managing Hybrid Services
    <https://developer.webex.com/docs/api/guides/managing-hybrid-services-licenses>`_ guide.
    """

    def list_people(self, email: str = None, display_name: str = None, id: str = None, org_id: str = None,
                    roles: str = None, calling_data: bool = None, location_id: str = None,
                    **params) -> Generator[Person1, None, None]:
        """
        List People

        List people in your organization. For most users, either the `email` or `displayName` parameter is required.
        Admin users can omit these fields and list all users in their organization.

        Response properties associated with a user's presence status, such as `status` or `lastActivity`, will only be
        returned for people within your organization or an organization you manage. Presence information will not be
        returned if the authenticated user has `disabled status sharing
        <https://help.webex.com/nkzs6wl/>`_.

        Admin users can include `Webex Calling` (BroadCloud) user details in the response by specifying `callingData`
        parameter as `true`. Admin users can list all users in a location or with a specific phone number. Admin users
        will receive an enriched payload with additional administrative fields like `licenses`,`roles` etc. These
        fields are shown when accessing a user via GET /people/{id}, not when doing a GET /people?id=

        Lookup by `email` is only supported for people within the same org or where a partner admin relationship is in
        place.

        Lookup by `roles` is only supported for Admin users for the people within the same org.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param email: List people with this email address. For non-admin requests, either this or `displayName` are
            required. With the exception of partner admins and a managed org relationship, people lookup by email is
            only available for users in the same org.
        :type email: str
        :param display_name: List people whose name starts with this string. For non-admin requests, either this or
            email are required.
        :type display_name: str
        :param id: List people by ID. Accepts up to 85 person IDs separated by commas. If this parameter is provided
            then presence information (such as the `lastActivity` or `status` properties) will not be included in the
            response.
        :type id: str
        :param org_id: List people in this organization. Only admin users of another organization (such as partners)
            may use this parameter.
        :type org_id: str
        :param roles: List of roleIds separated by commas.
        :type roles: str
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :param location_id: List people present in this location.
        :type location_id: str
        :return: Generator yielding :class:`Person1` instances
        """
        if email is not None:
            params['email'] = email
        if display_name is not None:
            params['displayName'] = display_name
        if id is not None:
            params['id'] = id
        if org_id is not None:
            params['orgId'] = org_id
        if roles is not None:
            params['roles'] = roles
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        if location_id is not None:
            params['locationId'] = location_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Person1, item_key='items', params=params)

    def create_a_person(self, emails: list[str], calling_data: bool = None,
                        phone_numbers: list[CreateAPersonPhoneNumbers] = None, extension: Union[str, datetime] = None,
                        location_id: str = None, display_name: str = None, first_name: str = None,
                        last_name: str = None, avatar: str = None, org_id: str = None, roles: list[str] = None,
                        licenses: list[str] = None, department: str = None, manager: str = None,
                        manager_id: str = None, title: str = None, addresses: list[PersonAddresses] = None,
                        site_urls: list[str] = None) -> Person1:
        """
        Create a Person

        Create a new user account for a given organization. Only an admin can create a new user account.

        At least one of the following body parameters is required to create a new user: `displayName`, `firstName`,
        `lastName`.

        Currently, users may have only one email address associated with their account. The `emails` parameter is an
        array, which accepts multiple values to allow for future expansion, but currently only one email address will
        be used for the new user.

        Admin users can include `Webex calling` (BroadCloud) user details in the response by specifying `callingData`
        parameter as true. It may happen that the POST request with calling data returns a 400 status, but the person
        was created still. One way to get into this state is if an invalid phone number is assigned to a user. The
        people API aggregates calls to several other microservices, and one may have failed. A best practice is to
        check if the user exists before retrying. This can be done with the user's email address and a GET /people.

        When doing attendee management, append `#attendee` to the `siteUrl` parameter (e.g.
        `mysite.webex.com#attendee`) to make the new user an attendee for a site.

        **NOTE**:

        * For creating a `Webex Calling` user, you must provide `phoneNumbers` or `extension`, `locationId`, and
        `licenses` string in the same request.

        :param emails: The email addresses of the person. Only one email address is allowed per person.
        :type emails: list[str]
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :param phone_numbers: Phone numbers for the person. Only settable for Webex Calling. Requires a Webex Calling
            license.
        :type phone_numbers: list[CreateAPersonPhoneNumbers]
        :param extension: Webex Calling extension of the person. This is only settable for a person with a Webex
            Calling license.
        :type extension: Union[str, datetime]
        :param location_id: The ID of the location for this person.
        :type location_id: str
        :param display_name: The full name of the person.
        :type display_name: str
        :param first_name: The first name of the person.
        :type first_name: str
        :param last_name: The last name of the person.
        :type last_name: str
        :param avatar: The URL to the person's avatar in PNG format.
        :type avatar: str
        :param org_id: The ID of the organization to which this person belongs.
        :type org_id: str
        :param roles: An array of role strings representing the roles to which this admin user belongs.
        :type roles: list[str]
        :param licenses: An array of license strings allocated to this person.
        :type licenses: list[str]
        :param department: The business department the user belongs to.
        :type department: str
        :param manager: A manager identifier.
        :type manager: str
        :param manager_id: Person Id of the manager
        :type manager_id: str
        :param title: the person's title
        :type title: str
        :param addresses: Person's address
        :type addresses: list[PersonAddresses]
        :param site_urls: One or several site names where this user has an attendee role. Append `#attendee` to the
            sitename (eg: mysite.webex.com#attendee)
        :type site_urls: list[str]
        :rtype: :class:`Person1`
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        body = dict()
        body['emails'] = emails
        body['phoneNumbers'] = loads(TypeAdapter(list[CreateAPersonPhoneNumbers]).dump_json(phone_numbers))
        body['extension'] = extension
        body['locationId'] = location_id
        body['displayName'] = display_name
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['avatar'] = avatar
        body['orgId'] = org_id
        body['roles'] = roles
        body['licenses'] = licenses
        body['department'] = department
        body['manager'] = manager
        body['managerId'] = manager_id
        body['title'] = title
        body['addresses'] = loads(TypeAdapter(list[PersonAddresses]).dump_json(addresses))
        body['siteUrls'] = site_urls
        url = self.ep()
        data = super().post(url, params=params, json=body)
        r = Person1.model_validate(data)
        return r

    def get_person_details(self, person_id: str, calling_data: bool = None) -> Person1:
        """
        Get Person Details

        Shows details for a person, by ID.

        Response properties associated with a user's presence status, such as `status` or `lastActivity`, will only be
        displayed for people within your organization or an organization you manage. Presence information will not be
        shown if the authenticated user has `disabled status sharing
        <https://help.webex.com/nkzs6wl/>`_.

        Admin users can include `Webex Calling` (BroadCloud) user details in the response by specifying `callingData`
        parameter as `true`.

        Specify the person ID in the `personId` parameter in the URI.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :rtype: :class:`Person1`
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        url = self.ep(f'{person_id}')
        data = super().get(url, params=params)
        r = Person1.model_validate(data)
        return r

    def update_a_person(self, person_id: str, display_name: str, calling_data: bool = None,
                        show_all_types: bool = None, emails: list[str] = None,
                        phone_numbers: list[CreateAPersonPhoneNumbers] = None, extension: Union[str, datetime] = None,
                        location_id: str = None, first_name: str = None, last_name: str = None, nick_name: str = None,
                        avatar: str = None, org_id: str = None, roles: list[str] = None, licenses: list[str] = None,
                        department: str = None, manager: str = None, manager_id: str = None, title: str = None,
                        addresses: list[PersonAddresses] = None, site_urls: list[str] = None,
                        login_enabled: str = None) -> Person1:
        """
        Update a Person

        Update details for a person, by ID.

        Specify the person ID in the `personId` parameter in the URI. Only an admin can update a person details.

        Include all details for the person. This action expects all user details to be present in the request. A common
        approach is to first `GET the person's details
        <https://developer.webex.com/docs/api/v1/people/get-person-details>`_, make changes, then PUT both the changed and unchanged values.

        Admin users can include `Webex Calling` (BroadCloud) user details in the response by specifying `callingData`
        parameter as true.

        When doing attendee management, to update a user from host role to an attendee for a site append `#attendee` to
        the respective `siteUrl` and remove the meeting host license for this site from the license array.
        To update a person from an attendee role to a host for a site, add the meeting license for this site in the
        meeting array, and remove that site from the `siteurl` parameter.

        To remove the attendee privilege for a user on a meeting site, remove the `sitename#attendee` from the
        `siteUrl`s array. The `showAllTypes` parameter must be set to `true`.

        **NOTE**:

        * The `locationId` can only be set when assigning a calling license to a user. It cannot be changed if a user
        is already an existing calling user.

        * The `extension` field should be used to update the Webex Calling extension for a person. The extension value
        should not include the location routing prefix. The `work_extension` type in the `phoneNumbers` object as seen
        in the response payload of `List People
        <https://developer.webex.com/docs/api/v1/people/list-people>`_ or `Get Person Details
        extension for a person.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param display_name: The full name of the person.
        :type display_name: str
        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :param show_all_types: Include additional user data like `#attendee` role
        :type show_all_types: bool
        :param emails: The email addresses of the person. Only one email address is allowed per person.
        :type emails: list[str]
        :param phone_numbers: Phone numbers for the person. Can only be set for Webex Calling. Needs a Webex Calling
            license.
        :type phone_numbers: list[CreateAPersonPhoneNumbers]
        :param extension: Webex Calling extension of the person. This is only settable for a person with a Webex
            Calling license
        :type extension: Union[str, datetime]
        :param location_id: The ID of the location for this person.
        :type location_id: str
        :param first_name: The first name of the person.
        :type first_name: str
        :param last_name: The last name of the person.
        :type last_name: str
        :param nick_name: The nickname of the person if configured. Set to the firstName automatically in update
            request.
        :type nick_name: str
        :param avatar: The URL to the person's avatar in PNG format.
        :type avatar: str
        :param org_id: The ID of the organization to which this person belongs.
        :type org_id: str
        :param roles: An array of role strings representing the roles to which this admin user belongs.
        :type roles: list[str]
        :param licenses: An array of license strings allocated to this person.
        :type licenses: list[str]
        :param department: The business department the user belongs to.
        :type department: str
        :param manager: A manager identifier
        :type manager: str
        :param manager_id: Person Id of the manager
        :type manager_id: str
        :param title: the person's title
        :type title: str
        :param addresses: Person's address
        :type addresses: list[PersonAddresses]
        :param site_urls: One or several site names where this user has a role (host or attendee). Append `#attendee`
            to the site name to designate the attendee role on that site.
        :type site_urls: list[str]
        :param login_enabled: Whether or not the user is allowed to use Webex. This property is only accessible if the
            authenticated user is an admin user for the person's organization.
        :type login_enabled: str
        :rtype: :class:`Person1`
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        if show_all_types is not None:
            params['showAllTypes'] = str(show_all_types).lower()
        body = dict()
        body['emails'] = emails
        body['phoneNumbers'] = loads(TypeAdapter(list[CreateAPersonPhoneNumbers]).dump_json(phone_numbers))
        body['extension'] = extension
        body['locationId'] = location_id
        body['displayName'] = display_name
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['nickName'] = nick_name
        body['avatar'] = avatar
        body['orgId'] = org_id
        body['roles'] = roles
        body['licenses'] = licenses
        body['department'] = department
        body['manager'] = manager
        body['managerId'] = manager_id
        body['title'] = title
        body['addresses'] = loads(TypeAdapter(list[PersonAddresses]).dump_json(addresses))
        body['siteUrls'] = site_urls
        body['loginEnabled'] = login_enabled
        url = self.ep(f'{person_id}')
        data = super().put(url, params=params, json=body)
        r = Person1.model_validate(data)
        return r

    def delete_a_person(self, person_id: str):
        """
        Delete a Person

        Remove a person from the system. Only an admin can remove a person.

        Specify the person ID in the `personId` parameter in the URI.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :rtype: None
        """
        url = self.ep(f'{person_id}')
        super().delete(url)

    def get_my_own_details(self, calling_data: bool = None) -> Person1:
        """
        Get My Own Details

        Get profile details for the authenticated user. This is the same as GET `/people/{personId}` using the Person
        ID associated with your Auth token.

        Admin users can include `Webex Calling` (BroadCloud) user details in the response by specifying `callingData`
        parameter as true.

        :param calling_data: Include Webex Calling user details in the response.
        :type calling_data: bool
        :rtype: :class:`Person1`
        """
        params = {}
        if calling_data is not None:
            params['callingData'] = str(calling_data).lower()
        url = self.ep('me')
        data = super().get(url, params=params)
        r = Person1.model_validate(data)
        return r


class PoliciesApi(ApiChild, base='policies'):
    """
    Policies
    
    Policies give organization administrators more control over the integrations available for use within their
    organization. By default, any user can add an integration for use with Webex. To restrict the usage of
    integrations within an organization, create policies to define what is either allowed or disallowed by the
    organization.
    """

    def list_policies(self, type: ListPoliciesType, app_id: list[str] = None, person_id: list[str] = None,
                      org_id: str = None, name: str = None, action: ApplicationUsagePolicyAction = None,
                      to_: Union[str, datetime] = None, cursor: str = None,
                      **params) -> Generator[Policy, None, None]:
        """
        List Policies

        List all policies for an organization. Only lists policies for the organization in which the authenticated user
        belongs.

        Use query parameters to filter the response. Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        :param type: List policies which apply to this policy type.
        :type type: ListPoliciesType
        :param app_id: List policies which apply to this app, by ID.
        :type app_id: list[str]
        :param person_id: List policies which apply to this person, by ID.
        :type person_id: list[str]
        :param org_id: List policies which apply to this `orgId`.
        :type org_id: str
        :param name: List policies which apply to this name.
        :type name: str
        :param action: List policies with this action.
        :type action: ApplicationUsagePolicyAction
        :param to_: List policies created before this date and time.
        :type to_: Union[str, datetime]
        :param cursor: List the next policies after the current cursor.
        :type cursor: str
        :return: Generator yielding :class:`Policy` instances
        """
        if app_id is not None:
            params['appId'] = ','.join(app_id)
        if person_id is not None:
            params['personId'] = ','.join(person_id)
        if org_id is not None:
            params['orgId'] = org_id
        if name is not None:
            params['name'] = name
        params['type'] = type
        if action is not None:
            params['action'] = action
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if cursor is not None:
            params['cursor'] = cursor
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Policy, item_key='items', params=params)

    def create_a_policy(self, type: ListPoliciesType, action: ApplicationUsagePolicyAction, app_id: str = None,
                        name: str = None, person_ids: list[str] = None) -> Policy:
        """
        Create a Policy

        Add a new policy.

        :param type: Specify a policy type.
        :type type: ListPoliciesType
        :param action: Specify policy action.
        :type action: ApplicationUsagePolicyAction
        :param app_id: Specify the `appId` for the policy.
        :type app_id: str
        :param name: Specify user-friendly name for the policy.
        :type name: str
        :param person_ids: The `personIds` for the individual people this policy applies to.
        :type person_ids: list[str]
        :rtype: :class:`Policy`
        """
        body = dict()
        body['appId'] = app_id
        body['name'] = name
        body['type'] = enum_str(type)
        body['personIds'] = person_ids
        body['action'] = enum_str(action)
        url = self.ep()
        data = super().post(url, json=body)
        r = Policy.model_validate(data)
        return r

    def get_policy_details(self, policy_id: str) -> Policy:
        """
        Get Policy Details

        Shows details for a policy, by ID.

        Specify the policy ID in the `policyId` URI parameter.

        :param policy_id: A unique identifier for the policy.
        :type policy_id: str
        :rtype: :class:`Policy`
        """
        url = self.ep(f'{policy_id}')
        data = super().get(url)
        r = Policy.model_validate(data)
        return r

    def update_a_policy(self, policy_id: str, action: ApplicationUsagePolicyAction, app_id: str = None,
                        name: str = None, person_ids: list[str] = None) -> Policy:
        """
        Update a Policy

        Update details for a policy, by ID.

        Specify the policy ID in the `policyId` URI parameter.

        :param policy_id: A unique identifier for the policy.
        :type policy_id: str
        :param action: The policy action.
        :type action: ApplicationUsagePolicyAction
        :param app_id: The `appId` of the app to which the policy applies.
        :type app_id: str
        :param name: A user-friendly name for the policy.
        :type name: str
        :param person_ids: The `personIds` for the individual people this policy applies to.
        :type person_ids: list[str]
        :rtype: :class:`Policy`
        """
        body = dict()
        body['appId'] = app_id
        body['name'] = name
        body['personIds'] = person_ids
        body['action'] = enum_str(action)
        url = self.ep(f'{policy_id}')
        data = super().put(url, json=body)
        r = Policy.model_validate(data)
        return r

    def delete_a_policy(self, policy_id: str):
        """
        Delete a Policy

        Delete a policy, by ID.

        Specify the policy ID in the `policyId` URI parameter.

        :param policy_id: A unique identifier for the policy.
        :type policy_id: str
        :rtype: None
        """
        url = self.ep(f'{policy_id}')
        super().delete(url)


class RecordingReportApi(ApiChild, base='recordingReport'):
    """
    Recording Report
    
    The recording report API is used to retrieve reports of recording.
    
    Refer to the `Meetings API Scopes` section of `Meetings Overview
    <https://developer.webex.com/docs/meetings>`_ for scopes required for each API.
    """

    def list_of_recording_audit_report_summaries(self, from_: Union[str, datetime] = None, to_: Union[str,
                                                 datetime] = None, host_email: str = None, site_url: str = None,
                                                 **params) -> Generator[RecordingReportSummaryObject, None, None]:
        """
        List of Recording Audit Report Summaries

        Lists of recording audit report summaries. You can specify a date range and the maximum number of recording
        audit report summaries to return.

        Only recording audit report summaries of meetings hosted by or shared with the authenticated user will be
        listed.

        The list returned is sorted in descending order by the date and time that the recordings were created.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * If `siteUrl` is specified, the recording audit report summaries of the specified site will be listed;
        otherwise, recording audit report summaries of the user's preferred site will be listed. All available Webex
        sites and the preferred site of the user can be retrieved by the `Get Site List` API.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.

        :param from_: Starting date and time (inclusive) for recording audit report summaries to return, in any
            `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot be after `to`. Please note that the interval between `to` and
            `from` cannot exceed 90 days and the interval between the current time and `from` cannot exceed 365 days.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time (exclusive) for recording audit report summaries to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. `to` cannot be before `from`. Please note that the interval between `to` and `from`
            cannot exceed 90 days and the interval between the current time and `from` cannot exceed 365 days.
        :type to_: Union[str, datetime]
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return recording audit report summaries of that user.
        :type host_email: str
        :param site_url: URL of the Webex site which the API lists recording audit report summaries from. If not
            specified, the API lists summary audit report for recordings from the user's preferred site. All available
            Webex sites and the preferred site of the user can be retrieved by `Get Site List` API.
        :type site_url: str
        :return: Generator yielding :class:`RecordingReportSummaryObject` instances
        """
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('accessSummary')
        return self.session.follow_pagination(url=url, model=RecordingReportSummaryObject, item_key='items', params=params)

    def get_recording_audit_report_details(self, recording_id: str, host_email: str = None,
                                           **params) -> Generator[RecordingReportObject, None, None]:
        """
        Get Recording Audit Report Details

        Retrieves details for a recording audit report with a specified recording ID.

        Only recording audit report details of meetings hosted by or shared with the authenticated user may be
        retrieved.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.

        :param recording_id: A unique identifier for the recording.
        :type recording_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the admin on-behalf-of scopes. If set, the admin may specify the email of a user in a
            site they manage and the API will return recording details of that user.
        :type host_email: str
        :return: Generator yielding :class:`RecordingReportObject` instances
        """
        params['recordingId'] = recording_id
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep('accessDetail')
        return self.session.follow_pagination(url=url, model=RecordingReportObject, item_key='items', params=params)

    def list_meeting_archive_summaries(self, from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                                       site_url: str = None,
                                       **params) -> Generator[RecordingAchriveSummaryObject, None, None]:
        """
        List Meeting Archive Summaries

        Lists of meeting archive summaries. You can specify a date range and the maximum number of meeting archive
        summaries to return.

        Meeting archive summaries are only available to full administrators, not even the meeting host.

        The list returned is sorted in descending order by the date and time that the archives were created.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * If `siteUrl` is specified, the meeting archive summaries of the specified site will be listed; otherwise,
        meeting archive summaries of the user's preferred site will be listed. All available Webex sites and the
        preferred site of the user can be retrieved by the `Get Site List` API.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.

        :param from_: Starting date and time (inclusive) for meeting archive summaries to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_
            compliant format. `from` cannot be after `to`. Please note that the interval between `to` and `from`
            cannot exceed 30 days.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time (exclusive) for meeting archive summaries to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant
            format. `to` cannot be before `from`. Please note that the interval between `to` and `from` cannot exceed
            30 days.
        :type to_: Union[str, datetime]
        :param site_url: URL of the Webex site which the API lists meeting archive summaries from. If not specified,
            the API lists meeting archive summaries for recordings from the user's preferred site. All available Webex
            sites and the preferred site of the user can be retrieved by `Get Site List` API.
        :type site_url: str
        :return: Generator yielding :class:`RecordingAchriveSummaryObject` instances
        """
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep('meetingArchiveSummaries')
        return self.session.follow_pagination(url=url, model=RecordingAchriveSummaryObject, item_key='items', params=params)

    def get_meeting_archive_details(self, archive_id: str) -> RecordingArchiveReportObject:
        """
        Get Meeting Archive Details

        Retrieves details for a meeting archive report with a specified archive ID, which contains recording metadata.

        Meeting archive details are only available to full administrators, not even the meeting host.

        #### Request Header

        * `timezone`: `Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.

        :param archive_id: A unique identifier for the meeting archive summary.
        :type archive_id: str
        :rtype: :class:`RecordingArchiveReportObject`
        """
        url = self.ep(f'meetingArchives/{archive_id}')
        data = super().get(url)
        r = RecordingArchiveReportObject.model_validate(data)
        return r


class RecordingsApi(ApiChild, base=''):
    """
    Recordings
    
    Recordings are meeting content captured in a meeting or files uploaded via the upload page for your Webex site.
    
    This API manages recordings. Recordings may be retrieved via download or playback links defined by `downloadUrl` or
    `playbackUrl` in the response body.
    
    When the recording function is paused in the meeting the recording will not contain the pause. If the recording
    function is stopped and restarted in the meeting, several recordings will be created. These recordings will be
    consolidate and available all at once.
    
    Refer to the `Meetings API Scopes
    <https://developer.webex.com/docs/meetings#user-level-authentication-and-scopes>`_ for the specific scopes required for each API.
    """

    def list_recordings(self, from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                        meeting_id: str = None, host_email: str = None, site_url: str = None,
                        integration_tag: str = None, topic: str = None, format: ListRecordingsFormat = None,
                        service_type: MeetingUsageReportObjectServiceType = None, status: ListRecordingsStatus = None,
                        **params) -> Generator[RecordingObject, None, None]:
        """
        List Recordings

        Lists recordings. You can specify a date range, a parent meeting ID, and the maximum number of recordings to
        return.

        Only recordings of meetings hosted by or shared with the authenticated user will be listed.

        The list returned is sorted in descending order by the date and time that the recordings were created.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * If `meetingId` is specified, only recordings associated with the specified meeting will be listed. **NOTE**:
        when `meetingId` is specified, parameter of `siteUrl` will be ignored.

        * If `siteUrl` is specified, recordings of the specified site will be listed; otherwise, the API lists
        recordings of all the user's sites. All available Webex sites and preferred site of the user can be retrieved
        by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        #### Request Header

        * `timezone`: *`Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.*

        :param from_: Starting date and time (inclusive) for recordings to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `from` cannot be after `to`.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time (exclusive) for List recordings to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `to` cannot be before `from`.
        :type to_: Union[str, datetime]
        :param meeting_id: Unique identifier for the parent meeting series, scheduled meeting, or meeting instance for
            which recordings are being requested. If a meeting series ID is specified, the operation returns an array
            of recordings for the specified meeting series. If a scheduled meeting ID is specified, the operation
            returns an array of recordings for the specified scheduled meeting. If a meeting instance ID is specified,
            the operation returns an array of recordings for the specified meeting instance. If no ID is specified,
            the operation returns an array of recordings for all meetings of the current user. When `meetingId` is
            specified, the `siteUrl` parameter is ignored.
        :type meeting_id: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the required `admin-level meeting scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a
            user in a site they manage and the API will return recordings of that user.
        :type host_email: str
        :param site_url: URL of the Webex site from which the API lists recordings. If not specified, the API lists
            recordings from all of a user's sites. All available Webex sites and the preferred site of the user can be
            retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param integration_tag: External key of the parent meeting created by an integration application. This
            parameter is used by the integration application to query recordings by a key in its own domain, such as a
            Zendesk ticket ID, a Jira ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str
        :param topic: Recording's topic. If specified, the API filters recordings by topic in a case-insensitive
            manner.
        :type topic: str
        :param format: Recording's file format. If specified, the API filters recordings by format.
        :type format: ListRecordingsFormat
        :param service_type: The service type for recordings. If this item is specified, the API filters recordings by
            service-type.
        :type service_type: MeetingUsageReportObjectServiceType
        :param status: Recording's status. If not specified or `available`, retrieves recordings that are available.
            Otherwise, if specified as `deleted`, retrieves recordings that have been moved into the recycle bin.
        :type status: ListRecordingsStatus
        :return: Generator yielding :class:`RecordingObject` instances
        """
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if host_email is not None:
            params['hostEmail'] = host_email
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        if topic is not None:
            params['topic'] = topic
        if format is not None:
            params['format'] = format
        if service_type is not None:
            params['serviceType'] = service_type
        if status is not None:
            params['status'] = status
        url = self.ep('recordings')
        return self.session.follow_pagination(url=url, model=RecordingObject, item_key='items', params=params)

    def list_recordings_for_an_admin_or_compliance_officer(self, from_: Union[str, datetime] = None, to_: Union[str,
                                                           datetime] = None, meeting_id: str = None,
                                                           site_url: str = None, integration_tag: str = None,
                                                           topic: str = None, format: ListRecordingsFormat = None,
                                                           service_type: MeetingUsageReportObjectServiceType = None,
                                                           status: ListRecordingsStatus = None,
                                                           **params) -> Generator[RecordingObjectForAdminAndCO, None, None]:
        """
        List Recordings For an Admin or Compliance Officer

        List recordings for an admin or compliance officer. You can specify a date range, a parent meeting ID, and the
        maximum number of recordings to return.

        The list returned is sorted in descending order by the date and time that the recordings were created.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        * If `meetingId` is specified, only recordings associated with the specified meeting will be listed. Please
        note that when `meetingId` is specified, parameter of `siteUrl` will be ignored.

        * If `siteUrl` is specified, all the recordings on the specified site are listed; otherwise, all the recordings
        on the admin user's or compliance officer's preferred site are listed. All the available Webex sites and the
        admin user's or compliance officer's preferred site can be retrieved by the `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        #### Request Header

        * `timezone`: *`Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.*

        :param from_: Starting date and time (inclusive) for recordings to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `from` cannot be after `to`. The interval between `from` and `to` must be within 30 days.
        :type from_: Union[str, datetime]
        :param to_: Ending date and time (exclusive) for List recordings to return, in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
            `to` cannot be before `from`. The interval between `from` and `to` must be within 30 days.
        :type to_: Union[str, datetime]
        :param meeting_id: Unique identifier for the parent meeting series, scheduled meeting, or meeting instance for
            which recordings are being requested. If a meeting series ID is specified, the operation returns an array
            of recordings for the specified meeting series. If a scheduled meeting ID is specified, the operation
            returns an array of recordings for the specified scheduled meeting. If a meeting instance ID is specified,
            the operation returns an array of recordings for the specified meeting instance. If not specified, the
            operation returns an array of recordings for all the current user's meetings. When `meetingId` is
            specified, the `siteUrl` parameter is ignored.
        :type meeting_id: str
        :param site_url: URL of the Webex site which the API lists recordings from. If not specified, the API lists
            recordings from user's preferred site. All available Webex sites and preferred site of the user can be
            retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param integration_tag: External key of the parent meeting created by an integration application. This
            parameter is used by the integration application to query recordings by a key in its own domain such as a
            Zendesk ticket ID, a Jira ID, a Salesforce Opportunity ID, etc.
        :type integration_tag: str
        :param topic: Recording topic. If specified, the API filters recordings by topic in a case-insensitive manner.
        :type topic: str
        :param format: Recording's file format. If specified, the API filters recordings by format.
        :type format: ListRecordingsFormat
        :param service_type: The service type for recordings. If specified, the API filters recordings by service type.
        :type service_type: MeetingUsageReportObjectServiceType
        :param status: Recording's status. If not specified or `available`, retrieves recordings that are available.
            Otherwise, if specified as `deleted`, retrieves recordings that have been moved to the recycle bin.
        :type status: ListRecordingsStatus
        :return: Generator yielding :class:`RecordingObjectForAdminAndCO` instances
        """
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if meeting_id is not None:
            params['meetingId'] = meeting_id
        if site_url is not None:
            params['siteUrl'] = site_url
        if integration_tag is not None:
            params['integrationTag'] = integration_tag
        if topic is not None:
            params['topic'] = topic
        if format is not None:
            params['format'] = format
        if service_type is not None:
            params['serviceType'] = service_type
        if status is not None:
            params['status'] = status
        url = self.ep('admin/recordings')
        return self.session.follow_pagination(url=url, model=RecordingObjectForAdminAndCO, item_key='items', params=params)

    def get_recording_details(self, recording_id: str,
                              host_email: str = None) -> RecordingObjectWithDirectDownloadLinks:
        """
        Get Recording Details

        Retrieves details for a recording with a specified recording ID.

        Only recordings of meetings hosted by or shared with the authenticated user may be retrieved.

        #### Request Header

        * `timezone`: *`Time zone
        <https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List>`_ in conformance with the `IANA time zone database
        not defined.*

        :param recording_id: A unique identifier for the recording.
        :type recording_id: str
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            required `admin-level meeting scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage, and the API will return recording details of that user.
        :type host_email: str
        :rtype: :class:`RecordingObjectWithDirectDownloadLinks`
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        url = self.ep(f'recordings/{recording_id}')
        data = super().get(url, params=params)
        r = RecordingObjectWithDirectDownloadLinks.model_validate(data)
        return r

    def delete_a_recording(self, recording_id: str, reason: str, comment: str, host_email: str = None):
        """
        Delete a Recording

        Removes a recording with a specified recording ID. The deleted recording cannot be recovered. If a Compliance
        Officer deletes another user's recording, the recording will be inaccessible to regular users (host, attendees
        and shared), but will be still available to the Compliance Officer.

        Only recordings of meetings hosted by the authenticated user can be deleted.

        :param recording_id: A unique identifier for the recording.
        :type recording_id: str
        :param reason: Reason for deleting a recording. Only required when a Compliance Officer is operating on another
            user's recording.
        :type reason: str
        :param comment: Compliance Officer's explanation for deleting a recording. The comment can be a maximum of 255
            characters long.
        :type comment: str
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            the required `admin-level meeting scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will delete a recording of that user.
        :type host_email: str
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['reason'] = reason
        body['comment'] = comment
        url = self.ep(f'recordings/{recording_id}')
        super().delete(url, params=params, json=body)

    def move_recordings_into_the_recycle_bin(self, recording_ids: list[str], site_url: str, host_email: str = None):
        """
        Move Recordings into the Recycle Bin

        Move recordings into the recycle bin with recording IDs. Recordings in the recycle bin can be recovered by
        `Restore Recordings from Recycle Bin
        <https://developer.webex.com/docs/api/v1/recordings/restore-recordings-from-recycle-bin>`_ API. If you'd like to empty recordings from the recycle bin, you can use
        `Purge Recordings from Recycle Bin
        <https://developer.webex.com/docs/api/v1/recordings/purge-recordings-from-recycle-bin>`_ API to purge all or some of them.

        Only recordings of meetings hosted by the authenticated user can be moved into the recycle bin.

        * `recordingIds` should not be empty and its maximum size is `100`.

        * All the IDs of `recordingIds` should belong to the site of `siteUrl` or the user's preferred site if
        `siteUrl` is not specified.

        :param recording_ids: Recording IDs for removing recordings into the recycle bin in batch. Please note that all
            the recording IDs should belong to the site of `siteUrl` or the user's preferred site if `siteUrl` is not
            specified.
        :type recording_ids: list[str]
        :param site_url: URL of the Webex site from which the API deletes recordings. If not specified, the API deletes
            recordings from the user's preferred site. All available Webex sites and preferred sites of a user can be
            retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            the required `admin-level meeting scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will move recordings into recycle bin of that user
        :type host_email: str
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['recordingIds'] = recording_ids
        body['siteUrl'] = site_url
        url = self.ep('recordings/softDelete')
        super().post(url, params=params, json=body)

    def restore_recordings_from_recycle_bin(self, restore_all: bool, recording_ids: list[str], site_url: str,
                                            host_email: str = None):
        """
        Restore Recordings from Recycle Bin

        Restore all or some recordings from the recycle bin. Only recordings of meetings hosted by the authenticated
        user can be restored from recycle bin.

        * If `restoreAll` is `true`, `recordingIds` should be empty.

        * If `restoreAll` is `false`, `recordingIds` should not be empty and its maximum size is `100`.

        * All the IDs of `recordingIds` should belong to the site of `siteUrl` or the user's preferred site if
        `siteUrl` is not specified.

        :param restore_all: If not specified or `false`, restores the recordings specified by `recordingIds`. If
            `true`, restores all recordings from the recycle bin.
        :type restore_all: bool
        :param recording_ids: Recording IDs for recovering recordings from the recycle bin in batch. Note that all the
            recording IDs should belong to the site of `siteUrl` or the user's preferred site if `siteUrl` is not
            specified.
        :type recording_ids: list[str]
        :param site_url: URL of the Webex site from which the API restores recordings. If not specified, the API
            restores recordings from a user's preferred site. All available Webex sites and preferred sites of a user
            can be retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param host_email: Email address for the meeting host. This parameter is only used if the user or application
            calling the API has the required `admin-level meeting scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a
            user in a site they manage and the API will restore recordings of that user.
        :type host_email: str
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['restoreAll'] = restore_all
        body['recordingIds'] = recording_ids
        body['siteUrl'] = site_url
        url = self.ep('recordings/restore')
        super().post(url, params=params, json=body)

    def purge_recordings_from_recycle_bin(self, purge_all: bool, recording_ids: list[str], site_url: str,
                                          host_email: str = None):
        """
        Purge Recordings from Recycle Bin

        Purge recordings from recycle bin with recording IDs or purge all the recordings that are in the recycle bin.

        Only recordings of meetings hosted by the authenticated user can be purged from recycle bin.

        * If `purgeAll` is `true`, `recordingIds` should be empty.

        * If `purgeAll` is `false`, `recordingIds` should not be empty and its maximum size is `100`.

        * All the IDs of `recordingIds` should belong to the site of `siteUrl` or the user's preferred site if
        `siteUrl` is not specified.

        :param purge_all: If not specified or `false`, purges the recordings specified by `recordingIds`. If `true`,
            purges all recordings from the recycle bin.
        :type purge_all: bool
        :param recording_ids: Recording IDs for purging recordings from the recycle bin in batch. Note that all the
            recording IDs should belong to the site of `siteUrl` or the user's preferred site if `siteUrl` is not
            specified.
        :type recording_ids: list[str]
        :param site_url: URL of the Webex site from which the API purges recordings. If not specified, the API purges
            recordings from user's preferred site. All available Webex sites and preferred sites of the user can be
            retrieved by `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :param host_email: Email address for the meeting host. Only used if the user or application calling the API has
            the required `admin-level meeting scopes
            <https://developer.webex.com/docs/meetings#adminorganization-level-authentication-and-scopes>`_. If set, the admin may specify the email of a user in a site they
            manage and the API will purge recordings from recycle bin of that user.
        :type host_email: str
        :rtype: None
        """
        params = {}
        if host_email is not None:
            params['hostEmail'] = host_email
        body = dict()
        body['purgeAll'] = purge_all
        body['recordingIds'] = recording_ids
        body['siteUrl'] = site_url
        url = self.ep('recordings/purge')
        super().post(url, params=params, json=body)


class ReportTemplatesApi(ApiChild, base='report/templates'):
    """
    Report Templates
    
    Report templates are available for use with the `Reports API
    <https://developer.webex.com/docs/api/v1/reports>`_.
    
    To access this endpoint, you must use an administrator token with the `analytics:read_all` `scope
    <https://developer.webex.com/docs/integrations#scopes>`_. The authenticated
    user must be a read-only or full administrator of the organization to which the report belongs.
    
    To use this endpoint the organization needs to be licensed for `Pro Pack for Control Hub
    <https://help.webex.com/article/np3c1rm/Pro-Pack-For-Control-Hub>`_.
    
    For more information about Report Templates, see the `Admin API
    <https://developer.webex.com/docs/admin#reports-api>`_ guide.
    """

    def list_report_templates(self) -> list[Template2]:
        """
        List Report Templates

        List all the available report templates that can be generated.

        CSV (comma separated value) reports for Webex services are only supported for organizations based in the North
        American region. Organizations based in other regions will return blank CSV files for any Webex reports.

        :rtype: list[Template2]
        """
        url = self.ep()
        data = super().get(url)
        r = TypeAdapter(list[Template2]).validate_python(data)
        return r


class ReportsDetailedCallHistoryApi(ApiChild, base='cdr_feed'):
    """
    Reports: Detailed Call History
    
    The base URL for these APIs is **analytics.webexapis.com** (or
    **analytics-f.webex.com** for Government), which does not work with the API
    reference's **Try It** feature. If you have any questions or need help please
    contact the Webex Developer Support team at devsupport@webex.com.
    
    
    
    To retrieve Detailed Call History information, you must use a token with the `spark-admin:calling_cdr_read` `scope
    <https://developer.webex.com/docs/integrations#scopes>`_.
    The authenticating user must be a read-only-admin or full-admin of the organization and have the administrator
    role "Webex Calling Detailed Call History API access" enabled.
    
    Detailed Call History information is available 5 minutes after a call has ended and may be retrieved for up to 48
    hours. For example, if a call ends at 9:46 am, the record for that call can be collected using the API from 9:51
    am, and is available until 9:46 am two days later.
    
    This API is rate-limited to one call every 1 minutes for a given organization ID.
    
    Details on the fields returned from this API and their potential values are available at
    <https://help.webex.com/en-us/article/nmug598/Reports-for-Your-Cloud-Collaboration-Portfolio>. Select the **Report
    templates** tab, and then in the **Webex Calling reports** section see **Calling Detailed Call History Report**.
    
    By default, the calls to analytics.webexapis.com are sent to the closest region's servers. If the region's servers
    host the organization's data, then the data is returned. Otherwise, an HTTP 451 error code response is returned.
    The body of the response in this case contains the end point information where a user can get data for the user's
    organization.
    """

    def get_detailed_call_history(self, start_time: Union[str, datetime], end_time: Union[str, datetime],
                                  locations: str = None, **params) -> Generator[CDR, None, None]:
        """
        Get Detailed Call History

        Provides Webex Calling Detailed Call History data for your organization.

        Results can be filtered with the `startTime`, `endTime` and `locations` request parameters. The `startTime` and
        `endTime` parameters specify the start and end of the time period for the Detailed Call History reports you
        wish to collect. The API will return all reports that were created between `startTime` and `endTime`.

        <br/><br/>
        Response entries may be added as more information is made available for the reports.
        Values in response items may be extended as more capabilities are added to Webex Calling.

        :param start_time: Time of the first report you wish to collect. (Report time is the time the call finished).
            **Note:** The specified time must be between 5 minutes ago and 48 hours ago, and be formatted as
            `YYYY-MM-DDTHH:MM:SS.mmmZ`.
        :type start_time: Union[str, datetime]
        :param end_time: Time of the last report you wish to collect. (Report time is the time the call finished).
            **Note:** The specified time should be later than `startTime` but no later than 48 hours, and be formatted
            as `YYYY-MM-DDTHH:MM:SS.mmmZ`.
        :type end_time: Union[str, datetime]
        :param locations: Name of the location (as shown in Control Hub). Up to 10 comma-separated locations can be
            provided. Allows you to query reports by location.
        :type locations: str
        :return: Generator yielding :class:`CDR` instances
        """
        if isinstance(start_time, str):
            start_time = isoparse(start_time)
        start_time = dt_iso_str(start_time)
        params['startTime'] = start_time
        if isinstance(end_time, str):
            end_time = isoparse(end_time)
        end_time = dt_iso_str(end_time)
        params['endTime'] = end_time
        if locations is not None:
            params['locations'] = locations
        url = self.ep()
        return self.session.follow_pagination(url=url, model=CDR, item_key='items', params=params)


class ReportsApi(ApiChild, base='reports'):
    """
    Reports
    
    To access these endpoints, you must use an administrator token with the `analytics:read_all` `scope
    <https://developer.webex.com/docs/integrations#scopes>`_. The
    authenticated user must be a read-only or full administrator of the organization to which the report belongs.
    
    To use this endpoint the org needs to be licensed for the Pro Pack.
    
    Reports available via `Webex Control Hub
    <https://admin.webex.com>`_ may be generated and downloaded via the Reports API. To access this API,
    the authenticated user must be a read-only or full administrator of the organization to which the report belongs.
    
    For more information about Reports, see the `Admin API
    <https://developer.webex.com/docs/admin#reports-api>`_ guide.
    """

    def list_reports(self, report_id: str = None, service: str = None, template_id: int = None, from_: Union[str,
                     datetime] = None, to_: Union[str, datetime] = None) -> list[Report1]:
        """
        List Reports

        Lists all reports. Use query parameters to filter the response. The parameters are optional. However, `from`
        and `to` parameters should be provided together.

        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param report_id: List reports by ID.
        :type report_id: str
        :param service: List reports which use this service.
        :type service: str
        :param template_id: List reports with this report template ID.
        :type template_id: int
        :param from_: List reports that were created on or after this date.
        :type from_: Union[str, datetime]
        :param to_: List reports that were created before this date.
        :type to_: Union[str, datetime]
        :rtype: list[Report1]
        """
        params = {}
        if report_id is not None:
            params['reportId'] = report_id
        if service is not None:
            params['service'] = service
        if template_id is not None:
            params['templateId'] = template_id
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[Report1]).validate_python(data['Report Attributes'])
        return r

    def create_a_report(self, template_id: str, start_date: Union[str, datetime] = None, end_date: Union[str,
                        datetime] = None, site_list: str = None) -> str:
        """
        Create a Report

        Create a new report. For each `templateId`, there are a set of validation rules that need to be followed. For
        example, for templates belonging to Webex, the user needs to provide `siteUrl`. These validation rules can be
        retrieved via the `Report Templates API
        <https://developer.webex.com/docs/api/v1/report-templates>`_.

        The 'templateId' parameter is a number. However, it is a limitation of developer.webex.com platform that it is
        passed as a string when you try to test the API from here.

        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param template_id: Unique ID representing valid report templates.
        :type template_id: str
        :param start_date: Data in the report will be from this date onwards.
        :type start_date: Union[str, datetime]
        :param end_date: Data in the report will be until this date.
        :type end_date: Union[str, datetime]
        :param site_list: Sites belonging to user's organization. This attribute is needed for site-based templates.
        :type site_list: str
        :rtype: str
        """
        body = dict()
        body['templateId'] = template_id
        body['startDate'] = start_date
        body['endDate'] = end_date
        body['siteList'] = site_list
        url = self.ep()
        data = super().post(url, json=body)
        r = data['id']
        return r

    def get_report_details(self, report_id: str) -> Report1:
        """
        Get Report Details

        Shows details for a report, by report ID.

        Specify the report ID in the `reportId` parameter in the URI.

        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param report_id: The unique identifier for the report.
        :type report_id: str
        :rtype: :class:`Report1`
        """
        url = self.ep(f'{report_id}')
        data = super().get(url)
        r = Report1.model_validate(data)
        return r

    def delete_a_report(self, report_id: str):
        """
        Delete a Report

        Remove a report from the system.

        Specify the report ID in the `reportId` parameter in the URI

        CSV reports for Teams services are only supported for organizations based in the North American region.
        Organizations based in a different region will return blank CSV files for any Teams reports.

        :param report_id: The unique identifier for the report.
        :type report_id: str
        :rtype: None
        """
        url = self.ep(f'{report_id}')
        super().delete(url)


class ResourceGroupMembershipsApi(ApiChild, base='resourceGroup/memberships'):
    """
    Resource Group Memberships
    
    Resource Group Memberships represent a person's relationship to a Resource Group for a particular `Hybrid Services
    <https://developer.webex.com/docs/api/guides/managing-hybrid-services-licenses>`_
    license. Users assigned a new license will be automatically placed in a "default" Resource Group. Use this API to
    list memberships for all people in an organization or update memberships to use a different Resource Group.
    
    Searching and viewing Resource Group Memberships requires an administrator auth token with the
    `spark-admin:resource_group_memberships_read` scope. Updating memberships requires an administrator auth token
    with the `spark-admin:resource_group_memberships_write` scope.
    
    To manage Resource Groups, see the `Resource Groups API
    <https://developer.webex.com/docs/api/v1/resource-groups>`_. For more information about Resource Groups, see the
    `Managing Hybrid Services
    <https://developer.webex.com/docs/api/guides/managing-hybrid-services-licenses>`_ guide.
    """

    def list_resource_group_memberships(self, license_id: str = None, person_id: str = None, person_org_id: str = None,
                                        status: ResourceGroupMembershipStatus = None,
                                        **params) -> Generator[ResourceGroupMembership, None, None]:
        """
        List Resource Group Memberships

        Lists all resource group memberships for an organization.

        Use query parameters to filter the response.

        :param license_id: List resource group memberships for a license, by ID.
        :type license_id: str
        :param person_id: List resource group memberships for a person, by ID.
        :type person_id: str
        :param person_org_id: List resource group memberships for an organization, by ID.
        :type person_org_id: str
        :param status: Limit resource group memberships to a specific status.
        :type status: ResourceGroupMembershipStatus
        :return: Generator yielding :class:`ResourceGroupMembership` instances
        """
        if license_id is not None:
            params['licenseId'] = license_id
        if person_id is not None:
            params['personId'] = person_id
        if person_org_id is not None:
            params['personOrgId'] = person_org_id
        if status is not None:
            params['status'] = status
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ResourceGroupMembership, item_key='items', params=params)

    def get_resource_group_membership_details(self, resource_group_membership_id: str) -> ResourceGroupMembership:
        """
        Get Resource Group Membership Details

        Shows details for a resource group membership, by ID.

        Specify the resource group membership ID in the `resourceGroupMembershipId` URI parameter.

        :param resource_group_membership_id: The unique identifier for the resource group membership.
        :type resource_group_membership_id: str
        :rtype: :class:`ResourceGroupMembership`
        """
        url = self.ep(f'{resource_group_membership_id}')
        data = super().get(url)
        r = ResourceGroupMembership.model_validate(data)
        return r

    def update_a_resource_group_membership(self, resource_group_membership_id: str, resource_group_id: str,
                                           license_id: str, person_id: str, person_org_id: str,
                                           status: ResourceGroupMembershipStatus) -> ResourceGroupMembership:
        """
        Update a Resource Group Membership

        Updates a resource group membership, by ID.

        Specify the resource group membership ID in the `resourceGroupMembershipId`URI parameter.

        Only the `resourceGroupId`can be changed with this action. Resource group memberships with a `status`of
        "pending" cannot be updated. For more information about resource group memberships, see the
        `Managing Hybrid Services
        <https://developer.webex.com/docs/api/guides/managing-hybrid-services-licenses#webex-resource-groups>`_ guide.

        :param resource_group_membership_id: The unique identifier for the resource group membership.
        :type resource_group_membership_id: str
        :param resource_group_id: The resource group ID.
        :type resource_group_id: str
        :param license_id: The license ID.
        :type license_id: str
        :param person_id: The person ID.
        :type person_id: str
        :param person_org_id: The organization ID of the person.
        :type person_org_id: str
        :param status: The activation status of the resource group membership.
        :type status: ResourceGroupMembershipStatus
        :rtype: :class:`ResourceGroupMembership`
        """
        body = dict()
        body['resourceGroupId'] = resource_group_id
        body['licenseId'] = license_id
        body['personId'] = person_id
        body['personOrgId'] = person_org_id
        body['status'] = enum_str(status)
        url = self.ep(f'{resource_group_membership_id}')
        data = super().put(url, json=body)
        r = ResourceGroupMembership.model_validate(data)
        return r


class ResourceGroupsApi(ApiChild, base='resourceGroups'):
    """
    Resource Groups
    
    Resource Groups are collections of on-premise clusters which provide `Hybrid Services
    <https://developer.webex.com/docs/api/guides/managing-hybrid-services-licenses>`_ to a particular subset of
    people in an organization. If a person has a Hybrid Services license associated with their account, they will be
    associated with a resource group to use specific on-premise clusters for that service.
    
    Searching and viewing Resource Groups requires an administrator auth token with a scope of
    `spark-admin:resource_groups_read`.
    
    To manage the people associated with Resource Groups, see the `Resource Group Memberships API
    <https://developer.webex.com/docs/api/v1/resource-group-memberships>`_. For more information
    about Resource Groups, see the `Managing Hybrid Services
    <https://developer.webex.com/docs/api/guides/managing-hybrid-services-licenses>`_ guide.
    """

    def list_resource_groups(self, org_id: str = None) -> list[ResourceGroup]:
        """
        List Resource Groups

        List resource groups.

        Use query parameters to filter the response.

        :param org_id: List resource groups in this organization. Only admin users of another organization (such as
            partners) may use this parameter.
        :type org_id: str
        :rtype: list[ResourceGroup]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[ResourceGroup]).validate_python(data['items'])
        return r

    def get_resource_group_details(self, resource_group_id: str) -> ResourceGroup:
        """
        Get Resource Group Details

        Shows details for a resource group, by ID.

        Specify the resource group ID in the `resourceGroupId` parameter in the URI.

        :param resource_group_id: The unique identifier for the resource group.
        :type resource_group_id: str
        :rtype: :class:`ResourceGroup`
        """
        url = self.ep(f'{resource_group_id}')
        data = super().get(url)
        r = ResourceGroup.model_validate(data)
        return r


class RolesApi(ApiChild, base='roles'):
    """
    Roles
    
    A persona for an authenticated user, corresponding to a set of privileges within an organization. This roles
    resource can be accessed only by an admin and shows only roles relevant to an admin.
    """

    def list_roles(self) -> list[Location]:
        """
        List Roles

        List all roles.

        :rtype: list[Location]
        """
        url = self.ep()
        data = super().get(url)
        r = TypeAdapter(list[Location]).validate_python(data['items'])
        return r

    def get_role_details(self, role_id: str) -> Location:
        """
        Get Role Details

        Shows details for a role, by ID.

        Specify the role ID in the `roleId` parameter in the URI.

        :param role_id: The unique identifier for the role.
        :type role_id: str
        :rtype: :class:`Location`
        """
        url = self.ep(f'{role_id}')
        data = super().get(url)
        r = Location.model_validate(data)
        return r


class RoomTabsApi(ApiChild, base='room/tabs'):
    """
    Room Tabs
    
    A Room Tab represents a URL shortcut that is added as a persistent tab to a Webex room (space) tab row. Use this
    API to list tabs of any Webex room that you belong to. Room Tabs can also be updated to point to a different
    content URL, or deleted to remove the tab from the room.
    
    Just like in the Webex app, you must be a member of the room in order to list its Room Tabs.
    """

    def list_room_tabs(self, room_id: str) -> list[RoomTab]:
        """
        List Room Tabs

        Lists all Room Tabs of a room specified by the `roomId` query parameter.

        :param room_id: ID of the room for which to list room tabs.
        :type room_id: str
        :rtype: list[RoomTab]
        """
        params = {}
        params['roomId'] = room_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[RoomTab]).validate_python(data['items'])
        return r

    def create_a_room_tab(self, room_id: str, content_url: str, display_name: str) -> RoomTab:
        """
        Create a Room Tab

        Add a tab with a specified URL to a room.

        :param room_id: A unique identifier for the room.
        :type room_id: str
        :param content_url: URL of the Room Tab. Must use `https` protocol.
        :type content_url: str
        :param display_name: User-friendly name for the room tab.
        :type display_name: str
        :rtype: :class:`RoomTab`
        """
        body = dict()
        body['roomId'] = room_id
        body['contentUrl'] = content_url
        body['displayName'] = display_name
        url = self.ep()
        data = super().post(url, json=body)
        r = RoomTab.model_validate(data)
        return r

    def get_room_tab_details(self, id: str) -> RoomTab:
        """
        Get Room Tab Details

        Get details for a Room Tab with the specified room tab ID.

        :param id: The unique identifier for the Room Tab.
        :type id: str
        :rtype: :class:`RoomTab`
        """
        url = self.ep(f'{id}')
        data = super().get(url)
        r = RoomTab.model_validate(data)
        return r

    def update_a_room_tab(self, id: str, room_id: str, content_url: str, display_name: str) -> RoomTab:
        """
        Update a Room Tab

        Updates the content URL of the specified Room Tab ID.

        :param id: The unique identifier for the Room Tab.
        :type id: str
        :param room_id: ID of the room that contains the room tab in question.
        :type room_id: str
        :param content_url: Content URL of the Room Tab. URL must use `https` protocol.
        :type content_url: str
        :param display_name: User-friendly name for the room tab.
        :type display_name: str
        :rtype: :class:`RoomTab`
        """
        body = dict()
        body['roomId'] = room_id
        body['contentUrl'] = content_url
        body['displayName'] = display_name
        url = self.ep(f'{id}')
        data = super().put(url, json=body)
        r = RoomTab.model_validate(data)
        return r

    def delete_a_room_tab(self, id: str):
        """
        Delete a Room Tab

        Deletes a Room Tab with the specified ID.

        :param id: The unique identifier for the Room Tab to delete.
        :type id: str
        :rtype: None
        """
        url = self.ep(f'{id}')
        super().delete(url)


class RoomsApi(ApiChild, base='rooms'):
    """
    Rooms
    
    Rooms are virtual meeting places where people post messages and collaborate to get work done. This API is used to
    manage the rooms themselves. Rooms are created and deleted with this API. You can also update a room to change its
    title or make it public, for example.
    
    To create a team room, specify the a `teamId` in the `POST` payload. Note that once a room is added to a team, it
    cannot be moved. To learn more about managing teams, see the `Teams API
    <https://developer.webex.com/docs/api/v1/teams>`_.
    
    To manage people in a room see the `Memberships API
    <https://developer.webex.com/docs/api/v1/memberships>`_.
    
    To post content see the `Messages API
    <https://developer.webex.com/docs/api/v1/messages>`_.
    """

    def list_rooms(self, team_id: str = None, type: ECMFolderRoomType = None, org_public_spaces: bool = None,
                   from_: Union[str, datetime] = None, to_: Union[str, datetime] = None,
                   sort_by: ListRoomsSortBy = None, **params) -> Generator[Room, None, None]:
        """
        List Rooms

        List rooms.

        The `title` of the room for 1:1 rooms will be the display name of the other person. When a Compliance Officer
        lists 1:1 rooms, the "other" person cannot be determined. This means that the room's title may not be filled
        in. Please use the `memberships API
        <https://developer.webex.com/docs/api/v1/memberships>`_ to list the people in the space.

        By default, lists rooms to which the authenticated user belongs.

        Long result sets will be split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        Known Limitations:
        The underlying database does not support natural sorting by `lastactivity` and will only sort on limited set of
        results, which are pulled from the database in order of `roomId`. For users or bots in more than 3000 spaces
        this can result in anomalies such as spaces that have had recent activity not being returned in the results
        when sorting by `lastacivity`.

        :param team_id: List rooms associated with a team, by ID. Cannot be set in combination with `orgPublicSpaces`.
        :type team_id: str
        :param type: List rooms by type. Cannot be set in combination with `orgPublicSpaces`.
        :type type: ECMFolderRoomType
        :param org_public_spaces: Shows the org's public spaces joined and unjoined. When set the result list is sorted
            by the `madePublic` timestamp.
        :type org_public_spaces: bool
        :param from_: Filters rooms, that were made public after this time. See `madePublic` timestamp
        :type from_: Union[str, datetime]
        :param to_: Filters rooms, that were made public before this time. See `maePublic` timestamp
        :type to_: Union[str, datetime]
        :param sort_by: Sort results. Cannot be set in combination with `orgPublicSpaces`.
        :type sort_by: ListRoomsSortBy
        :return: Generator yielding :class:`Room` instances
        """
        if team_id is not None:
            params['teamId'] = team_id
        if type is not None:
            params['type'] = type
        if org_public_spaces is not None:
            params['orgPublicSpaces'] = str(org_public_spaces).lower()
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if sort_by is not None:
            params['sortBy'] = sort_by
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Room, item_key='items', params=params)

    def create_a_room(self, title: str, team_id: str = None, classification_id: str = None, is_locked: str = None,
                      is_public: str = None, description: str = None, is_announcement_only: str = None) -> Room:
        """
        Create a Room

        Creates a room. The authenticated user is automatically added as a member of the room. See the `Memberships API
        <https://developer.webex.com/docs/api/v1/memberships>`_
        to learn how to add more people to the room.

        To create a 1:1 room, use the `Create Messages
        <https://developer.webex.com/docs/api/v1/messages/create-a-message>`_ endpoint to send a message directly to another person by using
        the `toPersonId` or `toPersonEmail` parameters.

        Bots are not able to create and simultaneously classify a room. A bot may update a space classification after a
        person of the same owning organization joined the space as the first human user.
        A space can only be put into announcement mode when it is locked.

        :param title: A user-friendly name for the room.
        :type title: str
        :param team_id: The ID for the team with which this room is associated.
        :type team_id: str
        :param classification_id: The `classificationId` for the room.
        :type classification_id: str
        :param is_locked: Set the space as locked/moderated and the creator becomes a moderator
        :type is_locked: str
        :param is_public: The room is public and therefore discoverable within the org. Anyone can find and join that
            room. When `true` the `description` must be filled in.
        :type is_public: str
        :param description: The description of the space.
        :type description: str
        :param is_announcement_only: Sets the space into announcement Mode.
        :type is_announcement_only: str
        :rtype: :class:`Room`
        """
        body = dict()
        body['title'] = title
        body['teamId'] = team_id
        body['classificationId'] = classification_id
        body['isLocked'] = is_locked
        body['isPublic'] = is_public
        body['description'] = description
        body['isAnnouncementOnly'] = is_announcement_only
        url = self.ep()
        data = super().post(url, json=body)
        r = Room.model_validate(data)
        return r

    def get_room_details(self, room_id: str) -> Room:
        """
        Get Room Details

        Shows details for a room, by ID.

        The `title` of the room for 1:1 rooms will be the display name of the other person.

        Specify the room ID in the `roomId` parameter in the URI.

        :param room_id: The unique identifier for the room.
        :type room_id: str
        :rtype: :class:`Room`
        """
        url = self.ep(f'{room_id}')
        data = super().get(url)
        r = Room.model_validate(data)
        return r

    def get_room_meeting_details(self, room_id: str) -> RoomMeetingDetails:
        """
        Get Room Meeting Details

        Shows Webex meeting details for a room such as the SIP address, meeting URL, toll-free and toll dial-in
        numbers.

        Specify the room ID in the `roomId` parameter in the URI.

        :param room_id: The unique identifier for the room.
        :type room_id: str
        :rtype: :class:`RoomMeetingDetails`
        """
        url = self.ep(f'{room_id}/meetingInfo')
        data = super().get(url)
        r = RoomMeetingDetails.model_validate(data)
        return r

    def update_a_room(self, room_id: str, title: str, classification_id: str = None, team_id: str = None,
                      is_locked: str = None, is_public: str = None, description: str = None,
                      is_announcement_only: str = None, is_read_only: str = None) -> Room:
        """
        Update a Room

        Updates details for a room, by ID.

        Specify the room ID in the `roomId` parameter in the URI.
        A space can only be put into announcement mode when it is locked.
        Any space participant or compliance officer can convert a space from public to private. Only a compliance
        officer can convert a space from private to public and only if the space is classified with the lowest
        category (usually `public`), and the space has a description.
        To remove a `description` please use a space character ` ` by itself.

        :param room_id: The unique identifier for the room.
        :type room_id: str
        :param title: A user-friendly name for the room.
        :type title: str
        :param classification_id: The classificationId for the room.
        :type classification_id: str
        :param team_id: The teamId to which this space should be assigned. Only unowned spaces can be assigned to a
            team. Assignment between teams is unsupported.
        :type team_id: str
        :param is_locked: Set the space as locked/moderated and the creator becomes a moderator
        :type is_locked: str
        :param is_public: The room is public and therefore discoverable within the org. Anyone can find and join that
            room. When `true` the `description` must be filled in.
        :type is_public: str
        :param description: The description of the space.
        :type description: str
        :param is_announcement_only: Sets the space into Announcement Mode or clears the Anouncement Mode (`false`)
        :type is_announcement_only: str
        :param is_read_only: A compliance officer can set a direct room as read-only, which will disallow any new
            information exchanges in this space, while maintaing historical data.
        :type is_read_only: str
        :rtype: :class:`Room`
        """
        body = dict()
        body['title'] = title
        body['classificationId'] = classification_id
        body['teamId'] = team_id
        body['isLocked'] = is_locked
        body['isPublic'] = is_public
        body['description'] = description
        body['isAnnouncementOnly'] = is_announcement_only
        body['isReadOnly'] = is_read_only
        url = self.ep(f'{room_id}')
        data = super().put(url, json=body)
        r = Room.model_validate(data)
        return r

    def delete_a_room(self, room_id: str):
        """
        Delete a Room

        Deletes a room, by ID. Deleted rooms cannot be recovered.
        As a security measure to prevent accidental deletion, when a non moderator deletes the room they are removed
        from the room instead.

        Deleting a room that is part of a team will archive the room instead.

        Specify the room ID in the `roomId` parameter in the URI.

        :param room_id: The unique identifier for the room.
        :type room_id: str
        :rtype: None
        """
        url = self.ep(f'{room_id}')
        super().delete(url)


class BulkManageSCIM2UsersAndGroupsApi(ApiChild, base='identity/scim/{orgId}/v2/Bulk'):
    """
    Bulk Manage SCIM 2 Users and Groups
    
    The bulk API allows you to create, update, and remove multiple users and groups in Webex.  The number of Bulk
    operations in a single request is limited to 100.
    """

    def user_bulk_api(self, org_id: str, schemas: list[str], fail_on_errors: int,
                      operations: list[BulkUserOperations]) -> BulkUser:
        """
        User bulk API

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        **Usage**:

        1. The input JSON must conform to the following schema: 'urn:ietf:params:scim:api:messages:2.0:BulkRequest'.

        1. The request must be accompanied with a body in JSON format according to the standard SCIM schema definition.
        The maximum number of operations in a request is 100; an error is thrown if the limit is exceeded.

        1. `failOnErrors` parameter

        An integer specifies the number of errors that the service provider will accept before the operation is
        terminated and an error response is returned.
        It is OPTIONAL in a request.
        Maximum number of operations allowed to fail before the server stops processing the request. The value must be
        between 1 and 100.

        1. `operations` parameter

        Contains a list of bulk operations for POST/PATCH/DELETE operations. (REQUIRED)
        + `operations.method`

        The HTTP method of the current operation. Possible values are POST, PATCH or DELETE.
        + `operations.path`

        The Resource's relative path. If the method is POST the value must specify a Resource type endpoint;
        e.g., /Users or /Groups whereas all other method values must specify the path to a specific Resource;
        e.g., /Users/2819c223-7f76-453a-919d-413861904646.
        + `operations.data`

        The Resource data as it would appear for a single POST or PATCH Resource operation.
        It is REQUIRED in a request when method is POST and PATCH.
        Refer to corresponding wiki for SCIM 2.0 POST, PATCH and DELETE API.
        + `operations.bulkId`

        The transient identifier of a newly created resource, unique within a bulk request and created by the client.
        The bulkId serves as a surrogate resource id enabling clients to uniquely identify newly created resources in
        the response and cross-reference new resources in and across operations within a bulk request.
        It is REQUIRED when "method" is "POST".

        :param org_id: Webex Identity assigned organization identifier for user's organization.
        :type org_id: str
        :param schemas: Input JSON schemas.
        :type schemas: list[str]
        :param fail_on_errors: An integer specifying the maximum number of errors that the service provider will accept
            before the operation is terminated and an error response is returned.
        :type fail_on_errors: int
        :param operations: Contains a list of bulk operations for POST/PATCH/DELETE operations.
        :type operations: list[BulkUserOperations]
        :rtype: :class:`BulkUser`
        """
        body = dict()
        body['schemas'] = schemas
        body['failOnErrors'] = fail_on_errors
        body['operations'] = loads(TypeAdapter(list[BulkUserOperations]).dump_json(operations))
        url = self.ep(f'')
        data = super().post(url, json=body)
        r = BulkUser.model_validate(data)
        return r


class SCIM2GroupsApi(ApiChild, base='identity/scim/{orgId}/v2/Groups'):
    """
    SCIM 2 Groups
    
    Implementation of the SCIM 2.0 group part for group management in a standards based manner. Please also see the
    `SCIM Specification
    <http://www.simplecloud.info/>`_. The schema and API design follows the standard SCIM 2.0 definition with detailed in
    `SCIM 2.0 schema
    <https://datatracker.ietf.org/doc/html/rfc7643>`_ and `SCIM 2.0 Protocol
    """

    def create_a_group(self, org_id: str, schemas: list[str], display_name: str, external_id: str,
                       members: list[GroupMemberObject],
                       urn_scim_schemas_extension_cisco_webexidentity_2_0_group: PostGroupUrnscimschemasextensionciscowebexidentity20Group) -> GetGroupResponse:
        """
        Create a group

        Create a new group for a given organization. The group may optionally be created with group members.

        <br/>

        **Authorization**

        OAuth token returned by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_group_admin`

        <br/>

        **Usage**:

        1. The input JSON must conform to one of the following schemas:
        - `urn:ietf:params:scim:schemas:core:2.0:Group`
        - `urn:scim:schemas:extension:cisco:webexidentity:2.0:Group`

        1. Unrecognized schemas (ID/section) are ignored.

        1. Read-only attributes provided as input values are ignored.

        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param schemas: Input JSON schemas.
        :type schemas: list[str]
        :param display_name: A human-readable name for the Group.
        :type display_name: str
        :param external_id: An identifier for the resource as defined by the provisioning client.
        :type external_id: str
        :param members: A list of members of this group.
        :type members: list[GroupMemberObject]
        :param urn_scim_schemas_extension_cisco_webexidentity_2_0_group: The Cisco extension of SCIM 2.
        :type urn_scim_schemas_extension_cisco_webexidentity_2_0_group: PostGroupUrnscimschemasextensionciscowebexidentity20Group
        :rtype: :class:`GetGroupResponse`
        """
        body = dict()
        body['schemas'] = schemas
        body['displayName'] = display_name
        body['externalId'] = external_id
        body['members'] = loads(TypeAdapter(list[GroupMemberObject]).dump_json(members))
        body['urn:scim:schemas:extension:cisco:webexidentity:2.0:Group'] = loads(urn_scim_schemas_extension_cisco_webexidentity_2_0_group.model_dump_json())
        url = self.ep(f'')
        data = super().post(url, json=body)
        r = GetGroupResponse.model_validate(data)
        return r

    def get_a_group(self, org_id: str, group_id: str) -> GetGroupResponse:
        """
        Get a group

        Retrieve details for a group, by ID.

        Optionally, members can be retrieved with this request. The maximum number of members returned is 500.

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `identity:people_read`

        - `Identity:SCIM`

        - `Identity:SCIM_read`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_group_admin`

        - `id_readonly_admin`

        - `id_device_admin`

        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param group_id: A unique identifier for the group.
        :type group_id: str
        :rtype: :class:`GetGroupResponse`
        """
        url = self.ep(f'{group_id}')
        data = super().get(url)
        r = GetGroupResponse.model_validate(data)
        return r

    def search_groups(self, org_id: str, filter: str = None, attributes: str = None, start_index: int = None,
                      count: int = None, include_members: bool = None, member_type: str = None, sort_by: str = None,
                      sort_order: str = None) -> SearchGroupResponse:
        """
        Search groups

        Retrieve a list of groups in the organization.

        Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        <br/>

        **Authorization**

        An OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `identity:people_read`

        - `Identity:SCIM`

        - `Identity:SCIM_read`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_group_admin`

        - `id_readonly_admin`

        - `id_device_admin`

        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param filter: The url encoded filter. The example content is 'displayName Eq "group1@example.com" or
            displayName Eq "group2@example.com"'.
        For more filter patterns, see https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2. If the value is
        empty, the API returns all groups under the organization.
        :type filter: str
        :param attributes: The attributes to return.
        :type attributes: str
        :param start_index: An integer indicating the 1-based index of the first query result. The default is 1.
        :type start_index: int
        :param count: An integer indicating the desired maximum number of query results per page. The default is 10.
        :type count: int
        :param include_members: Default "false". If false, no members returned.
        :type include_members: bool
        :param member_type: Filter the members by member type. Sample data: `user`, `machine`, `group`.
        :type member_type: str
        :param sort_by: A string indicating the attribute whose value be used to order the returned responses. Now we
            only allow `displayName, id, meta.lastModified` to sort.
        :type sort_by: str
        :param sort_order: A string indicating the order in which the `sortBy` parameter is applied. Allowed values are
            `ascending` and `descending`.
        :type sort_order: str
        :rtype: :class:`SearchGroupResponse`
        """
        params = {}
        if filter is not None:
            params['filter'] = filter
        if attributes is not None:
            params['attributes'] = attributes
        if start_index is not None:
            params['startIndex'] = start_index
        if count is not None:
            params['count'] = count
        if include_members is not None:
            params['includeMembers'] = str(include_members).lower()
        if member_type is not None:
            params['memberType'] = member_type
        if sort_by is not None:
            params['sortBy'] = sort_by
        if sort_order is not None:
            params['sortOrder'] = sort_order
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = SearchGroupResponse.model_validate(data)
        return r

    def get_group_members(self, org_id: str, group_id: str, start_index: int = None, count: int = None,
                          member_type: str = None) -> GroupMemberResponse:
        """
        Get Group Members

        Returns the members of a group.

        - The default maximum number of members returned is 500.

        - Control parameters are available to page through the members and to control the size of the results.

        - Long result sets are split into `pages
        <https://developer.webex.com/docs/basics#pagination>`_.

        <br/>

        **Authorization**

        OAuth token returned by the Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `identity:people_read`

        - `Identity:SCIM`

        - `Identity:SCIM_read`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_group_admin`

        - `id_readonly_admin`

        - `id_device_admin`

        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param start_index: The index to start for group pagination.
        :type start_index: int
        :param count: Non-negative integer that specifies the desired number of search results per page. The maximum
            value for the count is 500.
        :type count: int
        :param member_type: Filter the members by member type. Sample data: `user`, `machine`, `group`.
        :type member_type: str
        :rtype: :class:`GroupMemberResponse`
        """
        params = {}
        if start_index is not None:
            params['startIndex'] = start_index
        if count is not None:
            params['count'] = count
        if member_type is not None:
            params['memberType'] = member_type
        url = self.ep(f'{group_id}/Members')
        data = super().get(url, params=params)
        r = GroupMemberResponse.model_validate(data)
        return r

    def update_a_group_with_put(self, org_id: str, group_id: str, schemas: list[str], display_name: str,
                                external_id: str, members: list[GroupMemberObject],
                                urn_scim_schemas_extension_cisco_webexidentity_2_0_group: PostGroupUrnscimschemasextensionciscowebexidentity20Group) -> GetGroupResponse:
        """
        Update a group with PUT

        Replace the contents of the Group.

        Specify the group ID in the `groupId` parameter in the URI.

        <br/>

        **Authorization**

        OAuth token returned by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_group_admin`

        <br/>

        **Usage**:

        1. The input JSON must conform to one of the following schemas:
        - `urn:ietf:params:scim:schemas:core:2.0:Group`
        - `urn:scim:schemas:extension:cisco:webexidentity:2.0:Group`

        1. Unrecognized schemas (ID/section) are ignored.

        1. Read-only attributes provided as input values are ignored.

        1. The group `id` is not changed.

        1. All attributes are cleaned up if a new value is not provided by the client.

        1. The values, `meta` and `created` are not changed.

        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param schemas: Input JSON schemas.
        :type schemas: list[str]
        :param display_name: A human-readable name for the group.
        :type display_name: str
        :param external_id: An identifier for the resource as defined by the provisioning client.
        :type external_id: str
        :param members: A list of members of this group.
        :type members: list[GroupMemberObject]
        :param urn_scim_schemas_extension_cisco_webexidentity_2_0_group: The Cisco extension of SCIM 2.
        :type urn_scim_schemas_extension_cisco_webexidentity_2_0_group: PostGroupUrnscimschemasextensionciscowebexidentity20Group
        :rtype: :class:`GetGroupResponse`
        """
        body = dict()
        body['schemas'] = schemas
        body['displayName'] = display_name
        body['externalId'] = external_id
        body['members'] = loads(TypeAdapter(list[GroupMemberObject]).dump_json(members))
        body['urn:scim:schemas:extension:cisco:webexidentity:2.0:Group'] = loads(urn_scim_schemas_extension_cisco_webexidentity_2_0_group.model_dump_json())
        url = self.ep(f'{group_id}')
        data = super().put(url, json=body)
        r = GetGroupResponse.model_validate(data)
        return r

    def update_a_group_with_patch(self, org_id: str, group_id: str, schemas: list[str],
                                  operations: list[PatchGroupOperations]) -> GetGroupResponse:
        """
        Update a group with PATCH

        Update group attributes with PATCH.

        Specify the group ID in the `groupId` parameter in the URI.

        <br/>

        **Authorization**

        OAuth token returned by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_group_admin`

        <br/>

        **Usage**:

        1. The input JSON must conform to one of the following schemas:
        - `urn:ietf:params:scim:schemas:core:2.0:Group`
        - `urn:scim:schemas:extension:cisco:webexidentity:2.0:Group`

        1. Unrecognized schemas (ID/section) are ignored.

        1. Read-only attributes provided as input values are ignored.

        1. Each operation on an attribute must be compatible with the attribute's mutability.

        1. Each PATCH operation represents a single action to be applied to the
        same SCIM resource specified by the request URI. Operations are
        applied sequentially in the order they appear in the array. Each
        operation in the sequence is applied to the target resource; the
        resulting resource becomes the target of the next operation.
        Evaluation continues until all operations are successfully applied or
        until an error condition is encountered.

        <br/>

        **Add operations**:

        The `add` operation is used to add a new attribute value to an existing resource. The operation must contain a
        `value` member whose content specifies the value to be added. The value may be a quoted value, or it may be a
        JSON object containing the sub-attributes of the complex attribute specified in the operation's `path`. The
        result of the add operation depends upon the target location indicated by `path` references:

        <br/>

        - If omitted, the target location is assumed to be the resource itself. The `value` parameter contains a set of
        attributes to be added to the resource.

        - If the target location does not exist, the attribute and value are added.

        - If the target location specifies a complex attribute, a set of sub-attributes shall be specified in the
        `value` parameter.

        - If the target location specifies a multi-valued attribute, a new value is added to the attribute.

        - If the target location specifies a single-valued attribute, the existing value is replaced.

        - If the target location specifies an attribute that does not exist (has no value), the attribute is added with
        the new value.

        - If the target location exists, the value is replaced.

        - If the target location already contains the value specified, no changes should be made to the resource.

        <br/>

        **Replace operations**:

        The `replace` operation replaces the value at the target location specified by the `path`. The operation
        performs the following functions, depending on the target location specified by `path`:

        <br/>

        - If the `path` parameter is omitted, the target is assumed to be the resource itself. In this case, the
        `value` attribute shall contain a list of one or more attributes that are to be replaced.

        - If the target location is a single-value attribute, the value of the attribute is replaced.

        - If the target location is a multi-valued attribute and no filter is specified, the attribute and all values
        are replaced.

        - If the target location path specifies an attribute that does not exist, the service provider shall treat the
        operation as an "add".

        - If the target location specifies a complex attribute, a set of sub-attributes SHALL be specified in the
        `value` parameter, which replaces any existing values or adds where an attribute did not previously exist.
        Sub-attributes that are not specified in the `value` parameters are left unchanged.

        - If the target location is a multi-valued attribute and a value selection ("valuePath") filter is specified
        that matches one or more values of the multi-valued attribute, then all matching record values will be
        replaced.

        - If the target location is a complex multi-valued attribute with a value selection filter ("valuePath") and a
        specific sub-attribute (e.g., "addresses[type eq "work"].streetAddress"), the matching sub-attribute of all
        matching records is replaced.

        - If the target location is a multi-valued attribute for which a value selection filter ("valuePath") has been
        supplied and no record match was made, the service provider will indicate the failure by returning HTTP status
        code 400 and a `scimType` error code of `noTarget`.

        <br/>

        **Remove operations**:

        The `remove` operation removes the value at the target location specified by the required attribute `path`. The
        operation performs the following functions, depending on the target location specified by `path`:

        <br/>

        - If `path` is unspecified, the operation fails with HTTP status code 400 and a "scimType" error code of
        "noTarget".

        - If the target location is a single-value attribute, the attribute and its associated value is removed, and
        the attribute will be considered unassigned.

        - If the target location is a multi-valued attribute and no filter is specified, the attribute and all values
        are removed, and the attribute SHALL be considered unassigned.

        - If the target location is a multi-valued attribute and a complex filter is specified comparing a `value`, the
        values matched by the filter are removed. If no other values remain after the removal of the selected values,
        the multi-valued attribute will be considered unassigned.

        - If the target location is a complex multi-valued attribute and a complex filter is specified based on the
        attribute`s sub-attributes, the matching records are removed. Sub-attributes whose values have been removed
        will be considered unassigned. If the complex multi-valued attribute has no remaining records, the attribute
        will be considered unassigned.

        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param group_id: A unique identifier for the group.
        :type group_id: str
        :param schemas: Input JSON schemas.
        :type schemas: list[str]
        :param operations: A list of patch operations.
        :type operations: list[PatchGroupOperations]
        :rtype: :class:`GetGroupResponse`
        """
        body = dict()
        body['schemas'] = schemas
        body['Operations'] = loads(TypeAdapter(list[PatchGroupOperations]).dump_json(operations))
        url = self.ep(f'{group_id}')
        data = super().patch(url, json=body)
        r = GetGroupResponse.model_validate(data)
        return r

    def delete_a_group(self, org_id: str, group_id: str):
        """
        Delete a group

        Remove a group from the system.

        Specify the group ID in the `groupId` parameter in the URI.

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_group_admin`

        :param org_id: The ID of the organization to which this group belongs. If not specified, the organization ID
            from the OAuth token is used.
        :type org_id: str
        :param group_id: A unique identifier for the group.
        :type group_id: str
        :rtype: None
        """
        url = self.ep(f'{group_id}')
        super().delete(url)


class SCIM2UsersApi(ApiChild, base='identity/scim/{orgId}/v2/Users'):
    """
    SCIM 2 Users
    
    Implementation of the SCIM 2.0 user part for user management in a standards based manner. Please also see the
    `SCIM Specification
    <http://www.simplecloud.info/>`_. The schema and API design follows the standard SCIM 2.0 definition with detailed in
    `SCIM 2.0 schema
    <https://datatracker.ietf.org/doc/html/rfc7643>`_ and `SCIM 2.0 Protocol
    """

    def create_a_user(self, org_id: str, schemas: list[str], user_name: str, user_type: UserTypeObject, title: str,
                      active: bool, preferred_language: str, locale: str, timezone: str, profile_url: str,
                      external_id: str, display_name: str, nick_name: str, name: NameObject,
                      phone_numbers: list[PutUserPhoneNumbers], photos: list[PhotoObject],
                      addresses: list[PersonAddresses], emails: list[EmailObject],
                      urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: PostUserUrnietfparamsscimschemasextensionenterprise20User,
                      urn_scim_schemas_extension_cisco_webexidentity_2_0_user: PostUserUrnscimschemasextensionciscowebexidentity20User) -> GetUserResponse:
        """
        Create a user

        The SCIM 2 /Users API provides a programmatic way to manage users in Webex Identity using The Internet
        Engineering Task Force standard SCIM 2.0 standard as specified by `RFC 7643 SCIM 2.0 Core Schema 
        <https://datatracker.ietf.org/doc/html/rfc7643>`_ and
        `RFC 7644 SCIM 2.0 Core Protocol
        <https://datatracker.ietf.org/doc/html/rfc7644>`_.  The WebEx SCIM 2.0  APIs allow clients supporting the SCIM 2.0 standard to
        manage users, and groups within Webex.  Webex supports the following SCIM 2.0 Schemas:

         urn:ietf:params:scim:schemas:core:2.0:User

         urn:ietf:params:scim:schemas:extension:enterprise:2.0:User

         urn:scim:schemas:extension:cisco:webexidentity:2.0:User

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_user_admin`

        <br/>

        **Usage**:

        1. Input JSON must contain schema: "urn:ietf:params:scim:schemas:core:2.0:User".

        1. Support 3 schemas :
        - "urn:ietf:params:scim:schemas:core:2.0:User"
        - "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User"
        - "urn:scim:schemas:extension:cisco:webexidentity:2.0:User"

        1. Unrecognized schemas (ID/section) are ignored.

        1. Read-only attributes provided as input values are ignored.

        :param org_id: Webex Identity assigned organization identifier for user's organization.
        :type org_id: str
        :param schemas: Input JSON schemas.
        :type schemas: list[str]
        :param user_name: A unique identifier for the user and is used to authenticate the user in Webex.  This
            attribute must be set to the user's primary email address.  No other user in Webex may have the same
            userName value and thus this value is required to be unique within Webex.
        :type user_name: str
        :param user_type: The type of the user.
        :type user_type: UserTypeObject
        :param title: The user's business title.  Examples of a title is "Business Manager". "Senior Accountant",
            "Engineer" etc.
        :type title: str
        :param active: A boolean value of "true" or "false" indicating whether the user is active in Webex.
        :type active: bool
        :param preferred_language: Indicates the user's preferred language.  Acceptable values for this field are based
            on the `ISO-696
            <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
            code.  Examples are:

        en_US : for english spoken in the United Statesfr_FR: for french spoken in France.
        :type preferred_language: str
        :param locale: The user's locale which is used to represent the user's currency, time format, and numerical
            representations.  Acceptable values for this field are based on the `ISO-696
            <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
            language code followed by an _ and then the 2 letter country code.  Examples are:

        en_US : for English spoken in the United States or fr_FR: for French spoken in France.
        :type locale: str
        :param timezone: The user's time zone specified in the `IANA timezone
            <https://nodatime.org/timezones>`_ timezone format, for example,
            "America/Los_Angeles".
        :type timezone: str
        :param profile_url: A fully qualified URL pointing to a page representing the user's online profile.
        :type profile_url: str
        :param external_id: External identity.
        :type external_id: str
        :param display_name: The value to display or show the user's name in Webex.
        :type display_name: str
        :param nick_name: A casual name of the user.  The value Bob when the user's formal name is Robert.
        :type nick_name: str
        :param name: The components of the user's real name.
        :type name: NameObject
        :param phone_numbers: A list of user's phone numbers with an indicator of primary to specify the user's main
            number.
        :type phone_numbers: list[PutUserPhoneNumbers]
        :param photos: A list of photos for the user that represent a thing the user has.
        :type photos: list[PhotoObject]
        :param addresses: User's physical mailing address.
        :type addresses: list[PersonAddresses]
        :param emails: A list of the user's email addresses with an indicator of the user's primary email address.  The
            primary email address must be the same value as the user's userName.
        :type emails: list[EmailObject]
        :param urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: SCIM2 enterprise extension
        :type urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: PostUserUrnietfparamsscimschemasextensionenterprise20User
        :param urn_scim_schemas_extension_cisco_webexidentity_2_0_user: The Cisco extension of SCIM 2.
        :type urn_scim_schemas_extension_cisco_webexidentity_2_0_user: PostUserUrnscimschemasextensionciscowebexidentity20User
        :rtype: :class:`GetUserResponse`
        """
        body = dict()
        body['schemas'] = schemas
        body['userName'] = user_name
        body['userType'] = enum_str(user_type)
        body['title'] = title
        body['active'] = active
        body['preferredLanguage'] = preferred_language
        body['locale'] = locale
        body['timezone'] = timezone
        body['profileUrl'] = profile_url
        body['externalId'] = external_id
        body['displayName'] = display_name
        body['nickName'] = nick_name
        body['name'] = loads(name.model_dump_json())
        body['phoneNumbers'] = loads(TypeAdapter(list[PutUserPhoneNumbers]).dump_json(phone_numbers))
        body['photos'] = loads(TypeAdapter(list[PhotoObject]).dump_json(photos))
        body['addresses'] = loads(TypeAdapter(list[PersonAddresses]).dump_json(addresses))
        body['emails'] = loads(TypeAdapter(list[EmailObject]).dump_json(emails))
        body['urn:ietf:params:scim:schemas:extension:enterprise:2.0:User'] = loads(urn_ietf_params_scim_schemas_extension_enterprise_2_0_user.model_dump_json())
        body['urn:scim:schemas:extension:cisco:webexidentity:2.0:User'] = loads(urn_scim_schemas_extension_cisco_webexidentity_2_0_user.model_dump_json())
        url = self.ep(f'')
        data = super().post(url, json=body)
        r = GetUserResponse.model_validate(data)
        return r

    def get_a_user(self, org_id: str, user_id: str) -> GetUserResponse:
        """
        Get a user

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `identity:people_read`

        - `Identity:SCIM`

        - `Identity:SCIM_read`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_user_admin`

        - `id_readonly_admin`

        - `id_device_admin`

        <br/>

        :param org_id: Webex Identity assigned organization identifier for user's organization.
        :type org_id: str
        :param user_id: Webex Identity assigned user identifier.
        :type user_id: str
        :rtype: :class:`GetUserResponse`
        """
        url = self.ep(f'{user_id}')
        data = super().get(url)
        r = GetUserResponse.model_validate(data)
        return r

    def search_users(self, org_id: str, filter: str = None, attributes: str = None, excluded_attributes: str = None,
                     sort_by: str = None, sort_order: str = None, start_index: Union[str, datetime] = None,
                     count: Union[str, datetime] = None, return_groups: str = None, include_group_details: str = None,
                     group_usage_types: str = None) -> SearchUserResponse:
        """
        Search users

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `identity:people_read`

        - `Identity:SCIM`

        - `Identity:SCIM_read`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_user_admin`

        - `id_readonly_admin`

        - `id_device_admin`

        <br/>

        :param org_id: Webex Identity assigned organization identifier for user's organization.
        :type org_id: str
        :param filter: The url encoded filter. If the value is empty, the API will return all users under the
            organization.

        The examples below show some search filters:

        - userName eq "user1@example.com"

        - userName sw "user1@example"

        - userName ew "example"

        - phoneNumbers [ type eq "mobile" and value eq "14170120"]

        - urn:scim:schemas:extension:cisco:webexidentity:2.0:User:meta.organizationId eq
        "0ae87ade-8c8a-4952-af08-318798958d0c"

        - More filter patterns, please check <a href="https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2">
        filtering </a>.
        :type filter: str
        :param attributes: A multi-valued list of strings indicating the names of resource attributes to return in the
            response, likes 'userName,department,emails'. It supports the SCIM id
            'urn:ietf:params:scim:schemas:extension:enterprise:2.0:User,userName'. The default is empty, all
            attributes will be returned
        :type attributes: str
        :param excluded_attributes: A multi-valued list of strings indicating the names of resource attributes to be
            removed from the default set of attributes to return. The default is empty, all attributes will be
            returned
        :type excluded_attributes: str
        :param sort_by: A string indicating the attribute whose value be used to order the returned responses. Now we
            only allow 'userName, id, meta.lastModified' to sort.
        :type sort_by: str
        :param sort_order: A string indicating the order in which the 'sortBy' parameter is applied. Allowed values are
            'ascending' and 'descending'.
        :type sort_order: str
        :param start_index: An integer indicating the 1-based index of the first query result. The default is 1.
        :type start_index: Union[str, datetime]
        :param count: An integer indicating the desired maximum number of query results per page.  The default is 10.
        :type count: Union[str, datetime]
        :param return_groups: Define whether the group information needs to be returned.  The default is false.
        :type return_groups: str
        :param include_group_details: Define whether the group information with details need been returned. The default
            is false.
        :type include_group_details: str
        :param group_usage_types: Returns groups with details of the specified group type
        :type group_usage_types: str
        :rtype: :class:`SearchUserResponse`
        """
        params = {}
        if filter is not None:
            params['filter'] = filter
        if attributes is not None:
            params['attributes'] = attributes
        if excluded_attributes is not None:
            params['excludedAttributes'] = excluded_attributes
        if sort_by is not None:
            params['sortBy'] = sort_by
        if sort_order is not None:
            params['sortOrder'] = sort_order
        if start_index is not None:
            if isinstance(start_index, str):
                start_index = isoparse(start_index)
            start_index = dt_iso_str(start_index)
            params['startIndex'] = start_index
        if count is not None:
            if isinstance(count, str):
                count = isoparse(count)
            count = dt_iso_str(count)
            params['count'] = count
        if return_groups is not None:
            params['returnGroups'] = return_groups
        if include_group_details is not None:
            params['includeGroupDetails'] = include_group_details
        if group_usage_types is not None:
            params['groupUsageTypes'] = group_usage_types
        url = self.ep(f'')
        data = super().get(url, params=params)
        r = SearchUserResponse.model_validate(data)
        return r

    def update_a_user_with_put(self, org_id: str, user_id: str, schemas: list[str], user_name: str,
                               user_type: UserTypeObject, title: str, active: bool, preferred_language: str,
                               locale: str, timezone: str, profile_url: str, external_id: str, display_name: str,
                               nick_name: str, phone_numbers: list[PutUserPhoneNumbers], photos: list[PhotoObject],
                               addresses: list[PersonAddresses], emails: list[EmailObject],
                               urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: PostUserUrnietfparamsscimschemasextensionenterprise20User,
                               urn_scim_schemas_extension_cisco_webexidentity_2_0_user: PostUserUrnscimschemasextensionciscowebexidentity20User) -> GetUserResponse:
        """
        Update a user with PUT

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_user_admin`

        <br/>

        **Usage**:

        1. Input JSON must contain schema: "urn:ietf:params:scim:schemas:core:2.0:User".

        1. Support 3 schemas :
        - "urn:ietf:params:scim:schemas:core:2.0:User"
        - "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User"
        - "urn:scim:schemas:extension:cisco:webexidentity:2.0:User"

        1. Unrecognized schemas (ID/section) are ignored.

        1. Read-only attributes provided as input values are ignored.

        1. User `id` will not be changed.

        1. `meta`.`created` will not be changed.

        1. The PUT API replaces the contents of the user's data with the data in the request body.  All attributes
        specified in the request body will replace all existing attributes for the userId specified in the URL.
        Should you wish to replace or change some attributes as opposed to all attributes please refer to the SCIM
        PATCH operation https://developer.webex.com/docs/api/v1/scim2-user/update-a-user-with-patch .

        :param org_id: Webex Identity assigned organization identifier for user's organization.
        :type org_id: str
        :param user_id: Webex Identity assigned user identifier.
        :type user_id: str
        :param schemas: Input JSON schemas.
        :type schemas: list[str]
        :param user_name: A unique identifier for the user and is used to authenticate the user in Webex.  This
            attribute must be set to the user's primary email address.  No other user in Webex may have the same
            userName value and thus this value is required to b unique within Webex.
        :type user_name: str
        :param user_type: The type of the user.
        :type user_type: UserTypeObject
        :param title: The user's business title.  Examples of a title is "Business Manager". "Senior Accountant",
            "Engineer" etc.
        :type title: str
        :param active: A boolean value of "true" or "false" indicating whether the user is active in Webex.
        :type active: bool
        :param preferred_language: Indicates the user's preferred language.  Acceptable values for this field are based
            on the `ISO-696
            <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
            code.  Examples are:

        en_US : for english spoken in the United States, fr_FR: for french spoken in France.
        :type preferred_language: str
        :param locale: The user's locale which is used to represent the user's currency, time format, and numerical
            representations.  Acceptable values for this field are based on the  `ISO-696
            <http://www.loc.gov/standards/iso639-2/php/code_list.php>`_ and `ISO-3166
            letter language code followed by an _ and then the 2 letter country code.  Examples are:

        en_US : for English spoken in the United States, or fr_FR: for French spoken in France.
        :type locale: str
        :param timezone: The user's time zone specified in the `IANA timezone
            <https://nodatime.org/timezones>`_ timezone format. e.g:
            "America/Los_Angeles".
        :type timezone: str
        :param profile_url: A fully qualified URL pointing to a page representing the user's online profile.
        :type profile_url: str
        :param external_id: External identity.
        :type external_id: str
        :param display_name: The value to display or show the user's name in Webex.
        :type display_name: str
        :param nick_name: A casual name of the user.  The value Bob when the user's formal name is Robert.
        :type nick_name: str
        :param phone_numbers: A list of user's phone numbers with an indicator of primary to specify the users main
            number.
        :type phone_numbers: list[PutUserPhoneNumbers]
        :param photos: A list of photos for the user that represent a thing the user has.
        :type photos: list[PhotoObject]
        :param addresses: A physical mailing address of user.
        :type addresses: list[PersonAddresses]
        :param emails: A list of the user's email addresses with an indicator of the user's primary email address.  The
            primary email address must be the same value as the user's userName.
        :type emails: list[EmailObject]
        :param urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: SCIM2 enterprise extention
        :type urn_ietf_params_scim_schemas_extension_enterprise_2_0_user: PostUserUrnietfparamsscimschemasextensionenterprise20User
        :param urn_scim_schemas_extension_cisco_webexidentity_2_0_user: cisco extention of SCIM 2
        :type urn_scim_schemas_extension_cisco_webexidentity_2_0_user: PostUserUrnscimschemasextensionciscowebexidentity20User
        :rtype: :class:`GetUserResponse`
        """
        body = dict()
        body['schemas'] = schemas
        body['userName'] = user_name
        body['userType'] = enum_str(user_type)
        body['title'] = title
        body['active'] = active
        body['preferredLanguage'] = preferred_language
        body['locale'] = locale
        body['timezone'] = timezone
        body['profileUrl'] = profile_url
        body['externalId'] = external_id
        body['displayName'] = display_name
        body['nickName'] = nick_name
        body['phoneNumbers'] = loads(TypeAdapter(list[PutUserPhoneNumbers]).dump_json(phone_numbers))
        body['photos'] = loads(TypeAdapter(list[PhotoObject]).dump_json(photos))
        body['addresses'] = loads(TypeAdapter(list[PersonAddresses]).dump_json(addresses))
        body['emails'] = loads(TypeAdapter(list[EmailObject]).dump_json(emails))
        body['urn:ietf:params:scim:schemas:extension:enterprise:2.0:User'] = loads(urn_ietf_params_scim_schemas_extension_enterprise_2_0_user.model_dump_json())
        body['urn:scim:schemas:extension:cisco:webexidentity:2.0:User'] = loads(urn_scim_schemas_extension_cisco_webexidentity_2_0_user.model_dump_json())
        url = self.ep(f'{user_id}')
        data = super().put(url, json=body)
        r = GetUserResponse.model_validate(data)
        return r

    def update_a_user_with_patch(self, org_id: str, user_id: str, schemas: list[str],
                                 operations: list[PatchGroupOperations]) -> GetUserResponse:
        """
        Update a user with PATCH

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_user_admin`

        <br/>

        **Usage**:

        1. The PATCH API replaces individual attributes of the user's data in the request body.
        The PATCH api supports `add`, `remove` and `replace` operations on any individual
        attribute allowing only specific attributes of the user's object to be modified.

        1. Each operation against an attribute must be compatible with the attribute's mutability.

        1. Each PATCH operation represents a single action to be applied to the
        same SCIM resource specified by the request URI.  Operations are
        applied sequentially in the order they appear in the array.  Each
        operation in the sequence is applied to the target resource; the
        resulting resource becomes the target of the next operation.
        Evaluation continues until all operations are successfully applied or
        until an error condition is encountered.

        <br/>

        **Add operations**:

        The `add` operation is used to add a new attribute value to an existing resource.
        The operation must contain a `value` member whose content specifies the value to be added.
        The value may be a quoted value, or it may be a JSON object containing the sub-attributes of the complex
        attribute specified in the operation's `path`.
        The result of the add operation depends upon the target location indicated by `path` references:

        <br/>

        - If omitted, the target location is assumed to be the resource itself.  The `value` parameter contains a set
        of attributes to be added to the resource.

        - If the target location does not exist, the attribute and value are added.

        - If the target location specifies a complex attribute, a set of sub-attributes shall be specified in the
        `value` parameter.

        - If the target location specifies a multi-valued attribute, a new value is added to the attribute.

        - If the target location specifies a single-valued attribute, the existing value is replaced.

        - If the target location specifies an attribute that does not exist (has no value), the attribute is added with
        the new value.

        - If the target location exists, the value is replaced.

        - If the target location already contains the value specified, no changes should be made to the resource.

        <br/>

        **Replace operations**:

        The `replace` operation replaces the value at the target location specified by the `path`.
        The operation performs the following functions, depending on the target location specified by `path`:

        <br/>

        - If the `path` parameter is omitted, the target is assumed to be the resource itself.  In this case, the
        `value` attribute shall contain a list of one or more attributes that are to be replaced.

        - If the target location is a single-value attribute, the value of the attribute is replaced.

        - If the target location is a multi-valued attribute and no filter is specified, the attribute and all values
        are replaced.

        - If the target location path specifies an attribute that does not exist, the service provider shall treat the
        operation as an "add".

        - If the target location specifies a complex attribute, a set of sub-attributes SHALL be specified in the
        `value` parameter, which replaces any existing values or adds where an attribute did not previously exist.
        Sub-attributes that are not specified in the `value` parameters are left unchanged.

        - If the target location is a multi-valued attribute and a value selection ("valuePath") filter is specified
        that matches one or more values of the multi-valued attribute, then all matching record values will be
        replaced.

        - If the target location is a complex multi-valued attribute with a value selection filter ("valuePath") and a
        specific sub-attribute (e.g., "addresses[type eq "work"].streetAddress"), the matching sub-attribute of all
        matching records is replaced.

        - If the target location is a multi-valued attribute for which a value selection filter ("valuePath") has been
        supplied and no record match was made, the service provider will indicate the failure by returning HTTP status
        code 400 and a `scimType` error code of "noTarget".

        <br/>

        **Remove operations**:

        The `remove` operation removes the value at the target location specified by the required attribute `path`.
        The operation performs the following functions, depending on the target location specified by `path`:

        <br/>

        - If `path` is unspecified, the operation fails with HTTP status code 400 and a "scimType" error code of
        "noTarget".

        - If the target location is a single-value attribute, the attribute and its associated value is removed, and
        the attribute will be considered unassigned.

        - If the target location is a multi-valued attribute and no filter is specified, the attribute and all values
        are removed, and the attribute SHALL be considered unassigned.

        - If the target location is a multi-valued attribute and a complex filter is specified comparing a `value`, the
        values matched by the filter are removed.  If no other values remain after the removal of the selected values,
        the multi-valued attribute will be considered unassigned.

        - If the target location is a complex multi-valued attribute and a complex filter is specified based on the
        attribute's sub-attributes, the matching records are removed.  Sub-attributes whose values have been removed
        will be considered unassigned.  If the complex multi-valued attribute has no remaining records, the attribute
        will be considered unassigned.

        :param org_id: Webex Identity assigned organization identifier for user's organization.
        :type org_id: str
        :param user_id: Webex Identity assigned user identifier.
        :type user_id: str
        :param schemas: Input JSON schemas.
        :type schemas: list[str]
        :param operations: A list of patch operations.
        :type operations: list[PatchGroupOperations]
        :rtype: :class:`GetUserResponse`
        """
        body = dict()
        body['schemas'] = schemas
        body['Operations'] = loads(TypeAdapter(list[PatchGroupOperations]).dump_json(operations))
        url = self.ep(f'{user_id}')
        data = super().patch(url, json=body)
        r = GetUserResponse.model_validate(data)
        return r

    def delete_a_user(self, org_id: str, user_id: str):
        """
        Delete a user

        <br/>

        **Authorization**

        OAuth token rendered by Identity Broker.

        <br/>

        One of the following OAuth scopes is required:

        - `identity:people_rw`

        - `Identity:SCIM`

        <br/>

        The following administrators can use this API:

        - `id_full_admin`

        - `id_user_admin`

        <br/>

        :param org_id: Webex Identity assigned organization identifier for user's organization.
        :type org_id: str
        :param user_id: Webex Identity assigned user identifier.
        :type user_id: str
        :rtype: None
        """
        url = self.ep(f'{user_id}')
        super().delete(url)


class SecurityAuditEventsApi(ApiChild, base='admin/securityAudit/events'):
    """
    Security Audit Events
    
    """

    def list_security_audit_events(self, org_id: str, start_time: Union[str, datetime], end_time: Union[str, datetime],
                                   actor_id: str = None, event_categories: list[str] = None,
                                   **params) -> Generator[SecurityAuditEvent, None, None]:
        """
        List Security Audit Events

        List Security Audit Events. This API currently returns user sign-in and sign-out data.
        To call this API the `audit:events_read` scope must be selected for the Integration or Service App and
        auhtorized by a Full Admin.

        Several query parameters are available to filter the response.

        Long result sets will be split into multiple `pages
        <https://developer.webex.com/docs/basics#pagination>`_

        **NOTE**: A maximum of one year of audit events can be returned per request.

        :param org_id: List events in this organization, by ID.
        :type org_id: str
        :param start_time: List events which occurred after a specific date and time.
        :type start_time: Union[str, datetime]
        :param end_time: List events which occurred before a specific date and time.
        :type end_time: Union[str, datetime]
        :param actor_id: List events performed by this person, by ID.
        :type actor_id: str
        :param event_categories: List events, by event categories.
        :type event_categories: list[str]
        :return: Generator yielding :class:`SecurityAuditEvent` instances
        """
        params['orgId'] = org_id
        if isinstance(start_time, str):
            start_time = isoparse(start_time)
        start_time = dt_iso_str(start_time)
        params['startTime'] = start_time
        if isinstance(end_time, str):
            end_time = isoparse(end_time)
        end_time = dt_iso_str(end_time)
        params['endTime'] = end_time
        if actor_id is not None:
            params['actorId'] = actor_id
        if event_categories is not None:
            params['eventCategories'] = ','.join(event_categories)
        url = self.ep()
        return self.session.follow_pagination(url=url, model=SecurityAuditEvent, item_key='items', params=params)


class SiteApi(ApiChild, base='admin/meeting/config/commonSettings'):
    """
    Site
    
    This chapter provides descriptions of the Webex RESTful APIs for the site service, which contains operations like
    querying and updating common meeting configuration settings.
    
    Samples are given for the outbound request messages and expected server response messages. The API calls available
    as part of the Site service are listed below.
    
    You can see the elements that constitute the respective RESTful schema in a separate section below.
    """

    def get_meeting_common_settings_configuration(self,
                                                  site_url: str = None) -> GetMeetingConfigurationCommonSettingObject:
        """
        Get Meeting Common Settings Configuration

        Site administrators can use this API to get a list of functions, options, and privileges that are configured
        for their Webex service sites.

        * If `siteUrl` is specified, common settings of the meeting's configuration of the specified site will be
        queried; otherwise, the API will query from the site administrator's preferred site. All available Webex sites
        and preferred site of the user can be retrieved by `Get Site List
        <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.

        :param site_url: URL of the Webex site which the API queries common settings of the meeting's configuration
            from. If not specified, the API will query from the site administrator's preferred site. All available
            Webex sites and the preferred site of the user can be retrieved by the `Get Site List
            <https://developer.webex.com/docs/api/v1/meeting-preferences/get-site-list>`_ API.
        :type site_url: str
        :rtype: :class:`GetMeetingConfigurationCommonSettingObject`
        """
        params = {}
        if site_url is not None:
            params['siteUrl'] = site_url
        url = self.ep()
        data = super().get(url, params=params)
        r = GetMeetingConfigurationCommonSettingObject.model_validate(data)
        return r

    def update_meeting_common_settings_configuration(self,
                                                     site_options: GetMeetingConfigurationCommonSettingObjectSiteOptions,
                                                     default_scheduler_options: GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptions,
                                                     schedule_meeting_options: GetMeetingConfigurationCommonSettingObjectScheduleMeetingOptions,
                                                     security_options: GetMeetingConfigurationCommonSettingObjectSecurityOptions) -> GetMeetingConfigurationCommonSettingObject:
        """
        Update Meeting Common Settings Configuration

        Site administrators can use this API to update the option of features, options and privileges that are
        configured for their WebEx service sites.

        :param site_options: Site Options on Webex Administration.
        :type site_options: GetMeetingConfigurationCommonSettingObjectSiteOptions
        :param default_scheduler_options: Default Scheduler Options on Webex Administration (These options are applied
            to the site as defaults, but individual users can change them).
        :type default_scheduler_options: GetMeetingConfigurationCommonSettingObjectDefaultSchedulerOptions
        :param schedule_meeting_options: Schedule Meeting Options on Webex Administration.
        :type schedule_meeting_options: GetMeetingConfigurationCommonSettingObjectScheduleMeetingOptions
        :param security_options: Security Options on Webex Administration.
        :type security_options: GetMeetingConfigurationCommonSettingObjectSecurityOptions
        :rtype: :class:`GetMeetingConfigurationCommonSettingObject`
        """
        body = dict()
        body['siteOptions'] = loads(site_options.model_dump_json())
        body['defaultSchedulerOptions'] = loads(default_scheduler_options.model_dump_json())
        body['scheduleMeetingOptions'] = loads(schedule_meeting_options.model_dump_json())
        body['securityOptions'] = loads(security_options.model_dump_json())
        url = self.ep()
        data = super().patch(url, json=body)
        r = GetMeetingConfigurationCommonSettingObject.model_validate(data)
        return r


class PartnerTagsApi(ApiChild, base='partner/tags'):
    """
    Partner Tags
    
    Customer organization tags offer a flexible way of identifying and grouping customer organizations. Tags are
    configured by partners for their customers and are neither visible to other partners nor the customers themselves.
    To manage tags, the user must have a full partner admin or partner admin role. The authorizing admin must grant
    the spark-admin:organizations-read scope for read operations and spark-admin:organizations-write scope for write
    operations.
    """

    def retrieve_all_customer_tags(self, type: str) -> list[TagsObj]:
        """
        Retrieve all customer tags

        Retrieves all tags which are being used by any customer organizations. Once a tag is unassigned from the last
        customer, it is automatically removed and is not returned by this API.
        This API can be used by a partner full admin, a read-only partner, or an partner admin.
        The `type` can have the value ORGANIZATION or SUBSCRIPTION. If not provided, the value is ORGANIZATION

        :param type: List tags associated with an organization.
        :type type: str
        :rtype: list[TagsObj]
        """
        params = {}
        params['type'] = type
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[TagsObj]).validate_python(data)
        return r

    def create_or_replace_existing_customer_tags_with_the_provided_ones(self, org_id: str,
                                                                        tags: list[TagsObj]) -> list[TagsObj]:
        """
        Create or Replace existing customer tags with the provided ones

        Assign or replace tag(s) which for a customer organization. If the tag doesn't already exist, a new one is
        created and assigned to the customer automatically.
        This API can be used by partner full admins and partner admins.
        Each tag has a character limit of 25. Currently, there is a limit of 5 tags per organization when creating
        tags. To remove all the tags, pass an empty array.
        Specify the customer organization ID in the `orgId` parameter in the URI.

        :param org_id: The unique identifier for the customer organization.
        :type org_id: str
        :param tags: An array of tags.
        :type tags: list[TagsObj]
        :rtype: list[TagsObj]
        """
        body = dict()
        body['tags'] = loads(TypeAdapter(list[TagsObj]).dump_json(tags))
        url = self.ep(f'organizations/{org_id}/assignTags')
        data = super().post(url, json=body)
        r = TypeAdapter(list[TagsObj]).validate_python(data)
        return r

    def get_customer_organization_s_tags(self, org_id: str) -> CustomerTagsResponse:
        """
        Get customer organization's tags

        Retrieve tags associated with a customer organization based on the `orgId` provided.
        This API can be used by a partner full admin, a read-only partner, or an partner admin.
        Specify the customer orgId in the `orgId` parameter in the URI.

        :param org_id: Fetch all customers and associated tags for the customer.
        :type org_id: str
        :rtype: :class:`CustomerTagsResponse`
        """
        url = self.ep(f'organizations/{org_id}')
        data = super().get(url)
        r = CustomerTagsResponse.model_validate(data)
        return r

    def fetch_all_customers_for_a_given_set_of_tags(self, tags: str, max_: int = None) -> list[CustomerTagsResponse]:
        """
        Fetch all customers for a given set of tags

        For a set of tags, retrieve all customer organizations that match any one of the tags.
        This API can be used by a partner full admin, a read-only partner, or an partner admin.

        :param tags: A comma separated list of tags to filter by.
        :type tags: str
        :param max_: Value must be between 1 and 100, inclusive.
        :type max_: int
        :rtype: list[CustomerTagsResponse]
        """
        params = {}
        params['tags'] = tags
        if max_ is not None:
            params['max'] = max_
        url = self.ep('organizations')
        data = super().get(url, params=params)
        r = TypeAdapter(list[CustomerTagsResponse]).validate_python(data)
        return r

    def create_or_replace_existing_subscription_tags_with_the_provided_ones(self, org_id: str, subscription_id: str,
                                                                            tags: list[TagsObj]) -> list[TagsObj]:
        """
        Create or Replace existing subscription tags with the provided ones

        Assign or replace tags specific to each subscription for an organization. Each organization may have one or
        more subscriptions.
        This API can be used by partner full admins and partner admins.
        Currently there is a limit of 5 tags per subscription when creating tags. To remove all the tags, pass an empty
        array.
        Specify the customer organization ID in the `orgId` parameter in the URI and subscription ID in
        `subscriptionId` parameter

        :param org_id: The unique identifier for the customer organization.
        :type org_id: str
        :param subscription_id: The unique identifier for the subscription.
        :type subscription_id: str
        :param tags: An array of tags.
        :type tags: list[TagsObj]
        :rtype: list[TagsObj]
        """
        body = dict()
        body['tags'] = loads(TypeAdapter(list[TagsObj]).dump_json(tags))
        url = self.ep(f'organizations/{org_id}/subscriptions/{subscription_id}/assignTags')
        data = super().post(url, json=body)
        r = TypeAdapter(list[TagsObj]).validate_python(data)
        return r

    def subscription_list_on_a_given_tag_name_or_a_set_of_tags(self, tags: str,
                                                               max_: int = None) -> list[SubscriptionTagsResponse]:
        """
        Subscription List on a given tag name or a set of tags

        For a partner organization fetch all it's subscriptions with their tag list for a given tag names.
        This API can be used by partner full admins, partner admins and admin read-only partners.

        :param tags: A comma separated list of tags to filter by.
        :type tags: str
        :param max_: Value must be between 1 and 100, inclusive.
        :type max_: int
        :rtype: list[SubscriptionTagsResponse]
        """
        params = {}
        params['tags'] = tags
        if max_ is not None:
            params['max'] = max_
        url = self.ep('subscriptions')
        data = super().get(url, params=params)
        r = TypeAdapter(list[SubscriptionTagsResponse]).validate_python(data)
        return r

    def fetch_a_subscription(self, org_id: str, subscription_id: str) -> SubscriptionTagsResponse:
        """
        Fetch a Subscription

        For a given partner org, customer org and external subscription id, fetch subscription details with its
        associated tags.
        This API can be used by partner full admins, partner admins and admin read-only partners.

        :param org_id: The unique identifier for the customer organization.
        :type org_id: str
        :param subscription_id: The unique identifier for the subscription.
        :type subscription_id: str
        :rtype: :class:`SubscriptionTagsResponse`
        """
        url = self.ep(f'organizations/{org_id}/subscriptions/{subscription_id}')
        data = super().get(url)
        r = SubscriptionTagsResponse.model_validate(data)
        return r


class TeamMembershipsApi(ApiChild, base='team/memberships'):
    """
    Team Memberships
    
    Team Memberships represent a person's relationship to a team. Use this API to list members of any team that you're
    in or create memberships to invite someone to a team. Team memberships can also be updated to make someone a
    moderator or deleted to remove them from the team.
    
    Just like in the Webex app, you must be a member of the team in order to list its memberships or invite people.
    """

    def list_team_memberships(self, team_id: str, **params) -> Generator[TeamMembership, None, None]:
        """
        List Team Memberships

        Lists all team memberships for a given team, specified by the `teamId` query parameter.

        Use query parameters to filter the response.

        :param team_id: List memberships for a team, by ID.
        :type team_id: str
        :return: Generator yielding :class:`TeamMembership` instances
        """
        params['teamId'] = team_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=TeamMembership, item_key='items', params=params)

    def create_a_team_membership(self, team_id: str, person_id: str = None, person_email: str = None,
                                 is_moderator: str = None) -> TeamMembership:
        """
        Create a Team Membership

        Add someone to a team by Person ID or email address, optionally making them a moderator.

        :param team_id: The team ID.
        :type team_id: str
        :param person_id: The person ID.
        :type person_id: str
        :param person_email: The email address of the person.
        :type person_email: str
        :param is_moderator: Whether or not the participant is a team moderator.
        :type is_moderator: str
        :rtype: :class:`TeamMembership`
        """
        body = dict()
        body['teamId'] = team_id
        body['personId'] = person_id
        body['personEmail'] = person_email
        body['isModerator'] = is_moderator
        url = self.ep()
        data = super().post(url, json=body)
        r = TeamMembership.model_validate(data)
        return r

    def get_team_membership_details(self, membership_id: str) -> TeamMembership:
        """
        Get Team Membership Details

        Shows details for a team membership, by ID.

        Specify the team membership ID in the `membershipId` URI parameter.

        :param membership_id: The unique identifier for the team membership.
        :type membership_id: str
        :rtype: :class:`TeamMembership`
        """
        url = self.ep(f'{membership_id}')
        data = super().get(url)
        r = TeamMembership.model_validate(data)
        return r

    def update_a_team_membership(self, membership_id: str, is_moderator: str) -> TeamMembership:
        """
        Update a Team Membership

        Updates a team membership, by ID.

        Specify the team membership ID in the `membershipId` URI parameter.

        :param membership_id: The unique identifier for the team membership.
        :type membership_id: str
        :param is_moderator: Whether or not the participant is a team moderator.
        :type is_moderator: str
        :rtype: :class:`TeamMembership`
        """
        body = dict()
        body['isModerator'] = is_moderator
        url = self.ep(f'{membership_id}')
        data = super().put(url, json=body)
        r = TeamMembership.model_validate(data)
        return r

    def delete_a_team_membership(self, membership_id: str):
        """
        Delete a Team Membership

        Deletes a team membership, by ID.

        Specify the team membership ID in the `membershipId` URI parameter.

        The team membership for the last moderator of a team may not be deleted; `promote another user
        <https://developer.webex.com/docs/api/v1/team-memberships/update-a-team-membership>`_ to team moderator
        first.

        :param membership_id: The unique identifier for the team membership.
        :type membership_id: str
        :rtype: None
        """
        url = self.ep(f'{membership_id}')
        super().delete(url)


class TeamsApi(ApiChild, base='teams'):
    """
    Teams
    
    Teams are groups of people with a set of rooms that are visible to all members of that team. This API is used to
    manage the teams themselves. Teams are created and deleted with this API. You can also update a team to change its
    name, for example.
    
    To manage people in a team see the `Team Memberships API
    <https://developer.webex.com/docs/api/v1/team-memberships>`_.
    
    To manage team rooms see the `Rooms API
    <https://developer.webex.com/docs/api/v1/rooms>`_.
    """

    def list_teams(self, **params) -> Generator[Team, None, None]:
        """
        List Teams

        Lists teams to which the authenticated user belongs.

        :return: Generator yielding :class:`Team` instances
        """
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Team, item_key='items', params=params)

    def create_a_team(self, name: str, description: str = None) -> Team:
        """
        Create a Team

        Creates a team.

        The authenticated user is automatically added as a member of the team. See the `Team Memberships API
        <https://developer.webex.com/docs/api/v1/team-memberships>`_ to learn
        how to add more people to the team.

        :param name: A user-friendly name for the team.
        :type name: str
        :param description: The teams description.
        :type description: str
        :rtype: :class:`Team`
        """
        body = dict()
        body['name'] = name
        body['description'] = description
        url = self.ep()
        data = super().post(url, json=body)
        r = Team.model_validate(data)
        return r

    def get_team_details(self, team_id: str, description: str = None) -> Team:
        """
        Get Team Details

        Shows details for a team, by ID.

        Specify the team ID in the `teamId` parameter in the URI.

        :param team_id: The unique identifier for the team.
        :type team_id: str
        :param description: The teams description.
        :type description: str
        :rtype: :class:`Team`
        """
        params = {}
        if description is not None:
            params['description'] = description
        url = self.ep(f'{team_id}')
        data = super().get(url, params=params)
        r = Team.model_validate(data)
        return r

    def update_a_team(self, team_id: str, name: str, description: str = None) -> Team:
        """
        Update a Team

        Updates details for a team, by ID.

        Specify the team ID in the `teamId` parameter in the URI.

        :param team_id: The unique identifier for the team.
        :type team_id: str
        :param name: A user-friendly name for the team.
        :type name: str
        :param description: The teams description.
        :type description: str
        :rtype: :class:`Team`
        """
        body = dict()
        body['name'] = name
        body['description'] = description
        url = self.ep(f'{team_id}')
        data = super().put(url, json=body)
        r = Team.model_validate(data)
        return r

    def delete_a_team(self, team_id: str):
        """
        Delete a Team

        Deletes a team, by ID.

        Specify the team ID in the `teamId` parameter in the URI.

        :param team_id: The unique identifier for the team.
        :type team_id: str
        :rtype: None
        """
        url = self.ep(f'{team_id}')
        super().delete(url)


class UCMProfileApi(ApiChild, base='telephony/config/callingProfiles'):
    """
    UCM Profile
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    UCM Profiles supports reading and writing of UC Profile relatedsettings for a specific organization or person.
    
    Viewing these read-only organization settings requires a full or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read`.
    
    Modifying these organization settings requires a full administrator auth token with a scope of
    `spark-admin:telephony_config_write`.
    
    Viewing people settings requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by a
    person to read their own settings.
    
    Configuring people settings requires a full or user administrator auth token with the `spark-admin:people_write`
    scope or, for select APIs, a user auth token with `spark:people_write` scope can be used by a person to update
    their own settings.
    
    A partner administrator can retrieve or change settings in a customer's organization using the optional `orgId`
    query parameter.
    """

    def read_the_list_of_uc_manager_profiles(self, org_id: str = None) -> list[Location]:
        """
        Read the List of UC Manager Profiles

        List all calling UC Manager Profiles for the organization.

        UC Manager Profiles are applicable if your organization uses Jabber in Team Messaging mode or Calling in Webex
        (Unified CM).

        The UC Manager Profile has an organization-wide default and may be overridden for individual persons, although
        currently only setting at a user level is supported by Webex APIs.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:people_read` as this API is designed to be used in conjunction with calling behavior at the user
        level.

        :param org_id: List manager profiles in this organization.
        :type org_id: str
        :rtype: list[Location]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[Location]).validate_python(data['callingProfiles'])
        return r


class UserCallSettingsApi(ApiChild, base=''):
    """
    User Call Settings
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Person Call Settings supports modifying Webex Calling settings for a specific person.
    
    Viewing People requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:people_read` or, for select APIs, a user auth token with `spark:people_read` scope can be used by a
    person to read their own settings.
    
    Configuring People settings requires a full or user administrator auth token with the `spark-admin:people_write`
    scope or, for select APIs, a user auth token with `spark:people_write` scope can be used by a person to update
    their own settings.
    """

    def retrieve_a_person_s_application_services_settings(self, person_id: str,
                                                          org_id: str = None) -> ApplicationsSetting:
        """
        Retrieve a person's Application Services Settings

        Application services let you determine the ringing behavior for calls made to people in certain scenarios. You
        can also specify which devices can download the Webex Calling app.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`ApplicationsSetting`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/applications')
        data = super().get(url, params=params)
        r = ApplicationsSetting.model_validate(data)
        return r

    def modify_a_person_s_application_services_settings(self, person_id: str,
                                                        ring_devices_for_click_to_dial_calls_enabled: bool,
                                                        ring_devices_for_group_page_enabled: bool,
                                                        ring_devices_for_call_park_enabled: bool,
                                                        browser_client_enabled: bool, desktop_client_enabled: bool,
                                                        tablet_client_enabled: bool, mobile_client_enabled: bool,
                                                        org_id: str = None):
        """
        Modify a person's Application Services Settings

        Application services let you determine the ringing behavior for calls made to users in certain scenarios. You
        can also specify which devices users can download the Webex Calling app on.

        This API requires a full or user administrator or location administrator auth token with the
        spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param ring_devices_for_click_to_dial_calls_enabled: When `true`, indicates to ring devices for outbound Click
            to Dial calls.
        :type ring_devices_for_click_to_dial_calls_enabled: bool
        :param ring_devices_for_group_page_enabled: When `true`, indicates to ring devices for inbound Group Pages.
        :type ring_devices_for_group_page_enabled: bool
        :param ring_devices_for_call_park_enabled: When `true`, indicates to ring devices for Call Park recalled.
        :type ring_devices_for_call_park_enabled: bool
        :param browser_client_enabled: Indicates that the browser Webex Calling application is enabled for use.
        :type browser_client_enabled: bool
        :param desktop_client_enabled: Indicates that the desktop Webex Calling application is enabled for use.
        :type desktop_client_enabled: bool
        :param tablet_client_enabled: Indicates that the tablet Webex Calling application is enabled for use.
        :type tablet_client_enabled: bool
        :param mobile_client_enabled: Indicates that the mobile Webex Calling application is enabled for use.
        :type mobile_client_enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['ringDevicesForClickToDialCallsEnabled'] = ring_devices_for_click_to_dial_calls_enabled
        body['ringDevicesForGroupPageEnabled'] = ring_devices_for_group_page_enabled
        body['ringDevicesForCallParkEnabled'] = ring_devices_for_call_park_enabled
        body['browserClientEnabled'] = browser_client_enabled
        body['desktopClientEnabled'] = desktop_client_enabled
        body['tabletClientEnabled'] = tablet_client_enabled
        body['mobileClientEnabled'] = mobile_client_enabled
        url = self.ep(f'people/{person_id}/features/applications')
        super().put(url, params=params, json=body)

    def read_barge_in_settings_for_a_person(self, person_id: str, org_id: str = None) -> BargeInInfo:
        """
        Read Barge In Settings for a Person

        Retrieve a person's Barge In settings.

        The Barge In feature enables you to use a Feature Access Code (FAC) to answer a call that was directed to
        another subscriber, or barge-in on the call if it was already answered. Barge In can be used across locations.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read` or a user auth token with `spark:people_read` scope can be used by a person to read
        their own settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`BargeInInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/bargeIn')
        data = super().get(url, params=params)
        r = BargeInInfo.model_validate(data)
        return r

    def configure_barge_in_settings_for_a_person(self, person_id: str, enabled: bool, tone_enabled: bool,
                                                 org_id: str = None):
        """
        Configure Barge In Settings for a Person

        Configure a person's Barge In settings.

        The Barge In feature enables you to use a Feature Access Code (FAC) to answer a call that was directed to
        another subscriber, or barge-in on the call if it was already answered. Barge In can be used across locations.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope or a user auth token with `spark:people_write` scope can be used by a person
        to update their own settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: Set to enable or disable the Barge In feature.
        :type enabled: bool
        :param tone_enabled: Set to enable or disable a stutter dial tone being played when a person is barging in on
            the active call.
        :type tone_enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['toneEnabled'] = tone_enabled
        url = self.ep(f'people/{person_id}/features/bargeIn')
        super().put(url, params=params, json=body)

    def read_forwarding_settings_for_a_person(self, person_id: str, org_id: str = None) -> CallForwardingInfo:
        """
        Read Forwarding Settings for a Person

        Retrieve a person's Call Forwarding settings.

        Three types of call forwarding are supported:

        + Always - forwards all incoming calls to the destination you choose.

        + When busy - forwards all incoming calls to the destination you chose while the phone is in use or the person
        is busy.

        + When no answer - forwarding only occurs when you are away or not answering your phone.

        In addition, the Business Continuity feature will send calls to a destination of your choice if your phone is
        not connected to the network for any reason, such as a power outage, failed Internet connection, or wiring
        problem.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read` or a user auth token with `spark:people_read` scope can be used by a person to read
        their own settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`CallForwardingInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callForwarding')
        data = super().get(url, params=params)
        r = CallForwardingInfo.model_validate(data)
        return r

    def configure_call_forwarding_settings_for_a_person(self, person_id: str,
                                                        call_forwarding: CallForwardingPutCallForwarding,
                                                        business_continuity: GetHuntGroupCallPolicyObjectBusinessContinuity,
                                                        org_id: str = None):
        """
        Configure Call Forwarding Settings for a Person

        Configure a person's Call Forwarding settings.

        Three types of call forwarding are supported:

        + Always - forwards all incoming calls to the destination you choose.

        + When busy - forwards all incoming calls to the destination you chose while the phone is in use or the person
        is busy.

        + When no answer - forwarding only occurs when you are away or not answering your phone.

        In addition, the Business Continuity feature will send calls to a destination of your choice if your phone is
        not connected to the network for any reason, such as a power outage, failed Internet connection, or wiring
        problem.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope or a user auth token with `spark:people_write` scope can be used by a person
        to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param call_forwarding: Settings related to "Always", "Busy", and "No Answer" call forwarding.
        :type call_forwarding: CallForwardingPutCallForwarding
        :param business_continuity: Settings for sending calls to a destination of your choice if your phone is not
            connected to the network for any reason, such as a power outage, failed Internet connection, or wiring
            problem.
        :type business_continuity: GetHuntGroupCallPolicyObjectBusinessContinuity
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callForwarding'] = loads(call_forwarding.model_dump_json())
        body['businessContinuity'] = loads(business_continuity.model_dump_json())
        url = self.ep(f'people/{person_id}/features/callForwarding')
        super().put(url, params=params, json=body)

    def read_call_intercept_settings_for_a_person(self, person_id: str, org_id: str = None) -> CallInterceptInfo:
        """
        Read Call Intercept Settings for a Person

        Retrieves Person's Call Intercept settings.

        The intercept feature gracefully takes a person's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified person are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`CallInterceptInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/intercept')
        data = super().get(url, params=params)
        r = CallInterceptInfo.model_validate(data)
        return r

    def configure_call_intercept_settings_for_a_person(self, person_id: str, enabled: bool,
                                                       incoming: CallInterceptPutIncoming,
                                                       outgoing: GetLocationInterceptObjectOutgoing,
                                                       org_id: str = None):
        """
        Configure Call Intercept Settings for a Person

        Configures a person's Call Intercept settings.

        The intercept feature gracefully takes a person's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified person are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: `true` if the intercept feature is enabled.
        :type enabled: bool
        :param incoming: Settings related to how incoming calls are handled when the intercept feature is enabled.
        :type incoming: CallInterceptPutIncoming
        :param outgoing: Settings related to how outgoing calls are handled when the intercept feature is enabled.
        :type outgoing: GetLocationInterceptObjectOutgoing
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['incoming'] = loads(incoming.model_dump_json())
        body['outgoing'] = loads(outgoing.model_dump_json())
        url = self.ep(f'people/{person_id}/features/intercept')
        super().put(url, params=params, json=body)

    def configure_call_intercept_greeting_for_a_person(self, person_id: str, org_id: str = None):
        """
        Configure Call Intercept Greeting for a Person

        Configure a person's Call Intercept Greeting by uploading a Waveform Audio File Format, `.wav`, encoded audio
        file.

        Your request will need to be a `multipart/form-data` request rather than JSON, using the `audio/wav`
        Content-Type.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope or a user
        auth token with `spark:people_write` scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/intercept/actions/announcementUpload/invoke')
        super().post(url, params=params)

    def retrieve_list_of_call_queue_caller_id_information(self, person_id: str) -> list[CallQueueObject1]:
        """
        Retrieve List of Call Queue Caller ID information

        Retrieve the list of the person's available call queues and the associated Caller ID information.

        If the Agent is to enable `queueCallerIdEnabled`, they must choose which queue to use as the source for
        outgoing Caller ID.  This API returns a list of Call Queues from which the person must select.  If this
        setting is disabled or the Agent does not belong to any queue, this list will be empty.

        This API requires a full admin or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :rtype: list[CallQueueObject1]
        """
        url = self.ep(f'telephony/config/people/{person_id}/queues/availableCallerIds')
        data = super().get(url)
        r = TypeAdapter(list[CallQueueObject1]).validate_python(data['availableQueues'])
        return r

    def retrieve_a_call_queue_agent_s_caller_id_information(self, person_id: str) -> AgentCallQueueId1:
        """
        Retrieve a Call Queue Agent's Caller ID information

        Retrieve a call queue agent's Caller ID information.

        Each agent in the Call Queue will be able to set their outgoing Caller ID as either the Call Queue's phone
        number or their own configured Caller ID. This API fetches the configured Caller ID for the agent in the
        system.

        This API requires a full admin or read-only administrator or location administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :rtype: :class:`AgentCallQueueId1`
        """
        url = self.ep(f'telephony/config/people/{person_id}/queues/callerId')
        data = super().get(url)
        r = AgentCallQueueId1.model_validate(data)
        return r

    def modify_a_call_queue_agent_s_caller_id_information(self, person_id: str, queue_caller_id_enabled: bool,
                                                          selected_queue: Location):
        """
        Modify a Call Queue Agent's Caller ID information

        Modify a call queue agent's Caller ID information.

        Each Agent in the Call Queue will be able to set their outgoing Caller ID as either the designated Call Queue's
        phone number or their own configured Caller ID. This API modifies the configured Caller ID for the agent in
        the system.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:telephony_config_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param queue_caller_id_enabled: When true, indicates that this agent is using the `selectedQueue` for its
            Caller ID. When false, indicates that it is using the agent's configured Caller ID.
        :type queue_caller_id_enabled: bool
        :param selected_queue: Use the queue's caller ID for outgoing calls. Optional when queueCallerIdEnabled is
            false, required when it's true.
        :type selected_queue: Location
        :rtype: None
        """
        body = dict()
        body['queueCallerIdEnabled'] = queue_caller_id_enabled
        body['selectedQueue'] = loads(selected_queue.model_dump_json())
        url = self.ep(f'telephony/config/people/{person_id}/queues/callerId')
        super().put(url, json=body)

    def read_call_recording_settings_for_a_person(self, person_id: str, org_id: str = None) -> CallRecordingInfo:
        """
        Read Call Recording Settings for a Person

        Retrieve a person's Call Recording settings.

        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`CallRecordingInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callRecording')
        data = super().get(url, params=params)
        r = CallRecordingInfo.model_validate(data)
        return r

    def configure_call_recording_settings_for_a_person(self, person_id: str, enabled: bool,
                                                       record: CallRecordingInfoRecord,
                                                       record_voicemail_enabled: bool,
                                                       start_stop_announcement_enabled: bool,
                                                       notification: CallRecordingInfoNotification,
                                                       repeat: CallRecordingInfoRepeat,
                                                       start_stop_announcement: CallRecordingInfoStartStopAnnouncement,
                                                       org_id: str = None):
        """
        Configure Call Recording Settings for a Person

        Configure a person's Call Recording settings.

        The Call Recording feature provides a hosted mechanism to record the calls placed and received on the Carrier
        platform for replay and archival. This feature is helpful for quality assurance, security, training, and more.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: `true` if call recording is enabled.
        :type enabled: bool
        :param record: Call recording scenario.
        :type record: CallRecordingInfoRecord
        :param record_voicemail_enabled: When `true`, voicemail messages are also recorded.
        :type record_voicemail_enabled: bool
        :param start_stop_announcement_enabled: When enabled, an announcement is played when call recording starts and
            an announcement is played when call recording ends.
        :type start_stop_announcement_enabled: bool
        :param notification: Pause/resume notification settings.
        :type notification: CallRecordingInfoNotification
        :param repeat: Beep sound plays periodically.
        :type repeat: CallRecordingInfoRepeat
        :param start_stop_announcement: Call Recording starts and stops announcement settings.
        :type start_stop_announcement: CallRecordingInfoStartStopAnnouncement
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['record'] = enum_str(record)
        body['recordVoicemailEnabled'] = record_voicemail_enabled
        body['startStopAnnouncementEnabled'] = start_stop_announcement_enabled
        body['notification'] = loads(notification.model_dump_json())
        body['repeat'] = loads(repeat.model_dump_json())
        body['startStopAnnouncement'] = loads(start_stop_announcement.model_dump_json())
        url = self.ep(f'people/{person_id}/features/callRecording')
        super().put(url, params=params, json=body)

    def read_call_waiting_settings_for_a_person(self, person_id: str, org_id: str = None) -> bool:
        """
        Read Call Waiting Settings for a Person

        Retrieve a person's Call Waiting settings.

        With this feature, a person can place an active call on hold and answer an incoming call.  When enabled, while
        you are on an active call, a tone alerts you of an incoming call and you can choose to answer or ignore the
        call.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: bool
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callWaiting')
        data = super().get(url, params=params)
        r = data['enabled']
        return r

    def configure_call_waiting_settings_for_a_person(self, person_id: str, enabled: bool, org_id: str = None):
        """
        Configure Call Waiting Settings for a Person

        Configure a person's Call Waiting settings.

        With this feature, a person can place an active call on hold and answer an incoming call.  When enabled, while
        you are on an active call, a tone alerts you of an incoming call and you can choose to answer or ignore the
        call.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: `true` if the Call Waiting feature is enabled.
        :type enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        url = self.ep(f'people/{person_id}/features/callWaiting')
        super().put(url, params=params, json=body)

    def read_caller_id_settings_for_a_person(self, person_id: str, org_id: str = None) -> CallerIdInfo:
        """
        Read Caller ID Settings for a Person

        Retrieve a person's Caller ID settings.

        Caller ID settings control how a person's information is displayed when making outgoing calls.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`CallerIdInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callerId')
        data = super().get(url, params=params)
        r = CallerIdInfo.model_validate(data)
        return r

    def configure_caller_id_settings_for_a_person(self, person_id: str, selected: CallerIdSelectedType,
                                                  custom_number: str, first_name: str, last_name: str,
                                                  block_in_forward_calls_enabled: bool,
                                                  external_caller_id_name_policy: ListVirtualLineObjectExternalCallerIdNamePolicy,
                                                  custom_external_caller_id_name: str, org_id: str = None):
        """
        Configure Caller ID Settings for a Person

        Configure a person's Caller ID settings.

        Caller ID settings control how a person's information is displayed when making outgoing calls.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param selected: Which type of outgoing Caller ID will be used.
        :type selected: CallerIdSelectedType
        :param custom_number: This value must be an assigned number from the person's location.
        :type custom_number: str
        :param first_name: Person's Caller ID first name.  Characters of `%`,  `+`, ``, `"` and Unicode characters are
            not allowed.
        :type first_name: str
        :param last_name: Person's Caller ID last name.  Characters of `%`,  `+`, ``, `"` and Unicode characters are
            not allowed.
        :type last_name: str
        :param block_in_forward_calls_enabled: `true` if person's identity has to be blocked when receiving a
            transferred or forwarded call.
        :type block_in_forward_calls_enabled: bool
        :param external_caller_id_name_policy: Designates which type of External Caller Id Name policy is used. Default
            is `DIRECT_LINE`.
        :type external_caller_id_name_policy: ListVirtualLineObjectExternalCallerIdNamePolicy
        :param custom_external_caller_id_name: Person's custom External Caller ID last name.  Characters of `%`,  `+`,
            ``, `"` and Unicode characters are not allowed.
        :type custom_external_caller_id_name: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['selected'] = enum_str(selected)
        body['customNumber'] = custom_number
        body['firstName'] = first_name
        body['lastName'] = last_name
        body['blockInForwardCallsEnabled'] = block_in_forward_calls_enabled
        body['externalCallerIdNamePolicy'] = enum_str(external_caller_id_name_policy)
        body['customExternalCallerIdName'] = custom_external_caller_id_name
        url = self.ep(f'people/{person_id}/features/callerId')
        super().put(url, params=params, json=body)

    def read_person_s_calling_behavior(self, person_id: str, org_id: str = None) -> GetCallingBehaviorObject:
        """
        Read Person's Calling Behavior

        Retrieves the calling behavior and UC Manager Profile settings for the person which includes overall calling
        behavior and calling UC Manager Profile ID.

        Webex Calling Behavior controls which Webex telephony application and which UC Manager Profile is to be used
        for a person.

        An organization has an organization-wide default Calling Behavior that may be overridden for individual
        persons.

        UC Manager Profiles are applicable if your organization uses Jabber in Team Messaging mode or Calling in Webex
        (Unified CM).

        The UC Manager Profile also has an organization-wide default and may be overridden for individual persons.

        This API requires a full, user, or read-only administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`GetCallingBehaviorObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/callingBehavior')
        data = super().get(url, params=params)
        r = GetCallingBehaviorObject.model_validate(data)
        return r

    def configure_a_person_s_calling_behavior(self, person_id: str,
                                              behavior_type: GetCallingBehaviorObjectBehaviorType, profile_id: str,
                                              org_id: str = None):
        """
        Configure a person's Calling Behavior

        Modifies the calling behavior settings for the person which includes calling behavior and UC Manager Profile
        ID.

        Webex Calling Behavior controls which Webex telephony application and which UC Manager Profile is to be used
        for a person.

        An organization has an organization-wide default Calling Behavior that may be overridden for individual
        persons.

        UC Manager Profiles are applicable if your organization uses Jabber in Team Messaging mode or Calling in Webex
        (Unified CM).

        The UC Manager Profile also has an organization-wide default and may be overridden for individual persons.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param behavior_type: The new Calling Behavior setting for the person (case-insensitive). If `null`, the
            effective Calling Behavior will be the Organization's current default.
        :type behavior_type: GetCallingBehaviorObjectBehaviorType
        :param profile_id: The UC Manager Profile ID. Specifying null results in the organizational default being
            applied.
        :type profile_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['behaviorType'] = enum_str(behavior_type)
        body['profileId'] = profile_id
        url = self.ep(f'people/{person_id}/features/callingBehavior')
        super().put(url, params=params, json=body)

    def read_do_not_disturb_settings_for_a_person(self, person_id: str, org_id: str = None) -> DoNotDisturbInfo:
        """
        Read Do Not Disturb Settings for a Person

        Retrieve a person's Do Not Disturb settings.

        When enabled, this feature will give all incoming calls the busy treatment. Optionally, you can enable a Ring
        Reminder to play a brief tone on your desktop phone when you receive incoming calls.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read` or a user auth token with `spark:people_read` scope can be used by a person to read
        their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`DoNotDisturbInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/doNotDisturb')
        data = super().get(url, params=params)
        r = DoNotDisturbInfo.model_validate(data)
        return r

    def configure_do_not_disturb_settings_for_a_person(self, person_id: str, enabled: bool, ring_splash_enabled: bool,
                                                       org_id: str = None):
        """
        Configure Do Not Disturb Settings for a Person

        Configure a person's Do Not Disturb settings.

        When enabled, this feature will give all incoming calls the busy treatment. Optionally, you can enable a Ring
        Reminder to play a brief tone on your desktop phone when you receive incoming calls.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope or a user
        auth token with `spark:people_write` scope can be used by a person to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: `true` if the Do Not Disturb feature is enabled.
        :type enabled: bool
        :param ring_splash_enabled: Enables a Ring Reminder to play a brief tone on your desktop phone when you receive
            incoming calls.
        :type ring_splash_enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['ringSplashEnabled'] = ring_splash_enabled
        url = self.ep(f'people/{person_id}/features/doNotDisturb')
        super().put(url, params=params, json=body)

    def retrieve_executive_assistant_settings_for_a_person(self, person_id: str,
                                                           org_id: str = None) -> RetrieveExecutiveAssistantSettingsForAPersonResponseType:
        """
        Retrieve Executive Assistant Settings for a Person

        Retrieve the executive assistant settings for the specified `personId`.

        People with the executive service enabled, can select from a pool of assistants who have been assigned the
        executive assistant service and who can answer or place calls on their behalf. Executive assistants can set
        the call forward destination and join or leave an executive's pool.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: RetrieveExecutiveAssistantSettingsForAPersonResponseType
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/executiveAssistant')
        data = super().get(url, params=params)
        r = RetrieveExecutiveAssistantSettingsForAPersonResponseType.model_validate(data['type'])
        return r

    def modify_executive_assistant_settings_for_a_person(self, person_id: str, org_id: str = None,
                                                         type: RetrieveExecutiveAssistantSettingsForAPersonResponseType = None):
        """
        Modify Executive Assistant Settings for a Person

        Modify the executive assistant settings for the specified personId.

        People with the executive service enabled, can select from a pool of assistants who have been assigned the
        executive assistant service and who can answer or place calls on their behalf. Executive assistants can set
        the call forward destination and join or leave an executive's pool.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param type: executive assistant type
        :type type: RetrieveExecutiveAssistantSettingsForAPersonResponseType
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['type'] = enum_str(type)
        url = self.ep(f'people/{person_id}/features/executiveAssistant')
        super().put(url, params=params, json=body)

    def read_hoteling_settings_for_a_person(self, person_id: str, org_id: str = None) -> bool:
        """
        Read Hoteling Settings for a Person

        Retrieve a person's hoteling settings.

        As an administrator, you can enable hoteling for people so that their phone profile (phone number, features,
        and calling plan) is temporarily loaded onto a shared (host) phone.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: bool
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/hoteling')
        data = super().get(url, params=params)
        r = data['enabled']
        return r

    def configure_hoteling_settings_for_a_person(self, person_id: str, enabled: bool, org_id: str = None):
        """
        Configure Hoteling Settings for a Person

        Configure a person's hoteling settings.

        As an administrator, you can enable hoteling for people so that their phone profile (phone number, features,
        and calling plan) is temporarily loaded onto a shared (host) phone.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: When `true`, allow this person to connect to a Hoteling host device.
        :type enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        url = self.ep(f'people/{person_id}/features/hoteling')
        super().put(url, params=params, json=body)

    def retrieve_a_person_s_monitoring_settings(self, person_id: str, org_id: str = None) -> MonitoringSettings1:
        """
        Retrieve a person's Monitoring Settings

        Retrieves the monitoring settings of the person, which shows specified people, places, virtual lines or call
        park extenions that are being monitored.
        Monitors the line status which indicates if a person, place or virtual line is on a call and if a call has been
        parked on that extension.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`MonitoringSettings1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/monitoring')
        data = super().get(url, params=params)
        r = MonitoringSettings1.model_validate(data)
        return r

    def modify_a_person_s_monitoring_settings(self, person_id: str, enable_call_park_notification: bool,
                                              monitored_elements: list[str], org_id: str = None):
        """
        Modify a person's Monitoring Settings

        Modifies the monitoring settings of the person.
        Monitors the line status of specified people, places, virtual lines or call park extension. The line status
        indicates if a person, place or virtual line is on a call and if a call has been parked on that extension.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enable_call_park_notification: Enable or disable call park notification.
        :type enable_call_park_notification: bool
        :param monitored_elements: Identifiers of monitored elements whose monitoring settings will be modified.
        :type monitored_elements: list[str]
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enableCallParkNotification'] = enable_call_park_notification
        body['monitoredElements'] = monitored_elements
        url = self.ep(f'people/{person_id}/features/monitoring')
        super().put(url, params=params, json=body)

    def validate_or_initiate_move_users_job(self, users_list: list[UsersListItem],
                                            org_id: str = None) -> StartJobResponseObject:
        """
        Validate or Initiate Move Users Job

        This API allows the user to perform any one of the following operations:

        * When the `validate` attribute is true, this validates the user move from one location to another location.

        * When the `validate` attribute is false, this performs the user move from one location to another location.

        <br/>

        In order to validate or move a user,

        <br/>

        * Maximum of one calling user can be moved at a time.

        * The target location must be a calling location.

        * The user can have only an extension. The user must not have a phone number or alternate number.

        * Only one new extension can be moved to the target location, which is optional. If not provided, the existing
        extension will be retained to the user.

        <br/>

        Any errors that occur during initial API request validation will be captured directly in error response with
        appropriate HTTP status code.

        <br/>

        List of possible Errors:

        + 1026005 - Request is supported only for single user.

        + 1026006 - Attribute 'Location ID' is required.

        + 1026006 - Attribute 'User ID' is required.

        + 1026006 - Attribute 'Validate' is required.

        + 1026009 - Request is supported for users with extension number only.

        + 1026010 - User is not a valid Calling User.

        + 1026011 - Users list should not be empty.

        + 1026012 - Users should not be empty.

        + 1026013 - The source and the target location cannot be the same.

        + 1026014 - Error occurred while processing the move users request.

        <br/>

        When the `validate` is set to be true, the errors and impacts associated with the user move will be identified
        and returned in the response.

        <br/>

        List of possible Errors:

        + 4003 - `User Not Found`

        + 4007 - `User Not Found`

        + 4152 - `Location Not Found`

        + 5620 - `Location Not Found`

        + 4202 - `The extension is not available. It is already assigned to a user : {0}`

        + 19600 - `User has to be within an enterprise to be moved.`

        + 19601 - `User can only be moved to a different group within the same enterprise.`

        + 19602 - `Only regular end user can be moved. Service instance virtual user cannot be moved.`

        + 19603 - `New group already reaches maximum number of user limits.`

        + 19604 - `The {0} number of the user is the same as the calling line ID of the group.`

        + 19605 - `User is assigned services not authorized to the new group: {0}.`

        + 19606 - `User is in an active hoteling/flexible seating association.`

        + 19607 - `User is pilot user of a trunk group.`

        + 19608 - `User is using group level device profiles which is used by other users in current group. Following
        are the device profiles shared with other users: {0}.`

        + 19609 - `Following device profiles cannot be moved to the new group because there are already devices with
        the same name defined in the new group: {0}.`

        + 19610 - `The extension of the user is used as transfer to operator number for following Auto Attendent :
        {0}.`

        + 19611 - `Fail to move announcement file from {0} to {1}.`

        + 19612 - `Fail to move device management file from {0} to {1}.`

        + 19613 - `User is assigned service packs not authorized to the new group: {0}.`

        + 25008 - `Missing Mandatory field name: {0}`

        + 25110 - `{fieldName} cannot be less than {0} or greater than {1} characters.`

        + 25378 - `Target location is same as user's current location.`

        + 25379 - `Error Occurred while Fetching User's Current Location Id.`

        + 25381 - `Error Occurred while rolling back to Old Location Call recording Settings`

        + 25382 - `Error Occurred while Disabling Call Recording for user which is required Before User can be Moved`

        + 25383 - `OCI Error while moving user`

        + 25384 - `Error Occurred while checking for Possible Call Recording Impact.`

        + 25385 - `Error Occurred while getting Call Recording Settings`

        + 27960 - `Parameter isWebexCalling, newPhoneNumber, or newExtension can only be set in Webex Calling
        deployment mode.`

        + 27961 - `Parameter isWebexCalling shall be set if newPhoneNumber or newExtension is set.`

        + 27962 - `Work space cannot be moved.`

        + 27963 - `Virtual profile user cannot be moved.`

        + 27964 - `Need to unassign phone number from user before moving the user to the new group. Phone number: {0},
        phone number type: {1}`

        + 27965 - `The user's phone number: {0}, is same as the current group charge number.`

        + 27966 - `The phone number, {0}, is not available in the new group.`

        + 27967 - `User is configured as the ECBN user for another user in the current group.`

        + 27968 - `User is configured as the ECBN user for the current group.`

        + 27969 - `User is associated with DECT handset(s): {0}`

        + 27970 - `User is using a customer managed device: {0}`

        + 27971 - `User is using an ATA device: {0}`

        + 27972 - `User is in an active hotdesking association.`

        <br/>

        List of possible Impacts:

        + 19701 - `The identity/device profile the user is using is moved to the new group: {0}.`

        + 19702 - `The user level customized incoming digit string setting is removed from the user. User is set to use
        the new group setting.`

        + 19703 - `The user level customized outgoing digit plan setting is removed from the user. User is set to use
        the new group setting.`

        + 19704 - `The user level customized enhanced outgoing calling plan setting is removed from the user. User is
        set to use the new group setting.`

        + 19705 - `User is removed from following group services: {0}.`

        + 19706 - `The current group schedule used in any criteria is removed from the service settings.`

        + 19707 - `User is removed from the department of the old group.`

        + 19708 - `User is changed to use the default communication barring profile of the new group.`

        + 19709 - `The communication barring profile of the user is assigned to the new group: {0}.`

        + 19710 - `The charge number for the user is removed.`

        + 19711 - `The disabled FACs for the user are removed because they are not available in the new group.`

        + 19712 - `User is removed from trunk group.`

        + 19713 - `The extension of the user is reset to empty due to either the length is out of bounds of the new
        group, or the extension is already taken in new group.`

        + 19714 - `The extension of the following alternate number is reset to empty due to either the length out of
        bounds of the new group or the extension is already taken in new group: {0}.`

        + 19715 - `The collaborate room using current group default collaborate bridge is moved to the default
        collaborate bridge of the new group.`

        + 19716 - `Previously stored voice messages of the user are no longer available. The new voice message will be
        stored on the mail server of the new group.`

        + 19717 - `The primary number, alternate numbers or fax messaging number of the user are assigned to the new
        group: {0}.`

        + 19718 - `Following domains are assigned to the new group: {0}.`

        + 19719 - `The NCOS of the user is assigned to the new group: {0}.`

        + 19720 - `The office zone of the user is assigned to the new group: {0}.`

        + 19721 - `The announcement media files are relocated to the new group directory.`

        + 19722 - `User CLID number is set to use the new group CLID number: {0}.`

        + 19723 - `New group CLID number is not configured.`

        + 19724 - `The group level announcement file(s) are removed from the user's music on hold settings.`

        + 25388 - `Target Location Does not Have Vendor Configured. Call Recording for user will be disabled`

        + 25389 - `Call Recording Vendor for user will be changed from:{0} to:{1}`

        + 25390 - `Dub point of user is moved to new external group`

        + 25391 - `Error Occurred while moving Call recording Settings to new location`

        + 25392 - `Error Occurred while checking for Possible Call Recording Impact.`

        + 25393 - `Sending Billing Notification Failed`

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`,
        `spark-admin:people_write` and `identity:groups_rw`.

        :param users_list: The user to be moved from the source location.
        :type users_list: list[UsersListItem]
        :param org_id: Create Move Users job for this organization.
        :type org_id: str
        :rtype: StartJobResponseObject
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['usersList'] = loads(TypeAdapter(list[UsersListItem]).dump_json(users_list))
        url = self.ep('telephony/config/jobs/person/moveLocation')
        data = super().post(url, params=params, json=body)
        r = StartJobResponseObject.model_validate(data['response'])
        return r

    def list_move_users_jobs(self, org_id: str = None, start: int = None,
                             **params) -> Generator[JobDetailsResponse, None, None]:
        """
        List Move Users Jobs

        Lists all the Move Users jobs for the given organization in order of most recent job to oldest job irrespective
        of its status.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: Retrieve list of Move Users jobs for this organization.
        :type org_id: str
        :param start: Start at the zero-based offset in the list of jobs. Default is 0.
        :type start: int
        :return: Generator yielding :class:`JobDetailsResponse` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        url = self.ep('telephony/config/jobs/person/moveLocation')
        return self.session.follow_pagination(url=url, model=JobDetailsResponse, item_key='items', params=params)

    def get_move_users_job_status(self, job_id: str, org_id: str = None) -> JobDetailsResponseById:
        """
        Get Move Users Job Status

        Returns the status and other details of the job.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param job_id: Retrieve job details for this `jobId`.
        :type job_id: str
        :param org_id: Retrieve job details for this organization.
        :type org_id: str
        :rtype: :class:`JobDetailsResponseById`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/jobs/person/moveLocation/{job_id}')
        data = super().get(url, params=params)
        r = JobDetailsResponseById.model_validate(data)
        return r

    def abandon_the_move_users_job(self, job_id: str, org_id: str = None):
        """
        Abandon the Move Users Job

        Abandon the Move Users Job.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param job_id: Abandon the Move Users job for this `jobId`.
        :type job_id: str
        :param org_id: Abandon the Move Users job for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/jobs/person/moveLocation/{job_id}/actions/abandon/invoke')
        super().post(url, params=params)

    def pause_the_move_users_job(self, job_id: str, org_id: str = None):
        """
        Pause the Move Users Job

        Pause the running Move Users Job. A paused job can be resumed or abandoned.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param job_id: Pause the Move Users job for this `jobId`.
        :type job_id: str
        :param org_id: Pause the Move Users job for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/jobs/person/moveLocation/{job_id}/actions/pause/invoke')
        super().post(url, params=params)

    def resume_the_move_users_job(self, job_id: str, org_id: str = None):
        """
        Resume the Move Users Job

        Resume the paused Move Users Job that is in paused status.

        This API requires a full administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param job_id: Resume the Move Users job for this `jobId`.
        :type job_id: str
        :param org_id: Resume the Move Users job for this organization.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/jobs/person/moveLocation/{job_id}/actions/resume/invoke')
        super().post(url, params=params)

    def list_move_users_job_errors(self, job_id: str, org_id: str = None, start: int = None,
                                   **params) -> Generator[ItemObject, None, None]:
        """
        List Move Users Job errors

        Lists all error details of Move Users job. This will not list any errors if `exitCode` is `COMPLETED`. If the
        status is `COMPLETED_WITH_ERRORS` then this lists the cause of failures.

        This API requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param job_id: Retrieve the error details for this `jobId`.
        :type job_id: str
        :param org_id: Retrieve list of jobs for this organization.
        :type org_id: str
        :param start: Specifies the error offset from the first result that you want to fetch.
        :type start: int
        :return: Generator yielding :class:`ItemObject` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        url = self.ep(f'telephony/config/jobs/person/moveLocation/{job_id}/errors')
        return self.session.follow_pagination(url=url, model=ItemObject, item_key='items', params=params)

    def retrieve_music_on_hold_settings_for_a_person(self, person_id: str,
                                                     org_id: str = None) -> GetMusicOnHoldObject1:
        """
        Retrieve Music On Hold Settings for a Person

        Retrieve the person's music on hold settings.

        Music on hold is played when a caller is put on hold, or the call is parked.

        Retrieving a person's music on hold settings requires a full, user or read-only administrator auth token with a
        scope of `spark-admin:telephony_config_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`GetMusicOnHoldObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/people/{person_id}/musicOnHold')
        data = super().get(url, params=params)
        r = GetMusicOnHoldObject1.model_validate(data)
        return r

    def configure_music_on_hold_settings_for_a_person(self, person_id: str, moh_enabled: bool,
                                                      greeting: HoursMenuObjectGreeting,
                                                      audio_announcement_file: AudioAnnouncementFileGetObject1,
                                                      org_id: str = None):
        """
        Configure Music On Hold Settings for a Person

        Configure a person's music on hold settings.

        Music on hold is played when a caller is put on hold, or the call is parked.

        To configure music on hold settings for a person, music on hold setting must be enabled for this location.

        Updating a person's music on hold settings requires a full or user administrator auth token with a scope of
        `spark-admin:telephony_config_write`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param moh_enabled: Music on hold is enabled or disabled for the person.
        :type moh_enabled: bool
        :param greeting: Greeting type for the person.
        :type greeting: HoursMenuObjectGreeting
        :param audio_announcement_file: Announcement Audio File details when greeting is selected to be `CUSTOM`.
        :type audio_announcement_file: AudioAnnouncementFileGetObject1
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['mohEnabled'] = moh_enabled
        body['greeting'] = enum_str(greeting)
        body['audioAnnouncementFile'] = loads(audio_announcement_file.model_dump_json())
        url = self.ep(f'telephony/config/people/{person_id}/musicOnHold')
        super().put(url, params=params, json=body)

    def read_incoming_permission_settings_for_a_person(self, person_id: str,
                                                       org_id: str = None) -> IncomingPermissionSetting:
        """
        Read Incoming Permission Settings for a Person

        Retrieve a person's Incoming Permission settings.

        You can change the incoming calling permissions for a person if you want them to be different from your
        organization's default.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`IncomingPermissionSetting`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/incomingPermission')
        data = super().get(url, params=params)
        r = IncomingPermissionSetting.model_validate(data)
        return r

    def configure_incoming_permission_settings_for_a_person(self, person_id: str, use_custom_enabled: bool,
                                                            external_transfer: IncomingPermissionSettingExternalTransfer,
                                                            internal_calls_enabled: bool, collect_calls_enabled: bool,
                                                            org_id: str = None):
        """
        Configure Incoming Permission Settings for a Person

        Configure a person's Incoming Permission settings.

        You can change the incoming calling permissions for a person if you want them to be different from your
        organization's default.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param use_custom_enabled: When true, indicates that this person uses the specified calling permissions for
            receiving inbound calls rather than the organizational defaults.
        :type use_custom_enabled: bool
        :param external_transfer: Specifies the transfer behavior for incoming, external calls.
        :type external_transfer: IncomingPermissionSettingExternalTransfer
        :param internal_calls_enabled: Internal calls are allowed to be received.
        :type internal_calls_enabled: bool
        :param collect_calls_enabled: Collect calls are allowed to be received.
        :type collect_calls_enabled: bool
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['useCustomEnabled'] = use_custom_enabled
        body['externalTransfer'] = enum_str(external_transfer)
        body['internalCallsEnabled'] = internal_calls_enabled
        body['collectCallsEnabled'] = collect_calls_enabled
        url = self.ep(f'people/{person_id}/features/incomingPermission')
        super().put(url, params=params, json=body)

    def retrieve_a_person_s_outgoing_calling_permissions_settings(self, person_id: str,
                                                                  org_id: str = None) -> OutgoingCallingPermissionsSetting:
        """
        Retrieve a person's Outgoing Calling Permissions Settings

        Retrieve a person's Outgoing Calling Permissions settings.

        You can change the outgoing calling permissions for a person if you want them to be different from your
        organization's default.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`OutgoingCallingPermissionsSetting`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/outgoingPermission')
        data = super().get(url, params=params)
        r = OutgoingCallingPermissionsSetting.model_validate(data)
        return r

    def modify_a_person_s_outgoing_calling_permissions_settings(self, person_id: str, use_custom_enabled: bool,
                                                                calling_permissions: list[CallingPermissionObject],
                                                                org_id: str = None):
        """
        Modify a person's Outgoing Calling Permissions Settings

        Modify a person's Outgoing Calling Permissions settings.

        You can change the outgoing calling permissions for a person if you want them to be different from your
        organization's default.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param use_custom_enabled: When true, indicates that this user uses the specified calling permissions when
            placing outbound calls.
        :type use_custom_enabled: bool
        :param calling_permissions: Specifies the outbound calling permissions settings.
        :type calling_permissions: list[CallingPermissionObject]
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['useCustomEnabled'] = use_custom_enabled
        body['callingPermissions'] = loads(TypeAdapter(list[CallingPermissionObject]).dump_json(calling_permissions))
        url = self.ep(f'people/{person_id}/features/outgoingPermission')
        super().put(url, params=params, json=body)

    def get_a_list_of_phone_numbers_for_a_person(self, person_id: str, org_id: str = None,
                                                 prefer_e164_format: bool = None) -> GetNumbers1:
        """
        Get a List of Phone Numbers for a Person

        Get a person's phone numbers including alternate numbers.

        A person can have one or more phone numbers and/or extensions via which they can be called.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_read` scope.

        <br/>

        <div><Callout type="warning">The `preferE164Format` query parameter can be used to get phone numbers either in
        E.164 format or in their legacy format. The support for getting phone numbers in non-E.164 format in some
        geographies will be removed in the future.</Callout></div>

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param prefer_e164_format: Return phone numbers in E.164 format.
        :type prefer_e164_format: bool
        :rtype: :class:`GetNumbers1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if prefer_e164_format is not None:
            params['preferE164Format'] = str(prefer_e164_format).lower()
        url = self.ep(f'people/{person_id}/features/numbers')
        data = super().get(url, params=params)
        r = GetNumbers1.model_validate(data)
        return r

    def assign_or_unassign_numbers_to_a_person(self, person_id: str, enable_distinctive_ring_pattern: bool,
                                               phone_numbers: list[PhoneNumber], org_id: str = None):
        """
        Assign or Unassign numbers to a person

        Assign or unassign alternate phone numbers to a person.

        Each location has a set of phone numbers that can be assigned to people, workspaces, or features. Phone numbers
        must follow the E.164 format for all countries, except for the United States, which can also follow the
        National format. Active phone numbers are in service.

        Assigning or unassigning an alternate phone number to a person requires a full administrator or location
        administrator auth token with a scope of `spark-admin:telephony_config_write`.

        :param person_id: Unique identitfier of the person.
        :type person_id: str
        :param enable_distinctive_ring_pattern: Enables a distinctive ring pattern for the person.
        :type enable_distinctive_ring_pattern: bool
        :param phone_numbers: List of phone numbers that are assigned to a person.
        :type phone_numbers: list[PhoneNumber]
        :param org_id: Organization of the Route Group.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enableDistinctiveRingPattern'] = enable_distinctive_ring_pattern
        body['phoneNumbers'] = loads(TypeAdapter(list[PhoneNumber]).dump_json(phone_numbers))
        url = self.ep(f'telephony/config/people/{person_id}/numbers')
        super().put(url, params=params, json=body)

    def get_preferred_answer_endpoint(self, person_id: str, org_id: str = None) -> EndpointInformation:
        """
        Get Preferred Answer Endpoint

        Get the person's preferred answer endpoint and the list of endpoints available for selection. The preferred
        answer endpoint is null if one has not been selected. The list of endpoints is empty if the person has no
        endpoints assigned which support the preferred answer endpoint functionality. These endpoints can be used by
        the following Call Control API's that allow the person to specify an endpointId to use for the call:<br>

        + `/v1/telephony/calls/dial
        <https://developer.webex.com/docs/api/v1/call-controls/dial>`_<br>

        + `/v1/telephony/calls/retrieve
        <https://developer.webex.com/docs/api/v1/call-controls/retrieve>`_<br>

        + `/v1/telephony/calls/pickup
        <https://developer.webex.com/docs/api/v1/call-controls/pickup>`_<br>

        + `/v1/telephony/calls/barge-in
        <https://developer.webex.com/docs/api/v1/call-controls/barge-in>`_<br>

        + `/v1/telephony/calls/answer
        <https://developer.webex.com/docs/api/v1/call-controls/answer>`_<br>

        This API requires `spark:telephony_config_read` or `spark-admin:telephony_config_read` scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`EndpointInformation`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/people/{person_id}/preferredAnswerEndpoint')
        data = super().get(url, params=params)
        r = EndpointInformation.model_validate(data)
        return r

    def modify_preferred_answer_endpoint(self, person_id: str, preferred_answer_endpoint_id: str, org_id: str = None):
        """
        Modify Preferred Answer Endpoint

        Sets or clears the persons preferred answer endpoint. To clear the preferred answer endpoint the
        `preferredAnswerEndpointId` attribute must be set to null.<br>
        This API requires `spark:telephony_config_write` or `spark-admin:telephony_config_write` scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param preferred_answer_endpoint_id: Persons preferred answer endpoint.
        :type preferred_answer_endpoint_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['preferredAnswerEndpointId'] = preferred_answer_endpoint_id
        url = self.ep(f'telephony/config/people/{person_id}/preferredAnswerEndpoint')
        super().put(url, params=params, json=body)

    def get_a_person_s_privacy_settings(self, person_id: str, org_id: str = None) -> PrivacyGet1:
        """
        Get a person's Privacy Settings

        Get a person's privacy settings for the specified person ID.

        The privacy feature enables the person's line to be monitored by others and determine if they can be reached by
        Auto Attendant services.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        spark-admin:people_read.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`PrivacyGet1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/privacy')
        data = super().get(url, params=params)
        r = PrivacyGet1.model_validate(data)
        return r

    def configure_a_person_s_privacy_settings(self, person_id: str, org_id: str = None,
                                              aa_extension_dialing_enabled: str = None,
                                              aa_naming_dialing_enabled: str = None,
                                              enable_phone_status_directory_privacy: str = None,
                                              monitoring_agents: list[str] = None):
        """
        Configure a person's Privacy Settings

        Configure a person's privacy settings for the specified person ID.

        The privacy feature enables the person's line to be monitored by others and determine if they can be reached by
        Auto Attendant services.

        This API requires a full or user administrator or location administrator auth token with the
        spark-admin:people_write scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param aa_extension_dialing_enabled: When `true` auto attendant extension dialing is enabled.
        :type aa_extension_dialing_enabled: str
        :param aa_naming_dialing_enabled: When `true` auto attendant dailing by first or last name is enabled.
        :type aa_naming_dialing_enabled: str
        :param enable_phone_status_directory_privacy: When `true` phone status directory privacy is enabled.
        :type enable_phone_status_directory_privacy: str
        :param monitoring_agents: List of monitoring person IDs.
        :type monitoring_agents: list[str]
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['aaExtensionDialingEnabled'] = aa_extension_dialing_enabled
        body['aaNamingDialingEnabled'] = aa_naming_dialing_enabled
        body['enablePhoneStatusDirectoryPrivacy'] = enable_phone_status_directory_privacy
        body['monitoringAgents'] = monitoring_agents
        url = self.ep(f'people/{person_id}/features/privacy')
        super().put(url, params=params, json=body)

    def read_push_to_talk_settings_for_a_person(self, person_id: str, org_id: str = None) -> PushToTalkInfo1:
        """
        Read Push-to-Talk Settings for a Person

        Retrieve a person's Push-to-Talk settings.

        Push-to-Talk allows the use of desk phones as either a one-way or two-way intercom that connects people in
        different parts of your organization.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`PushToTalkInfo1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/pushToTalk')
        data = super().get(url, params=params)
        r = PushToTalkInfo1.model_validate(data)
        return r

    def configure_push_to_talk_settings_for_a_person(self, person_id: str, allow_auto_answer: bool,
                                                     connection_type: PushToTalkConnectionType,
                                                     access_type: PushToTalkAccessType, members: list[str],
                                                     org_id: str = None):
        """
        Configure Push-to-Talk Settings for a Person

        Configure a person's Push-to-Talk settings.

        Push-to-Talk allows the use of desk phones as either a one-way or two-way intercom that connects people in
        different parts of your organization.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param allow_auto_answer: `true` if Push-to-Talk feature is enabled.
        :type allow_auto_answer: bool
        :param connection_type: Specifies the connection type to be used.
        :type connection_type: PushToTalkConnectionType
        :param access_type: Specifies the access type to be applied when evaluating the member list.
        :type access_type: PushToTalkAccessType
        :param members: List of people that are allowed or disallowed to interact using the Push-to-Talk feature.
        :type members: list[str]
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['allowAutoAnswer'] = allow_auto_answer
        body['connectionType'] = enum_str(connection_type)
        body['accessType'] = enum_str(access_type)
        body['members'] = members
        url = self.ep(f'people/{person_id}/features/pushToTalk')
        super().put(url, params=params, json=body)

    def read_receptionist_client_settings_for_a_person(self, person_id: str, org_id: str = None) -> ReceptionInfo1:
        """
        Read Receptionist Client Settings for a Person

        Retrieve a person's Receptionist Client settings.

        To help support the needs of your front-office personnel, you can set up people, workspaces or virtual lines as
        telephone attendants so that they can screen all incoming calls to certain numbers within your organization.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`ReceptionInfo1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/reception')
        data = super().get(url, params=params)
        r = ReceptionInfo1.model_validate(data)
        return r

    def configure_receptionist_client_settings_for_a_person(self, person_id: str, reception_enabled: bool,
                                                            monitored_members: list[str], org_id: str = None):
        """
        Configure Receptionist Client Settings for a Person

        Configure a person's Receptionist Client settings.

        To help support the needs of your front-office personnel, you can set up people, workspaces or virtual lines as
        telephone attendants so that they can screen all incoming calls to certain numbers within your organization.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param reception_enabled: `true` if the Receptionist Client feature is enabled.
        :type reception_enabled: bool
        :param monitored_members: List of members' unique identifiers to monitor.
        :type monitored_members: list[str]
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['receptionEnabled'] = reception_enabled
        body['monitoredMembers'] = monitored_members
        url = self.ep(f'people/{person_id}/features/reception')
        super().put(url, params=params, json=body)

    def list_of_schedules_for_a_person(self, person_id: str, org_id: str = None, start: int = None, name: str = None,
                                       type: str = None, **params) -> Generator[ScheduleShortDetails, None, None]:
        """
        List of Schedules for a Person

        List schedules for a person in an organization.

        Schedules are used to support calling features and can be defined at the location or person level.
        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full, user, or read-only administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :param start: Specifies the offset from the first result that you want to fetch.
        :type start: int
        :param name: Specifies the case insensitive substring to be matched against the schedule names. The maximum
            length is 40.
        :type name: str
        :param type: Specifies the schedule event type to be matched on the given type.
        :type type: str
        :return: Generator yielding :class:`ScheduleShortDetails` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if start is not None:
            params['start'] = start
        if name is not None:
            params['name'] = name
        if type is not None:
            params['type'] = type
        url = self.ep(f'people/{person_id}/features/schedules')
        return self.session.follow_pagination(url=url, model=ScheduleShortDetails, item_key='schedules', params=params)

    def create_schedule_for_a_person(self, person_id: str, name: str, type: GetScheduleObjectType,
                                     events: list[EventLongDetails], org_id: str = None) -> str:
        """
        Create Schedule for a Person

        Create a new schedule for a person.

        Schedules are used to support calling features and can be defined at the location or person level.
        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param name: Name for the schedule.
        :type name: str
        :param type: Indicates the schedule type whether `businessHours` or `holidays`.
        :type type: GetScheduleObjectType
        :param events: Indicates a list of events.
        :type events: list[EventLongDetails]
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['type'] = enum_str(type)
        body['events'] = loads(TypeAdapter(list[EventLongDetails]).dump_json(events))
        url = self.ep(f'people/{person_id}/features/schedules')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def get_a_schedule_details(self, person_id: str, schedule_type: ScheduleType, schedule_id: str,
                               org_id: str = None) -> ScheduleLongDetails:
        """
        Get a Schedule Details

        Retrieve a schedule by its schedule ID.

        Schedules are used to support calling features and can be defined at the location or person level.
        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full, user, or read-only administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either `businessHours` or `holidays`.
        :type schedule_type: ScheduleType
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`ScheduleLongDetails`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}')
        data = super().get(url, params=params)
        r = ScheduleLongDetails.model_validate(data)
        return r

    def update_a_schedule(self, person_id: str, schedule_type: ScheduleType, schedule_id: str, new_name: str,
                          name: str, type: GetScheduleObjectType, events: list[EventLongDetails],
                          org_id: str = None) -> str:
        """
        Update a Schedule

        Modify a schedule by its schedule ID.

        Schedules are used to support calling features and can be defined at the location or person level.
        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either `businessHours` or `holidays`.
        :type schedule_type: ScheduleType
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param new_name: New name for the schedule.
        :type new_name: str
        :param name: Name for the schedule.
        :type name: str
        :param type: Indicates the schedule type whether `businessHours` or `holidays`.
        :type type: GetScheduleObjectType
        :param events: Indicates a list of events.
        :type events: list[EventLongDetails]
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['newName'] = new_name
        body['name'] = name
        body['type'] = enum_str(type)
        body['events'] = loads(TypeAdapter(list[EventLongDetails]).dump_json(events))
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def delete_a_schedule(self, person_id: str, schedule_type: ScheduleType, schedule_id: str, org_id: str = None):
        """
        Delete a Schedule

        Delete a schedule by its schedule ID.

        Schedules are used to support calling features and can be defined at the location or person level.
        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either `businessHours` or `holidays`.
        :type schedule_type: ScheduleType
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}')
        super().delete(url, params=params)

    def fetch_event_for_a_person_s_schedule(self, person_id: str, schedule_type: ScheduleType, schedule_id: str,
                                            event_id: str, org_id: str = None) -> GetEvent:
        """
        Fetch Event for a person's Schedule

        People can use shared location schedules or define personal schedules containing events.

        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full, user, or read-only administrator auth token with a scope of
        `spark-admin:people_read`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either `businessHours` or `holidays`.
        :type schedule_type: ScheduleType
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param event_id: Unique identifier for the event.
        :type event_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`GetEvent`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events/{event_id}')
        data = super().get(url, params=params)
        r = GetEvent.model_validate(data)
        return r

    def add_a_new_event_for_person_s_schedule(self, person_id: str, schedule_type: ScheduleType, schedule_id: str,
                                              name: str, start_date: Union[str, datetime], end_date: Union[str,
                                              datetime], start_time: Union[str, datetime], end_time: Union[str,
                                              datetime], all_day_enabled: bool,
                                              recurrence: EventLongDetailsRecurrence, org_id: str = None) -> str:
        """
        Add a New Event for Person's Schedule

        People can use shared location schedules or define personal schedules containing events.

        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either `businessHours` or `holidays`.
        :type schedule_type: ScheduleType
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start date of the event, or first occurrence if repeating, in the format of `YYYY-MM-DD`.
            This field is required if the `allDayEnabled` field is present.
        :type start_date: Union[str, datetime]
        :param end_date: End date of the event, or first occurrence if repeating, in the format of `YYYY-MM-DD`.  This
            field is required if the `allDayEnabled` field is present.
        :type end_date: Union[str, datetime]
        :param start_time: Start time of the event in the format of `HH:MM` (24 hours format).  This field is required
            if the `allDayEnabled` field is false or omitted.
        :type start_time: Union[str, datetime]
        :param end_time: End time of the event in the format of `HH:MM` (24 hours format).  This field is required if
            the `allDayEnabled` field is false or omitted.
        :type end_time: Union[str, datetime]
        :param all_day_enabled: True if it is all-day event.
        :type all_day_enabled: bool
        :param recurrence: Recurrance scheme for an event.
        :type recurrence: EventLongDetailsRecurrence
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['name'] = name
        body['startDate'] = start_date
        body['endDate'] = end_date
        body['startTime'] = start_time
        body['endTime'] = end_time
        body['allDayEnabled'] = all_day_enabled
        body['recurrence'] = loads(recurrence.model_dump_json())
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events')
        data = super().post(url, params=params, json=body)
        r = data['id']
        return r

    def update_an_event_for_a_person_s_schedule(self, person_id: str, schedule_type: ScheduleType, schedule_id: str,
                                                event_id: str, new_name: str, name: str, start_date: Union[str,
                                                datetime], end_date: Union[str, datetime], start_time: Union[str,
                                                datetime], end_time: Union[str, datetime], all_day_enabled: bool,
                                                recurrence: EventLongDetailsRecurrence, org_id: str = None) -> str:
        """
        Update an Event for a person's Schedule

        People can use shared location schedules or define personal schedules containing events.

        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either `businessHours` or `holidays`.
        :type schedule_type: ScheduleType
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param event_id: Unique identifier for the event.
        :type event_id: str
        :param new_name: New name for the event.
        :type new_name: str
        :param name: Name for the event.
        :type name: str
        :param start_date: Start date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD.
            This field is required if the `allDayEnabled` field is present.
        :type start_date: Union[str, datetime]
        :param end_date: End date of the event, or first occurrence if repeating, in the format of YYYY-MM-DD.  This
            field is required if the `allDayEnabled` field is present.
        :type end_date: Union[str, datetime]
        :param start_time: Start time of the event in the format of HH:MM (24 hours format).  This field is required if
            the `allDayEnabled` field is false or omitted.
        :type start_time: Union[str, datetime]
        :param end_time: End time of the event in the format of HH:MM (24 hours format).  This field is required if the
            `allDayEnabled` field is false or omitted.
        :type end_time: Union[str, datetime]
        :param all_day_enabled: True if it is all-day event.
        :type all_day_enabled: bool
        :param recurrence: Recurrance scheme for an event.
        :type recurrence: EventLongDetailsRecurrence
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: str
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['newName'] = new_name
        body['name'] = name
        body['startDate'] = start_date
        body['endDate'] = end_date
        body['startTime'] = start_time
        body['endTime'] = end_time
        body['allDayEnabled'] = all_day_enabled
        body['recurrence'] = loads(recurrence.model_dump_json())
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events/{event_id}')
        data = super().put(url, params=params, json=body)
        r = data['id']
        return r

    def delete_an_event_for_a_person_s_schedule(self, person_id: str, schedule_type: ScheduleType, schedule_id: str,
                                                event_id: str, org_id: str = None):
        """
        Delete an Event for a person's Schedule

        People can use shared location schedules or define personal schedules containing events.

        `businessHours` schedules allow you to apply specific call settings at different times of the day or week by
        defining one or more events. `holidays` schedules define exceptions to normal business hours by defining one
        or more events.

        This API requires a full or user administrator auth token with the `spark-admin:people_write` scope.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param schedule_type: Type of schedule, either `businessHours` or `holidays`.
        :type schedule_type: ScheduleType
        :param schedule_id: Unique identifier for the schedule.
        :type schedule_id: str
        :param event_id: Unique identifier for the event.
        :type event_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/schedules/{schedule_type}/{schedule_id}/events/{event_id}')
        super().delete(url, params=params)

    def search_shared_line_appearance_members(self, person_id: str, application_id: str, max_: str = None,
                                              start: str = None, location: str = None, name: str = None,
                                              number: str = None, order: str = None, extension: Union[str,
                                              datetime] = None) -> list[AvailableSharedLineMemberItem1]:
        """
        Search Shared-Line Appearance Members

        Get members available for shared-line assignment to a Webex Calling Apps Desktop device.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_read` scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str
        :param max_: Number of records per page.
        :type max_: str
        :param start: Page number.
        :type start: str
        :param location: Location ID for the user.
        :type location: str
        :param name: Search for users with names that match the query.
        :type name: str
        :param number: Search for users with numbers that match the query.
        :type number: str
        :param order: Sort by first name (`fname`) or last name (`lname`).
        :type order: str
        :param extension: Search for users with extensions that match the query.
        :type extension: Union[str, datetime]
        :rtype: list[AvailableSharedLineMemberItem1]
        """
        body = dict()
        body['max'] = max_
        body['start'] = start
        body['location'] = location
        body['name'] = name
        body['number'] = number
        body['order'] = order
        body['extension'] = extension
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/availableMembers')
        data = super().get(url, json=body)
        r = TypeAdapter(list[AvailableSharedLineMemberItem1]).validate_python(data['members'])
        return r

    def get_shared_line_appearance_members(self, person_id: str, application_id: str) -> GetSharedLineMemberList1:
        """
        Get Shared-Line Appearance Members

        Get primary and secondary members assigned to a shared line on a Webex Calling Apps Desktop device.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_read` scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str
        :rtype: :class:`GetSharedLineMemberList1`
        """
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/members')
        data = super().get(url)
        r = GetSharedLineMemberList1.model_validate(data)
        return r

    def put_shared_line_appearance_members(self, person_id: str, application_id: str,
                                           members: list[PutSharedLineMemberItem]):
        """
        Put Shared-Line Appearance Members

        Add or modify primary and secondary users assigned to shared-lines on a Webex Calling Apps Desktop device.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        :param person_id: A unique identifier for the person.
        :type person_id: str
        :param application_id: A unique identifier for the application.
        :type application_id: str
        :type members: list[PutSharedLineMemberItem]
        :rtype: None
        """
        body = dict()
        body['members'] = loads(TypeAdapter(list[PutSharedLineMemberItem]).dump_json(members))
        url = self.ep(f'telephony/config/people/{person_id}/applications/{application_id}/members')
        super().put(url, json=body)

    def read_voicemail_settings_for_a_person(self, person_id: str, org_id: str = None) -> VoicemailInfo:
        """
        Read Voicemail Settings for a Person

        Retrieve a person's Voicemail settings.

        The voicemail feature transfers callers to voicemail based on your settings. You can then retrieve voice
        messages via Voicemail. Voicemail audio is sent in Waveform Audio File Format, `.wav`, format.

        Optionally, notifications can be sent to a mobile phone via text or email. These notifications will not include
        the voicemail files.

        This API requires a full, user, or read-only administrator or location administrator auth token with a scope of
        `spark-admin:people_read` or a user auth token with `spark:people_read` scope can be used by a person to read
        their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`VoicemailInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail')
        data = super().get(url, params=params)
        r = VoicemailInfo.model_validate(data)
        return r

    def configure_voicemail_settings_for_a_person(self, person_id: str, enabled: bool,
                                                  send_all_calls: ModifyCallRecordingSettingsObject,
                                                  send_busy_calls: VoicemailPutSendBusyCalls,
                                                  send_unanswered_calls: VoicemailPutSendUnansweredCalls,
                                                  notifications: GetLocationVoicemailGroupObjectNotifications,
                                                  transfer_to_number: VoicemailInfoTransferToNumber,
                                                  email_copy_of_message: GetLocationVoicemailGroupObjectEmailCopyOfMessage,
                                                  message_storage: VoicemailInfoMessageStorage,
                                                  fax_message: VoicemailInfoFaxMessage, org_id: str = None):
        """
        Configure Voicemail Settings for a Person

        Configure a person's Voicemail settings.

        The voicemail feature transfers callers to voicemail based on your settings. You can then retrieve voice
        messages via Voicemail. Voicemail audio is sent in Waveform Audio File Format, `.wav`, format.

        Optionally, notifications can be sent to a mobile phone via text or email. These notifications will not include
        the voicemail files.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope or a user auth token with `spark:people_write` scope can be used by a person
        to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param enabled: Voicemail is enabled or disabled.
        :type enabled: bool
        :param send_all_calls: Settings for sending all calls to voicemail.
        :type send_all_calls: ModifyCallRecordingSettingsObject
        :param send_busy_calls: Settings for sending calls to voicemail when the line is busy.
        :type send_busy_calls: VoicemailPutSendBusyCalls
        :type send_unanswered_calls: VoicemailPutSendUnansweredCalls
        :param notifications: Settings for notifications when there are any new voicemails.
        :type notifications: GetLocationVoicemailGroupObjectNotifications
        :param transfer_to_number: Settings for voicemail caller to transfer to a different number by pressing zero
            (0).
        :type transfer_to_number: VoicemailInfoTransferToNumber
        :param email_copy_of_message: Settings for sending a copy of new voicemail message audio via email.
        :type email_copy_of_message: GetLocationVoicemailGroupObjectEmailCopyOfMessage
        :type message_storage: VoicemailInfoMessageStorage
        :type fax_message: VoicemailInfoFaxMessage
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['sendAllCalls'] = loads(send_all_calls.model_dump_json())
        body['sendBusyCalls'] = loads(send_busy_calls.model_dump_json())
        body['sendUnansweredCalls'] = loads(send_unanswered_calls.model_dump_json())
        body['notifications'] = loads(notifications.model_dump_json())
        body['transferToNumber'] = loads(transfer_to_number.model_dump_json())
        body['emailCopyOfMessage'] = loads(email_copy_of_message.model_dump_json())
        body['messageStorage'] = loads(message_storage.model_dump_json())
        body['faxMessage'] = loads(fax_message.model_dump_json())
        url = self.ep(f'people/{person_id}/features/voicemail')
        super().put(url, params=params, json=body)

    def configure_busy_voicemail_greeting_for_a_person(self, person_id: str, org_id: str = None):
        """
        Configure Busy Voicemail Greeting for a Person

        Configure a person's Busy Voicemail Greeting by uploading a Waveform Audio File Format, `.wav`, encoded audio
        file.

        Your request will need to be a `multipart/form-data` request rather than JSON, using the `audio/wav`
        Content-Type.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope or a user auth token with `spark:people_write` scope can be used by a person
        to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail/actions/uploadBusyGreeting/invoke')
        super().post(url, params=params)

    def configure_no_answer_voicemail_greeting_for_a_person(self, person_id: str, org_id: str = None):
        """
        Configure No Answer Voicemail Greeting for a Person

        Configure a person's No Answer Voicemail Greeting by uploading a Waveform Audio File Format, `.wav`, encoded
        audio file.

        Your request will need to be a `multipart/form-data` request rather than JSON, using the `audio/wav`
        Content-Type.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope or a user auth token with `spark:people_write` scope can be used by a person
        to update their settings.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail/actions/uploadNoAnswerGreeting/invoke')
        super().post(url, params=params)

    def reset_voicemail_pin(self, person_id: str, org_id: str = None):
        """
        Reset Voicemail PIN

        Reset a voicemail PIN for a person.

        The voicemail feature transfers callers to voicemail based on your settings. You can then retrieve voice
        messages via Voicemail.  A voicemail PIN is used to retrieve your voicemail messages.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:people_write` scope.

        **NOTE**: This API is expected to have an empty request body and Content-Type header should be set to
        `application/json`.

        :param person_id: Unique identifier for the person.
        :type person_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'people/{person_id}/features/voicemail/actions/resetPin/invoke')
        super().post(url, params=params)

    def get_message_summary(self) -> GetMessageSummaryResponse:
        """
        Get Message Summary

        Get a summary of the voicemail messages for the user.

        :rtype: :class:`GetMessageSummaryResponse`
        """
        url = self.ep('telephony/voiceMessages/summary')
        data = super().get(url)
        r = GetMessageSummaryResponse.model_validate(data)
        return r

    def list_messages(self) -> list[VoiceMessageDetails]:
        """
        List Messages

        Get the list of all voicemail messages for the user.

        :rtype: list[VoiceMessageDetails]
        """
        url = self.ep('telephony/voiceMessages')
        data = super().get(url)
        r = TypeAdapter(list[VoiceMessageDetails]).validate_python(data['items'])
        return r

    def delete_message(self, message_id: str):
        """
        Delete Message

        Delete a specfic voicemail message for the user.

        :param message_id: The message identifer of the voicemail message to delete
        :type message_id: str
        :rtype: None
        """
        url = self.ep(f'telephony/voiceMessages/{message_id}')
        super().delete(url)

    def mark_as_read(self, message_id: str = None):
        """
        Mark As Read

        Update the voicemail message(s) as read for the user.

        If the `messageId` is provided, then only mark that message as read.  Otherwise, all messages for the user are
        marked as read.

        :param message_id: The voicemail message identifier of the message to mark as read.  If the `messageId` is not
            provided, then all voicemail messages for the user are marked as read.
        :type message_id: str
        :rtype: None
        """
        body = dict()
        body['messageId'] = message_id
        url = self.ep('telephony/voiceMessages/markAsRead')
        super().post(url, json=body)

    def mark_as_unread(self, message_id: str = None):
        """
        Mark As Unread

        Update the voicemail message(s) as unread for the user.

        If the `messageId` is provided, then only mark that message as unread.  Otherwise, all messages for the user
        are marked as unread.

        :param message_id: The voicemail message identifier of the message to mark as unread.  If the `messageId` is
            not provided, then all voicemail messages for the user are marked as unread.
        :type message_id: str
        :rtype: None
        """
        body = dict()
        body['messageId'] = message_id
        url = self.ep('telephony/voiceMessages/markAsUnread')
        super().post(url, json=body)

    def modify_a_device_s_hoteling_settings(self, person_id: str, hoteling: Hoteling, org_id: str = None):
        """
        Modify a device's hoteling settings

        Modify hoteling for a person's Webex Calling Device.

        Modifying devices for a person requires a full administrator or location administrator auth token with a scope
        of `spark-admin:telephony_config_write`.

        :param person_id: ID of the person associated with the device.
        :type person_id: str
        :param hoteling: Modify person Device Hoteling Setting.
        :type hoteling: Hoteling
        :param org_id: Organization to which the person belongs.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['hoteling'] = loads(hoteling.model_dump_json())
        url = self.ep(f'telephony/config/people/{person_id}/devices/settings/hoteling')
        super().put(url, params=params, json=body)


class VideoMeshClientTypeDistributionAPIApi(ApiChild, base='videoMesh/clientTypeDistribution'):
    """
    Video Mesh Client Type Distribution API
    
    Video Mesh Developer APIs enable organization admins to view Client Type Distribution details from the Developer
    Portal or their own monitoring application.
    
    <br>
    
    <b>NOTE:</b> The APIs will return data for all device types if the "deviceType" request parameter is empty.
    
    <br>
    
    To obtain the Organization ID needed for these APIs, use the `Organizations API
    <https://developer.webex.com/docs/api/v1/organizations/list-organizations>`_.
    """

    def list_cluster_client_type_distribution_details(self, org_id: str, from_: Union[str, datetime], to_: Union[str,
                                                      datetime],
                                                      device_type: str) -> list[ClienttypedistributionCollectionforOrg]:
        """
        List Cluster Client Type Distribution details

        Returns the client type distribution details for all Video Mesh clusters in an organization.

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param device_type: Device type(s).

        - Possible values:
        `webexDevices` `webexAppVdi` `webexForMobile` `sipEndpoint` `webexForDesktop`
        :type device_type: str
        :rtype: list[ClienttypedistributionCollectionforOrg]
        """
        params = {}
        params['orgId'] = org_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['deviceType'] = device_type
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClienttypedistributionCollectionforOrg]).validate_python(data['items'])
        return r

    def get_cluster_client_type_distribution_details(self, cluster_id: str, from_: Union[str, datetime],
                                                     to_: Union[str, datetime],
                                                     device_type: str) -> list[ClienttypedistributionCollectionforOrg]:
        """
        Get Cluster Client Type Distribution details

        Returns the client type distribution details for a single Video Mesh cluster.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param device_type: Device type(s).

        - Possible values:
        `webexDevices` `webexAppVdi` `webexForMobile` `sipEndpoint` `webexForDesktop`
        :type device_type: str
        :rtype: list[ClienttypedistributionCollectionforOrg]
        """
        params = {}
        params['clusterId'] = cluster_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['deviceType'] = device_type
        url = self.ep('clusters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClienttypedistributionCollectionforOrg]).validate_python(data['items'])
        return r


class VideoMeshApi(ApiChild, base='videoMesh'):
    """
    Video Mesh
    
    The Video Mesh Developer APIs provide the ability for organization admins to retrieve analytics and monitoring
    data, trigger on-demand troubleshooting tests (Media Health Monitoring Tool, Network, and Reachability), and
    getting and setting thresholds for Webhook events from the Developer Portal or their own monitoring applications,
    which can help in quickly isolating and identifying root cause of issues affecting the normal functioning of a
    customer's Video Mesh Deployment.
    
    <br/>
    
    <b>NOTE:</b> The Media Health Monitor Test and Reachability Test can be triggered only on clusters that are not
    reserved for private meetings.
    
    <br>
    
    To obtain the Organization ID needed for these APIs, use the `Organizations API
    <https://developer.webex.com/docs/api/v1/organizations/list-organizations>`_
    """

    def list_clusters_availability(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                   org_id: str) -> list[ClusterAvailabilityCollection]:
        """
        List Clusters Availability

        Returns the availability details for all Video Mesh clusters in an organization.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param org_id: The unique ID for the organization.
        :type org_id: str
        :rtype: list[ClusterAvailabilityCollection]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('clusters/availability')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClusterAvailabilityCollection]).validate_python(data['items'])
        return r

    def get_cluster_availability(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                 cluster_id: str) -> list[ClusterAvailabilityCollection]:
        """
        Get Cluster Availability

        Returns the availability details of a single Video Mesh cluster in an organization.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param cluster_id: The unique Video Mesh clusterID
        :type cluster_id: str
        :rtype: list[ClusterAvailabilityCollection]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        url = self.ep(f'clusters/availability/{cluster_id}')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClusterAvailabilityCollection]).validate_python(data['items'])
        return r

    def list_node_availability(self, from_: Union[str, datetime], to_: Union[str, datetime],
                               cluster_id: str) -> list[NodeAvailabilityCollection]:
        """
        List Node Availability

        Returns the availability details of all nodes in a Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param cluster_id: The unique Video Mesh cluster ID.
        :type cluster_id: str
        :rtype: list[NodeAvailabilityCollection]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('nodes/availability')
        data = super().get(url, params=params)
        r = TypeAdapter(list[NodeAvailabilityCollection]).validate_python(data['items'])
        return r

    def get_node_availability(self, from_: Union[str, datetime], to_: Union[str, datetime],
                              node_id: str) -> list[SingleNodeAvailabilityCollection]:
        """
        Get Node Availability

        Returns the availability details of a single node in a Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param node_id: The unique Video Mesh node ID.
        :type node_id: str
        :rtype: list[SingleNodeAvailabilityCollection]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        url = self.ep(f'nodes/availability/{node_id}')
        data = super().get(url, params=params)
        r = TypeAdapter(list[SingleNodeAvailabilityCollection]).validate_python(data['items'])
        return r

    def list_media_health_monitoring_tool_results(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                                  org_id: str) -> list[MediaHealthMonitoringResultsCollectionfororganization]:
        """
        List Media Health Monitoring Tool results

        <div><Callout type="warning"> This API is EOL and will be decommissioned soon. Please start using the
        replacement `List Media Health Monitoring Tool Test results V2 API
        <https://developer.webex.com/docs/api/v1/video-mesh/list-media-health-monitoring-tool-test-results-v2>`_ for all future projects.</Callout></div>

        Returns the test results of the Media Health Monitoring Tool tests for an organization.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`. `from` must not be older than 1 week.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param org_id: The unique Video Mesh organization ID.
        :type org_id: str
        :rtype: list[MediaHealthMonitoringResultsCollectionfororganization]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('mediaHealthMonitor')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MediaHealthMonitoringResultsCollectionfororganization]).validate_python(data['items'])
        return r

    def list_media_health_monitoring_tool_test_results_v2(self, org_id: str, from_: Union[str, datetime],
                                                          to_: Union[str, datetime],
                                                          trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> MediaHealthMonitoringResultsCollectionfororganization:
        """
        List Media Health Monitoring Tool Test results V2

        Returns the test results of the Media Health Monitoring Tool tests for an organization.

        <br/>

        Changes in V2:

        <br/>

        On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`MediaHealthMonitoringResultsCollectionfororganization`
        """
        params = {}
        params['orgId'] = org_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/mediaHealthMonitorTest')
        data = super().get(url, params=params)
        r = MediaHealthMonitoringResultsCollectionfororganization.model_validate(data)
        return r

    def get_media_health_monitoring_tool_cluster_results(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                                         cluster_id: str) -> list[MediaHealthMonitoringResultsCollectionfororganization]:
        """
        Get Media Health Monitoring Tool Cluster results

        <div><Callout type="warning"> This API is EOL and will be decommissioned soon. Please start using the
        replacement `Get Media Health Monitoring Tool Test results for clusters V2 API
        <https://developer.webex.com/docs/api/v1/video-mesh/get-media-health-monitoring-tool-test-results-for-cluster-v2>`_ for all future
        projects.</Callout></div>

        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`. `from` must not be older than 1 week.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str
        :rtype: list[MediaHealthMonitoringResultsCollectionfororganization]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('mediaHealthMonitor/clusters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MediaHealthMonitoringResultsCollectionfororganization]).validate_python(data['items'])
        return r

    def get_media_health_monitoring_tool_test_results_for_clusters_v2(self, cluster_id: str, from_: Union[str,
                                                                      datetime], to_: Union[str, datetime],
                                                                      trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> MediaHealthMonitoringResultsCollectionfororganization:
        """
        Get Media Health Monitoring Tool Test results for clusters V2

        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh cluster.

        <br/>

        Changes in V2:

        <br/>

        On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`MediaHealthMonitoringResultsCollectionfororganization`
        """
        params = {}
        params['clusterId'] = cluster_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/mediaHealthMonitorTest/clusters')
        data = super().get(url, params=params)
        r = MediaHealthMonitoringResultsCollectionfororganization.model_validate(data)
        return r

    def get_media_health_monitoring_tool_node_results(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                                      node_id: str) -> list[MediaHealthMonitoringResultsCollectionfororganization]:
        """
        Get Media Health Monitoring Tool Node results

        <div><Callout type="warning"> This API is EOL and will be decommissioned soon. Please start using the
        replacement `Get Media Health Monitoring Tool Test results for node V2 API
        <https://developer.webex.com/docs/api/v1/video-mesh/get-media-health-monitoring-tool-test-results-for-node-v2>`_ for all future
        projects.</Callout></div>

        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh node.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`. `from` must not be older than 1 week.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param node_id: The unique Video Mesh Node ID.
        :type node_id: str
        :rtype: list[MediaHealthMonitoringResultsCollectionfororganization]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['nodeId'] = node_id
        url = self.ep('mediaHealthMonitor/nodes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[MediaHealthMonitoringResultsCollectionfororganization]).validate_python(data['items'])
        return r

    def get_media_health_monitoring_tool_test_results_for_node_v2(self, node_id: str, from_: Union[str, datetime],
                                                                  to_: Union[str, datetime],
                                                                  trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> MediaHealthMonitoringResultsCollectionfororganization:
        """
        Get Media Health Monitoring Tool Test results for node V2

        Returns the test results of the Media Health Monitoring Tool tests for a single Video Mesh node.

        <br/>

        Changes in V2:

        <br/>

        On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`MediaHealthMonitoringResultsCollectionfororganization`
        """
        params = {}
        params['nodeId'] = node_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/mediaHealthMonitorTest/nodes')
        data = super().get(url, params=params)
        r = MediaHealthMonitoringResultsCollectionfororganization.model_validate(data)
        return r

    def list_overflow_to_cloud_details(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                       org_id: str) -> list[OverflowtoCloudCollection]:
        """
        List Overflow to Cloud details

        Returns details of overflows to the cloud in an organization.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param org_id: The unique Video Mesh organization ID.
        :type org_id: str
        :rtype: list[OverflowtoCloudCollection]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('cloudOverflow')
        data = super().get(url, params=params)
        r = TypeAdapter(list[OverflowtoCloudCollection]).validate_python(data['items'])
        return r

    def list_cluster_redirect_details(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                      org_id: str) -> list[RedirectCollectionForOrg]:
        """
        List Cluster Redirect details

        Returns the redirect details of all Video Mesh clusters in an organization.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param org_id: The unique Video Mesh organization ID.
        :type org_id: str
        :rtype: list[RedirectCollectionForOrg]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('callRedirects')
        data = super().get(url, params=params)
        r = TypeAdapter(list[RedirectCollectionForOrg]).validate_python(data['items'])
        return r

    def get_cluster_redirect_details(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                     cluster_id: str) -> list[RedirectCollectionForOrg]:
        """
        Get Cluster Redirect details

        Returns details of cluster redirects for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str
        :rtype: list[RedirectCollectionForOrg]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('clusters/callRedirects')
        data = super().get(url, params=params)
        r = TypeAdapter(list[RedirectCollectionForOrg]).validate_python(data['items'])
        return r

    def list_clusters_utilization(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                  org_id: str) -> list[ClusterUtilizationCollection]:
        """
        List Clusters Utilization

        Returns the utilization details of all Video Mesh clusters in an organization.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param org_id: The unique ID for the organization.
        :type org_id: str
        :rtype: list[ClusterUtilizationCollection]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('utilization')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClusterUtilizationCollection]).validate_python(data['items'])
        return r

    def get_cluster_utilization_details(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                        cluster_id: str) -> list[ClusterUtilizationCollection]:
        """
        Get Cluster Utilization details

        Returns the utilization details for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str
        :rtype: list[ClusterUtilizationCollection]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('clusters/utilization')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClusterUtilizationCollection]).validate_python(data['items'])
        return r

    def list_reachability_test_results(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                       org_id: str) -> list[ReachabilityTestresultsfororganization]:
        """
        List Reachability Test results

        <div><Callout type="warning"> This API is EOL and will be decommissioned soon. Please start using the
        replacement `List Reachability Test results V2 API
        <https://developer.webex.com/docs/api/v1/video-mesh/list-reachability-test-results-v2>`_ for all future projects.</Callout></div>

        Returns the test results of the Reachability tests for an organization.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`.  `from` must not be older than 1 week.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param org_id: The unique ID for the organization.
        :type org_id: str
        :rtype: list[ReachabilityTestresultsfororganization]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['orgId'] = org_id
        url = self.ep('reachabilityTest')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ReachabilityTestresultsfororganization]).validate_python(data['items'])
        return r

    def list_reachability_test_results_v2(self, org_id: str, from_: Union[str, datetime], to_: Union[str, datetime],
                                          trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> ReachabilityTestresultsfororganization:
        """
        List Reachability Test results V2

        Returns the test results of the Reachability tests for an organization.

        <br/>

        Changes in V2:

        <br/>

        1. On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        <br/>

        2. You can now view the destination IP address of the destination cluster in the JSON response.

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`ReachabilityTestresultsfororganization`
        """
        params = {}
        params['orgId'] = org_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/reachabilityTest')
        data = super().get(url, params=params)
        r = ReachabilityTestresultsfororganization.model_validate(data)
        return r

    def get_reachability_test_results_for_cluster(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                                  cluster_id: str) -> list[ReachabilityTestresultsfororganization]:
        """
        Get Reachability Test results for Cluster

        <div><Callout type="warning"> This API is EOL and will be decommissioned soon. Please start using the
        replacement `Get Reachability Test results for cluster V2 API
        <https://developer.webex.com/docs/api/v1/video-mesh/get-reachability-test-results-for-cluster-v2>`_ for all future projects.</Callout></div>

        Returns the test results of the Reachability tests for a single Video Mesh cluster.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`. `from` must not be older than 1 week.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str
        :rtype: list[ReachabilityTestresultsfororganization]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['clusterId'] = cluster_id
        url = self.ep('reachabilityTest/clusters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ReachabilityTestresultsfororganization]).validate_python(data['items'])
        return r

    def get_reachability_test_results_for_cluster_v2(self, cluster_id: str, from_: Union[str, datetime],
                                                     to_: Union[str, datetime],
                                                     trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> ReachabilityTestresultsfororganization:
        """
        Get Reachability Test results for cluster V2

        Returns the test results of the Reachability tests for a single Video Mesh cluster.

        <br/>

        Changes in V2:

        <br/>

        1. On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        <br/>

        2. You can now view the destination IP address of the destination cluster in the JSON response.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`ReachabilityTestresultsfororganization`
        """
        params = {}
        params['clusterId'] = cluster_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/reachabilityTest/clusters')
        data = super().get(url, params=params)
        r = ReachabilityTestresultsfororganization.model_validate(data)
        return r

    def get_reachability_test_results_for_node(self, from_: Union[str, datetime], to_: Union[str, datetime],
                                               node_id: str) -> list[ReachabilityTestresultsfororganization]:
        """
        Get Reachability Test results for Node

        <div><Callout type="warning"> This API is EOL and will be decommissioned soon. Please start using the
        replacement `Get Reachability Test results for node V2 API
        <https://developer.webex.com/docs/api/v1/video-mesh/get-reachability-test-results-for-node-v2>`_ for all future projects.</Callout></div>

        Returns the test results of the Reachability tests for a single Video Mesh node.

        :param from_: The starting date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. `from` cannot
            be after `to`. `from` must not be older than 1 week.
        :type from_: Union[str, datetime]
        :param to_: The ending date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param node_id: The unique Video Mesh node ID.
        :type node_id: str
        :rtype: list[ReachabilityTestresultsfororganization]
        """
        params = {}
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['nodeId'] = node_id
        url = self.ep('reachabilityTest/nodes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ReachabilityTestresultsfororganization]).validate_python(data['items'])
        return r

    def get_reachability_test_results_for_node_v2(self, node_id: str, from_: Union[str, datetime], to_: Union[str,
                                                  datetime],
                                                  trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> ReachabilityTestresultsfororganization:
        """
        Get Reachability Test results for node V2

        Returns the test results of the Reachability tests for a single Video Mesh node.

        <br/>

        Changes in V2:

        <br/>

        1. On-demand test results can be obtained along with the periodic tests that are executed on Video Mesh nodes.

        <br/>

        2. You can now view the destination IP address of the destination cluster in the JSON response.

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`ReachabilityTestresultsfororganization`
        """
        params = {}
        params['nodeId'] = node_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/reachabilityTest/nodes')
        data = super().get(url, params=params)
        r = ReachabilityTestresultsfororganization.model_validate(data)
        return r

    def list_cluster_details(self, org_id: str) -> list[ClusterDetailsCollection]:
        """
        List Cluster Details

        Returns the cluster details of all Video Mesh clusters in an organization.

        :param org_id: The unique ID for the organization.
        :type org_id: str
        :rtype: list[ClusterDetailsCollection]
        """
        params = {}
        params['orgId'] = org_id
        url = self.ep('clusters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClusterDetailsCollection]).validate_python(data['items'])
        return r

    def get_cluster_details(self, cluster_id: str) -> list[ClusterDetailsCollection]:
        """
        Get Cluster Details

        Returns the cluster details for a single Video Mesh cluster.

        :param cluster_id: The unique Video Mesh Cluster ID.
        :type cluster_id: str
        :rtype: list[ClusterDetailsCollection]
        """
        url = self.ep(f'clusters/{cluster_id}')
        data = super().get(url)
        r = TypeAdapter(list[ClusterDetailsCollection]).validate_python(data['items'])
        return r

    def trigger_on_demand_test_for_cluster(self, cluster_id: str, type: TriggerOnDemandBodyType,
                                           nodes: list[str]) -> TriggeredTestStatus1:
        """
        Trigger on-demand test for cluster

        Triggers an on-demand test for a cluster.
        The test is run on a maximum of 10 nodes present in the cluster, chosen at random, or based on input from the
        user.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param type: Test type to trigger on node.
        :type type: TriggerOnDemandBodyType
        :param nodes: List of nodes to test.
        :type nodes: list[str]
        :rtype: :class:`TriggeredTestStatus1`
        """
        body = dict()
        body['type'] = enum_str(type)
        body['nodes'] = nodes
        url = self.ep(f'triggerTest/clusters/{cluster_id}')
        data = super().post(url, json=body)
        r = TriggeredTestStatus1.model_validate(data)
        return r

    def trigger_on_demand_test_for_node(self, node_id: str, type: TriggerOnDemandBodyType) -> TriggeredTestStatus1:
        """
        Trigger on-demand test for node

        Triggers an on-demand test for a node.

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param type: Test type to trigger on node.
        :type type: TriggerOnDemandBodyType
        :rtype: :class:`TriggeredTestStatus1`
        """
        body = dict()
        body['type'] = enum_str(type)
        url = self.ep(f'triggerTest/nodes/{node_id}')
        data = super().post(url, json=body)
        r = TriggeredTestStatus1.model_validate(data)
        return r

    def get_triggered_test_status(self, command_id: str) -> TriggeredTestStatus1:
        """
        Get Triggered test status

        Returns the status of the test triggered using the Trigger on-demand test API.

        :param command_id: The unique command ID generated from Trigger on-demand test API.
        :type command_id: str
        :rtype: :class:`TriggeredTestStatus1`
        """
        params = {}
        params['commandId'] = command_id
        url = self.ep('testStatus')
        data = super().get(url, params=params)
        r = TriggeredTestStatus1.model_validate(data)
        return r

    def get_triggered_test_results(self, command_id: str) -> TriggeredTestResult:
        """
        Get Triggered test results

        Returns the results of the test triggered using the command ID.<br/>
        <b>NOTE:</b> The response format depends on the type of test triggered and it is the same as that of
        `NetworkTest API
        <https://developer.webex.com/docs/api/v1/video-mesh/list-network-test-results>`_, `MediaHealthMonitorTest API

        :param command_id: The unique command ID generated from Trigger on-demand test API.
        :type command_id: str
        :rtype: :class:`TriggeredTestResult`
        """
        params = {}
        params['commandId'] = command_id
        url = self.ep('testResults')
        data = super().get(url, params=params)
        r = TriggeredTestResult.model_validate(data)
        return r

    def list_network_test_results(self, org_id: str, from_: Union[str, datetime], to_: Union[str, datetime],
                                  trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> ConnectivityTestResultsObject:
        """
        List Network Test results

        Returns the test results of the Network tests triggered for an organization. The tests listed below are run as
        a part of the Network Test execution on the node.

        <b>Bandwidth Test</b> - Tests the bandwidth parameters of the Video Mesh node's network. The test is run
        between the Video Mesh node and cloud services.<br/>
        <b>DNS Resolution Test</b> - Tests the resolution of IP addresses related to cloud services, against the DNS
        servers configured on the Video Mesh node's network.<br/>
        <b>HTTPS Connectivity Test</b> - Tests whether the Video Mesh node is able to connect to cloud services via
        HTTPS protocol.<br/>
        <b>Websocket Connectivity Test</b> - Tests whether the Video Mesh node is able to connect to Webex cloud
        services via Websocket.<br/>

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`ConnectivityTestResultsObject`
        """
        params = {}
        params['orgId'] = org_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/networkTest')
        data = super().get(url, params=params)
        r = ConnectivityTestResultsObject.model_validate(data)
        return r

    def get_network_test_results_for_cluster(self, cluster_id: str, from_: Union[str, datetime], to_: Union[str,
                                             datetime],
                                             trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> ConnectivityTestResultsObject:
        """
        Get Network Test results for cluster

        Returns the test results of the Network tests triggered for a single Video Mesh cluster. The tests listed below
        are run as a part of the Network Test execution on the node.

        <b>Bandwidth Test</b> - Tests the bandwidth parameters of the Video Mesh node's network. The test is run
        between the Video Mesh node and cloud services.<br/>
        <b>DNS Resolution Test</b> - Tests the resolution of IP addresses related to cloud services, against the DNS
        servers configured on the Video Mesh node's network.<br/>
        <b>HTTPS Connectivity Test</b> - Tests whether the Video Mesh node is able to connect to cloud services via
        HTTPS protocol.<br/>
        <b>Websocket Connectivity Test</b> - Tests whether the Video Mesh node is able to connect to Webex cloud
        services via Websocket.<br/>

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`ConnectivityTestResultsObject`
        """
        params = {}
        params['clusterId'] = cluster_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/networkTest/clusters')
        data = super().get(url, params=params)
        r = ConnectivityTestResultsObject.model_validate(data)
        return r

    def get_network_test_results_for_node(self, node_id: str, from_: Union[str, datetime], to_: Union[str, datetime],
                                          trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType) -> ConnectivityTestResultsObject:
        """
        Get Network Test results for node

        Returns the test results of the Network tests triggered for a single Video Mesh node. The tests listed below
        are run as a part of the Network Test execution on the node.

        <b>Bandwidth Test</b> - Tests the bandwidth parameters of the Video Mesh node's network. The test is run
        between the Video Mesh node and cloud services.<br/>
        <b>DNS Resolution Test</b> - Tests the resolution of IP addresses related to cloud services, against the DNS
        servers configured on the Video Mesh node's network.<br/>
        <b>HTTPS Connectivity Test</b> - Tests whether the Video Mesh node is able to connect to cloud services via
        HTTPS protocol.<br/>
        <b>Websocket Connectivity Test</b> - Tests whether the Video Mesh node is able to connect to Webex cloud
        services via Websocket.<br/>

        :param node_id: Unique ID of the Video Mesh node.
        :type node_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param trigger_type: Trigger type.
        :type trigger_type: ListMediaHealthMonitoringToolTestResultsV2TriggerType
        :rtype: :class:`ConnectivityTestResultsObject`
        """
        params = {}
        params['nodeId'] = node_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['triggerType'] = trigger_type
        url = self.ep('testResults/networkTest/nodes')
        data = super().get(url, params=params)
        r = ConnectivityTestResultsObject.model_validate(data)
        return r

    def list_cluster_client_type_distribution_details(self, org_id: str, from_: Union[str, datetime], to_: Union[str,
                                                      datetime],
                                                      device_type: str) -> list[ClienttypedistributionCollectionforOrg]:
        """
        List Cluster Client Type Distribution details

        Returns the client type distribution details for all Video Mesh clusters in an organization.

        :param org_id: Unique ID of the organization.
        :type org_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param device_type: Device type(s).

        - Possible values:
        `webexDevices` `webexAppVdi` `webexForMobile` `sipEndpoint` `webexForDesktop`
        :type device_type: str
        :rtype: list[ClienttypedistributionCollectionforOrg]
        """
        params = {}
        params['orgId'] = org_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['deviceType'] = device_type
        url = self.ep('clientTypeDistribution')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClienttypedistributionCollectionforOrg]).validate_python(data['items'])
        return r

    def get_cluster_client_type_distribution_details(self, cluster_id: str, from_: Union[str, datetime],
                                                     to_: Union[str, datetime],
                                                     device_type: str) -> list[ClienttypedistributionCollectionforOrg]:
        """
        Get Cluster Client Type Distribution details

        Returns the client type distribution details for a single Video Mesh cluster.

        :param cluster_id: Unique ID of the Video Mesh cluster.
        :type cluster_id: str
        :param from_: The start date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format. The `from`
            parameter cannot have date and time values that exceed `to`.
        :type from_: Union[str, datetime]
        :param to_: The end date and time of the requested data in any `ISO 8601
            <https://en.wikipedia.org/wiki/ISO_8601>`_ compliant format.
        :type to_: Union[str, datetime]
        :param device_type: Device type(s).

        - Possible values:
        `webexDevices` `webexAppVdi` `webexForMobile` `sipEndpoint` `webexForDesktop`
        :type device_type: str
        :rtype: list[ClienttypedistributionCollectionforOrg]
        """
        params = {}
        params['clusterId'] = cluster_id
        if isinstance(from_, str):
            from_ = isoparse(from_)
        from_ = dt_iso_str(from_)
        params['from'] = from_
        if isinstance(to_, str):
            to_ = isoparse(to_)
        to_ = dt_iso_str(to_)
        params['to'] = to_
        params['deviceType'] = device_type
        url = self.ep('clientTypeDistribution/clusters')
        data = super().get(url, params=params)
        r = TypeAdapter(list[ClienttypedistributionCollectionforOrg]).validate_python(data['items'])
        return r

    def list_event_threshold_configuration(self, org_id: str = None, cluster_id: str = None,
                                           event_name: ListEventThresholdConfigurationEventName = None,
                                           event_scope: ListEventThresholdConfigurationEventScope = None) -> GetEventThresholdResponse:
        """
        List Event Threshold Configuration

        Returns the event threshold configurations for `orgId` or `clusterId`, with optional filters `eventName` and
        `eventScope`.

        :param org_id: Unique ID of the Organization.
        :type org_id: str
        :param cluster_id: Unique ID of the Video Mesh Cluster.
        :type cluster_id: str
        :param event_name: Event name to fetch threshold details.
        :type event_name: ListEventThresholdConfigurationEventName
        :param event_scope: Scope name to filter events.
        :type event_scope: ListEventThresholdConfigurationEventScope
        :rtype: :class:`GetEventThresholdResponse`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if cluster_id is not None:
            params['clusterId'] = cluster_id
        if event_name is not None:
            params['eventName'] = event_name
        if event_scope is not None:
            params['eventScope'] = event_scope
        url = self.ep('eventThresholds')
        data = super().get(url, params=params)
        r = GetEventThresholdResponse.model_validate(data)
        return r

    def get_event_threshold_configuration(self, event_threshold_id: str) -> GetEventThresholdResponse:
        """
        Get Event Threshold Configuration

        Returns the event threshold configurations for `eventThresholdId`.

        :param event_threshold_id: Unique ID of the event threshold configuration.
        :type event_threshold_id: str
        :rtype: :class:`GetEventThresholdResponse`
        """
        url = self.ep(f'eventThresholds/{event_threshold_id}')
        data = super().get(url)
        r = GetEventThresholdResponse.model_validate(data)
        return r

    def update_event_threshold_configuration(self,
                                             event_thresholds: list[UpdateEventThresholdConfigurationEventThresholds]) -> BulkUpdateEventThresholdResponse:
        """
        Update Event Threshold Configuration

        Updates an existing event threshold configuration for given Event Threshold IDs.

        :type event_thresholds: list[UpdateEventThresholdConfigurationEventThresholds]
        :rtype: :class:`BulkUpdateEventThresholdResponse`
        """
        body = dict()
        body['eventThresholds'] = loads(TypeAdapter(list[UpdateEventThresholdConfigurationEventThresholds]).dump_json(event_thresholds))
        url = self.ep('eventThresholds')
        data = super().patch(url, json=body)
        r = BulkUpdateEventThresholdResponse.model_validate(data)
        return r

    def reset_event_threshold_configuration(self, event_threshold_ids: list[str]) -> BulkUpdateEventThresholdResponse:
        """
        Reset Event Threshold Configuration

        Resets the existing event threshold configuration for given Event Threshold IDs to default value. To stop
        receiving webhook events, use the `Webhooks API
        <docs/api/v1/webhooks>`_ to delete the webhook in question.

        :type event_threshold_ids: list[str]
        :rtype: :class:`BulkUpdateEventThresholdResponse`
        """
        body = dict()
        body['eventThresholdIds'] = event_threshold_ids
        url = self.ep('eventThresholds/reset')
        data = super().post(url, json=body)
        r = BulkUpdateEventThresholdResponse.model_validate(data)
        return r


class VirtualLineCallSettingsApi(ApiChild, base='telephony/config/virtualLines'):
    """
    Virtual Line Call Settings
    
    Not supported for Webex for Government (FedRAMP)
    
    
    
    Viutual Line Settings supports listing Webex Calling virtual lines.
    
    Viewing Virtual Lines requires a full, user, or read-only administrator auth token with a scope of
    `spark-admin:telephony_config_read.
    """

    def read_the_list_of_virtual_lines(self, org_id: str = None, location_id: list[str] = None, start: int = None,
                                       id: list[str] = None, owner_name: list[str] = None,
                                       phone_number: list[str] = None, location_name: list[str] = None,
                                       order: list[str] = None, has_device_assigned: bool = None,
                                       has_extension_assigned: bool = None, has_dn_assigned: bool = None,
                                       **params) -> Generator[ListVirtualLineObject1, None, None]:
        """
        Read the List of Virtual Lines

        List all Virtual Lines for the organization.

        Virtual line is a capability in Webex Calling that allows administrators to configure multiple lines to Webex
        Calling users.

        Retrieving this list requires a full or read-only administrator auth token with a scope of
        `spark-admin:telephony_config_read`.

        :param org_id: List virtual lines for this organization.
        :type org_id: str
        :param location_id: Return the list of virtual lines matching these location ids. Example for multiple values -
            `?locationId=locId1&locationId=locId2`.
        :type location_id: list[str]
        :param start: Start at the zero-based offset in the list of matching objects.
        :type start: int
        :param id: Return the list of virtual lines matching these virtualLineIds. Example for multiple values -
            `?id=id1&id=id2`.
        :type id: list[str]
        :param owner_name: Return the list of virtual lines matching these owner names. Example for multiple values -
            `?ownerName=name1&ownerName=name2`.
        :type owner_name: list[str]
        :param phone_number: Return the list of virtual lines matching these phone numbers. Example for multiple values
            - `?phoneNumber=number1&phoneNumber=number2`.
        :type phone_number: list[str]
        :param location_name: Return the list of virtual lines matching the location names. Example for multiple values
            - `?locationName=loc1&locationName=loc2`.
        :type location_name: list[str]
        :param order: Return the list of virtual lines based on the order. Default sort will bein an Ascending order.
            Maximum 3 orders allowed at a time. Example for multiple values - `?order=order1&order=order2`.
        :type order: list[str]
        :param has_device_assigned: If `true`, includes onlyvirtual lines with devices assigned. When not explicitly
            specified, the default includes bothvirtual lines with devices assigned and not assigned.
        :type has_device_assigned: bool
        :param has_extension_assigned: If `true`, includesonly virtual lines withan extension assigned. When not
            explicitly specified, the default includes both virtual lines withextension assigned and not assigned.
        :type has_extension_assigned: bool
        :param has_dn_assigned: If `true`, includes only virtual lines withan assigned directory number, also known as
            a Dn. When not explicitly specified, the default includes both virtual lines witha Dn assigned and not
            assigned.
        :type has_dn_assigned: bool
        :return: Generator yielding :class:`ListVirtualLineObject1` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if location_id is not None:
            params['locationId'] = ','.join(location_id)
        if start is not None:
            params['start'] = start
        if id is not None:
            params['id'] = ','.join(id)
        if owner_name is not None:
            params['ownerName'] = ','.join(owner_name)
        if phone_number is not None:
            params['phoneNumber'] = ','.join(phone_number)
        if location_name is not None:
            params['locationName'] = ','.join(location_name)
        if order is not None:
            params['order'] = ','.join(order)
        if has_device_assigned is not None:
            params['hasDeviceAssigned'] = str(has_device_assigned).lower()
        if has_extension_assigned is not None:
            params['hasExtensionAssigned'] = str(has_extension_assigned).lower()
        if has_dn_assigned is not None:
            params['hasDnAssigned'] = str(has_dn_assigned).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ListVirtualLineObject1, item_key='virtualLines', params=params)


class AssistantSkillsServiceAPIApi(ApiChild, base=''):
    """
    Assistant Skills Service API
    
    Develop custom skills to use with the Webex Assistant.
    
    ## Authentication
    
    Uses OAuth v2 Bearer Token / Personal Access Token for its authentication.
    """


class WebhooksApi(ApiChild, base='webhooks'):
    """
    Webhooks
    
    For Webex for Government (FedRAMP), the following resource types are not
    available for Webhooks: meetings, recordings, meetingParticipants, and
    meetingTranscripts.
    
    
    
    Webhooks allow your app to be notified via HTTP when a specific event occurs in Webex. For example, your app can
    register a webhook to be notified when a new message is posted into a specific room.
    
    Events trigger in near real-time allowing your app and backend IT systems to stay in sync with new content and room
    activity.
    
    Check The `Webhooks Guide
    <https://developer.webex.com/docs/api/guides/webhooks>`_ and `our blog
    
    Long result sets will be split into `pages
    <https://developer.webex.com/docs/basics#pagination>`_.
    """

    def list_webhooks(self, owned_by: str = None, **params) -> Generator[Webhook, None, None]:
        """
        List Webhooks

        List all of your webhooks.

        :param owned_by: Limit the result list to org wide webhooks. Only allowed value is `org`.
        :type owned_by: str
        :return: Generator yielding :class:`Webhook` instances
        """
        if owned_by is not None:
            params['ownedBy'] = owned_by
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Webhook, item_key='items', params=params)

    def create_a_webhook(self, name: str, target_url: str, resource: WebhookResource, event: WebhookEvent,
                         filter: str = None, secret: str = None, owned_by: str = None) -> Webhook:
        """
        Create a Webhook

        Creates a webhook.

        To learn more about how to create and use webhooks, see The `Webhooks Guide
        <https://developer.webex.com/docs/api/guides/webhooks>`_.

        :param name: A user-friendly name for the webhook.
        :type name: str
        :param target_url: The URL that receives POST requests for each event.
        :type target_url: str
        :param resource: The resource type for the webhook. Creating a webhook requires 'read' scope on the resource
            the webhook is for.
        :type resource: WebhookResource
        :param event: The event type for the webhook.
        :type event: WebhookEvent
        :param filter: The filter that defines the webhook scope. See `Filtering Webhooks
            <https://developer.webex.com/docs/api/guides/webhooks#filtering-webhooks>`_ for more information.
        :type filter: str
        :param secret: The secret used to generate payload signature.
        :type secret: str
        :param owned_by: Specify `org` when creating an org/admin level webhook. Supported for `meetings`,
            `recordings`, `meetingParticipants`, `meetingTranscripts`, `videoMeshAlerts`, `controlHubAlerts`, `rooms`,
            and `messaging` (for Compliance Officers and messages with file attachments only - see `inline file DLP
            <https://developer.webex.com/docs/api/guides/webex-real-time-file-dlp-basics>`_)
            resources.
        :type owned_by: str
        :rtype: :class:`Webhook`
        """
        body = dict()
        body['name'] = name
        body['targetUrl'] = target_url
        body['resource'] = enum_str(resource)
        body['event'] = enum_str(event)
        body['filter'] = filter
        body['secret'] = secret
        body['ownedBy'] = owned_by
        url = self.ep()
        data = super().post(url, json=body)
        r = Webhook.model_validate(data)
        return r

    def get_webhook_details(self, webhook_id: str) -> Webhook:
        """
        Get Webhook Details

        Shows details for a webhook, by ID.

        Specify the webhook ID in the `webhookId` parameter in the URI.

        :param webhook_id: The unique identifier for the webhook.
        :type webhook_id: str
        :rtype: :class:`Webhook`
        """
        url = self.ep(f'{webhook_id}')
        data = super().get(url)
        r = Webhook.model_validate(data)
        return r

    def update_a_webhook(self, webhook_id: str, name: str, target_url: str, secret: str = None, owned_by: str = None,
                         status: WebhookStatus = None) -> Webhook:
        """
        Update a Webhook

        Updates a webhook, by ID. You cannot use this call to deactivate a webhook, only to activate a webhook that was
        auto deactivated.
        The fields that can be updated are `name`, `targetURL`, `secret` and `status`. All other fields, if supplied,
        are ignored.

        Specify the webhook ID in the `webhookId` parameter in the URI.

        :param webhook_id: The unique identifier for the webhook.
        :type webhook_id: str
        :param name: A user-friendly name for the webhook.
        :type name: str
        :param target_url: The URL that receives POST requests for each event.
        :type target_url: str
        :param secret: The secret used to generate payload signature.
        :type secret: str
        :param owned_by: Specify `org` when creating an org/admin level webhook. Supported for `meetings`,
            `recordings`, `meetingParticipants`, `meetingTranscripts`, `videoMeshAlerts`, `controlHubAlerts`, `rooms`,
            and `messaging` (for Compliance Officers and messages with file attachments only - see `inline file DLP
            <https://developer.webex.com/docs/api/guides/webex-real-time-file-dlp-basics>`_)
            resources.
        :type owned_by: str
        :param status: The status of the webhook. Use "active" to reactivate a disabled webhook.
        :type status: WebhookStatus
        :rtype: :class:`Webhook`
        """
        body = dict()
        body['name'] = name
        body['targetUrl'] = target_url
        body['secret'] = secret
        body['ownedBy'] = owned_by
        body['status'] = enum_str(status)
        url = self.ep(f'{webhook_id}')
        data = super().put(url, json=body)
        r = Webhook.model_validate(data)
        return r

    def delete_a_webhook(self, webhook_id: str):
        """
        Delete a Webhook

        Deletes a webhook, by ID.

        Specify the webhook ID in the `webhookId` parameter in the URI.

        :param webhook_id: The unique identifier for the webhook.
        :type webhook_id: str
        :rtype: None
        """
        url = self.ep(f'{webhook_id}')
        super().delete(url)


class WholesaleBillingReportsApi(ApiChild, base='wholesale/billing/reports'):
    """
    Wholesale Billing Reports
    
    The Wholesale Billing Report APIs are targeted at Service Providers who sign up for the Webex for Wholesale
    solution. These APIs provides customer and user breakdown reports to the service providers or partners. Service
    providers can use these reports to reconcile their monthly invoices.
    
    Viewing Webex for Wholesale billing reports information requires a partner administrator auth token with the
    `spark-admin:wholesale_billing_reports_read` scope. Creating, Deleting billing reports require a partner
    administrator auth token with the `spark-admin:wholesale_billing_reports_write` scope.
    
    Each Webex Developer Sandbox for Webex Wholesale use is limited to a maximum
    of 10 account users for validation and test purposes only. Cisco may from time
    to time audit Webex Developer Sandbox accounts and reserves the right to
    remove users in excess of 10 account users, or terminate the Webex Developer
    Sandbox environment for any Developer resource misuse. To learn more about the
    error codes used in Wholesale billing reports API, see the [API Error
    codes](/docs/api/guides/webex-for-broadworks-and-wholesale-common-guide#api-
    error-codes) guides.
    
    """

    def list_wholesale_billing_reports(self, billing_start_date: Union[str, datetime] = None,
                                       billing_end_date: Union[str, datetime] = None,
                                       sort_by: ListWholesaleBillingReportsSortBy = None, type: ListReportType = None,
                                       status: ReportStatus = None, sub_partner_org_id: str = None,
                                       **params) -> Generator[ListReport1, None, None]:
        """
        List Wholesale Billing Reports

        Search for associated wholesale billing reconciliation reports.

        :param billing_start_date: Only include billing reports having this billing `startDate`.
        :type billing_start_date: Union[str, datetime]
        :param billing_end_date: Only include billing reports having this billing `endDate`.
        :type billing_end_date: Union[str, datetime]
        :param sort_by: Sort the reports.
        :type sort_by: ListWholesaleBillingReportsSortBy
        :param type: Only include reports of this type.
        :type type: ListReportType
        :param status: The status of the billing report
        :type status: ReportStatus
        :param sub_partner_org_id: The Organization ID of the sub partner on Cisco Webex.
        :type sub_partner_org_id: str
        :return: Generator yielding :class:`ListReport1` instances
        """
        if billing_start_date is not None:
            if isinstance(billing_start_date, str):
                billing_start_date = isoparse(billing_start_date)
            billing_start_date = dt_iso_str(billing_start_date)
            params['billingStartDate'] = billing_start_date
        if billing_end_date is not None:
            if isinstance(billing_end_date, str):
                billing_end_date = isoparse(billing_end_date)
            billing_end_date = dt_iso_str(billing_end_date)
            params['billingEndDate'] = billing_end_date
        if sort_by is not None:
            params['sortBy'] = sort_by
        if type is not None:
            params['type'] = type
        if status is not None:
            params['status'] = status
        if sub_partner_org_id is not None:
            params['subPartnerOrgId'] = sub_partner_org_id
        url = self.ep()
        return self.session.follow_pagination(url=url, model=ListReport1, item_key='items', params=params)

    def get_a_wholesale_billing_report(self, id: str) -> Report2:
        """
        Get a Wholesale Billing Report

        Retrieve a specific wholesale billing reconciliation report.

        :param id: A unique identifier for the report being requested.
        :type id: str
        :rtype: :class:`Report2`
        """
        url = self.ep(f'{id}')
        data = super().get(url)
        r = Report2.model_validate(data)
        return r

    def create_a_wholesale_billing_report(self, billing_start_date: Union[str, datetime], billing_end_date: Union[str,
                                          datetime], type: str = None, sub_partner_org_id: str = None) -> ReportId1:
        """
        Create a Wholesale Billing Report

        Generate a wholesale billing reconciliation report.

        :param billing_start_date: The `startDate` (`YYYY-MM-DD`) for which the partner requests the billing report.
        :type billing_start_date: Union[str, datetime]
        :param billing_end_date: The `endDate` (`YYYY-MM-DD`) for which the partner requests the billing report.
        :type billing_end_date: Union[str, datetime]
        :param type: Create report of the given type, `PARTNER`, `CUSTOMER`, or `USER`. Default: `PARTNER`.
        :type type: str
        :param sub_partner_org_id: The Organization ID of the sub partner on Cisco Webex.
        :type sub_partner_org_id: str
        :rtype: :class:`ReportId1`
        """
        body = dict()
        body['billingStartDate'] = billing_start_date
        body['billingEndDate'] = billing_end_date
        body['type'] = type
        body['subPartnerOrgId'] = sub_partner_org_id
        url = self.ep()
        data = super().post(url, json=body)
        r = ReportId1.model_validate(data)
        return r

    def delete_a_wholesale_billing_report(self, id: str):
        """
        Delete a Wholesale Billing Report

        Delete a monthly reconciliation report by report ID.

        :param id: A unique report ID that corresponds to a billing report.
        :type id: str
        :rtype: None
        """
        url = self.ep(f'{id}')
        super().delete(url)


class WholesaleProvisioningApi(ApiChild, base='wholesale'):
    """
    Wholesale Provisioning
    
    These are a set of APIs that are specifically targeted at Service Providers who sign up for Webex Wholesale. They
    enable Service Providers to provision Webex Services for their Customers.
    
    Viewing Webex Wholesale customer information requires an administrator API access token with
    `spark-admin:wholesale_customers_read` scope. Provisioning, updating, and removing customers requires an
    administrator API token with the `spark-admin:wholesale_customers_write` scope.
    
    Additional information codes are given for all success cases. To learn more about the error and info codes used in
    Wholesale Customer Provisioning Precheck APIs, see the `Provisioning Precheck API Error Codes
    <https://developer.webex.com/docs/api/guides/webex-for-wholesale#api-error-codes>`_ guide.
    
    Each Webex Developer Sandbox for Webex Wholesale use is limited to a maximum
    of 10 account users for validation and test purposes only. Cisco may from time
    to time audit Webex Developer Sandbox accounts and reserves the right to
    remove users in excess of 10 account users, or terminate the Webex Developer
    Sandbox environment for any Developer resource misuse.
    
    """

    def list_wholesale_customers(self, external_id: str = None, org_id: str = None, status: list[str] = None,
                                 **params) -> Generator[Customer2, None, None]:
        """
        List Wholesale Customers

        This API allows a Service Provider to search for their customers. There are a number of filter options, which
        can be combined in a single request.

        :param external_id: Customer external ID.
        :type external_id: str
        :param org_id: The encoded Organization ID for the customer.
        :type org_id: str
        :param status: Customer API status.
        :type status: list[str]
        :return: Generator yielding :class:`Customer2` instances
        """
        if external_id is not None:
            params['externalId'] = external_id
        if org_id is not None:
            params['orgId'] = org_id
        if status is not None:
            params['status'] = ','.join(status)
        url = self.ep('customers')
        return self.session.follow_pagination(url=url, model=Customer2, item_key='items', params=params)

    def provision_a_wholesale_customer(self, provisioning_id: str, packages: list[str], external_id: str,
                                       address: Address, org_id: str = None,
                                       customer_info: ProvisionAWholesaleCustomerCustomerInfo = None,
                                       provisioning_parameters: ProvisionAWholesaleCustomerProvisioningParameters = None) -> str:
        """
        Provision a Wholesale Customer

        Provision a Wholesale customer for Cisco Webex services.

        This API will allow a Service Provider to map the Wholesale customer and assign the required licenses and
        entitlements for Webex, Calling and Meetings.

        The Wholesale customer provisioning is asynchronous and thus a background task is created when this endpoint is
        invoked.

        <div>
        <Callout type='info'>After successful invocation of this endpoint a URL will be returned in the `Location`
        header, which will point to the `Get a Wholesale Customer
        <https://developer.webex.com/docs/api/v1/wholesale-provisioning/get-a-wholesale-customer>`_ endpoint for this customer.</Callout>
        </div>

        :param provisioning_id: This Provisioning ID defines how this customer is to be provisioned for Webex Services.

        Each Customer Template will have their own unique Provisioning ID. This ID will be displayed under the chosen
        Customer Template
        on `Webex Control Hub
        <https://admin.webex.com>`_.
        :type provisioning_id: str
        :param packages: The complete list of Webex Wholesale packages to be assigned to the customer.
        :type packages: list[str]
        :param external_id: External ID of the Wholesale customer.
        :type external_id: str
        :param address: Billing Address of the customer.
        :type address: Address
        :param org_id: The Organization ID of the enterprise on Webex. Mandatory for existing customer.
        :type org_id: str
        :param customer_info: Mandatory for new customer. Optional if Organization ID is provided.
        :type customer_info: ProvisionAWholesaleCustomerCustomerInfo
        :type provisioning_parameters: ProvisionAWholesaleCustomerProvisioningParameters
        :rtype: str
        """
        body = dict()
        body['provisioningId'] = provisioning_id
        body['packages'] = packages
        body['orgId'] = org_id
        body['externalId'] = external_id
        body['address'] = loads(address.model_dump_json())
        body['customerInfo'] = loads(customer_info.model_dump_json())
        body['provisioningParameters'] = loads(provisioning_parameters.model_dump_json())
        url = self.ep('customers')
        data = super().post(url, json=body)
        r = data['url']
        return r

    def get_a_wholesale_customer(self, customer_id: str) -> Customer2:
        """
        Get a Wholesale Customer

        This API will allow a Service Provider to retrieve details of a provisioned Wholesale customer on Cisco Webex.

        :param customer_id: A unique identifier for the customer in question.
        :type customer_id: str
        :rtype: :class:`Customer2`
        """
        url = self.ep(f'customers/{customer_id}')
        data = super().get(url)
        r = Customer2.model_validate(data)
        return r

    def update_a_wholesale_customer(self, customer_id: str, packages: list[str], external_id: str = None,
                                    address: Address = None,
                                    provisioning_parameters: ProvisionAWholesaleCustomerProvisioningParameters = None) -> str:
        """
        Update a Wholesale Customer

        This API allows a Service Provider to update certain details of a provisioned Wholesale customer.

        The Wholesale customer provisioning is asynchronous and thus a background task is created when this endpoint is
        invoked.

        <div>
        <Callout type='info'>After successful invocation of this endpoint a URL will be returned in the `Location`
        header, which will point to the `Get a Wholesale Customer
        <https://developer.webex.com/docs/api/v1/wholesale-provisioning/get-a-wholesale-customer>`_ endpoint for this customer.</Callout>
        </div>

        :param customer_id: A unique identifier for the customer to be updated.
        :type customer_id: str
        :param packages: The complete list of Webex Wholesale packages to be assigned to the customer, including any
            packages already provisioned. If a package has already been assigned to this customer and is not present
            in this list, then that package will be removed.
        :type packages: list[str]
        :param external_id: External ID of the Wholesale customer.
        :type external_id: str
        :param address: Billing Address of the customer.
        :type address: Address
        :param provisioning_parameters: Provisioning parameters are required when updating an existing package.
        :type provisioning_parameters: ProvisionAWholesaleCustomerProvisioningParameters
        :rtype: str
        """
        body = dict()
        body['externalId'] = external_id
        body['packages'] = packages
        body['address'] = loads(address.model_dump_json())
        body['provisioningParameters'] = loads(provisioning_parameters.model_dump_json())
        url = self.ep(f'customers/{customer_id}')
        data = super().put(url, json=body)
        r = data['url']
        return r

    def remove_a_wholesale_customer(self, customer_id: str):
        """
        Remove a Wholesale Customer

        Allows a Service Provider to remove the mapping between a Wholesale Customer and a Cisco Webex organization.

        :param customer_id: A unique identifier for the customer in question.
        :type customer_id: str
        :rtype: None
        """
        url = self.ep(f'customers/{customer_id}')
        super().delete(url)

    def precheck_a_wholesale_customer_provisioning(self, address: Address, provisioning_id: str = None,
                                                   packages: list[str] = None, org_id: str = None,
                                                   external_id: str = None,
                                                   customer_info: PrecheckAWholesaleCustomerProvisioningCustomerInfo = None,
                                                   provisioning_parameters: ProvisionAWholesaleCustomerProvisioningParameters = None) -> SubscriberProvisioningPrecheckResponse:
        """
        Precheck a Wholesale Customer Provisioning

        This API will allow the Partner sales team to verify likely success of provisioning a Wholesale customer.

        <div>
        <Callout type='info'>
        The Prerequisite for using this API is to have `wxc-wholesale` entitlement or `webex-wholesale-partner-testing`
        setting enabled for the Partner Organization. The Provisioning Precheck APIs supports two variants of
        Wholesale Customer Provisioning Precheck Requests. Please refer to `Using the Provisioning Precheck APIs
        <https://developer.webex.com/docs/api/guides/webex-for-wholesale#using-the-precheck-provisioning-api>`_
        section in `Webex for Wholesale
        <https://developer.webex.com/docs/api/guides/webex-for-wholesale>`_ guide for more information.
        </Callout>
        </div>

        :param address: Billing Address of the Wholesale customer.
        :type address: Address
        :param provisioning_id: This Provisioning ID defines how this wholesale customer is to be provisioned for Cisco
            Webex Services.

        Each Customer Template will have its unique Provisioning ID. This ID will be displayed under the chosen
        Customer Template
        on Cisco Webex Control Hub.
        :type provisioning_id: str
        :param packages: The complete list of Webex Wholesale packages to be assigned to the Wholesale customer.
        :type packages: list[str]
        :param org_id: The Organization ID of the enterprise on Cisco Webex.
        :type org_id: str
        :param external_id: External ID of the Wholesale customer.
        :type external_id: str
        :type customer_info: PrecheckAWholesaleCustomerProvisioningCustomerInfo
        :type provisioning_parameters: ProvisionAWholesaleCustomerProvisioningParameters
        :rtype: :class:`SubscriberProvisioningPrecheckResponse`
        """
        body = dict()
        body['provisioningId'] = provisioning_id
        body['packages'] = packages
        body['orgId'] = org_id
        body['externalId'] = external_id
        body['address'] = loads(address.model_dump_json())
        body['customerInfo'] = loads(customer_info.model_dump_json())
        body['provisioningParameters'] = loads(provisioning_parameters.model_dump_json())
        url = self.ep('customers/validate')
        data = super().post(url, json=body)
        r = SubscriberProvisioningPrecheckResponse.model_validate(data)
        return r

    def list_wholesale_sub_partners(self, provisioning_state: str = None,
                                    **params) -> Generator[SubPartner, None, None]:
        """
        List Wholesale Sub-partners

        This API allows a Service Provider to list all of their associated sub-partners. There are a number of filter
        and pagination options that can be combined in a single request.

        :param provisioning_state: Status to filter sub-partners based on provisioning state.
        :type provisioning_state: str
        :return: Generator yielding :class:`SubPartner` instances
        """
        if provisioning_state is not None:
            params['provisioningState'] = provisioning_state
        url = self.ep('subPartners')
        return self.session.follow_pagination(url=url, model=SubPartner, item_key='items', params=params)

    def list_wholesale_subscribers(self, customer_id: str = None, person_id: str = None,
                                   external_customer_id: str = None, email: str = None, status: str = None,
                                   after: str = None, last_status_change: str = None, sort_by: str = None,
                                   sort_order: str = None, **params) -> Generator[Subscriber2, None, None]:
        """
        List Wholesale Subscribers

        This API allows a Service Provider to search for their associated subscribers. There are a number of filter
        options, which can be combined in a single request.

        :param customer_id: Wholesale customer ID.
        :type customer_id: str
        :param person_id: The person ID of the subscriber used in the `/v1/people API
            <https://developer.webex.com/docs/api/v1/people>`_.
        :type person_id: str
        :param external_customer_id: Customer external ID.
        :type external_customer_id: str
        :param email: The email address of the subscriber.
        :type email: str
        :param status: The provisioning status of the subscriber.
        :type status: str
        :param after: Only include subscribers created after this date and time. Epoch time (in milliseconds)
            preferred, but ISO 8601 date format also accepted.
        :type after: str
        :param last_status_change: Only include subscribers with a provisioning status change after this date and time.
            Epoch time (in milliseconds) preferred, but ISO 8601 date format also accepted.
        :type last_status_change: str
        :param sort_by: Supported `sortBy` attributes are `created` and `lastStatusChange`. Default is `created`.
        :type sort_by: str
        :param sort_order: Sort by `ASC` (ascending) or `DESC` (descending).
        :type sort_order: str
        :return: Generator yielding :class:`Subscriber2` instances
        """
        if customer_id is not None:
            params['customerId'] = customer_id
        if person_id is not None:
            params['personId'] = person_id
        if external_customer_id is not None:
            params['externalCustomerId'] = external_customer_id
        if email is not None:
            params['email'] = email
        if status is not None:
            params['status'] = status
        if after is not None:
            params['after'] = after
        if last_status_change is not None:
            params['lastStatusChange'] = last_status_change
        if sort_by is not None:
            params['sortBy'] = sort_by
        if sort_order is not None:
            params['sortOrder'] = sort_order
        url = self.ep('subscribers')
        return self.session.follow_pagination(url=url, model=Subscriber2, item_key='items', params=params)

    def provision_a_wholesale_subscriber(self, customer_id: str, email: str, package: SubscriberPackage2,
                                         provisioning_parameters: ProvisionAWholesaleSubscriberProvisioningParameters) -> Subscriber2:
        """
        Provision a Wholesale Subscriber

        Provision a new Wholesale subscriber for Cisco Webex services.

        This API allows a Service Provider to map the Wholesale subscriber to a Cisco Webex Wholesale customer and
        assign the required licenses and entitlements for Webex, Calling and Meetings.

        **Note:**
        If this subscriber is a existing Webex Calling entitled user, the `locationId`, `primaryPhoneNumber` and
        `extension` are optional and if provided are ignored.

        :param customer_id: ID of the Provisioned Customer for Webex Wholesale.
        :type customer_id: str
        :param email: The email address of the subscriber (mandatory for the trusted email provisioning flow).
        :type email: str
        :param package: The Webex Wholesale package to be assigned to the subscriber.
        :type package: SubscriberPackage2
        :type provisioning_parameters: ProvisionAWholesaleSubscriberProvisioningParameters
        :rtype: :class:`Subscriber2`
        """
        body = dict()
        body['customerId'] = customer_id
        body['email'] = email
        body['package'] = enum_str(package)
        body['provisioningParameters'] = loads(provisioning_parameters.model_dump_json())
        url = self.ep('subscribers')
        data = super().post(url, json=body)
        r = Subscriber2.model_validate(data)
        return r

    def get_a_wholesale_subscriber(self, subscriber_id: str) -> Subscriber2:
        """
        Get a Wholesale Subscriber

        This API allow a Service Provider to retrieve details of a provisioned Wholesale subscriber on Cisco Webex.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :rtype: :class:`Subscriber2`
        """
        url = self.ep(f'subscribers/{subscriber_id}')
        data = super().get(url)
        r = Subscriber2.model_validate(data)
        return r

    def update_a_wholesale_subscriber(self, subscriber_id: str, package: SubscriberPackage2,
                                      provisioning_parameters: UpdateAWholesaleSubscriberProvisioningParameters = None) -> Subscriber2:
        """
        Update a Wholesale Subscriber

        This API allows a Service Provider to update certain details of a provisioned Wholesale subscriber.

        **Note:**

        * The `provisioningParameters` attributes should only be supplied when changing from the webex_meetings package
        to any calling-enabled package.

        * Even in that scenario, if this subscriber is a existing Webex Calling entitled user, these attributes are
        optional and if provided are ignored.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :param package: The Webex Wholesale package to be assigned to the subscriber.
        :type package: SubscriberPackage2
        :type provisioning_parameters: UpdateAWholesaleSubscriberProvisioningParameters
        :rtype: :class:`Subscriber2`
        """
        body = dict()
        body['package'] = enum_str(package)
        body['provisioningParameters'] = loads(provisioning_parameters.model_dump_json())
        url = self.ep(f'subscribers/{subscriber_id}')
        data = super().put(url, json=body)
        r = Subscriber2.model_validate(data)
        return r

    def remove_a_wholesale_subscriber(self, subscriber_id: str):
        """
        Remove a Wholesale Subscriber

        This API allows a Service Provider to remove the mapping between Wholesale Subscriber and a Webex user.

        :param subscriber_id: A unique identifier for the subscriber in question.
        :type subscriber_id: str
        :rtype: None
        """
        url = self.ep(f'subscribers/{subscriber_id}')
        super().delete(url)

    def precheck_a_wholesale_subscriber_provisioning(self, email: str, provisioning_id: str = None,
                                                     customer_id: str = None, package: SubscriberPackage2 = None,
                                                     provisioning_parameters: ProvisionAWholesaleSubscriberProvisioningParameters = None,
                                                     customer_info: PrecheckABroadworksSubscriberProvisioningCustomerInfo = None) -> SubscriberProvisioningPrecheckResponse:
        """
        Precheck a Wholesale Subscriber Provisioning

        This API will allow the Partner sales team to verify likely success of provisioning a wholesale subscriber.

        <div>
        <Callout type='info'>
        The Prerequisite for using this API is to have `wxc-wholesale` entitlement or `webex-wholesale-partner-testing`
        setting enabled for the Partner Organization. The Provisioning Precheck APIs supports three variants of
        Wholesale Subscriber Provisioning Precheck Requests. Please refer to `Using the Provisioning Precheck API
        <https://developer.webex.com/docs/api/guides/webex-for-wholesale#using-the-precheck-provisioning-api>`_
        section in `Webex for Wholesale
        <https://developer.webex.com/docs/api/guides/webex-for-wholesale>`_ guide for more information.
        </Callout>
        </div>

        :param email: The email address of the subscriber.
        :type email: str
        :param provisioning_id: This Provisioning ID defines how this wholesale subscriber is to be provisioned for
            Cisco Webex Services.

        Each Customer template has its unique provisioning ID. This ID is displayed under the chosen customer template
        on Cisco Webex Control Hub.
        :type provisioning_id: str
        :param customer_id: ID of the Provisioned Customer for Webex Wholesale.
        :type customer_id: str
        :param package: The Webex Wholesale package to be assigned to the subscriber.
        :type package: SubscriberPackage2
        :type provisioning_parameters: ProvisionAWholesaleSubscriberProvisioningParameters
        :type customer_info: PrecheckABroadworksSubscriberProvisioningCustomerInfo
        :rtype: :class:`SubscriberProvisioningPrecheckResponse`
        """
        body = dict()
        body['provisioningId'] = provisioning_id
        body['customerId'] = customer_id
        body['email'] = email
        body['package'] = enum_str(package)
        body['provisioningParameters'] = loads(provisioning_parameters.model_dump_json())
        body['customerInfo'] = loads(customer_info.model_dump_json())
        url = self.ep('subscribers/validate')
        data = super().post(url, json=body)
        r = SubscriberProvisioningPrecheckResponse.model_validate(data)
        return r


class WorkspaceCallSettingsApi(ApiChild, base=''):
    """
    Workspace Call Settings
    
    Workspaces represent places where people work, such as conference rooms, meeting spaces, lobbies, and lunchrooms.
    Devices may be associated with workspaces.
    
    Webex Calling Workspace Settings support reading and writing of Webex Calling settings for a specific workspace
    within the organization.
    
    Viewing the list of settings in a workspace /v1/workspaces API requires an full, device, or read-only administrator
    auth token with the `spark-admin:workspaces_read` scope.
    
    Adding, updating, or deleting settings in a workspace /v1/workspaces API requires an full or device administrator
    auth token with the `spark-admin:workspaces_write` scope.
    
    This API can also be used by partner administrators acting as administrators of a different organization than their
    own. In those cases, an `orgId` must be supplied, as indicated in the reference documentation for the relevant
    endpoints.
    """

    def retrieve_call_forwarding_settings_for_a_workspace(self, workspace_id: str,
                                                          org_id: str = None) -> CallForwardingInfo:
        """
        Retrieve Call Forwarding Settings for a Workspace

        Retrieve Call Forwarding Settings for a Workspace.

        Three types of call forwarding are supported:

        + Always - forwards all incoming calls to the destination you choose.

        + When busy, forwards all incoming calls to the destination you chose while the phone is in use or the person
        is busy.

        + When no answer, forwarding only occurs when you are away or not answering your phone.

        In addition, the Business Continuity feature will send calls to a destination of your choice if your phone is
        not connected to the network for any reason, such as a power outage, failed Internet connection, or wiring
        problem.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`CallForwardingInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/callForwarding')
        data = super().get(url, params=params)
        r = CallForwardingInfo.model_validate(data)
        return r

    def modify_call_forwarding_settings_for_a_workspace(self, workspace_id: str,
                                                        call_forwarding: CallForwardingInfoCallForwarding,
                                                        business_continuity: GetHuntGroupCallPolicyObjectBusinessContinuity,
                                                        org_id: str = None):
        """
        Modify Call Forwarding Settings for a Workspace

        Modify call forwarding settings for a Workspace.

        Three types of call forwarding are supported:

        + Always - forwards all incoming calls to the destination you choose.

        + When busy, forwards all incoming calls to the destination you chose while the phone is in use or the person
        is busy.

        + When no answer, forwarding only occurs when you are away or not answering your phone.

        In addition, the Business Continuity feature will send calls to a destination of your choice if your phone is
        not connected to the network for any reason, such as a power outage, failed Internet connection, or wiring
        problem.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param call_forwarding: Call forwarding settings for a Workspace.
        :type call_forwarding: CallForwardingInfoCallForwarding
        :param business_continuity: Settings for sending calls to a destination of your choice if your phone is not
            connected to the network for any reason, such as power outage, failed Internet connection, or wiring
            problem.
        :type business_continuity: GetHuntGroupCallPolicyObjectBusinessContinuity
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['callForwarding'] = loads(call_forwarding.model_dump_json())
        body['businessContinuity'] = loads(business_continuity.model_dump_json())
        url = self.ep(f'workspaces/{workspace_id}/features/callForwarding')
        super().put(url, params=params, json=body)

    def retrieve_call_waiting_settings_for_a_workspace(self, workspace_id: str, org_id: str = None) -> bool:
        """
        Retrieve Call Waiting Settings for a Workspace

        Retrieve Call Waiting Settings for a Workspace.

        Call Waiting allows workspaces to handle multiple simultaneous calls. Workspaces with Call Waiting enabled can
        place a call on hold to answer or initiate another call.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: bool
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/callWaiting')
        data = super().get(url, params=params)
        r = data['enabled']
        return r

    def modify_call_waiting_settings_for_a_workspace(self, workspace_id: str, enabled: bool, org_id: str = None):
        """
        Modify Call Waiting Settings for a Workspace

        Modify Call Waiting Settings for a Workspace.

        Call Waiting allows workspaces to handle multiple simultaneous calls. Workspaces with Call Waiting enabled can
        place a call on hold to answer or initiate another call.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param enabled: Call Waiting state.
        :type enabled: bool
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        url = self.ep(f'workspaces/{workspace_id}/features/callWaiting')
        super().put(url, params=params, json=body)

    def retrieve_caller_id_settings_for_a_workspace(self, workspace_id: str, org_id: str = None) -> PlaceCallerIdGet:
        """
        Retrieve Caller ID Settings for a Workspace

        Retrieve Caller ID Settings for a Workspace.

        Caller ID settings control how a workspace's information is displayed when making outgoing calls.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`PlaceCallerIdGet`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/callerId')
        data = super().get(url, params=params)
        r = PlaceCallerIdGet.model_validate(data)
        return r

    def modify_caller_id_settings_for_a_workspace(self, workspace_id: str, selected: CLIDPolicySelection,
                                                  custom_number: str, display_name: str, display_detail: str,
                                                  block_in_forward_calls_enabled: bool,
                                                  external_caller_id_name_policy: ListVirtualLineObjectExternalCallerIdNamePolicy,
                                                  custom_external_caller_id_name: str,
                                                  location_external_caller_id_name: str, org_id: str = None):
        """
        Modify Caller ID Settings for a Workspace

        Modify Caller ID settings for a Workspace.

        Caller ID settings control how a workspace's information is displayed when making outgoing calls.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param selected: Which type of outgoing Caller ID will be used.
        :type selected: CLIDPolicySelection
        :param custom_number: This value must be an assigned number from the workspace's location.
        :type custom_number: str
        :param display_name: Workspace's caller ID display name.
        :type display_name: str
        :param display_detail: Workspace's caller ID display details.
        :type display_detail: str
        :param block_in_forward_calls_enabled: Flag to block call forwarding.
        :type block_in_forward_calls_enabled: bool
        :param external_caller_id_name_policy: Designates which type of External Caller ID Name policy is used. Default
            is `DIRECT_LINE`.
        :type external_caller_id_name_policy: ListVirtualLineObjectExternalCallerIdNamePolicy
        :param custom_external_caller_id_name: Custom External Caller Name, which will be shown if External Caller ID
            Name is `OTHER`.
        :type custom_external_caller_id_name: str
        :param location_external_caller_id_name: External Caller Name, which will be shown if External Caller ID Name
            is `OTHER`.
        :type location_external_caller_id_name: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['selected'] = enum_str(selected)
        body['customNumber'] = custom_number
        body['displayName'] = display_name
        body['displayDetail'] = display_detail
        body['blockInForwardCallsEnabled'] = block_in_forward_calls_enabled
        body['externalCallerIdNamePolicy'] = enum_str(external_caller_id_name_policy)
        body['customExternalCallerIdName'] = custom_external_caller_id_name
        body['locationExternalCallerIdName'] = location_external_caller_id_name
        url = self.ep(f'workspaces/{workspace_id}/features/callerId')
        super().put(url, params=params, json=body)

    def retrieve_monitoring_settings_for_a_workspace(self, workspace_id: str,
                                                     org_id: str = None) -> UserMonitoringGet1:
        """
        Retrieve Monitoring Settings for a Workspace

        Retrieves Monitoring settings for a Workspace.

        Allow workspaces to monitor the line status of specified agents, workspaces, or call park extensions. The line
        status indicates if a monitored agent or a workspace is on a call, or if a call has been parked on the
        monitored call park extension.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`UserMonitoringGet1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/monitoring')
        data = super().get(url, params=params)
        r = UserMonitoringGet1.model_validate(data)
        return r

    def modify_monitoring_settings_for_a_workspace(self, workspace_id: str, enable_call_park_notification: bool,
                                                   monitored_elements: list[str], org_id: str = None):
        """
        Modify Monitoring Settings for a Workspace

        Modify Monitoring settings for a Workspace.

        Allow workspaces to monitor the line status of specified agents, workspaces, or call park extensions. The line
        status indicates if a monitored agent or a workspace is on a call, or if a call has been parked on the
        monitored call park extension.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param enable_call_park_notification: Call park notification is enabled or disabled.
        :type enable_call_park_notification: bool
        :param monitored_elements: Array of ID strings of monitored elements.
        :type monitored_elements: list[str]
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enableCallParkNotification'] = enable_call_park_notification
        body['monitoredElements'] = monitored_elements
        url = self.ep(f'workspaces/{workspace_id}/features/monitoring')
        super().put(url, params=params, json=body)

    def retrieve_music_on_hold_settings_for_a_workspace(self, workspace_id: str,
                                                        org_id: str = None) -> GetMusicOnHoldObject1:
        """
        Retrieve Music On Hold Settings for a Workspace

        Retrieve Music On Hold Settings for a Workspace.

        Music on hold is played when a caller is put on hold, or the call is parked.

        Retrieving a workspace's music on hold settings requires a full, device or read-only administrator auth token
        with a scope of `spark-admin:telephony_config_read`.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: :class:`GetMusicOnHoldObject1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'telephony/config/workspaces/{workspace_id}/musicOnHold')
        data = super().get(url, params=params)
        r = GetMusicOnHoldObject1.model_validate(data)
        return r

    def modify_music_on_hold_settings_for_a_workspace(self, workspace_id: str, moh_enabled: bool,
                                                      greeting: HoursMenuObjectGreeting,
                                                      audio_announcement_file: AudioAnnouncementFileGetObject1,
                                                      org_id: str = None):
        """
        Modify Music On Hold Settings for a Workspace

        Modify music on hold settings for a Workspace.

        Music on hold is played when a caller is put on hold, or the call is parked.

        To configure music on hold setting for a workspace, music on hold setting must be enabled for this location.

        This API requires a full or device administrator auth token with the `spark-admin:telephony_config_write`
        scope.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param moh_enabled: Music on hold is enabled or disabled for the workspace.
        :type moh_enabled: bool
        :param greeting: Greeting type for the workspace.
        :type greeting: HoursMenuObjectGreeting
        :param audio_announcement_file: Announcement Audio File details when greeting is selected to be `CUSTOM`.
        :type audio_announcement_file: AudioAnnouncementFileGetObject1
        :param org_id: ID of the organization in which the person resides. Only admin users of another organization
            (such as partners) may use this parameter as the default is the same organization as the token used to
            access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['mohEnabled'] = moh_enabled
        body['greeting'] = enum_str(greeting)
        body['audioAnnouncementFile'] = loads(audio_announcement_file.model_dump_json())
        url = self.ep(f'telephony/config/workspaces/{workspace_id}/musicOnHold')
        super().put(url, params=params, json=body)

    def list_numbers_associated_with_a_specific_workspace(self, workspace_id: str,
                                                          org_id: str = None) -> ListNumbersAssociatedWithASpecificWorkspaceResponse1:
        """
        List numbers associated with a specific workspace

        List the PSTN phone numbers associated with a specific workspace, by ID, within the organization. Also shows
        the location and organization associated with the workspace.

        Retrieving this list requires a full or read-only administrator or location administrator auth token with a
        scope of `spark-admin:workspaces_read`.

        :param workspace_id: List numbers for this workspace.
        :type workspace_id: str
        :param org_id: Workspace is in this organization. Only admin users of another organization (such as partners)
            can use this parameter as the default is the same organization as the token used to access API.
        :type org_id: str
        :rtype: :class:`ListNumbersAssociatedWithASpecificWorkspaceResponse1`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/numbers')
        data = super().get(url, params=params)
        r = ListNumbersAssociatedWithASpecificWorkspaceResponse1.model_validate(data)
        return r

    def retrieve_incoming_permission_settings_for_a_workspace(self, workspace_id: str,
                                                              org_id: str = None) -> IncomingPermissionSetting:
        """
        Retrieve Incoming Permission Settings for a Workspace

        Retrieve Incoming Permission settings for a Workspace.

        Incoming permission settings allow modifying permissions for a workspace that can be different from the
        organization's default to manage different call types.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`IncomingPermissionSetting`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/incomingPermission')
        data = super().get(url, params=params)
        r = IncomingPermissionSetting.model_validate(data)
        return r

    def modify_incoming_permission_settings_for_a_workspace(self, workspace_id: str, use_custom_enabled: bool,
                                                            external_transfer: IncomingPermissionSettingExternalTransfer,
                                                            internal_calls_enabled: bool, collect_calls_enabled: bool,
                                                            org_id: str = None):
        """
        Modify Incoming Permission Settings for a Workspace

        Modify Incoming Permission settings for a Workspace.

        Incoming permission settings allow modifying permissions for a workspace that can be different from the
        organization's default to manage different call types.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param use_custom_enabled: Incoming Permission state. If disabled, the default settings are used.
        :type use_custom_enabled: bool
        :param external_transfer: Indicate call transfer setting.
        :type external_transfer: IncomingPermissionSettingExternalTransfer
        :param internal_calls_enabled: Flag to indicate if the workspace can receive internal calls.
        :type internal_calls_enabled: bool
        :param collect_calls_enabled: Flag to indicate if the workspace can receive collect calls.
        :type collect_calls_enabled: bool
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['useCustomEnabled'] = use_custom_enabled
        body['externalTransfer'] = enum_str(external_transfer)
        body['internalCallsEnabled'] = internal_calls_enabled
        body['collectCallsEnabled'] = collect_calls_enabled
        url = self.ep(f'workspaces/{workspace_id}/features/incomingPermission')
        super().put(url, params=params, json=body)

    def retrieve_outgoing_permission_settings_for_a_workspace(self, workspace_id: str,
                                                              org_id: str = None) -> OutgoingCallingPermissionsSetting:
        """
        Retrieve Outgoing Permission Settings for a Workspace

        Retrieve Outgoing Permission settings for a Workspace.

        Turn on outgoing call settings for this workspace to override the calling settings from the location that are
        used by default.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`OutgoingCallingPermissionsSetting`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission')
        data = super().get(url, params=params)
        r = OutgoingCallingPermissionsSetting.model_validate(data)
        return r

    def modify_outgoing_permission_settings_for_a_workspace(self, workspace_id: str, use_custom_enabled: bool,
                                                            calling_permissions: list[CallingPermissionObject],
                                                            org_id: str = None):
        """
        Modify Outgoing Permission Settings for a Workspace

        Modify Outgoing Permission settings for a Place.

        Turn on outgoing call settings for this workspace to override the calling settings from the location that are
        used by default.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param use_custom_enabled: Outgoing Permission state. If disabled, the default settings are used.
        :type use_custom_enabled: bool
        :param calling_permissions: Workspace's list of outgoing permissions.
        :type calling_permissions: list[CallingPermissionObject]
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['useCustomEnabled'] = use_custom_enabled
        body['callingPermissions'] = loads(TypeAdapter(list[CallingPermissionObject]).dump_json(calling_permissions))
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission')
        super().put(url, params=params, json=body)

    def retrieve_access_codes_for_a_workspace(self, workspace_id: str, org_id: str = None) -> list[AuthorizationCode]:
        """
        Retrieve Access Codes for a Workspace

        Retrieve Access codes for a Workspace.

        Access codes are used to bypass permissions.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: list[AuthorizationCode]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/accessCodes')
        data = super().get(url, params=params)
        r = TypeAdapter(list[AuthorizationCode]).validate_python(data['accessCodes'])
        return r

    def modify_access_codes_for_a_workspace(self, workspace_id: str, delete_codes: list[str], org_id: str = None):
        """
        Modify Access Codes for a Workspace

        Modify Access codes for a workspace.

        Access codes are used to bypass permissions.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param delete_codes: Indicates access codes to delete.
        :type delete_codes: list[str]
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['deleteCodes'] = delete_codes
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/accessCodes')
        super().put(url, params=params, json=body)

    def create_access_codes_for_a_workspace(self, workspace_id: str, code: Union[str, datetime], description: str,
                                            org_id: str = None):
        """
        Create Access Codes for a Workspace

        Create new Access codes for the given workspace.

        Access codes are used to bypass permissions.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param code: Indicates an access code.
        :type code: Union[str, datetime]
        :param description: Indicates the description of the access code.
        :type description: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['code'] = code
        body['description'] = description
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/accessCodes')
        super().post(url, params=params, json=body)

    def read_call_intercept_settings_for_a_workspace(self, workspace_id: str, org_id: str = None) -> CallInterceptInfo:
        """
        Read Call Intercept Settings for a Workspace

        Retrieves Workspace's Call Intercept Settings

        The intercept feature gracefully takes a workspace's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified workspace are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`CallInterceptInfo`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/intercept')
        data = super().get(url, params=params)
        r = CallInterceptInfo.model_validate(data)
        return r

    def configure_call_intercept_settings_for_a_workspace(self, workspace_id: str, enabled: bool,
                                                          incoming: CallInterceptPutIncoming,
                                                          outgoing: GetLocationInterceptObjectOutgoing,
                                                          org_id: str = None):
        """
        Configure Call Intercept Settings for a Workspace

        Configures a Workspace's Call Intercept Settings

        The intercept feature gracefully takes a workspace's phone out of service, while providing callers with
        informative announcements and alternative routing options. Depending on the service configuration, none, some,
        or all incoming calls to the specified person are intercepted. Also depending on the service configuration,
        outgoing calls are intercepted or rerouted to another location.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_write` or a user auth token with `spark:workspaces_read` scope can be used by a person
        to read their settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param enabled: `true` if call interception is enabled.
        :type enabled: bool
        :param incoming: Settings related to how incoming calls are handled when the intercept feature is enabled.
        :type incoming: CallInterceptPutIncoming
        :param outgoing: Settings related to how outgoing calls are handled when the intercept feature is enabled.
        :type outgoing: GetLocationInterceptObjectOutgoing
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['enabled'] = enabled
        body['incoming'] = loads(incoming.model_dump_json())
        body['outgoing'] = loads(outgoing.model_dump_json())
        url = self.ep(f'workspaces/{workspace_id}/features/intercept')
        super().put(url, params=params, json=body)

    def retrieve_transfer_numbers_settings_for_a_workspace(self, workspace_id: str,
                                                           org_id: str = None) -> GetAutoTransferNumberObject:
        """
        Retrieve Transfer Numbers Settings for a Workspace

        Retrieve Transfer Numbers Settings for a Workspace.

        When calling a specific call type, this workspace will be automatically transferred to another number. The
        person assigned the Auto Transfer Number can then approve the call and send it through or reject the call
        type. You can add up to 3 numbers.

        This API requires a full or read-only administrator or location administrator auth token with a scope of
        `spark-admin:workspaces_read` or a user auth token with `spark:workspaces_read` scope can be used to read
        workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: :class:`GetAutoTransferNumberObject`
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/autoTransferNumbers')
        data = super().get(url, params=params)
        r = GetAutoTransferNumberObject.model_validate(data)
        return r

    def modify_transfer_numbers_settings_for_a_workspace(self, workspace_id: str, auto_transfer_number1: str,
                                                         auto_transfer_number2: str, auto_transfer_number3: str,
                                                         org_id: str = None):
        """
        Modify Transfer Numbers Settings for a Workspace

        Modify Transfer Numbers Settings for a place.

        When calling a specific call type, this workspace will be automatically transferred to another number. The
        person assigned the Auto Transfer Number can then approve the call and send it through or reject the call
        type. You can add up to 3 numbers.

        This API requires a full or user administrator or location administrator auth token with the
        `spark-admin:workspaces_write` scope or a user auth token with `spark:workspaces_write` scope can be used to
        update workspace settings.

        :param workspace_id: Unique identifier for the workspace.
        :type workspace_id: str
        :param auto_transfer_number1: When calling a specific call type, this workspace will be automatically
            transferred to another number.
        :type auto_transfer_number1: str
        :param auto_transfer_number2: When calling a specific call type, this workspace will be automatically
            transferred to another number.
        :type auto_transfer_number2: str
        :param auto_transfer_number3: When calling a specific call type, this workspace will be automatically
            transferred to another number.
        :type auto_transfer_number3: str
        :param org_id: ID of the organization within which the workspace resides. Only admin users of another
            organization (such as partners) may use this parameter as the default is the same organization as the
            token used to access API.
        :type org_id: str
        :rtype: None
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        body = dict()
        body['autoTransferNumber1'] = auto_transfer_number1
        body['autoTransferNumber2'] = auto_transfer_number2
        body['autoTransferNumber3'] = auto_transfer_number3
        url = self.ep(f'workspaces/{workspace_id}/features/outgoingPermission/autoTransferNumbers')
        super().put(url, params=params, json=body)


class WorkspaceLocationsApi(ApiChild, base='workspaceLocations'):
    """
    Workspace Locations
    
    A `Workspace
    <https://developer.webex.com/docs/api/v1/workspaces>`_ Location is a physical location with a name, address, country, city, latitude and longitude.
    
    Viewing the list of locations in an organization requires an administrator auth token with the
    `spark-admin:workspace_locations_read` scope. Adding, updating, or deleting workspace locations in an organization
    requires an administrator auth token with the `spark-admin:workspace_locations_write` scope.
    
    The Workspace Locations API can also be used by partner administrators acting as administrators of a different
    organization than their own. In those cases an `orgId` value must be supplied, as indicated in the reference
    documentation for the relevant endpoints.
    """

    def list_workspace_locations(self, org_id: str = None, display_name: str = None, address: str = None,
                                 country_code: str = None, city_name: str = None) -> list[Location10]:
        """
        List Workspace Locations

        List workspace locations. Use query parameters to filter the response. The `orgId` parameter can only be used
        by admin users of another
        organization (such as partners). The `displayName`, `address`, `countryCode` and `cityName` parameters are all
        optional.
        Requires an administrator auth token with the `spark-admin:workspace_locations_read` scope.

        :param org_id: List workspace locations in this organization. Only admin users of another organization (such as
            partners) may use this parameter.
        :type org_id: str
        :param display_name: Location display name.
        :type display_name: str
        :param address: Location address.
        :type address: str
        :param country_code: Location country code (ISO 3166-1).
        :type country_code: str
        :param city_name: Location city name.
        :type city_name: str
        :rtype: list[Location10]
        """
        params = {}
        if org_id is not None:
            params['orgId'] = org_id
        if display_name is not None:
            params['displayName'] = display_name
        if address is not None:
            params['address'] = address
        if country_code is not None:
            params['countryCode'] = country_code
        if city_name is not None:
            params['cityName'] = city_name
        url = self.ep()
        data = super().get(url, params=params)
        r = TypeAdapter(list[Location10]).validate_python(data['items'])
        return r

    def create_a_workspace_location(self, display_name: str, address: str, country_code: str, city_name: str,
                                    latitude: int, longitude: int, notes: str) -> Location10:
        """
        Create a Workspace Location

        Create a location. The `cityName` and `notes` parameters are optional, and omitting them will result in the
        creation of a location without values for those attributes.
        Requires an administrator auth token with the `spark-admin:workspace_locations_write` scope.

        :param display_name: A friendly name for the location.
        :type display_name: str
        :param address: The location address.
        :type address: str
        :param country_code: The location country code (ISO 3166-1).
        :type country_code: str
        :param city_name: The location city name.
        :type city_name: str
        :param latitude: The location latitude.
        :type latitude: int
        :param longitude: The location longitude.
        :type longitude: int
        :param notes: Notes associated with the location.
        :type notes: str
        :rtype: :class:`Location10`
        """
        body = dict()
        body['displayName'] = display_name
        body['address'] = address
        body['countryCode'] = country_code
        body['cityName'] = city_name
        body['latitude'] = latitude
        body['longitude'] = longitude
        body['notes'] = notes
        url = self.ep()
        data = super().post(url, json=body)
        r = Location10.model_validate(data)
        return r

    def get_a_workspace_location_details(self, location_id: str) -> Location10:
        """
        Get a Workspace Location Details

        Shows details for a location, by ID. Specify the location ID in the `locationId` parameter in the URI.
        Requires an administrator auth token with the `spark-admin:workspace_locations_read` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :rtype: :class:`Location10`
        """
        url = self.ep(f'{location_id}')
        data = super().get(url)
        r = Location10.model_validate(data)
        return r

    def update_a_workspace_location(self, location_id: str, id: str, display_name: str, address: str,
                                    country_code: str, city_name: str, latitude: int, longitude: int,
                                    notes: str) -> Location10:
        """
        Update a Workspace Location

        Updates details for a location, by ID. Specify the location ID in the `locationId` parameter in the URI. The
        request should include all details for the location returned in a previous call to
        `Get Workspace Location Details
        <https://developer.webex.com/docs/api/v1/workspace-locations/get-a-workspace-location-details>`_. Omitting the optional `cityName` or `notes` fields will result in those fields
        no longer being defined for the location.
        Requires an administrator auth token with the `spark-admin:workspace_locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param id: Unique identifier for the location.
        :type id: str
        :param display_name: A friendly name for the location.
        :type display_name: str
        :param address: The location address.
        :type address: str
        :param country_code: The location country code (ISO 3166-1).
        :type country_code: str
        :param city_name: The location city name.
        :type city_name: str
        :param latitude: The location latitude.
        :type latitude: int
        :param longitude: The location longitude.
        :type longitude: int
        :param notes: Notes associated with the location.
        :type notes: str
        :rtype: :class:`Location10`
        """
        body = dict()
        body['id'] = id
        body['displayName'] = display_name
        body['address'] = address
        body['countryCode'] = country_code
        body['cityName'] = city_name
        body['latitude'] = latitude
        body['longitude'] = longitude
        body['notes'] = notes
        url = self.ep(f'{location_id}')
        data = super().put(url, json=body)
        r = Location10.model_validate(data)
        return r

    def delete_a_workspace_location(self, location_id: str):
        """
        Delete a Workspace Location

        Deletes a location, by ID. The workspaces associated to that location will no longer have a location, but a new
        location can be reassigned to them.
        Requires an administrator auth token with the `spark-admin:workspace_locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :rtype: None
        """
        url = self.ep(f'{location_id}')
        super().delete(url)

    def list_workspace_location_floors(self, location_id: str) -> list[Floor]:
        """
        List Workspace Location Floors

        List workspace location floors.
        Requires an administrator auth token with the `spark-admin:workspace_locations_read` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :rtype: list[Floor]
        """
        url = self.ep(f'{location_id}/floors')
        data = super().get(url)
        r = TypeAdapter(list[Floor]).validate_python(data['items'])
        return r

    def create_a_workspace_location_floor(self, location_id: str, floor_number: int, display_name: str) -> Floor:
        """
        Create a Workspace Location Floor

        Create a new floor in the given location. The `displayName` parameter is optional, and omitting it will result
        in the creation of a floor without that value set.
        Requires an administrator auth token with the `spark-admin:workspace_locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str
        :rtype: :class:`Floor`
        """
        body = dict()
        body['floorNumber'] = floor_number
        body['displayName'] = display_name
        url = self.ep(f'{location_id}/floors')
        data = super().post(url, json=body)
        r = Floor.model_validate(data)
        return r

    def get_a_workspace_location_floor_details(self, location_id: str, floor_id: str) -> Floor:
        """
        Get a Workspace Location Floor Details

        Shows details for a floor, by ID. Specify the floor ID in the `floorId` parameter in the URI.
        Requires an administrator auth token with the `spark-admin:workspace_locations_read` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :rtype: :class:`Floor`
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().get(url)
        r = Floor.model_validate(data)
        return r

    def update_a_workspace_location_floor(self, location_id: str, floor_id: str, floor_number: int,
                                          display_name: str) -> Floor:
        """
        Update a Workspace Location Floor

        Updates details for a floor, by ID. Specify the floor ID in the `floorId` parameter in the URI. Include all
        details for the floor returned by a previous call to `Get Workspace Location Floor Details
        <https://developer.webex.com/docs/api/v1/workspace-locations/get-a-workspace-location-details>`_. Omitting the
        optional `displayName` field will result in that field no longer being defined for the floor.
        Requires an administrator auth token with the `spark-admin:workspace_locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :param floor_number: The floor number.
        :type floor_number: int
        :param display_name: The floor display name.
        :type display_name: str
        :rtype: :class:`Floor`
        """
        body = dict()
        body['floorNumber'] = floor_number
        body['displayName'] = display_name
        url = self.ep(f'{location_id}/floors/{floor_id}')
        data = super().put(url, json=body)
        r = Floor.model_validate(data)
        return r

    def delete_a_workspace_location_floor(self, location_id: str, floor_id: str):
        """
        Delete a Workspace Location Floor

        Deletes a floor, by ID.
        Requires an administrator auth token with the `spark-admin:workspace_locations_write` scope.

        :param location_id: A unique identifier for the location.
        :type location_id: str
        :param floor_id: A unique identifier for the floor.
        :type floor_id: str
        :rtype: None
        """
        url = self.ep(f'{location_id}/floors/{floor_id}')
        super().delete(url)


class WorkspaceMetricsApi(ApiChild, base='workspace'):
    """
    Workspace Metrics
    
    Workspace metrics contain various measurements, such as sound level or temperature, collected by devices in a
    workspace.
    
    Getting the workspace metrics in an organization requires an administrator auth token with the
    `spark-admin:workspace_metrics_read` scope.
    """

    def workspace_metrics(self, workspace_id: str, metric_name: WorkspaceMetricsResponseMetricName,
                          aggregation: WorkspaceMetricsResponseAggregation = None, from_: Union[str, datetime] = None,
                          to_: Union[str, datetime] = None, unit: WorkspaceMetricsResponseUnit = None,
                          sort_by: WorkspaceMetricsResponseSortBy = None) -> WorkspaceMetricsResponse:
        """
        Workspace Metrics

        Get metric data for the specified workspace and metric name, optionally aggregated over a specified time
        period.

        * The `workspaceId` and `metricName` parameters indicate which workspace to fetch metrics for and what kind of
        metrics to get.

        * When executing an aggregated query, the result bucket start times will be truncated to the start of an hour
        or a day, depending on
        the aggregation interval. However, the buckets will not contain data from outside the requested time range. For
        example, when
        passing `from=2020-10-21T10:34:56.000Z` and `aggregation=hourly`, the first output bucket would start at
        `2020-10-21T10:00:00.000Z`,
        but the bucket would only aggregate data timestamped after `10:34:56`.

        * For aggregation modes `none` and `hourly`, the maximum time span is 48 hours. For aggregation mode `daily`,
        the maximum
        time span is 30 days.

        :param workspace_id: ID of the workspace to get metrics for.
        :type workspace_id: str
        :param metric_name: The type of data to extract.
        :type metric_name: WorkspaceMetricsResponseMetricName
        :param aggregation: Time unit over which to aggregate measurements.
        :type aggregation: WorkspaceMetricsResponseAggregation
        :param from_: List only data points after a specific date and time (ISO 8601 timestamp)
        :type from_: Union[str, datetime]
        :param to_: List data points before a specific date and time (ISO 8601 timestamp)
        :type to_: Union[str, datetime]
        :param unit: Output data unit (only a valid parameter if `metricName` is `temperature`).
        :type unit: WorkspaceMetricsResponseUnit
        :param sort_by: Sort results.
        :type sort_by: WorkspaceMetricsResponseSortBy
        :rtype: :class:`WorkspaceMetricsResponse`
        """
        params = {}
        params['workspaceId'] = workspace_id
        params['metricName'] = metric_name
        if aggregation is not None:
            params['aggregation'] = aggregation
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        if unit is not None:
            params['unit'] = unit
        if sort_by is not None:
            params['sortBy'] = sort_by
        url = self.ep('Metrics')
        data = super().get(url, params=params)
        r = WorkspaceMetricsResponse.model_validate(data)
        return r

    def workspace_duration_metrics(self, workspace_id: str,
                                   aggregation: WorkspaceDurationMetricsResponseAggregation = None,
                                   measurement: WorkspaceDurationMetricsResponseMeasurement = None, from_: Union[str,
                                   datetime] = None, to_: Union[str,
                                   datetime] = None) -> WorkspaceDurationMetricsResponse:
        """
        Workspace Duration Metrics

        Get metrics for how much time a workspace has been in the state given by the `measurement` parameter.

        For example, if the measurement is  `timeBooked` then the duration for which the workspace has been booked is
        returned. The `workspaceId` parameter indicates which workspace to fetch metrics for. If no `measurement` is
        given, the default value is `timeUsed`.

        * When executing a query, the result bucket start times will default to the start of an hour or a day,
        depending on
        the aggregation interval. However, the buckets will not contain data from outside the requested time range. For
        example, when
        passing `from=2020-10-21T10:34:56.000Z` and `aggregation=hourly`, the first output bucket would start at
        `2020-10-21T10:00:00.000Z`,
        but the bucket would only aggregate data timestamped after `10:34:56`.

        * For aggregation mode `hourly`, the maximum time span is 48 hours. For aggregation mode `daily`, the maximum
        time span is 30 days.

        :param workspace_id: ID of the workspace to get metrics for.
        :type workspace_id: str
        :param aggregation: Unit of time over which to aggregate measurements.
        :type aggregation: WorkspaceDurationMetricsResponseAggregation
        :param measurement: The measurement to return duration for.
        :type measurement: WorkspaceDurationMetricsResponseMeasurement
        :param from_: Include data points after a specific date and time (ISO 8601 timestamp).
        :type from_: Union[str, datetime]
        :param to_: Include data points before a specific date and time (ISO 8601 timestamp).
        :type to_: Union[str, datetime]
        :rtype: :class:`WorkspaceDurationMetricsResponse`
        """
        params = {}
        params['workspaceId'] = workspace_id
        if aggregation is not None:
            params['aggregation'] = aggregation
        if measurement is not None:
            params['measurement'] = measurement
        if from_ is not None:
            if isinstance(from_, str):
                from_ = isoparse(from_)
            from_ = dt_iso_str(from_)
            params['from'] = from_
        if to_ is not None:
            if isinstance(to_, str):
                to_ = isoparse(to_)
            to_ = dt_iso_str(to_)
            params['to'] = to_
        url = self.ep('DurationMetrics')
        data = super().get(url, params=params)
        r = WorkspaceDurationMetricsResponse.model_validate(data)
        return r


class WorkspacePersonalizationApi(ApiChild, base='workspaces/{workspaceId}'):
    """
    Workspace Personalization
    
    **This API collection applies only to Webex Edge registered devices.**
    
    The Workspace Personalization API is designed to help administrators enable Personal Mode for `Webex Edge
    <https://help.webex.com/en-us/article/cy2l2z/Webex-Edge-for-Devices>`_ registered
    devices. This one-time operation allows for end users to receive calls and meeting notifications directly on their
    device, without needing to pair. This API aids with the process of the migration from on-premise to
    cloud-registered personal mode systems.
    
    For the personalization of a device to be successful, the following requirements must be satisfied:
    
    - The workspace must contain a single, Webex Edge registered, shared mode device.
    
    - The workspace must not have any calendars configured.
    
    - The device belonging to the workspace must be online.
    
    Invoking this API requires the `spark-admin:devices_write`, `spark:xapi_commands`, `spark:xapi_statuses` and
    `Identity:one_time_password` scopes.
    """

    def personalize_a_workspace(self, workspace_id: str, email: str):
        """
        Personalize a Workspace

        Initializes the personalization for a given workspace for the user email provided.

        The personalization process is asynchronous and thus a background task is created when this endpoint is
        invoked.
        After successful invocation of this endpoint a personalization task status URL will be returned in the
        `Location` header, which will point to the `Get Personalization Task
        <https://developer.webex.com/docs/api/v1/workspace-personalization/get-personalization-task>`_ endpoint for this workspace.
        The task should be completed in approximately 30 seconds.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :param email: The user that the device will become personalised for.
        :type email: str
        :rtype: None
        """
        body = dict()
        body['email'] = email
        url = self.ep(f'personalize')
        super().post(url, json=body)

    def get_personalization_task(self, workspace_id: str) -> WorkspacePersonalizationTaskResponse:
        """
        Get Personalization Task

        Returns the status of a personalization task for a given workspace.

        Whilst in progress the endpoint will return `Accepted` and provide a `Retry-After` header indicating the number
        of seconds a client should wait before retrying.

        Upon completion of the task, the endpoint will return `OK` with a body detailing if the personalization was
        successful and an error description if appropriate.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :rtype: :class:`WorkspacePersonalizationTaskResponse`
        """
        url = self.ep(f'personalizationTask')
        data = super().get(url)
        r = WorkspacePersonalizationTaskResponse.model_validate(data)
        return r


class WorkspacesApi(ApiChild, base='workspaces'):
    """
    Workspaces
    
    Workspaces represent where people work, such as conference rooms, meeting spaces, lobbies, and lunch rooms. `Devices
    <https://developer.webex.com/docs/api/v1/devices>`_
    may be associated with workspaces.
    
    Viewing the list of workspaces in an organization requires an administrator auth token with the
    `spark-admin:workspaces_read` scope. Adding, updating, or deleting workspaces in an organization requires an
    administrator auth token with the scopes `spark-admin:workspaces_write` and `spark-admin:telephony_config_write`.
    
    The Workspaces API can also be used by partner administrators acting as administrators of a different organization
    than their own. In those cases an `orgId` value must be supplied, as indicated in the reference documentation for
    the relevant endpoints.
    """

    def list_workspaces(self, org_id: str = None, workspace_location_id: str = None, floor_id: str = None,
                        display_name: str = None, capacity: int = None, type: WorkspaceUpdateRequestType = None,
                        start: int = None, calling: WorkspaceCallingType = None,
                        supported_devices: WorkspaceSupportedDevices = None, calendar: WorkspaceCalendarType = None,
                        device_hosted_meetings_enabled: bool = None, **params) -> Generator[Workspace4, None, None]:
        """
        List Workspaces

        List workspaces.

        Use query parameters to filter the response. The `orgId` parameter can only be used by admin users of another
        organization (such as partners). The `workspaceLocationId`, `floorId`, `capacity` and `type` fields will only
        be present for workspaces that have a value set for them. The special values `notSet` (for filtering on
        category) and `-1` (for filtering on capacity) can be used to filter for workspaces without a type and/or
        capacity.

        :param org_id: List workspaces in this organization. Only admin users of another organization (such as
            partners) may use this parameter.
        :type org_id: str
        :param workspace_location_id: Location associated with the workspace.
        :type workspace_location_id: str
        :param floor_id: Floor associated with the workspace.
        :type floor_id: str
        :param display_name: List workspaces by display name.
        :type display_name: str
        :param capacity: List workspaces with the given capacity. Must be -1 or higher. A value of -1 lists workspaces
            with no capacity set.
        :type capacity: int
        :param type: List workspaces by type.
        :type type: WorkspaceUpdateRequestType
        :param start: Offset. Default is 0.
        :type start: int
        :param calling: List workspaces by calling type.
        :type calling: WorkspaceCallingType
        :param supported_devices: List workspaces by supported devices.
        :type supported_devices: WorkspaceSupportedDevices
        :param calendar: List workspaces by calendar type.
        :type calendar: WorkspaceCalendarType
        :param device_hosted_meetings_enabled: List workspaces enabled for device hosted meetings.
        :type device_hosted_meetings_enabled: bool
        :return: Generator yielding :class:`Workspace4` instances
        """
        if org_id is not None:
            params['orgId'] = org_id
        if workspace_location_id is not None:
            params['workspaceLocationId'] = workspace_location_id
        if floor_id is not None:
            params['floorId'] = floor_id
        if display_name is not None:
            params['displayName'] = display_name
        if capacity is not None:
            params['capacity'] = capacity
        if type is not None:
            params['type'] = type
        if start is not None:
            params['start'] = start
        if calling is not None:
            params['calling'] = calling
        if supported_devices is not None:
            params['supportedDevices'] = supported_devices
        if calendar is not None:
            params['calendar'] = calendar
        if device_hosted_meetings_enabled is not None:
            params['deviceHostedMeetingsEnabled'] = str(device_hosted_meetings_enabled).lower()
        url = self.ep()
        return self.session.follow_pagination(url=url, model=Workspace4, item_key='items', params=params)

    def create_a_workspace(self, display_name: str, org_id: str, workspace_location_id: str, floor_id: str,
                           capacity: int, type: WorkspaceType1, sip_address: str,
                           calling: WorkspaceCreationRequestCalling, calendar: WorkspaceCreationRequestCalendar,
                           notes: str, hotdesking_status: CallMembershipAudio,
                           device_hosted_meetings: WorkspaceDeviceHostedMeetings,
                           supported_devices: WorkspaceSupportedDevices) -> Workspace4:
        """
        Create a Workspace

        Create a workspace.

        The `workspaceLocationId`, `floorId`, `capacity`, `type`, `notes` and `hotdeskingStatus`  parameters are
        optional, and omitting them will result in the creation of a workspace without these values set, or set to
        their default. A `workspaceLocationId` must be provided when the `floorId` is set. Calendar and calling can
        also be set for a new workspace. Omitting them will default to free calling and no calendaring. The `orgId`
        parameter can only be used by admin users of another organization (such as partners).

        * Information for Webex Calling fields may be found here: `locations
        <https://developer.webex.com/docs/api/v1/locations/list-locations>`_ and `available numbers

        * The `locationId` and `supportedDevices` fields cannot be changed once configured.

        * When creating a `webexCalling` workspace, a `locationId` and either a `phoneNumber` or `extension` or both is
        required.

        :param display_name: A friendly name for the workspace.
        :type display_name: str
        :param org_id: `OrgId` associated with the workspace. Only admin users of another organization (such as
            partners) may use this parameter.
        :type org_id: str
        :param workspace_location_id: Location associated with the workspace. Must be provided when the `floorId` is
            set.
        :type workspace_location_id: str
        :param floor_id: Floor associated with the workspace.
        :type floor_id: str
        :param capacity: How many people the workspace is suitable for. If set, must be 0 or higher.
        :type capacity: int
        :param type: The type that best describes the workspace.
        :type type: WorkspaceType1
        :param sip_address: The `sipAddress` field can only be provided when calling type is `thirdPartySipCalling`
        :type sip_address: str
        :param calling: Calling types supported on create are `freeCalling`, `webexEdgeForDevices`,
            `thirdPartySipCalling`, `webexCalling` and `none`. Default is `freeCalling`.
        :type calling: WorkspaceCreationRequestCalling
        :param calendar: Workspace calendar configuration. Provide a type (`microsoft`, `google` or `none`) and an
            `emailAddress`. Default is `none`.
        :type calendar: WorkspaceCreationRequestCalendar
        :param notes: Notes associated to the workspace.
        :type notes: str
        :param hotdesking_status: Hot desking status of the workspace.
        :type hotdesking_status: CallMembershipAudio
        :param device_hosted_meetings: To enable device hosted meetings, set a Webex `siteUrl` and the `enabled` flag
            to `true`.
        :type device_hosted_meetings: WorkspaceDeviceHostedMeetings
        :param supported_devices: The supported devices for the workspace. Default is `collaborationDevices`.
        :type supported_devices: WorkspaceSupportedDevices
        :rtype: :class:`Workspace4`
        """
        body = dict()
        body['displayName'] = display_name
        body['orgId'] = org_id
        body['workspaceLocationId'] = workspace_location_id
        body['floorId'] = floor_id
        body['capacity'] = capacity
        body['type'] = enum_str(type)
        body['sipAddress'] = sip_address
        body['calling'] = loads(calling.model_dump_json())
        body['calendar'] = loads(calendar.model_dump_json())
        body['notes'] = notes
        body['hotdeskingStatus'] = enum_str(hotdesking_status)
        body['deviceHostedMeetings'] = loads(device_hosted_meetings.model_dump_json())
        body['supportedDevices'] = enum_str(supported_devices)
        url = self.ep()
        data = super().post(url, json=body)
        r = Workspace4.model_validate(data)
        return r

    def get_workspace_details(self, workspace_id: str) -> Workspace4:
        """
        Get Workspace Details

        Shows details for a workspace, by ID.

        The `workspaceLocationId`, `floorId`, `capacity`, `type` and `notes` fields will only be present if they have
        been set for the workspace. Specify the workspace ID in the `workspaceId` parameter in the URI.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :rtype: :class:`Workspace4`
        """
        url = self.ep(f'{workspace_id}')
        data = super().get(url)
        r = Workspace4.model_validate(data)
        return r

    def update_a_workspace(self, workspace_id: str, display_name: str, workspace_location_id: str, floor_id: str,
                           capacity: int, type: WorkspaceUpdateRequestType,
                           calendar: WorkspaceCreationRequestCalendar, sip_address: str,
                           calling: WorkspaceCreationRequestCalling, notes: str,
                           hotdesking_status: CallMembershipAudio,
                           device_hosted_meetings: WorkspaceDeviceHostedMeetings) -> Workspace4:
        """
        Update a Workspace

        Updates details for a workspace by ID.

        Specify the workspace ID in the `workspaceId` parameter in the URI. Include all details for the workspace that
        are present in a `GET request for the workspace details
        <https://developer.webex.com/docs/api/v1/workspaces/get-workspace-details>`_. Not including the optional `capacity`, `type` or
        `notes` fields will result in the fields no longer being defined for the workspace. A `workspaceLocationId`
        must be provided when the `floorId` is set. The `workspaceLocationId`, `floorId`, `supportedDevices`,
        `calendar` and `calling` fields do not change when omitted from the update request.

        * Information for Webex Calling fields may be found here: `locations
        <https://developer.webex.com/docs/api/v1/locations/list-locations>`_ and `available numbers

        * Updating the `calling` parameter is only supported if the existing `calling` type is `freeCalling`, `none`,
        `thirdPartySipCalling` or `webexCalling`.

        * Updating the `calling` parameter to `none`, `thirdPartySipCalling` or `webexCalling` is not supported if the
        workspace contains any devices.

        * The `locationId` and `supportedDevices` fields cannot be changed once configured.

        * When updating `webexCalling` information, a `locationId` and either a `phoneNumber` or `extension` or both is
        required.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :param display_name: A friendly name for the workspace.
        :type display_name: str
        :param workspace_location_id: Location associated with the workspace. Must be provided when the `floorId` is
            set.
        :type workspace_location_id: str
        :param floor_id: Floor associated with the workspace.
        :type floor_id: str
        :param capacity: How many people the workspace is suitable for. If set, must be 0 or higher.
        :type capacity: int
        :param type: The type that best describes the workspace.
        :type type: WorkspaceUpdateRequestType
        :param calendar: An empty/null calendar field will not cause any changes. Provide a type (`microsoft`, `google`
            or `none`) and an `emailAddress`. Removing calendar is done by setting the `none` type, and setting `none`
            type does not require an `emailAddress`.
        :type calendar: WorkspaceCreationRequestCalendar
        :param sip_address: The `sipAddress` field can only be provided when calling type is `thirdPartySipCalling`
        :type sip_address: str
        :param calling: Calling types supported on update are `freeCalling`, `thirdPartySipCalling`, `webexCalling` and
            `none`.
        :type calling: WorkspaceCreationRequestCalling
        :param notes: Notes associated to the workspace.
        :type notes: str
        :param hotdesking_status: Hot desking status of the workspace.
        :type hotdesking_status: CallMembershipAudio
        :param device_hosted_meetings: To enable device hosted meetings, set a Webex `siteUrl` and the `enabled` flag
            to `true`.
        :type device_hosted_meetings: WorkspaceDeviceHostedMeetings
        :rtype: :class:`Workspace4`
        """
        body = dict()
        body['displayName'] = display_name
        body['workspaceLocationId'] = workspace_location_id
        body['floorId'] = floor_id
        body['capacity'] = capacity
        body['type'] = enum_str(type)
        body['calendar'] = loads(calendar.model_dump_json())
        body['sipAddress'] = sip_address
        body['calling'] = loads(calling.model_dump_json())
        body['notes'] = notes
        body['hotdeskingStatus'] = enum_str(hotdesking_status)
        body['deviceHostedMeetings'] = loads(device_hosted_meetings.model_dump_json())
        url = self.ep(f'{workspace_id}')
        data = super().put(url, json=body)
        r = Workspace4.model_validate(data)
        return r

    def delete_a_workspace(self, workspace_id: str):
        """
        Delete a Workspace

        Deletes a workspace by ID.

        Also deletes all devices associated with the workspace. Any deleted devices will need to be reactivated.
        Specify the workspace ID in the `workspaceId` parameter in the URI.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :rtype: None
        """
        url = self.ep(f'{workspace_id}')
        super().delete(url)

    def get_workspace_capabilities(self, workspace_id: str) -> CapabilityMap:
        """
        Get Workspace Capabilities

        Shows the capabilities for a workspace by ID.

        Returns a set of capabilities, including whether or not the capability is supported by any device in the
        workspace, and if the capability is configured (enabled). For example for a specific capability like
        `occupancyDetection`, the API will return if the capability is supported and/or configured such that occupancy
        detection data will flow from the workspace (device) to the cloud. Specify the workspace ID in the
        `workspaceId` parameter in the URI.

        :param workspace_id: A unique identifier for the workspace.
        :type workspace_id: str
        :rtype: CapabilityMap
        """
        url = self.ep(f'{workspace_id}/capabilities')
        data = super().get(url)
        r = CapabilityMap.model_validate(data['capabilities'])
        return r


class XAPIApi(ApiChild, base='xapi'):
    """
    xAPI
    
    The xAPI allows developers to programmatically invoke commands and query the status of devices that run Webex
    RoomOS software.
    
    Executing commands requires an auth token with the `spark:xapi_commands` scope. Querying devices requires an auth
    token with the `spark:xapi_statuses` scope.
    
    All xAPI requests require a `deviceId` which can be obtained using the `Devices API
    <https://developer.webex.com/docs/api/v1/devices>`_. xAPI commands and statuses are
    described in the `Cisco Collaboration Endpoint Software API Reference Guide
    <https://www.cisco.com/c/en/us/support/collaboration-endpoints/spark-room-kit-series/products-command-reference-list.html>`_. For more information about developing
    applications for cloud connected devices, see the `Device Developers Guide
    <https://developer.webex.com/docs/api/guides/device-developers-guide>`_.
    """

    def query_status(self, device_id: str, name: str) -> QueryStatusResponse:
        """
        Query Status

        Query the current status of the Webex RoomOS Device. You specify the target device in the `deviceId` parameter
        in the URI. The target device is queried for statuses according to the expression in the `name` parameter.

        See the `xAPI section of the Device Developers Guide
        <https://developer.webex.com/docs/api/guides/device-developers-guide#xapi>`_ for a description of status expressions.

        :param device_id: The unique identifier for the Webex RoomOS Device.
        :type device_id: str
        :param name: Status expression used to query the Webex RoomOS Device. See the
            `xAPI section of the Device Developers Guide
            <https://developer.webex.com/docs/api/guides/device-developers-guide#xapi>`_ for a description of status expressions.
        :type name: str
        :rtype: :class:`QueryStatusResponse`
        """
        params = {}
        params['deviceId'] = device_id
        params['name'] = name
        url = self.ep('status')
        data = super().get(url, params=params)
        r = QueryStatusResponse.model_validate(data)
        return r

    def execute_command(self, command_name: str, device_id: str, arguments: ExecuteCommandArguments,
                        body: ExecuteCommandBody = None) -> ExecuteCommandResponse:
        """
        Execute Command

        Executes a command on the Webex RoomOS Device. Specify the command to execute in the `commandName` URI
        parameter.

        See the `xAPI section of the Device Developers Guide
        <https://developer.webex.com/docs/devices#xapi>`_ for a description of command expressions.

        :param command_name: Command to execute on the Webex RoomOS Device.
        :type command_name: str
        :param device_id: The unique identifier for the Webex RoomOS Device.
        :type device_id: str
        :param arguments: xAPI command arguments
        :type arguments: ExecuteCommandArguments
        :param body: xAPI command body, as a complex JSON object or as a string, for example: `import xapi from
            'xapi';\n\nconsole.log('Hello, World!');\n`
        :type body: ExecuteCommandBody
        :rtype: :class:`ExecuteCommandResponse`
        """
        body = dict()
        body['deviceId'] = device_id
        body['arguments'] = loads(arguments.model_dump_json())
        body['body'] = loads(body.model_dump_json())
        url = self.ep(f'command/{command_name}')
        data = super().post(url, json=body)
        r = ExecuteCommandResponse.model_validate(data)
        return r
